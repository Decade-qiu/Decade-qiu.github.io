[{"title":"AcWing 80场杯赛","url":"/2023/02/05/AcWing-80%E5%9C%BA%E6%9D%AF%E8%B5%9B/","content":"Q1 4803.\n满足的数 [Easy] 题解\nQ2 4804.\n构造矩阵 [Medium] 题解\nQ3 4805.\n加减乘 [Hard] 题解\n\nQ1\n\n4803.\n满足的数 - AcWing题库\n\n思路\n额，模拟\n代码\nn = int(input())a = list(map(int,input().split()))s = sum(a)ans = 0for i in range(1, 6):    if (s+i)%(n+1) != 1: ans += 1print(ans)\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\nQ2\n\n4804. 构造矩阵\n- AcWing题库\n\n思路\n题目理解很容易，但写起来怪怪的😅😅。\n\n有0就必须行列全为0，这个规则很硬性。所以得先处理，把所有必须为0的先改成0.\n再遍历改完的数组，如果为1，则把行列标记为”有1存在“。\n最后遍历原数组，如果为1，看其所属行列有没有”1存在的标记“。如果没有，返回NO。\n输出答案。\n\n代码\nn, m = list(map(int,input().split()))g = [list(map(int,input().split())) for i in range(n)]f = [[ii for ii in g[i]] for i in range(n)]zx = set()zy = set()ox = set()oy = set()for i in range(n):    for j in range(m):        if g[i][j] == 0:            zx.add(i)            zy.add(j)for i in range(n):    for j in range(m):        if i in zx or j in zy: f[i][j] = 0for i in range(n):    for j in range(m):        if f[i][j] == 1:            ox.add(i)            oy.add(j)for i in range(n):    for j in range(m):        if g[i][j] == 1:            if not i in ox and not j in oy:                print(\"NO\")                exit()print(\"YES\")for i in range(n):    for j in range(m):        print(f[i][j], end=' ')    print()\n复杂度分析\n\n时间复杂度：O(nm)\n空间复杂度：O(nm)\n\nQ3\n\n4805. 加减乘 -\nAcWing题库\n\n思路\nDP\n代码\nimport java.util.*;import java.io.*;public class Main {    static String ss, io[];    static int test, N = 100010, M = 1000000007;    static void solve() throws Exception{        int n = ni();         long x = ni(), y = ni();        long[] dp = new long[2*n+1];        Arrays.fill(dp, (long)1e18);        dp[0] = 0;        for (int i = 0;i &lt;= n;i++){            dp[i] = min(dp[i], min(dp[i-1]+x, dp[i+1]+x));            dp[i*2] = min(dp[i*2], dp[i]+y);        }        out.println(dp[n]);    }    public static void main(String[] args) throws Exception {        test = 1;        // test = ni(in.readLine());        while (test-- &gt; 0){            solve();        }out.flush();    }    static int ni() throws IOException{input.nextToken();return (int) input.nval;}    static long nl() throws IOException{input.nextToken();return (long) input.nval;}    static int ni(String x) {return Integer.parseInt(x);}    static long nl(String x) {return Long.parseLong(x);}    static int max(int a, int b) {return a &gt; b ? a : b;}    static long max(long a, long b) {return a &gt; b ? a : b;}    static int min(int a, int b) {return a &lt; b ? a : b;}    static long min(long a, long b) {return a &lt; b ? a : b;}    static int lg2(long a) {return (int)Math.ceil((Math.log(a)/Math.log(2)));}    static int abs(int a) {return a &gt; 0?a:-a;}    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    static StreamTokenizer input = new StreamTokenizer(in);    static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));}  \n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","categories":["AcWing","Contest","Algorithm","Problem"],"tags":["模拟","动态规划"]},{"title":"AcWing 90场杯赛","url":"/2023/02/12/AcWing-90%E5%9C%BA%E6%9D%AF%E8%B5%9B/","content":"Q1 4806.\n首字母大写 [Easy] 题解\nQ2 4807.\n找数字 [Medium] 题解\nQ3 4808.\n构造字符串 [Hard] 题解\n\nQ1\n\n4806.\n首字母大写 - AcWing题库\n给你一个字符串，如果首字符是小写，就把它改为大写。最后返回\n\n思路\n额😅😅\n代码\ndef solve():     s = input()    if ord(s[0]) &gt;= 97:        s = chr(ord(s[0])-97+65)+s[1:]    print(s)\n复杂度分析\n\n时间复杂度：O(1)\n空间复杂度：O(1)\n\nQ2\n\n4807. 找数字 -\nAcWing题库\n给定一个正整数 m\n和一个非负整数 s。\n请你找到长度为 m\n且各位数字之和为 s\n的最小和最大非负整数。\n要求所求非负整数不得包含前导零。\n\n思路\n因为位数是固定的，所以直接从高位到低位贪心。\n\n最小数：从高位到低位遍历，每次从最小值选择（最高位最小值为1，因为不能有前导0）。判断剩余的的数字能不能被剩余的位数填满，就是后面全填9看总和有没有大于m；如果小于，说明后面无论怎么填都不行。\n最大数：从高位到低位遍历，每次都填9，如果剩余数字不满9，就填剩余的数字。\n\n然后开头加两个特判：总和为0，位数只能小于等于1；如果所有位都填9还小于m，说明不可能实现。\n代码\ndef solve():     n, m = list(map(int, input().split()))    if m == 0:        if n &lt;= 1: print(0, 0)        else: print(-1, -1)        return    if n*9 &lt; m:        print(-1, -1)        return    a, b = [0]*n, [0]*n    ca, cb = 0, 0    for i in range(n):        bound = 0 if i != 0 else 1        for k in range(bound, 10):            if ca+k+9*(n-i-1) &gt;= m:                a[i] = k                ca += k                break    for i in range(n):        if m-cb &gt;= 9:            b[i] = 9            cb += 9        else:            b[i] = m-cb            break    for i in a: print(i, end='')    print(' ', end='')    for i in b: print(i, end='')\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\nQ3\n\n4808.\n构造字符串 - AcWing题库\n给定一个长度为 n 的由小写字母构成的字符串 t 以及一个整数 k。\n请你构造一个字符串 s，要求：\n\n字符串 s 恰好有 k 个子串等于字符串 t。\n字符串 s 的长度尽可能短。\n\n\n思路\n简单来说，就是s后面再加上(k-1)个s。为了总长最小，所以每次添加的字符要最少。\n即求出最长的，s的前缀和后缀相等的长度。\n例如，s = “abab” 最长的是”ab”，2个字符长。三个就不行了，因为”aba” !=\n“bab”。\n对于这题数据量\nn &lt;= 50,直接暴力遍历公共前后缀长度。\n代码\ndef solve():     n, m = list(map(int, input().split()))    s = input()    match = 0    for i in range(n-1, 0, -1):        if s[:i] == s[n-i:]:            match = i            break    ans = s    for j in range(m-1):        ans += s[match:]    print(ans)\n复杂度分析\n\n时间复杂度：O(n2)\n空间复杂度：O(n)\n\nTips\n当数据量大的时候，建议使用KMP，匹配公共前后缀。复杂度 O(n)\ndef solve():     n, m = list(map(int, input().split()))    s = \" \"+input()    i, j = 2, 0    ne = [0]*(n+1)    while i &lt;= n:        while j and s[i] != s[j + 1]: j = ne[j]        if s[i] == s[j + 1]: j += 1        ne[i] = j;        i += 1    ans = s[1:]    for j in range(m-1):        ans += s[ne[n]+1:]    print(ans)\n","categories":["AcWing","Contest","Algorithm","Problem"],"tags":["贪心","二分","KMP"]},{"title":"AcWing 91场杯赛","url":"/2023/02/19/AcWing-91%E5%9C%BA%E6%9D%AF%E8%B5%9B/","content":"Q1 4861.\n构造数列 [Easy] 题解\nQ2 4862.\n浇花 [Medium] 题解\nQ3 4863.\n构造新矩阵 [Hard] 题解\n\nQ1\n\n4861. 构造数列\n- AcWing题库\n输出每个数按10进制分解出的结果。如‘23007’ =&gt; 20000，3000，7\n\n思路\n暴力\n代码\ndef solve():    n = input()    print(len([n[i] for i in range(len(n)) if n[i] != '0']))    for i in range(len(n)):        if n[i] != '0': print(int(n[i])*pow(10, len(n)-i-1), end=' ')    print()\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\nQ2\n\n4862. 浇花 -\nAcWing题库\n给定m个修改，每次将区间[l, r]加一。问最后哪一天的值不等于1。\n\n思路\n区间修改，单点查询。\n明显的差分，最后在求前缀和的时候判断即可。\n代码\ndef solve():    n, m = list(map(int, input().split()))    a = [0]*(n+2)    for i in range(m):        l, r = list(map(int, input().split()))        a[l] += 1        a[r+1] -= 1    for i in range(1, n+1):        a[i] += a[i-1]        if a[i] != 1:            print(i, a[i])            return    print('OK')\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\nQ3\n\n4863.\n构造新矩阵 - AcWing题库\n\n思路\n二分和鸽巢原理.\n首先如果能找到L+1符合题意，那么L也肯定符合题意，所以可以二分答案。\n之后要生成一个满足题意(m-1)*m的矩阵。由鸽巢原理，必须有一行要贡献两列大于L的值。\n代码\ndef solve():    input()    n, m = list(map(int, input().split()))    g = [list(map(int, input().split())) for i in range(n)]    l, r = 1, int(1e9)    while l &lt;= r:        mid = l+r &gt;&gt; 1        if ck(g, mid, n, m): l = mid+1        else: r = mid-1    print(r)def ck(g, t, n, m):    cnt = [0]*n    for i in range(m):        hs = set()        for j in range(n):             if g[j][i] &gt;= t:                hs.add(j)                cnt[j] += 1        if len(hs) == 0: return False    if n &lt; m-1: return True    for i in cnt:        if i &gt; 1: return True    return False\n复杂度分析\n\n时间复杂度：O(nmlog (1e9))\n空间复杂度：O(nm)\n\nTips\n当数据量大的时候，建议使用KMP，匹配公共前后缀。复杂度 O(n)\ndef solve():     n, m = list(map(int, input().split()))    s = \" \"+input()    i, j = 2, 0    ne = [0]*(n+1)    while i &lt;= n:        while j and s[i] != s[j + 1]: j = ne[j]        if s[i] == s[j + 1]: j += 1        ne[i] = j;        i += 1    ans = s[1:]    for j in range(m-1):        ans += s[ne[n]+1:]    print(ans)\n","categories":["AcWing","Contest","Algorithm","Problem"],"tags":["二分","KMP","差分","鸽巢原理"]},{"title":"AtCoder Beginner COntest 289","url":"/2024/05/13/AtCoder-Beginner-COntest-289/","content":"A -\nflip [Easy] 题解\nB - V\n[Easy] 题解\nC -\nCoverage [Easy] 题解\nD - Step\nUp Robot [Medium] 题解\nE - Swap\nPlaces [Medium] 题解\n\nA - flip\n\nA -\nflip\n就是给你一个01字符串，将里面的0改成1，1改成0\n\n思路\n模拟。另外用上异或的小技巧\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():     s = input()    for i in s:        print(int(i)^1, end='')\nB - V\n\nB -\nV\n给定一张无向图，n 个点， m 条边。第 i 条边连接点 ci 和 ci+1。\n要求输出所有点，从最小的点所在的连通块开始，并从该连通块标号最大的点开始输出。\n\n思路\n遍历，每次求出连续的一段点集合，从大到小输出。\n在每次遍历前，要先判断前面有没有点还没有输出，如果有，就从小到大输出。\n最后还要判断是否n个点都输出完毕。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():     n, m = list(map(int, input().split()))    a = list(map(int, input().split()))    i, pre = 0, 0    while i &lt; m:        if a[i] != pre+1:            for k in range(pre+1, a[i]): print(k, end=' ')        pre = a[i]-1        for k in range(i, m):            if a[k] == pre+1: pre += 1            else: break        for j in range(pre+1, a[i]-1, -1): print(j, end=' ')        pre += 1        i = k        if a[k]+1 == pre: break    for i in range(pre+1, n+1): print(i, end=' ')\nC - Coverage\n\nC -\nCoverage\n给出m个集合，每个集合存放1~n中的数字。问有多少种选择方式，使得选择的集合的并集覆盖了\n1∼n。\n\n思路\n范围只有10，二进制枚举暴力判断即可。\n\n时间复杂度：O(nm2m)\n空间复杂度：O(1)\n\n代码\ndef solve():     n, m = list(map(int, input().split()))    s = []    for i in range(m):        tp = input()        s.append(set(list(map(int, input().split()))))    ans = 0    for i in range(1, (1&lt;&lt;m)):        cur = set()        for j in range(m):            if (i &gt;&gt; j &amp; 1) : cur |= s[j]        if len(cur) == n: ans += 1    print(ans)\nD - Step Up Robot\n\nD - Step\nUp Robot\n走楼梯，某些阶梯不能踩。每一步可以选择n种步长向上走。并且有 m\n个障碍，走的过程中不能经过这些层。\n问能不能从第 0 层走到第 x 层。\n\n思路\n爬楼梯，经典dp问题。只不过多了一些选择和限制。\n\n时间复杂度：O(nx)\n空间复杂度：O(x)\n\n代码\ndef solve():    n = int(input())    a = list(map(int, input().split()))    m = int(input())    b = set(list(map(int, input().split())))    x = int(input())    dp = [False]*(x+1)    dp[0] = True    for i in range(1, x+1):        for j in range(n):            if i not in b and i &gt;= a[j]: dp[i] |= dp[i-a[j]]    print('Yes' if dp[x] else 'No')\nE - Swap Places\n\nE - Swap\nPlaces\n给定一张n个点m条边的无向图，点有红蓝两种颜色。\nA从1号点出发，B从 n 号点出发。\n每个时刻，两人同时移动至其相邻点，要求每次移动之后，两人所在点的颜色不同。\n问两人能否同时抵达n号点和 1号点，若能的话，输出最小耗时。\n\n思路\n图里面求最小值，一眼BFS。\n设 dis[i][j]\n是A走到点 i，B走到点 j 所需的最短距离。（两人都走了 dis[i][j]步）双重循环遍历点\ni，j 的所有相邻点\nni, nj\n。则 dis[ni][nj] = dis[i][j] + 1。由于是求最短路，对于更新过的点就不要在更新了。\n整个过程一共需要遍历 n2\n个状态，并且因为更新过的点就不要在更新，所以每个状态不会重复求解。而求解一个状态时，需要循环遍历两个点的所有相邻点，即边的数量，这有\nm2\n种选择，并且也不会重复求解（假设有一种情况重复求解，就相当于遍历了边ab和边cd两次，这两次起点都是a，c，与\ndis[a][c]\n只求解一次相悖）。\n\n时间复杂度：O(n2 + m2)\n空间复杂度：O(n2 + m)\n\n代码\nstatic int n, m, c[] = new int[N], dis[][] = new int[N][N];static List&lt;Integer&gt;[] g = new List[N];static void solve() throws Exception{    n = ni(); m = ni();    for (int i = 1;i &lt;= n;i++){        g[i] = new ArrayList&lt;&gt;();        for (int j = 1;j &lt;= n;j++) dis[i][j] = -1;    }    for (int i = 1;i &lt;= n;i++) c[i] = ni();    for (int i = 1;i &lt;= m;i++){        int u = ni(), v = ni();        g[u].add(v);        g[v].add(u);    }    Deque&lt;int[]&gt; d = new LinkedList&lt;&gt;();    d.offerLast(new int[]{1, n});    dis[1][n] = 0;    while (!d.isEmpty()){        int[] cur = d.pollFirst();        int x = cur[0], y = cur[1];        for (int nx : g[x]){            for (int ny : g[y]){                if (c[nx] != c[ny] &amp;&amp; dis[nx][ny] == -1){                    dis[nx][ny] = dis[x][y]+1;                    d.offerLast(new int[]{nx, ny});                }            }        }    }out.println(dis[n][1]);}\n","categories":["AtCoder","Algorithm","Contest","Problem"],"tags":["动态规划","BFS","二进制枚举"]},{"title":"Basic Algorithm","url":"/2022/08/22/Basic-Algorithm/","content":"梦开始的地方\n\n1. 二分\n不多说，基础中的基础。\nint binary_search(int[] nums, int target) {    int left = 0, right = nums.length - 1;    while(left &lt;= right) {        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid - 1;        } else if(nums[mid] == target) {            // 直接返回            return mid;        }    }    // 直接返回    return -1;}int left_bound(int[] nums, int target) {    int left = 0, right = nums.length - 1;    while (left &lt;= right) {        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) {            left = mid + 1;        } else {            // 别返回，锁定左侧边界            right = mid - 1;        }    }    // 最后要检查 left 越界的情况    if (left &gt;= nums.length || nums[left] != target)        return -1;    return left;}int right_bound(int[] nums, int target) {    int left = 0, right = nums.length - 1;    while (left &lt;= right) {        int mid = left + (right - left) / 2;        if (nums[mid] &lt; target) {            left = mid + 1;        } else {            // 别返回，锁定右侧边界            left = mid + 1;        }    }    // 最后要检查 right 越界的情况    if (right &lt; 0 || nums[right] != target)        return -1;    return right;}\n\n2. 位运算\n\n基础位操作\n\n获取一个数二进制的某一位：\n// 获取 a 的第 b 位，最低位编号为 0int getBit(int a, int b) { return (a &gt;&gt; b) &amp; 1; }\n将一个数二进制的某一位设置为 0：\n// 将 a 的第 b 位设置为 0 ，最低位编号为 0int unsetBit(int a, int b) { return a &amp; ~(1 &lt;&lt; b); }\n将一个数二进制的某一位设置为 1：\n// 将 a 的第 b 位设置为 1 ，最低位编号为 0int setBit(int a, int b) { return a | (1 &lt;&lt; b); }\n将一个数二进制的某一位取反：\n// 将 a 的第 b 位取反 ，最低位编号为 0int flapBit(int a, int b) { return a ^ (1 &lt;&lt; b); }\n\n2 的幂次运用\n\n判断一个数是不是 2 的非负整数次幂：\nbool isPowerOfTwo(int n) { return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0; }\nlowbit:\n一个数二进制表示从低往高的第一个 连同后面的零，如 1010 的\nlowbit 是 0010\nint lowbit(int x) {  return x &amp; -x;}\n\n模拟集合操作（二进制枚举）\n\n一个数的二进制表示可以看作是一个集合（ 0 表示不在集合中， 1\n表示在集合中）。比如集合 {1，3，4，8} ，可以表示成（100011010）\n。而对应的位运算也就可以看作是对集合进行的操作。\n\n\n\n操作\n集合表示\n位运算语句\n\n\n\n\n交集\na ∩ b\na &amp; b\n\n\n并集\na ∪ b\na\n\n\n补集\nā\n~a （全集为二进制都是 1）\n\n\n差集\na \\ b\na &amp; (~b)\n\n\n对称差\na△b\na ^ b\n\n\n\n子集\n\n3. 前缀和与差分\n\n前缀和\n一维\n\n\n\nK\n倍区间\n\n\n二维\n\n\n给以为左上角，为右下角的子矩阵中的所有元素加上：\nP1719\n最大加权矩形\n\n\n差分\n\n这种策略的定义是令  简单性质：\n\nai\n的值是 bi\n的前缀和，即 \n计算 ai 的前腏和 sum\n\n它可以维护多次对序列的一个区间加上一个数，并在最后询问某一位的数或是多次询问某一位的\n数。注意修改操作一定要在查询操作之前。\n\n地毯\n\n4. 排序\n4.1. 快排\n\n递归\n\nprivate static void sorted(int[] n, int low, int up) {    if (low &gt;= up) return;    int randIdx = new Random().nextInt(up-low+1)+low;swap(n, up, randIdx);    // 一般 pivot = n[up] 就可以了    int pivot = n[up], idx = low-1;    for (int i = low;i &lt; up;++i){        if (n[i] &lt;= pivot) swap(n, ++idx, i);    }    swap(n, ++idx, up);    sorted(n, low, idx-1);    sorted(n, idx+1, up);}private static void swap(int[] n, int up, int randIdx) {    int tp = n[up];    n[up] = n[randIdx];    n[randIdx] = tp;}\n\n用于线性求第 K 大的数\n\nint k;...private void sorted(int[] n, int low, int up) {    ...    //只有下面不同    if (idx == k) return;    else if (idx &gt; k) sorted(n, low, idx-1);    else sorted(n, idx+1, up);}\n数组中的第\nK 个最大元素\n4.2. 归并\n\n分治\n\nprivate static void mergeSort(int[] n, int left, int right) {    if (left &gt;= right) return;    int mid = left+(right-left)/2;    mergeSort(n, left, mid);//左    mergeSort(n, mid+1, right);//右    merge(n, left, mid+1, right+1);//合并}private static void merge(int[] n, int low, int mid, int up) {    int loc = 0, s1 = low, s2 = mid;    int[] arr = new int[up-low];    while (s1 &lt; mid &amp;&amp; s2 &lt; up) {//合并有序数组        if (n[s1] &lt; n[s2]) arr[loc++] = n[s1++];        else arr[loc++] = n[s2++];    }    while (s1 &lt; mid) arr[loc++] = n[s1++];    while (s2 &lt; up) arr[loc++] = n[s2++];    for (int i = 0;i &lt; up-low;i++) {        n[i+low] = arr[i];    }}\n\n逆序对\n\n所谓逆序对，就是对于一个数组 a ，满足 ai &gt; aj且i &lt; j 的数对 (i, j)。\nint ans = 0;...void merge(int[] nums, int left, int mid, int right){ ...    while (i&lt;n &amp;&amp; j&lt;m){        if (nums[i]&lt;=nums[j]) tp[idx++] = nums[i++];            else{                // 如果nums[i]&gt;nums[j]且i&lt;j 说明原数组中(i, j)已经形成逆序对                // 又i~mid-1间是已经排好序的 所以逆序对数是 mid-1-i+1 = mid-i                ans += (mid-i);                tp[idx++] = nums[j++];        }    } ...}\n逆序对也可以用 树状数组、线段树\n等数据结构求解。这三种方法的时间复杂度都是 O(nlog n)。\n5. 单调队列&amp;&amp;滑动窗口\n有一个长为 n 的序列\naa，以及一个大小为 k\n的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\nprivate static void max_deque() {Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;();// 队头 最大值下标  队尾 最小值下标    for (int i = 0;i &lt; n;i++){        int cur = a[i];        while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &lt;= cur) q.pollLast();        q.offerLast(i);        while (!q.isEmpty() &amp;&amp; q.peekFirst() &lt;= i-k) q.pollFirst();        if (i &gt;= k-1) System.out.print(a[q.peekFirst()]+\" \");    }}private static void min_deque() {    Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;();// 队头 最小值下标  队尾 最大值下标    for (int i = 0;i &lt; n;i++){        int cur = a[i];        while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &gt;= cur) q.pollLast();        q.offerLast(i);        while (!q.isEmpty() &amp;&amp; q.peekFirst() &lt;= i-k) q.pollFirst();        if (i &gt;= k-1) System.out.print(a[q.peekFirst()]+\" \");    }}\n\n滑动窗口+贪心\n\nP1638 逛画展\n","categories":["Algorithm","Template"],"tags":["二分","差分","Template","位运算","前缀和","排序","单调队列","滑动窗口","梦开始的地方"]},{"title":"CSS 包含块","url":"/2024/01/11/CSS-%E5%8C%85%E5%90%AB%E5%9D%97/","content":"涉及到CSS中position，width等属性设置\n\n你不知道的 CSS 之包含块\n一说到 CSS\n盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box\n和 content-box 这两种盒模型的区别。\n但是一说到 CSS\n包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。\n好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。\n包含块英语全称为containing block，实际上平时你在书写\nCSS\n时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在\nCSS 规范中也是明确书写了的：\nhttps://drafts.csswg.org/css2/#containing-block-details\n并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。\n那么，这个包含块究竟说了什么内容呢？\n说起来也简单，就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如\nwidth, height, padding, margin，绝对定位元素的偏移值（比如 position\n被设置为 absolute 或\nfixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。\n\nstatic：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。\nrelative：元素框偏移某个距离。元素仍保持其未定位前的状态，它原本所占的空间仍保留。\nabsolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来他在正常留中生成何种类型的框。\nfixed：元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身。\n\n来吧，少年，让我们从最简单的 case 开始看。\n&lt;body&gt;  &lt;div class=\"container\"&gt;    &lt;div class=\"item\"&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;\n.container{  width: 500px;  height: 300px;  background-color: skyblue;}.item{  width: 50%;  height: 50%;  background-color: red;}\n请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？\n\n\ncssb11\n\n相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为\n250px，height 为 150px。\n这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素\ndiv.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此\n50% 就是 150px。\n这个答案实际上是不准确的。正确的答案应该是，div.item\n的宽高是根据它的包含块来计算的，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。\n因此正如我前面所说，很多时候你都感受不到包含块的存在。\n包含块分为两种，一种是根元素（HTML\n元素）所在的包含块，被称之为初始包含块（initial containing\nblock）。对于浏览器而言，初始包含块的的大小等于视口 viewport\n的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。\n另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种：\n\n如果元素的 positiion 是 relative 或 static\n，那么包含块由离它最近的块容器（block container）的内容区域（content\narea）的边缘建立。\n如果 position 属性是 fixed，那么包含块由视口建立。\n如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是\nstatic （也就是值为fixed、absolute、relative 或\nsticky）的祖先元素的内边距区的边缘组成。\n\n前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例：\n&lt;body&gt;    &lt;div class=\"container\"&gt;      &lt;div class=\"item\"&gt;        &lt;div class=\"item2\"&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;\n.container {  width: 500px;  height: 300px;  background-color: skyblue;  position: relative;}.item {  width: 300px;  height: 150px;  border: 5px solid;  margin-left: 100px;}.item2 {  width: 100px;  height: 100px;  background-color: red;  position: absolute;  left: 10px;  top: 10px;}\n首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。\n公布正确答案：\n\n\ncssb22\n\n怎么样？有没有和你所想象的对上？\n其实原因也非常简单，根据上面的第三条规则，对于 div.item2\n来讲，它的包含块应该是 div.container，而非 div.item。\n如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握\n80% 了。\n实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position\n属性是 absolute 或\nfixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：\n\ntransform 或 perspective 的值不是 none\nwill-change 的值是 transform 或 perspective\nfilter 的值不是 none 或 will-change 的值是 filter(只在 Firefox\n下生效).\ncontain 的值是 paint (例如: contain: paint;)\n\n我们还是来看一个示例：\n&lt;body&gt;  &lt;div class=\"container\"&gt;    &lt;div class=\"item\"&gt;      &lt;div class=\"item2\"&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;\n.container {  width: 500px;  height: 300px;  background-color: skyblue;  position: relative;}.item {  width: 300px;  height: 150px;  border: 5px solid;  margin-left: 100px;  transform: rotate(0deg); /* 新增代码 */}.item2 {  width: 100px;  height: 100px;  background-color: red;  position: absolute;  left: 10px;  top: 10px;}\n我们对于上面的代码只新增了一条声明，那就是 transform:\nrotate(0deg)，此时的渲染效果却发生了改变，如下图所示：\n\n\ncssb33\n\n可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。\n好了，到这里，关于包含块的知识就基本讲完了。\n我们再把 CSS 规范中所举的例子来看一下。\n&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Illustration of containing blocks&lt;/title&gt;  &lt;/head&gt;  &lt;body id=\"body\"&gt;    &lt;div id=\"div1\"&gt;      &lt;p id=\"p1\"&gt;This is text in the first paragraph...&lt;/p&gt;      &lt;p id=\"p2\"&gt;        This is text        &lt;em id=\"em1\"&gt;          in the          &lt;strong id=\"strong1\"&gt;second&lt;/strong&gt;          paragraph.        &lt;/em&gt;      &lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n上面是一段简单的 HTML 代码，在没有添加任何 CSS\n代码的情况下，你能说出各自的包含块么？\n对应的结果如下：\n\n\n\n元素\n包含块\n\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\nbody\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\np2\n\n\nstrong1\np2\n\n\n\n首先 HTML\n作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body\n而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为\nhtml，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。\n不过 strong1 比较例外，它的包含块确实 p2，而非\nem1。为什么会这样？建议你再把非根元素的第一条规则读一下：\n\n如果元素的 positiion 是 relative 或 static\n，那么包含块由离它最近的块容器（block\ncontainer）的内容区域（content area）的边缘建立。\n\n没错，因为 em1\n不是块容器，而包含块是离它最近的块容器的内容区域，所以是\np2。\n接下来添加如下的 CSS：\n#div1 {   position: absolute;   left: 50px; top: 50px }\n上面的代码我们对 div1\n进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。\n答案如下：\n\n\n\n元素\n包含块\n\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\ninitial C.B. (UA-dependent)\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\np2\n\n\nstrong1\np2\n\n\n\n可以看到，这里 div1\n的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话：\n\n初始包含块（initial containing\nblock）。对于浏览器而言，初始包含块的的大小等于视口 viewport\n的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。\n如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是\nstatic （也就是值为fixed、absolute、relative 或\nsticky）的祖先元素的内边距区的边缘组成。\n\n是不是一下子就理解了。没错，因为我们对 div1\n进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的\nposition 的值不是 static 的祖先元素，不过显然 body 的定位方式为\nstatic，因此 div1 的包含块最终就变成了初始包含块。\n接下来我们继续修改我们的 CSS：\n#div1 {   position: absolute;   left: 50px;   top: 50px }#em1  {   position: absolute;   left: 100px;   top: 100px }\n这里我们对 em1 同样进行了 absolute\n绝对定位，你想一想会有什么样的变化？\n没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而\nstrong1 的包含块也不再是 p2 了，而是变成了 em1。\n如下表所示：\n\n\n\n\n\n\n\n元素\n包含块\n\n\n\n\nhtml\ninitial C.B. (UA-dependent)\n\n\nbody\nhtml\n\n\ndiv1\ninitial C.B. (UA-dependent)\n\n\np1\ndiv1\n\n\np2\ndiv1\n\n\nem1\ndiv1（因为定位了，参阅非根元素包含块确定规则的第三条）\n\n\nstrong1\nem1（因为 em1\n变为了块容器，参阅非根元素包含块确定规则的第一条）\n\n\n\n好了，这就是 CSS\n规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的\nCSS 规范的人。\n另外，关于包含块的知识，在 MDN\n上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。\n具体你可以移步到：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block\n","categories":["前端"],"tags":["CSS"]},{"title":"CSS 属性计算","url":"/2024/01/11/CSS-%E5%B1%9E%E6%80%A7%E8%AE%A1%E7%AE%97/","content":"浏览器渲染过程中，CSS渲染的结果如何确定？\n\nCSS 属性计算过程\n你是否了解 CSS 的属性计算过程呢？\n有的同学可能会讲，CSS属性我倒是知道，例如：\np{  color : red;}\n上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS\n属性。\n但是要说 CSS 属性的计算过程，还真的不是很清楚。\n没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。\n首先，不知道你有没有考虑过这样的一个问题，假设在 HTML\n中有这么一段代码：\n&lt;body&gt;  &lt;h1&gt;这是一个h1标题&lt;/h1&gt;&lt;/body&gt;\n上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1\n标题呈现出来的外观是如下：\n\n\ncsssx2\n\n目前我们没有设置该 h1 的任何样式，但是却能看到该 h1\n有一定的默认样式，例如有默认的字体大小、默认的颜色。\n那么问题来了，我们这个 h1\n元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？\n答案是该元素上面会有 CSS\n所有的属性。你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此\nh1 上面所有 CSS 属性对应的值。\n\n\nimage-20220813141516153\n\n换句话说，我们所书写的任何一个 HTML\n元素，实际上都有完整的一整套 CSS\n样式。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS\n样式时，往往只会书写必要的部分，例如前面的：\np{  color : red;}\n这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color\n属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS\n样式，只不过你没有书写的样式，大概率可能会使用其默认值。例如上图中\nh1 一个样式都没有设置，全部都用的默认值。\n但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？\n嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。\n总的来讲，属性值的计算过程，分为如下这么 4 个步骤：\n\n确定声明值\n层叠冲突\n使用继承\n使用默认值\n\n确定声明值\n首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS\n样式，例如前面的：\np{  color : red;}\n这里我们声明了 p 元素为红色，那么就会应用此属性设置。\n当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。\n\n\nimage-20220813143500066\n\n在上面的示例中，作者样式表中设置了 color\n属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如\ndisplay、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end\n等属性对应的值。\n这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。\n层叠冲突\n在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。\n此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤：\n\n比较源的重要性\n比较优先级\n比较次序\n\n来来来，我们一步一步来看。\n比较源的重要性\n当不同的 CSS\n样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。\n那么问题来了，咱们的样式表的源究竟有几种呢？\n整体来讲有三种来源：\n\n浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称用户代理样式。\n网页的作者可以定义文档的样式，这是最常见的样式表，称之为页面作者样式。\n浏览器的用户，可以使用自定义样式表定制使用体验，称之为用户样式。\n\n对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt;\n用户代理样式\n更详细的来源重要性比较，可以参阅\nMDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade\n我们来看一个示例。\n例如现在有页面作者样式表和用户代理样式表中存在属性的冲突，那么会以作者样式表优先。\np{  color : red;  display: inline-block;}\n\n\nimage-20220813144222152\n\n可以明显的看到，作者样式表和用户代理样式表中同时存在的 display\n属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。\n比较优先级\n那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。\n例如：\n&lt;div class=\"test\"&gt;  &lt;h1&gt;test&lt;/h1&gt;&lt;/div&gt;\n.test h1{  font-size: 50px;}h1 {  font-size: 20px;}\n在上面的代码中，同属于页面作者样式，源的重要性是相同的，此时会以选择器的权重来比较重要性。\n很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为\n50px。\n\n\ncsssx22\n\n可以看到，落败的作者样式在 Elements&gt;Styles\n中会被划掉。\n有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity\n比较次序\n经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。\n此时就会进入第三个步骤，比较样式声明的次序。\n举个例子：\nh1 {  font-size: 50px;}h1 {  font-size: 20px;}\n在上面的代码中，同样都是页面作者样式，选择器的权重也相同，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用\n20px 这一条属性值。\n\n\nimage-20220823183928330\n\n至此，样式声明中存在冲突的所有情况，就全部被解决了。\n使用继承\n层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。\n那么如果没有声明的属性呢？此时就使用默认值么？\nNo、No、No，别急，此时还有第三个步骤，那就是使用继承而来的值。\n例如：\n&lt;div&gt;  &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;/div&gt;\ndiv {  color: red;}\n在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p\n元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p\n元素从最近的 div 身上继承到了 color 属性的值。\n\n\nimage-20220813145102293\n\n这里有两个点需要同学们注意一下。\n首先第一个是我强调了是最近的 div\n元素，看下面的例子：\n&lt;div class=\"test\"&gt;  &lt;div&gt;    &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;\ndiv {  color: red;}.test{  color: blue;}\n\n\nimage-20220813145652726\n\n因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到\ncolor\n对应的值，因此这里是谁近就听谁的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到\np 元素。\n第二个就是哪些属性能够继承？\n关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以\ntext-align 为例，如下图所示：\n\n\nimage-20220813150147885\n\n使用默认值\n好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。\n如下图所示：\n\n\nimage-20220813150824752\n\n前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的\nCSS\n属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。\n好了，这就是关于 CSS 属性计算过程的所有知识了。\n\n\ncsssx1\n\n一道面试题\n好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。\n下面的代码，最终渲染出来的效果，a 元素是什么颜色？p\n元素又是什么颜色？\n&lt;div&gt;  &lt;a href=\"\"&gt;test&lt;/a&gt;  &lt;p&gt;test&lt;/p&gt;&lt;/div&gt;\ndiv {  color: red;}\n大家能说出为什么会呈现这样的结果么？\n解答如下：\n\n\nimage-20220813151941113\n\n实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color\n属性对应的值，因此会应用此声明值。而在 p\n元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于\ncolor 属性是可以继承的，因此最终 p 元素的 color\n属性值通过继承来自于父元素。\n","categories":["前端"],"tags":["CSS"]},{"title":"CodeForces Round 849","url":"/2025/04/09/CodeForces-Round-849/","content":"A -\nCodeforces Checking [Easy] 题解\nB - Following\nDirections [Easy] 题解\nC - Prepend\nand Append [Easy] 题解\nD - Distinct\nSplit [Easy] 题解\nE - Negatives\nand Positives [Easy] 题解\nF - Range\nUpdate Point Query [Easy] 题解\nG1 -\nTeleporters (Easy Version) [Medium] 题解\nG2 -\nTeleporters (Hard Version) [Hard] 题解\n\nA - Codeforces Checking\n\nA -\nCodeforces Checking\n就是给你一个字符，判断它是不是在单词“codeforces”里。\n\n思路\n暴力\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():    x = input()    print(\"yes\" if x in \"codeforces\" else \"no\")\nB - Following Directions\n\nB - Following\nDirections\n给你一个字符串表示移动方向，看移动过程中有没有经过点（1， 1）。\n\n思路\n数据量很小，直接模拟；到了点（1， 1）就return true。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():    n = int(input())    s = input()    x, y = 0, 0    for i in range(n):        c = s[i]        if c == 'U': y += 1        if c == 'D': y -= 1        if c == 'L': x -= 1        if c == 'R': x += 1        if x == 1 and y == 1:            print(\"yes\")            return    print(\"no\")\nC. Prepend and Append\n\nC - Prepend\nand Append\n有一个操作每次可以将字符串头部和尾部加上0、1或1、0。给你一个字符串，返回可以经过任意次操作可得到它的最短字符串。\n\n思路\n反向思考，每次操作删去首尾0、1。直到首尾为0、0或1、1或字符串为空。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():    n = int(input())    s = input()    t = 0    while t &lt; n//2 and s[t]+s[n-t-1] in '010': t += 1    print(n-t*2)    \nD. Distinct Split\n\nD - Distinct\nSplit\n让我们把一个字符串x的f(x)函数表示为该字符串包含的不同字符的数量。例如f(abc)=3,\nf(bbbb)=1和f(babacaba)=3。\n给定一个字符串ss，把它分成两个非空字符串a和b，使f(a)+f(b)为最大可能值。换句话说，找出f(a)+f(b)的最大可能值，使a+b=ss。\n\n思路\n枚举分割点，分别维护两边不同字符的数量。\n考虑到Set比较耗时，可以用两个数组来记录出现不同字符的数目：增加后字符数量为1就+1，删除后字符数量为0就-1。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n代码\ndef solve():    n = int(input())    s = input()    a, b, c1, c2, ans = [0]*26, [0]*26, 0, 0, 0    for x in s:        i = ord(x)-ord('a')        b[i] += 1        if b[i] == 1: c2 += 1    for x in s:        i = ord(x)-ord('a')        a[i] += 1        if a[i] == 1: c1 += 1        b[i] -= 1        if b[i] == 0: c2 -= 1        ans = max(ans, c1+c2)    print(ans)\nE. Negatives and Positives\n\nE - Negatives\nand Positives\n给定一个由n个元素组成的数组a，求该数组在执行以下任意次数的操作后可能具有的最大和。\n选择2个相邻的元素，翻转它们的符号。换句话说，选择一个索引i，使1≤i≤n-1，并指定ai=-ai，ai+1=-ai+1。\n\n思路\n一眼看去像是贪心，但不敢贪😅；这题动态规划思路很好像，还是老老实实DP。\n对于每个数而言，只有两种可能情况：翻转和不翻转（和背包问题很像，可以看看这篇文章这篇文章）。\n于是定义dp[i][0]:不翻转第i个数可以得到的最大值 dp[i][1]翻转第i个数可以得到的最大值:\n递推：不反转就直接把第i个数和前面可以得到的最大值相加；否则第i个数和第i-1个数也要翻转。\ndp[i-1][0]表示i-1个数没有翻转，此时dp[i-1][0]-a[i-1]就是前i-2个数最大值，再减去a[i-1]和a[i]就行。\ndp[i-1][1]表示i-1个数没有翻转，此时dp[i-1][0]+a[i-1]就是前i-2个数最大值，再减去-a[i-1]和a[i]就行。（因为此时啊a[i-1]翻转过了，变成了-a[i-1]）\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n代码\ndef solve():     n = int(input())    a = list(map(int, input().split()))    dp = [[0]*2 for i in range(n+1)]    dp[1][0], dp[1][1] = a[0], int(-1e18)    for i in range(2, n+1):        dp[i][0] = max(dp[i-1][0], dp[i-1][1])+a[i-1]        dp[i][1] = max(dp[i-1][0]-2*a[i-2], dp[i-1][1]+2*a[i-2])-a[i-1]    print(max(dp[n][0], dp[n][1]))\nTips\n\ndp[1][0], dp[1][1] = a[0], int(-1e18)\n初始化要思考下。\n单独翻转第一个数是不可能的，所以要设置为无穷小。（比可能的最小值小就行了，一开始写成-1e9，怒wa）\n\nF. Range Update Point Query\n\nF - Range\nUpdate Point Query\n给定一个数组a1,a2,……,an，你需要处理两类共计q的更新和查询。\n1 l r -\n对于每个有l≤i≤r的索引i，将ai的值更新为ai的各个位数上的数字之和。\n2 x - 输出a[x]。\n\n思路\n看到题干，一眼线段树。但这题只涉及区间修改和单点查询，用树状数组更简单。两种数据结构详见数据结构\n还要注意所有可能的数最多更新三次就不会变了。\n\n时间复杂度：O(nlog n)\n空间复杂度：O(n)\n\n代码\nstatic int n, m, a[] = new int[N], tr[] = new int[N];static void add(int x, int v){    for (int i = x;i &lt;= n;i += i&amp;-i) tr[i] += v;}static int sum(int x){    int res = 0;    for (int i = x;i &gt; 0;i -= i&amp;-i) res += tr[i];    return res;}static int get(int t, int cnt){    while (cnt != 0 &amp;&amp; t &gt; 9){        int tp = 0;        while (t != 0){            tp += t%10;            t /= 10;        } t = tp;        cnt--;    }return t;}static void solve() throws Exception{    n = ni(); m = ni();    Arrays.fill(a, 0); Arrays.fill(tr, 0);    for (int i = 1;i &lt;= n;i++) a[i] = ni();    for (int i = 0;i &lt; m;i++){        int op = ni();        if (op == 1){            int l = ni(), r = ni();            add(l, 1); add(r+1, -1);        }else{            int t = ni();            out.println(get(a[t], sum(t)));        }    }}\nTips\n\n多组测试用例的题目，对于全局变量一定要初始化！！！\n即Arrays.fill(a, 0); Arrays.fill(tr, 0);，不然会死的很惨。\n\nG1. Teleporters (Easy\nVersion)\n\nG1 -\nTeleporters (Easy Version)\n考虑到数线上的点0,1,…,n。在每一个点1,2,…,n上有一个传送器。在i点，你可以做以下事情。\n\n向左移动一个单位：花费1枚硬币。\n向右移动一个单位：需要花费1个硬币。\n在第i点使用一个传送器，如果它存在的话：它需要花费ai硬币。结果，你会被传送到0点。\n一旦你使用了一个传送器，你就不能再使用它了。\n\n你有c硬币，你从0点开始。你最多可以使用多少个传送器？\n\n思路\n可以发现，每次到一个点传送后都回到原点。即到达每个点使用传送器的总消耗是独立的，等于\n到该点的花费+该店使用传送的花费。\n即预处理所有点的花费，从小到大排序，看最多能支持几次。（其实可以前缀和+二分，但懒😅）\n\n时间复杂度：O(nlog n)\n空间复杂度：O(n)\n\n代码\ndef solve():     n, m = list(map(int, input().split()))    a = list(map(int, input().split()))    cost = [i+1+a[i] for i in range(n)]    cost.sort()    ans, s = 0, 0    for i in cost:        s += i        if s &lt;= m:            ans += 1        else: break    print(ans)\nG2. Teleporters (Hard\nVersion)\n\nG2 -\nTeleporters (Hard Version)\n与EASY版本不同的是使用传送后，可以回到点0，也可以回到点n+1。\n\n思路\n与EASY版本一样，如果我们不考虑第一个去的点，问题对每个点来说仍然是独立的，但这一次门户的成本是min(a[i]+i,a[i]+n+1-i)（因为我们可以从0点或n+1点来到一个门户）。因此，我们再次按成本对传送门进行排序。但是这一次，我们需要确保第一个拿下的传送门是从0点去的，所以我们将遍历所有的点，并检查如果我们把它作为第一个传送门，我们能拿下的最大传送门数量。\n这里就需要用二分找到每次可以去的点的最大值。（与常规二分不同，需要单独对当前遍历到的点处理）\n\n时间复杂度：O(nlog n)\n空间复杂度：O(n)\n\n代码\nstatic int n, c;static long a[] = new long[N], cost[][] = new long[N][2];static void solve() throws Exception{    n = ni(); c = ni();    Arrays.fill(a, 0);    for (int i = 1;i &lt;= n;i++) cost[i] = new long[]{0, 0};    for (int i = 1;i &lt;= n;i++) a[i] = ni();    for (int i = 1;i &lt;= n;i++){        cost[i][0] = min(i+a[i], n-i+1+a[i]);        cost[i][1] = i;    }    Arrays.sort(cost, 1, n+1, (x,y)-&gt;Long.compare(x[0], y[0]));    for (int i = 1;i &lt;= n;i++) cost[i][0] += cost[i-1][0];    int ans = 0;    for (int i = 1;i &lt;= n;i++){        int l = 1, r = n, dx = i;        long first = cost[i][1]+a[(int)cost[i][1]];        if (first &gt; c) continue;        while (l &lt;= r){            int m = l+r &gt;&gt; 1;            long cur = cost[m][0];            if (m &lt; dx) cur += first;            else cur += first-cost[dx][0]+cost[dx-1][0];            if (cur &lt;= c) l = m+1;            else r = m-1;        }        ans = max(ans, r&lt;dx?r+1:r);    }out.println(ans);}\n","categories":["Algorithm","CodeForces","Problem","Contest"],"tags":["模拟","动态规划","二分","前缀和","树状数组"]},{"title":"CodeForces Round 888","url":"/2025/03/26/CodeForces-Round-888/","content":"​\nE. Nastya and\nPotions [Medium] 题解\nF. Lisa and\nthe Martians [Hard] 题解\n\nProblem - E -\nCodeforces\n\n需要n个药水用于做实验，第i个药水价值cost[i]。\n再给你k个药水下标，表示这些药水都是免费的（学生福利）。\n最后告诉你每个药水不仅可以直接买，还可以通过其他药水合成。\n问你分别得到每个药水费用最小值。\n\n思路\n经典的dp问题，将费用分为两种情况：\n\n直接购买\n通过其他合成\n\n两者取最小即可，可以直接记忆化搜索（写起来快）。\n代码\nvector&lt;int&gt; a, cost;vector&lt;vector&lt;int&gt;&gt; g;ll dp(int x){    if (a[x] != -1) return a[x];    ll min_cost = cost[x]; // 直接购买    // 如果直接购买费用不为0且可以通过其他合成-&gt;递归搜索    if (min_cost != 0 &amp;&amp; g[x].size() != 0){        ll sum = 0;        for (int pre : g[x]){            sum += dp(pre);        }        min_cost = min(min_cost, sum);    }    a[x] = min_cost;    return a[x];}void solve(){    cin &gt;&gt; n &gt;&gt; k;    a.resize(n + 1); a.assign(n + 1, -1);    cost.resize(n + 1); cost.assign(n + 1, 0);    g.resize(n + 1); g.assign(n + 1, vector&lt;int&gt;());    for (int i = 1;i &lt;= n;i++){         cin &gt;&gt; cost[i];    }    for (int i = 0;i &lt; k;i++){        int tp = 0; cin &gt;&gt; tp;        cost[tp] = 0;    }    for (int i = 1;i &lt;= n;i++){        int cnt = 0; cin &gt;&gt; cnt;        for (int j = 0;j &lt; cnt;j++){            int cur = 0; cin &gt;&gt; cur;            g[i].push_back(cur);        }    }    for (int i = 1;i &lt;= n;i++){        p(dp(i));    }    nl;}\n复杂度分析\n\n时间复杂度: O(n)\n。\n空间复杂度: O(n)\n。\n\n\nProblem - F -\nCodeforces\n\n给你n个数字，每个数字二进制表示都是k位。\n求一个整数x，使得(ai ⊕ x)&amp;(aj ⊕ x)最大。\n\n思路\n\n因为最后会&amp;，\n所以我们尽量要让两个数字高位都为1，这样最后才会尽可能大。\n又因为两边数字都会异或x，要为1的话就对应位需要和x不同。\n即ai和aj要求从高到低对应位尽量相同，与x尽量不同。\n即求出ai和aj的同或最大值即可，x可以根据这两个数中任意一个构造。\n此时可以通过字典树来解决。\n\n代码\nstruct trie{    trie* next[2] = {nullptr, nullptr};    int x; //保存走到这个位置上的数的下标};trie* root;int find(int t, int dx){    trie* cur = root;    int x = 0, f = 0;    for (int i = k-1;i &gt;= 0;i--){        int bit = (t &gt;&gt; i &amp; 1);        if (cur-&gt;next[bit] == nullptr){            cur-&gt;next[bit] = new trie();            f = 1;        }else{            if (f == 0 || x == -1){                x = cur-&gt;next[bit]-&gt;x;               }        }        cur-&gt;next[bit]-&gt;x = dx;        cur = cur-&gt;next[bit];    }    if (x == 0) x = 1;    return x;}// 计算同或int cal(int x, int y){    int res = 0;    for (int i = k-1;i &gt;= 0;i--){        int bit1 = (x &gt;&gt; i &amp; 1);        int bit2 = (y &gt;&gt; i &amp; 1);        res |= (bit1^bit2^1) &lt;&lt; i;    }    return res;}void solve(){    cin &gt;&gt; n &gt;&gt; k;    root = new trie();    int ans = 0, x = 0, y = 0, z = 0;    for (int i = 1;i &lt;= n;i++){        int t = 0; cin &gt;&gt; t;        a[i] = t;        int res = find(t, i);        int maxv = cal(t, a[res]);        if (i &gt; 1 &amp;&amp; ans &lt;= maxv){            ans = maxv;            x = i, y = res;        }    }    // 翻转二进制位    for (int i = k-1;i &gt;= 0;i--){        int bit = (a[x] &gt;&gt; i &amp; 1) ^ 1;        z |= bit &lt;&lt; i;    }    p(x);p(y);pl(z);}\n复杂度分析\n\n时间复杂度: O(nk) 。\n空间复杂度: O(n)\n。\n\n","categories":["Algorithm","CodeForces","Problem","Contest"],"tags":["贪心","DFS","异或","字典树"]},{"title":"Data Structure Algorithm","url":"/2022/12/31/Data-Structure-Algorithm/","content":"数据结构与算法的常见应用，涵盖并查集、树状数组、线段树、ST表和分块算法等。涉及并查集的路径压缩与秩压缩优化，树状数组的区间查询与更新操作，线段树的区间求和与区间最值查询，ST表的倍增技术用于区间最值查询等。\n\n并查集\n并查集是一种树形的数据结构，它用于处理一些不交集的\n合并 及 查询 问题。\n它支持两种操作：\n\n查找（Find）：确定某个元素处于哪个子集；\n合并（Union）：将两个子集合并成一个集合。\n\n并不能提供删除操作\nint[] father;int[] rank; //秩压缩UnionSet(int n){    father = new int[n];    rank = new int[n];    for (int i = 0;i &lt; n;i++) father[i] = i; //初始化 每个i肯定在它本身所对应的集合中}void join(int x, int y){    x = find(x); y = find(y);    if (x != y){        if (rank[x] &gt; rank[y]) father[y] = x;        else{            if (rank[x] == rank[y]) rank[y]++;            father[x] = y;        }    }// 简单点 直接 father[x] = y;}int find(int x){    if (x == father[x]) return x;    return father[x] = find(father[x]); //路径压缩}\n\n树状数组\n单点修改 区间查询\nstatic long[] tr; //树状数组 （不是原数组）static int lowbit(int x){    return x &amp; -x;}static void add(int idx, int w){ //原数组a[idx] += w;    for (int i = idx;i &lt;= n;i += lowbit(i)) tr[i] += w;}static long sum(int idx){ //求原数组a[1]+a[2]+...+a[idx]和    long res = 0;    for (int i = idx;i &gt; 0;i -= lowbit(i)) res += tr[i];    return res;}System.out.println(sum(r)-sum(l-1)); //求原数组a[l]+a[l+1]+...+a[r]和\nadd时间复杂度 \nsum时间复杂度 \n区间修改 单点查询\nstatic int[] tr, ori; //tr维护的是ori（原数组）的差分数组static int lowbit(int x){...}static void add(int idx, int w){...}static long sum(int idx){...}for (int i = 1;i &lt;= n;i++) add(i, ori[i]-ori[i-1]); //初始化差分数组add(l, w); add(r+1, -w); //ori区间l~r上都加上wSystem.out.println(sum(idx)); //计算ori[idx]\n区间修改 区间查询\n位置p的前缀和 =\n\n在等式最右侧的式子  中， d[1] 被用了 p 次， d[2] 被用了 p − 1 次…..那么我们可以写出:\n位置p的前缀和 =\n\n那么我们可以维护两个差分数组的前缀和（d[i]是a[i]的差分数组）:\n一个数组是 sum 1[i] = ∑d[i]\n， 另一个数组是 sum 2[i] = ∑d[i] * i\n。\nstatic long[] tr1, tr2; //对应上面的sum1[], sum2[]static int[] ori;static int lowbit(int x){...}static void add(int idx, long w){    for (int i = idx;i &lt;= n;i += lowbit(i)){        tr1[i] += w;        tr2[i] += w*idx; //不是 w*i    }}static long sum(int idx){ //求ori区间 1~idx 的和    long res = 0;    for (int i = idx;i &gt; 0;i -= lowbit(i)){        res += (idx+1)*tr1[i]-tr2[i]; //不是 (i+1)*tr[1]    }    return res;}for (int i = 1;i &lt;= n;i++) add(i, ori[i]-ori[i-1]); //初始化差分数组add(l, w); add(r+1, -w); //ori区间l~r上都加上wSystem.out.println(sum(r)-sum(l-1)); //求原数组ori[l]+ori[l+1]+...+ori[r]和\n最值问题\n树状数组 C[i] 所包含的区间[i − lowbit(i) + 1, i],\n其中区间的个数是 个, C[i] 一定包含A[i]\n树状数组下标都从1开始\n\n\nimage-20250601173428110\n\nstatic void update(int x) {    for (int i = x;i &lt;= n;i += lowbit(i)){        tr[i] = ori[i];·        for (int j = 1;j &lt; lowbit(i);j &lt;&lt;= 1) tr[i] = max(tr[i], tr[i-j]);    }}static int query(int l, int r){    int ans = ori[r];    while (l &lt;= r){        ans = max(ans, ori[r--]);        while (r-lowbit(r) &gt;= l){            ans = max(ans, tr[r]);            r -= lowbit(r);        }    }    return ans;}public static void main(String[] args) throws Exception{    for (int i = 1;i &lt;= n;i++){        ori[i] = nextInt();//初始化        update(i);    }    while (m-- &gt; 0){        io = in.readLine().split(\" \");        char ops = io[0].charAt(0);        int x = Integer.parseInt(io[1]), y = Integer.parseInt(io[2]);        if (ops == 'U'){            ori[x] = y;// 更新 首先更新原数组值 （把x处的值变成y）            update(x);        }        else System.out.println(query(x, y));    }}\n求解GCD，LCM等其他问题只需要把里面max()换成GCD()就行了\n项链\n\n线段树\n\n求和基本操作\n\n线段树将每个长度不为\n的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。\n有个大小为 5 的数组 a = {10, 11, 12, 13, 14}，要将其转化为线段树，有以下做法：设线段树的根节点编号为\n1，用数组d来保存我们的线段树， d[i]用来保存线段树上编号为i的节点的值（这里每个节点所维护的值就是这个节点所表示的区间总和）。\n\n\nimage-20250601173516107\n\n// f[i]:以i为根对应的区间和 v[i]:表示以i为根对应的区间是否要修改 a[i]:原数组static long[] f = new long[N], v = new long[N], a = new long[M];static void build(int k, int l, int r){    if (l == r){        f[k] = a[l];        return;    }    int m = l+r &gt;&gt; 1;    build(k*2, l, m);    build(k*2+1, m+1, r);    f[k] = f[k*2]+f[k*2+1];}static void down(int k, int l, int r, int m){    if (v[k] == 0) return;    f[k*2] += v[k]*(m-l+1);    f[k*2+1] += v[k]*(r-m); //更新下一层f    v[k*2] += v[k];     v[k*2+1] += v[k]; //更新下一层标记    v[k] = 0; //这一层标记清0}static void add(int k, int l, int r, int s, int t, long w){    if (s &lt;= l &amp;&amp; r &lt;= t){        f[k] += w*(r-l+1);        v[k] += w;        return;    }    int m = l+r &gt;&gt; 1;    down(k, l, r, m);    if (s &lt;= m) add(k*2, l, m, s, t, w);    if (t &gt; m) add(k*2+1, m+1, r, s, t, w);    f[k] = f[k*2] + f[k*2+1];}static long sum(int k, int l, int r, int s, int t){    if (s &lt;= l &amp;&amp; r &lt;= t) return f[k];    int m = l+r &gt;&gt; 1;    down(k, l, r, m);    long res = 0;    if (s &lt;= m) res += sum(k*2, l, m, s, t);    if (t &gt; m) res += sum(k*2+1, m+1, r, s, t);    return res;}build(1, 1, n); //建树add(1, 1, n, x, y, w); //原数组[x, y]上加wsum(1, 1, n, x, y)； //原数组[x, y]求和\n关于线段树的空间：d = new\nint[n &lt;  &lt; 2]\n开四倍空间\n再提供一个C++版本的动态开点版本：\nstruct node{    int val = 0, add = 0;    node *left = nullptr, *right = nullptr;};void down(node* cur, int l, int r, int m){    int t = cur-&gt;add;    if (cur-&gt;left == nullptr) cur-&gt;left = new node();    if (cur-&gt;right == nullptr) cur-&gt;right = new node();    cur-&gt;left-&gt;val += t*(m-l+1);    cur-&gt;right-&gt;val += t*(r-m);    cur-&gt;left-&gt;add += t;    cur-&gt;right-&gt;add += t;     cur-&gt;add = 0;}void upd(node* cur, int l, int r, int s, int t, int val){    if (s &lt;= l &amp;&amp; r &lt;= t){        cur-&gt;val += val*(r-l+1);        cur-&gt;add += val;        return;    }    int m = l+r &gt;&gt; 1;    down(cur, l, r, m);    if (s &lt;= m) upd(cur-&gt;left, l, m, s, t, val);    if (m+1 &lt;= t) upd(cur-&gt;right, m+1, r, s, t, val);    cur-&gt;val = cur-&gt;left-&gt;val+cur-&gt;right-&gt;val;}int qry(node* cur, int l, int r, int s, int t){    if (s &lt;= l &amp;&amp; r &lt;= t) return cur-&gt;val;    int m = l+r &gt;&gt; 1, res = 0;    down(cur, l, r, m);    if (s &lt;= m) res += qry(cur-&gt;left, l, m, s, t);    if (m+1 &lt;= t) res += qry(cur-&gt;right, m+1, r, s, t);    return res;}// examplenode* root;int MAXV = 1e9;NumArray(vector&lt;int&gt;&amp; nums) {    root = new node();    for (int i = 1;i &lt;= nums.size();i++){        upd(root, 1, MAXV, i, i, nums[i-1]);    }}void update(int index, int val) {    upd(root, 1, MAXV, index+1, index+1, val);}int sumRange(int left, int right) {    return qry(root, 1, MAXV, left+1, right+1);}\n\nST表(离线区间查询)\nST表（Sparse\nTable，稀疏表）是一种简单的数据结构，主要用来解决RMQ（Range\nMaximum/Minimum\nQuery，区间最大/最小值查询）问题。它主要应用倍增的思想，可以实现O(nlog n)预处理、\nO(1)查询。\n主要思想：倍增\nST表板子\nF[i][j]:原数组区间[i, i + 2j − 1]的最值\n\n预处理原理\nf[j][i] = Max(f[j][i-1], f[j+(1&lt;&lt;(i-1))][i-1]);\n\n\n\nimage-20250601173733251\n\n\n查询原理\nres = Math.max(f[l][s], f[r-(1&lt;&lt;s)+1][s]);\n\n需要找到两个[l, r]的子区间，它们的并集恰是\n[l, r](可以相交)。\n\n\nimage-20250601173757465\n\nstatic int[][] f = new int[N][17]; //第二维的大小根据数据范围决定，不小于log2(N)static int[] log2 = new int[N];private static void init() {    for (int i = 2;i &lt;= n;i++) log2[i] = log2[i/2]+1; //对log2也进行一次递推的预处理    for (int i = 1;i &lt;= n;i++) f[i][0] = A[i]; //初始化 区间[i, i]最值就是A[i]本身    for (int i = 1;i &lt;= 17;i++){        for (int j = 1;j + (1&lt;&lt;i)-1 &lt;= n;j++){            f[j][i] = Math.max(f[j][i-1], f[j+(1&lt;&lt;(i-1))][i-1]);        }    }}private static int query(int l, int r) {    int s = log2[r-l+1];    int res = Math.max(f[l][s], f[r-(1&lt;&lt;s)+1][s]);    return res;}\n其实ST表不仅能处理最大值/最小值，凡是符合结合律且可重复贡献的信息查询都可以使用ST表高效进行。什么叫可重复贡献呢？设有一个二元运算\nf(x, y)，满足\nf(a, a) = a，则f(x, y)是可重复贡献的。显然最大值(max)、最小值(min)、最大公因数(GCD)、最小公倍数(LCM)、按位或(|)、按位与(&amp;)都符合这个条件。可重复贡献的意义在于，可以对两个交集不为空的区间进行信息合并。区间和就不具有这个性质，求区间和的时候采用的预处理区间重叠了，则会导致重叠部分被计算两次；即f(a, a) = 2a。\n\n分块\nP3372 【模板】线段树\n1 - 洛谷 | 计算机科学教育新生态\n传说中的根号算法，比线段树和树状数组好理解，优雅的暴力。\nstatic int n, m, bel[]=new int[N];static int sq, st[]=new int[N], ed[]=new int[N];static long a[]=new long[N], sum[]=new long[N], f[]=new long[N];static void update(int l, int r, long v){    // 当x与y在同一块内时，直接暴力修改原数组和sum数组：    if (bel[l] == bel[r]){        for (int i = l;i &lt;= r;i++){            a[i] += v;            sum[bel[i]] += v;        }    }else{ // 否则，先暴力修改左右两边的零散区间：        for (int i = l;i &lt;= ed[bel[l]];i++){            a[i] += v;            sum[bel[i]] += v;        }        for (int i = st[bel[r]];i &lt;= r;i++){            a[i] += v;            sum[bel[i]] += v;        } // 对中间的整块打上标记 （与线段树的打标记类似）        for (int i = bel[l] + 1; i &lt; bel[r]; ++i) f[i] += v;    }}static long query(int l, int r){    long ans = 0;    if (bel[l] == bel[r]){ // 左右两边在同一块，直接暴力计算区间和。        for (int i = l;i &lt;= r;i++) ans += a[i];    }else{ // 否则，先暴力计算左右两边零碎块        for (int i = l;i &lt;= ed[bel[l]];i++) ans += a[i]+f[bel[i]];        for (int i = st[bel[r]];i &lt;= r;i++) ans += a[i]+f[bel[i]];        // 处理中间整块 （不要忘了把标记值也加上去）        for (int i = bel[l] + 1; i &lt; bel[r]; ++i) ans += sum[i]+f[i]*(ed[i]-st[i]+1);    }    return ans;}static void solve() throws Exception {    sq = (int)Math.sqrt(n); //获得块数    for (int i = 1;i &lt;= sq;i++){        st[i] = n/sq*(i-1)+1; // st[i]表示i号块的第一个元素的下标        ed[i] = n/sq*i; // ed[i]表示i号块的最后一个元素的下标    }    ed[sq] = n;     //数组的长度并不一定是一个完全平方数，所以这样下来很可能会漏掉一小块，我们把它们纳入最后一块中。    for (int i = 1; i &lt;= sq; ++i){        for (int j = st[i]; j &lt;= ed[i]; ++j){            bel[j] = i; //为每个元素确定它所归属的块：            sum[i] += a[j]; //预处理每个块中所有元素的和        }    }    update(l, r, x); //[l, r]加上x    query(l, r); //查询[l, r]和}\n算算时间复杂度\n首先看查询操作:\n\n若 l 和 r\n在同一个块内，直接暴力求和即可，因为块长为 s ，因此最坏复杂度为 O(s) 。\n若 l 和 r\n不在同一个块内，则答案由三部分组成：以 l 开头的不完整块，中间几个完整块，以\nr\n结尾的不完整块。对于不完整的块，仍然采用上面暴力计算的方法，对于完整块，则直接利用已经求出的\nbi\n求和即可。这种情况下，最坏复杂度为  。\n\n接下来是修改操作：\n\n若 l 和 r\n在同一个块内，直接暴力修改即可，因为块长为 s ，因此最坏复杂度为 O(s) 。\n若 l 和 r\n不在同一个块内，则需要修改三部分：以 l 开头的不完整块，中间几个完整块，以\nr\n结尾的不完整块。对于不完整的块，仍然是暴力修改每个元素的值（别忘了更新区间和\nbi ），\n对于完整块，则直接修改 bi\n即可。这种情况下，最坏复杂度和仍然为  。\n\n利用均值不等式可知，当  ，即  时，单次操作的时间复杂度最优，为\n 。\n对于数组长度为 n，查询和修改次数为 m，时间复杂度为 \n\n莫队\n基于分块思想，复杂度为\n 。\n一般来说，如果可以在 O(1) 内从 [l,r] 的答案转移到 [l−1,r] 、 [l+1,r]\n、 [l,r−1] 、 [l,r+1]\n这四个与之紧邻的区间的答案，则可以考虑使用莫队。\nSPOJ\nDQUERY - D-query\nstatic int[] a = new int[N], cnt = new int[N], ans = new int[N];static int[][] q = new int[N][3];static void add(int p){    if (cnt[a[p]]++ == 0) cur++;}static void del(int p){    if (--cnt[a[p]] == 0) cur--;}static void solve() throws Exception{    n = ni(); sq = (int)Math.sqrt(n);    for (int i = 1;i &lt;= n;i++) a[i] = ni();    m = ni();    for (int i = 1;i &lt;= m;i++){    q[i][0] = ni();    q[i][1] = ni();    q[i][2] = i;    }    Arrays.sort(q, 1, m+1, (x, y)-&gt;{        if (x[0]/sq == y[0]/sq){            if (x[0]/sq % 2 == 1) return x[1]/sq-y[1]/sq;            return y[1]/sq-x[1]/sq;        }        return x[0]/sq - y[0]/sq;    });    for (int i = 1;i &lt;= m;i++){        int s = q[i][0], t = q[i][1], dx = q[i][2];        while (l &gt; s) add(--l);        while (l &lt; s) del(l++);        while (r &gt; t) del(r--);        while (r &lt; t) add(++r);        ans[dx] = cur;    }    for (int i = 1;i &lt;= m;i++) out.println(ans[i]);}\n线性基\n性质\n\n原数列里的任何一个数都可以通过线性基里的数异或表示出来\n线性基里任意一个子集的异或和都不为0\n一个数列可能有多个线性基，但是线性基里数的数量一定唯一，而且是满足性质一的基础上最少的\n线性基中元素互相异或，异或集合不变。\n\n用处\n\n快速查询一个数是否可以被一堆数异或出来\n快速查询一堆数可以异或出来的最大/最小值\n快速查询一堆数可以异或出来的第k大值\n\n\n线性基序列构造\n\nstatic long[] d = new long[63]; //大小 = Log2(X) x是原序列中最大的数static void add(long x) {    for (int i = 62;i &gt;= 0;i--){        if ((x &gt;&gt; i &amp; 1) == 0) continue;        // x第i位是1  d[i]没有插入数,则d[i] = x;否则x与插入的数异或,继续循环.        if (d[i] == 0){             d[i] = x; break;        }        x ^= d[i];    }    if (x != 0) ++cnt; // cnt表示原序列的数插入线性基序列中的数量 就是线性基序列有效长度}\n\n查询一个元素是否可以被原序列中的数异或出来\n\nBoolean ask(long x) {\tfor(R int i=62;i&gt;=0;i--) \t\tif((x &gt;&gt; i &amp; 1) == 1) x ^= d[i];\treturn x==0;}\n前置知识：a ^ b ^ c = 0 ⇒ a\n^ b = c且a ^ c = b且b ^ c = a\n对于一个数x不能成功插入线性基。显然就是它在尝试插入时异或若干个数之后变成了0。\n则有：x∧d[a]∧d[b]∧d[c]∧… = 0\n即：d[a]∧d[b]∧d[c]∧… = x\n说明x肯定能由原序列中数异或得到。\n\n求原序列异或最大值\n\nstatic long getMax() {    long ans = 0;    for (int i = 62;i &gt;= 0;i--) ans = Math.max(ans, ans^d[i]);    return ans;}\n\n求原序列异或最小值\n\nstatic long getMax() { //如果插入的数量和原序列数量不等 那么说明肯定存在一个数能由其他数表示出,于是这些数异或肯定等于0。    if (cnt != n) return 0;    long ans = 0;    for (int i = 0;i &lt;= 63 &amp;&amp; ans == 0;i++){        if (d[i] != 0) ans = d[i]; //直接找一个最小的数就行 因为 a^x &gt;= a; x为任意正整数    }    return ans;}\n\n求原序列异或第k小值\n\nstatic void rebuild() {    for(int i = 62;i &gt;= 0;i--) {        for (int j = i - 1; j &gt;= 0; j--) {            if ((d[i]&gt;&gt;j &amp; 1) == 1) d[i] ^= d[j];        }    }    for(int i = 0;i &lt;= 62;i++) if(d[i]!=0) p[m++]=d[i];    // m为线性基的个数}static long Kmin(int k){    //m与n不同 说明原序列中存在异或和为0的序列    //下面求第k小是不包含0的 所以要把0排除 即要求的第k小其实是k-1小    if (m != n) --k;     if (k == 0) return 0; //k等于0 说明求的第1小且最小值为0    //m个线性基都有两个状态 选或不选 但全不选是不合题意的要减去1 总共有2^m-1个可能的异或值    if (k &gt;= (1L &lt;&lt; m)) return -1;     long res = 0;    for (int i = 0;i &lt;= 62;i++) if ((k&gt;&gt;i &amp; 1) == 1) res ^= p[i];    return res;}\n","categories":["Algorithm","Template"],"tags":["Template","树状数组","并查集","线段树","ST表","分块","莫队","线性基"]},{"title":"Database View视图","url":"/2024/02/22/Database-View%E8%A7%86%E5%9B%BE/","content":"SQL\n中视图（View）的定义、创建、更新与删除方法，涵盖单表视图、多表联合视图、基于视图再创建视图的技巧，并结合大量示例说明视图在数据格式化、权限控制、逻辑封装等方面的实际应用。同时分析了视图可更新与不可更新的情形，总结了视图的优缺点及其在大型数据库项目中的使用价值与维护风险。\n\n1. 常见的数据库对象\n\n\n\n\n\n\n\n对象\n描述\n\n\n\n\n表(TABLE)\n表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录\n\n\n数据字典\n就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看\n\n\n约束(CONSTRAINT)\n执行数据校验的规则，用于保证数据完整性的规则\n\n\n视图(VIEW)\n一个或者多个数据表里的数据的逻辑显示，视图并不存储数据\n\n\n索引(INDEX)\n用于提高查询性能，相当于书的目录\n\n\n存储过程(PROCEDURE)\n用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境\n\n\n存储函数(FUNCTION)\n用于完成一次特定的计算，具有一个返回值\n\n\n触发器(TRIGGER)\n相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理\n\n\n\n2. 视图概述\n2.1 为什么使用视图？\n视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。\n刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。\n2.2 视图的理解\n\n视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是\nSQL 中的一个重要概念。\n视图建立在已有表的基础上,\n视图赖以建立的这些表称为基表。\n视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。\n向视图提供数据内容的语句为 SELECT 语句,\n可以将视图理解为存储起来的 SELECT\n语句\n\n在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。\n\n视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。\n\n3. 创建视图\n\n在 CREATE VIEW\n语句中嵌入子查询\n\nCREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION]\n\n精简版\n\nCREATE VIEW 视图名称 AS 查询语句\n3.1 创建单表视图\n举例：\nCREATE VIEW empvu80AS SELECT  employee_id, last_name, salaryFROM    employeesWHERE   department_id = 80;\n查询视图：\nSELECT *FROM\tsalvu80;\n举例：\nCREATE VIEW emp_year_salary (ename,year_salary)AS SELECT ename,salary*12*(1+IFNULL(commission_pct,0))FROM t_employee;\n举例：\nCREATE VIEW salvu50AS SELECT  employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARYFROM    employeesWHERE   department_id = 50;\n说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图\nVIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。\n说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。\n3.2 创建多表联合视图\n举例：\nCREATE VIEW empview AS SELECT employee_id emp_id,last_name NAME,department_nameFROM employees e,departments dWHERE e.department_id = d.department_id;\nCREATE VIEW emp_deptAS SELECT ename,dnameFROM t_employee LEFT JOIN t_departmentON t_employee.did = t_department.did;\nCREATE VIEW\tdept_sum_vu(name, minsal, maxsal, avgsal)AS SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)FROM employees e, departments dWHERE e.department_id = d.department_id GROUP BY  d.department_name;\n\n利用视图对数据进行格式化\n\n我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为\nemp_name(department_name)，就可以使用视图来完成数据格式化的操作：\nCREATE VIEW emp_departASSELECT CONCAT(last_name,'(',department_name,')') AS emp_deptFROM employees e JOIN departments dWHERE e.department_id = d.department_id\n3.3 基于视图创建视图\n当我们创建好一张视图之后，还可以在它的基础上继续创建视图。\n举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建\n“emp_dept_ysalary”视图。\nCREATE VIEW emp_dept_ysalaryAS SELECT emp_dept.ename,dname,year_salaryFROM emp_dept INNER JOIN emp_year_salaryON emp_dept.ename = emp_year_salary.ename;\n4. 查看视图\n语法1：查看数据库的表对象、视图对象\nSHOW TABLES;\n语法2：查看视图的结构\nDESC / DESCRIBE 视图名称;\n语法3：查看视图的属性信息\n# 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）SHOW TABLE STATUS LIKE '视图名称'\\G\n执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。\n语法4：查看视图的详细定义信息\nSHOW CREATE VIEW 视图名称;\n5. 更新视图的数据\n5.1 一般情况\nMySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。\n举例：UPDATE操作\nmysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';+---------+-------------+| ename   | tel         |+---------+-------------+| 孙洪亮 \t| 13789098765 |+---------+-------------+1 row in set (0.01 sec)mysql&gt; UPDATE emp_tel SET tel = '13789091234' WHERE ename = '孙洪亮';Query OK, 1 row affected (0.01 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';+---------+-------------+| ename\t  | tel         |+---------+-------------+| \t孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = '孙洪亮';+---------+-------------+| ename   | tel         |+---------+-------------+| 孙洪亮 \t| 13789091234 |+---------+-------------+1 row in set (0.00 sec)\n举例：DELETE操作\nmysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';+---------+-------------+| ename  \t| tel           |+---------+-------------+| 孙洪亮 \t| 13789091234 |+---------+-------------+1 row in set (0.00 sec)mysql&gt; DELETE FROM emp_tel  WHERE ename = '孙洪亮';Query OK, 1 row affected (0.01 sec)mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = '孙洪亮';Empty set (0.00 sec)mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = '孙洪亮';Empty set (0.00 sec)\n5.2 不可更新的视图\n要使视图可更新，视图中的行和底层基本表中的行之间必须存在一对一的关系。另外当视图定义出现如下情况时，视图不支持更新操作：\n\n在定义视图的时候指定了“ALGORITHM =\nTEMPTABLE”，视图将不支持INSERT和DELETE操作；\n视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；\n在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持INSERT和DELETE操作；\n在定义视图的SELECT语句后的字段列表中使用了数学表达式或子查询，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；\n在定义视图的SELECT语句后的字段列表中使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等，视图将不支持INSERT、UPDATE、DELETE；\n在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；\n视图定义基于一个不可更新视图；\n常量视图。\n\n举例：\nmysql&gt; CREATE OR REPLACE VIEW emp_dept    -&gt; (ename,salary,birthday,tel,email,hiredate,dname)    -&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname    -&gt; FROM t_employee INNER JOIN t_department    -&gt; ON t_employee.did = t_department.did ;Query OK, 0 rows affected (0.01 sec)\nmysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)    -&gt; VALUES('张三',15000,'1995-01-08','18201587896',    -&gt; 'zs@atguigu.com','2022-02-14','新部门');    #ERROR 1393 (HY000): Can not modify more than one base table through a join view 'atguigu_chapter9.emp_dept'\n从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。\n\n虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询，不建议更新视图的数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。\n\n6. 修改、删除视图\n6.1 修改视图\n方式1：使用CREATE OR REPLACE VIEW\n子句修改视图\nCREATE OR REPLACE VIEW empvu80(id_number, name, sal, department_id)AS SELECT  employee_id, first_name || ' ' || last_name, salary, department_idFROM employeesWHERE department_id = 80;\n\n说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。\n\n方式2：ALTER VIEW\n修改视图的语法是：\nALTER VIEW 视图名称 AS查询语句\n6.2 删除视图\n\n删除视图只是删除视图的定义，并不会删除基表的数据。\n删除视图的语法是：\nDROP VIEW IF EXISTS 视图名称;\nDROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;\n举例：\nDROP VIEW empvu80;\n说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。\n\n7. 总结\n7.1 视图优点\n1. 操作简单\n将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。\n2. 减少数据冗余\n视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。\n3. 数据安全\nMySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。\n同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据表，可以直接通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性。\n4. 适应灵活多变的需求\n当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。\n5. 能够分解复杂的查询逻辑\n数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。\n7.2 视图不足\n如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，可读性不好，容易变成系统的潜在隐患。因为创建视图的\nSQL\n查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。\n实际项目中，如果视图过多，会导致数据库维护成本的问题。\n所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。\n","categories":["Database","SQL"],"tags":["SQL,View"]},{"title":"Database 存储引擎介绍","url":"/2024/02/23/Database-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D/","content":"各种存储引擎简单介绍\n\n1. 查看存储引擎\n\n查看mysql提供什么存储引擎\n\nshow engines;\n2. 设置系统默认的存储引擎\n\n查看默认的存储引擎\n\nshow variables like '%storage_engine%';#或SELECT @@default_storage_engine;\n\n修改默认的存储引擎\n\n如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用\nInnoDB 作为表的存储引擎。\n如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：\nSET DEFAULT_STORAGE_ENGINE=MyISAM;\n或者修改 my.cnf 文件：\ndefault-storage-engine=MyISAM# 重启服务systemctl restart mysqld.service\n3. 设置表的存储引擎\n存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为\n不同的表设置不同的存储引擎\n，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。\n3.1 创建表时指定存储引擎\n我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎\nInnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：\nCREATE TABLE 表名(建表语句;) ENGINE = 存储引擎名称;\n3.2 修改表的存储引擎\n如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：\nALTER TABLE 表名 ENGINE = 存储引擎名称;\n比如我们修改一下 engine_demo_table 表的存储引擎：\nmysql&gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;\n这时我们再查看一下 engine_demo_table 的表结构：\nmysql&gt; SHOW CREATE TABLE engine_demo_table\\G*************************** 1. row ***************************Table: engine_demo_tableCreate Table: CREATE TABLE `engine_demo_table` (`i` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.01 sec)\n4. 引擎介绍\n4.1 InnoDB\n引擎：具备外键支持功能的事务存储引擎\n\nMySQL从3.23.34a开始就包含InnoDB存储引擎。\n大于等于5.5之后，默认采用InnoDB引擎 。\nInnoDB是MySQL的 默认事务型引擎\n，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。\n除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。\n除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。\n数据文件结构：（在《第02章_MySQL数据目录》章节已讲）\n\n表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）\n表名.ibd 存储数据和索引\n\nInnoDB是 为处理巨大数据量的最大性能设计 。\n\n在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除\n了。比如： .frm ， .par ， .trn ， .isl ， .db.opt\n等都在MySQL8.0中不存在了。\n\n对比MyISAM的存储引擎， InnoDB写的处理效率差一些\n，并且会占用更多的磁盘空间以保存数据和索引。\nMyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，\n对内存要求较高 ，而且内存大小对性能有决定性的影响。\n\n4.2 MyISAM\n引擎：主要的非事务处理存储引擎\n\nMyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务、行级锁、外键\n，有一个毫无疑问的缺陷就是崩溃后无法安全恢复 。\n5.5之前默认的存储引擎\n优势是访问的速度快\n，对事务完整性没有要求或者以SELECT、INSERT为主的应用\n针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高\n数据文件结构：（在《第02章_MySQL数据目录》章节已讲）\n\n表名.frm 存储表结构\n表名.MYD 存储数据 (MYData)\n表名.MYI 存储索引 (MYIndex)\n\n应用场景：只读应用或者以读为主的业务（日志记录）\n\n4.3 Archive 引擎：用于数据存档\n\n下表展示了ARCHIVE 存储引擎功能\n\n4.4 Blackhole\n引擎：丢弃写操作，读操作会返回空内容\n4.5 CSV\n引擎：存储数据时，以逗号分隔各个数据项\n使用案例如下\nmysql&gt; CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL) ENGINE = CSV;Query OK, 0 rows affected (0.06 sec)mysql&gt; INSERT INTO test VALUES(1,'record one'),(2,'record two');Query OK, 2 rows affected (0.05 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM test;+---+------------+| i |      c     |+---+------------+| 1 | record one || 2 | record two |+---+------------+2 rows in set (0.00 sec)\n创建CSV表还会创建相应的元文件 ，用于 存储表的状态 和 表中存在的行数\n。此文件的名称与表的名称相 同，后缀为 CSM 。如图所示\n如果检查 test.CSV\n通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下：\n\"1\",\"record one\"\"2\",\"record two\"\n这种格式可以被 Microsoft Excel\n等电子表格应用程序读取，甚至写入。使用Microsoft Excel打开如图所示\n4.6 Memory 引擎：置于内存的表\n概述：\nMemory采用的逻辑介质是内存，响应速度很快，但是当mysqld守护进程崩溃的时候数据会丢失\n。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。\n主要特征：\n\nMemory同时 支持哈希（HASH）索引 和 B+树索引 。\nMemory表至少比MyISAM表要快一个数量级 。\nMEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是\nmax_rows 和 max_heap_table_size\n。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默\n认为16MB，可以按需要进行扩大。\n数据文件与索引文件分开存储。\n缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。\n\n使用Memory存储引擎的场景：\n\n目标数据比较小，而且非常频繁的进行访问，在内存中存放数据，如果太大的数据会造成内存溢出\n。可以通过参数 max_heap_table_size\n控制Memory表的大小，限制Memory表的最大的大小。\n如果数据是临时的，而且必须立即可用得到，那么就可以放在内存中。\n存储在Memory表中的数据如果突然间丢失的话也没有太大的关系 。\n\n4.7 Federated 引擎：访问远程表\nFederated引擎是访问其他MySQL服务器的一个 代理\n，尽管该引擎看起来提供了一种很好的 跨服务 器的灵活性\n，但也经常带来问题，因此默认是禁用的 。\n4.8\nMerge引擎：管理多个MyISAM表构成的表集合\n4.9\nNDB引擎：MySQL集群专用存储引擎\n也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群\n环境，类似于 Oracle 的 RAC 集 群。\n4.10 引擎对比\nMySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。\n\n\nimage-20220616125945304\n\n其实这些东西大家没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功能。\n其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其中\nInnoDB 是 MySQL 默认的存储引擎。\n5. MyISAM和InnoDB\n很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？\nMySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。\n\n\n\n\n\n\n\n\n对比项\nMyISAM\nInnoDB\n\n\n\n\n外键\n不支持\n支持\n\n\n事务\n不支持\n支持\n\n\n行表锁\n表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作\n行锁，操作时只锁某一行，不对其它行有影响，适合高并发的操作\n\n\n缓存\n只缓存索引，不缓存真实数据\n不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响\n\n\n自带系统表使用\nY\nN\n\n\n关注点\n性能：节省资源、消耗少、简单业务\n事务：并发写、事务、更大资源\n\n\n默认安装\nY\nY\n\n\n默认使用\nN\nY\n\n\n\n","categories":["Database","存储引擎"],"tags":["存储引擎"]},{"title":"Database 概述","url":"/2024/02/20/Database-%E6%A6%82%E8%BF%B0/","content":"为什么需要数据库？数据库有哪些分类？数据库设计原则有哪些？\n\n1. 为什么要使用数据库\n\n持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。\n持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。\n\n2. 数据库与数据库管理系统\n2.1 数据库的相关概念\n\n\n\n\n\n\nDB：数据库（Database）\n\n\n\n\n即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。\n\n\nDBMS：数据库管理系统（Database Management\nSystem）\n\n\n是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。\n\n\nSQL：结构化查询语言（Structured Query\nLanguage）\n\n\n专门用来与数据库通信的语言。\n\n\n\n2.2\n数据库与数据库管理系统的关系\n数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n数据库管理系统、数据库和表的关系如图所示：\n\n\nimage-20211013202511233\n\n\n\nimage-20210915112546261\n\n2.3\n常见的数据库管理系统排名(DBMS)\n目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL\nServer、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年DB-Engines\nRanking\n对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:https://db-engines.com/en/ranking）\n对应的走势图：（https://db-engines.com/en/ranking_trend）\n2.4 常见的数据库介绍\nOracle\n1979 年，Oracle 2 诞生，它是第一个商用的\nRDBMS（关系型数据库管理系统）。随着 Oracle\n软件的名气越来越大，公司也改名叫 Oracle 公司。\n2007年，总计85亿美金收购BEA Systems。\n2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle\n同时拥有了 MySQL 的管理权，至此 Oracle\n在数据库领域中成为绝对的领导者。\n2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。\n如今 Oracle 的年收入达到了 400\n亿美金，足以证明商用（收费）数据库软件的价值。\nSQL Server\nSQL Server 是微软开发的大型商业数据库，诞生于 1989\n年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft\nBackOffice产品集成。\nDB2\nIBM公司的数据库产品,收费的。常应用在银行系统中。\nPostgreSQL\nPostgreSQL\n的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。\nSyBase\n已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。\nSQLite\n嵌入式的小型数据库，应用在手机端。\n零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\ninformix\nIBM公司出品，取自Information\n和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。\n性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\n3. MySQL介绍\n3.1 概述\n\nMySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL\nAB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的\nNo.1。\n2008被Sun收购（10亿美金），2009年Sun被Oracle收购。MariaDB应运而生。（MySQL\n的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目\nMariaDB）\nMySQL6.x 版本之后分为社区版和商业版。\nMySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\nMySQL是开源的，所以你不需要支付额外的费用。\nMySQL是可以定制的，采用了GPL（GNU General Public License）协议，你可以修改源码来开发自己的MySQL系统。\nMySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\nMySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB，64位系统支持最大的表文件为8TB。\nMySQL使用标准的SQL数据语言形式。\nMySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。\n\n3.2 MySQL发展史重大事件\nMySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。\n\n\nimage-20210730161043856\n\n1.4 关于MySQL 8.0\nMySQL从5.7版本直接跳跃发布了8.0版本，可见这是一个令人兴奋的里程碑版本。MySQL\n8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL\nOptimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n1.5 Why choose MySQL?\n为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：\n\n开放源代码，使用成本低。\n性能卓越，服务稳定。\n软件体积小，使用简单，并且易于维护。\n历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n许多互联网公司在用，经过了时间的验证。\n\n1.6 Oracle vs MySQL\nOracle\n更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\nMySQL\n由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\n4. RDBMS 与 非RDBMS\n从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的\nDBMS 分别是 Oracle、MySQL 和 SQL\nServer。这些都是关系型数据库（RDBMS）。\n4.1 关系型数据库(RDBMS)\n4.1.1 实质\n\n这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n\n\nimage-20211020145811031\n\n关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表(table)，一组表组成了一个库(database)。\n表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，就是建立在关系模型基础上的数据库。\nSQL 就是关系型数据库的查询语言。\n\n4.1.2 优势\n\n复杂查询\n可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\n事务支持\n使得对于安全性能很高的数据访问要求得以实现。\n\n4.2 非关系型数据库(非RDBMS)\n4.2.1 介绍\n非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，通过减少不常用的功能，进一步提高性能。\n目前基本上大部分主流的非关系型数据库都是免费的。\n4.2.2 有哪些非关系型数据库\n相比于 SQL，NoSQL\n泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用\nNoSQL 一词才能将这些技术囊括进来。\n键值型数据库\n键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value\n可以是简单的对象，也可以是复杂的对象。Key\n作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如\nWHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。\n键值型数据库典型的使用场景是作为内存缓存。Redis是最流行的键值型数据库。\n\n\nimage-20211020172958427\n\n文档型数据库\n此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB\n是最流行的文档型数据库。此外，还有CouchDB等。\n搜索引擎数据库\n虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。\n典型产品：Solr、Elasticsearch、Splunk 等。\n列式数据库\n列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server\n等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的\nI/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。\n\n\nimage-20211020173921726\n\n图形数据库\n图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。\n4.2.3 NoSQL的演变\n由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离\nSQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止\nNoSQL 阵营中的 DBMS 都会有实现类似 SQL\n的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出\nNoSQL 功能的演变：\n1970：NoSQL = We have no SQL\n1980：NoSQL = Know SQL\n2000：NoSQL = No SQL!\n2005：NoSQL = Not only SQL\n2013：NoSQL = No, SQL!\nNoSQL 对 SQL\n做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。\n4.3 小结\nNoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL\n阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20\n的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL\n是非常有必要的。整套课程将围绕 SQL 展开。\n5. 关系型数据库设计规则\n\n关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的（Structured）。\n将数据放到表中，表再放到库中。\n一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中\n“类”的设计。\n\n5.1 表、记录、字段\n\nE-R（entity-relationship，实体-联系）模型中有三个主要概念是：实体集、属性、联系集。\n一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。\n\n\n\nimage-20210914235450032\n\nORM思想 (Object Relational Mapping)体现：数据库中的一个表  &lt;---&gt; Java或Python中的一个类表中的一条数据  &lt;---&gt; 类中的一个对象（或实体）表中的一个列  &lt;----&gt; 类中的一个字段、属性(field)\n5.2 表的关联关系\n\n表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n四种：一对一关联、一对多关联、多对多关联、自我引用\n\n5.2.1 一对一关联（one-to-one）\n\n在实际的开发中应用不多，因为一对一可以创建成一张表。\n举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…\n\n拆为两个表：两个表的记录是一一对应关系。\n基础信息表（常用信息）：学号、姓名、手机号码、班级、系别\n档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…\n\n两种建表原则：\n\n外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n\n5.2.2 一对多关系（one-to-many）\n\n常见实例场景：客户表和订单表，分类表和商品表，部门表和员工表。\n举例：\n\n员工表：编号、姓名、…、所属部门\n部门表：编号、名称、简介\n\n一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n5.2.3 多对多（many-to-many）\n要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n举例1：学生-课程\n\n学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）\n课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…）\n选课信息表：一个学生可以选多门课，一门课可以被多个学生选择\n学号     课程编号  1        10012        10011        1002\n\n举例2：产品-订单\n“订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。\n\n产品表：“产品”表中的每条记录表示一个产品。\n订单表：“订单”表中的每条记录表示一个订单。\n订单明细表：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。\n\n\n\n\nimage-20210914235637068\n\n\n举例3：用户-角色\n多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。\n\n5.3.4 自我引用(Self reference)\n\n\nimage-20210914235651997\n\n","categories":["Database"]},{"title":"Document 文档对象模型","url":"/2024/12/24/Document-%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","content":"全面梳理 DOM 与 BOM\n的核心概念与用法，包括节点的访问与遍历、元素的搜索与筛选、文档结构的动态创建与修改、样式操作、窗口尺寸与滚动控制等内容，帮助前端开发者打牢文档结构控制的基础能力。\n\n\n文档对象模型（DOM）\n文档对象模型（Document Object Model），简称\nDOM，将所有页面内容表示为可以修改的对象。\ndocument\n对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。\n// 将背景颜色修改为红色document.body.style.background = \"red\";// 在 1 秒后将其修改回来setTimeout(() =&gt; document.body.style.background = \"\", 1000);\n浏览器对象模型（BOM）\n浏览器对象模型（Browser Object Model），简称\nBOM，表示由浏览器（主机环境）提供的用于处理文档（document）之外的所有内容的其他对象。\n\nnavigator\n对象提供了有关浏览器和操作系统的背景信息。navigator\n有许多属性，但是最广为人知的两个属性是：navigator.userAgent\n—— 关于当前浏览器，navigator.platform ——\n关于平台（有助于区分 Windows/Linux/Mac 等）。\nlocation\n对象允许我们读取当前 URL，并且可以将浏览器重定向到新的 URL。\n\n这是我们可以如何使用 location 对象的方法：\nalert(location.href); // 显示当前 URLif (confirm(\"Go to Wikipedia?\")) {  location.href = \"https://wikipedia.org\"; // 将浏览器重定向到另一个 URL}\n函数 alert/confirm/prompt 也是 BOM\n的一部分：它们与文档（document）没有直接关系，但它代表了与用户通信的纯浏览器方法。\nDOM 遍历\n\n纯元素导航\n上面列出的导航（navigation）属性引用 所有\n节点。例如，在 childNodes\n中我们可以看到文本节点，元素节点，甚至包括注释节点（如果它们存在的话）。\n但是对于很多任务来说，我们并不想要文本节点或注释节点。我们希望操纵的是代表标签的和形成页面结构的元素节点。\n所以，让我们看看更多只考虑 元素节点\n的导航链接（navigation link）：\n\n这些链接和我们在上面提到过的类似，只是在词中间加了\nElement：\n\nchildren —— 仅那些作为元素节点的子代的节点。\nfirstElementChild，lastElementChild ——\n第一个和最后一个子元素。\npreviousElementSibling，nextElementSibling\n—— 兄弟元素。\nparentElement —— 父元素。\n\n指定元素搜索\ndocument.getElementById\n&lt;div id=\"elem\"&gt;  &lt;div id=\"elem-content\"&gt;Element&lt;/div&gt;&lt;/div&gt;&lt;script&gt;  // 获取该元素  let elem = document.getElementById('elem');  // 将该元素背景改为红色  elem.style.background = 'red';&lt;/script&gt;\nquerySelectorAll\n到目前为止，最通用的方法是\nelem.querySelectorAll(css)，它返回 elem\n中与给定 CSS 选择器匹配的所有元素。\n在这里，我们查找所有为最后一个子元素的 &lt;li&gt;\n元素：\n&lt;ul&gt;  &lt;li&gt;The&lt;/li&gt;  &lt;li&gt;test&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;  &lt;li&gt;has&lt;/li&gt;  &lt;li&gt;passed&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  let elements = document.querySelectorAll('ul &gt; li:last-child');  for (let elem of elements) {    alert(elem.innerHTML); // \"test\", \"passed\"  }&lt;/script&gt;\nquerySelector\nelem.querySelector(css) 调用会返回给定 CSS\n选择器的第一个元素。\nmatches\n&lt;a href=\"http://example.com/file.zip\"&gt;...&lt;/a&gt;&lt;a href=\"http://ya.ru\"&gt;...&lt;/a&gt;&lt;script&gt;  // 不一定是 document.body.children，还可以是任何集合  for (let elem of document.body.children) {    if (elem.matches('a[href$=\"zip\"]')) {      alert(\"The archive reference: \" + elem.href );    }  }&lt;/script&gt;\nclosest\n元素的祖先（ancestor）是：父级，父级的父级，它的父级等。祖先们一起组成了从元素到顶端的父级链。\nelem.closest(css) 方法会查找与 CSS\n选择器匹配的最近的祖先。elem 自己也会被搜索。\n换句话说，方法 closest\n在元素中得到了提升，并检查每个父级。如果它与选择器匹配，则停止搜索并返回该祖先。\n&lt;h1&gt;Contents&lt;/h1&gt;&lt;div class=\"contents\"&gt;  &lt;ul class=\"book\"&gt;    &lt;li class=\"chapter\"&gt;Chapter 1&lt;/li&gt;    &lt;li class=\"chapter\"&gt;Chapter 2&lt;/li&gt;  &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;  let chapter = document.querySelector('.chapter'); // LI  alert(chapter.closest('.book')); // UL  alert(chapter.closest('.contents')); // DIV  alert(chapter.closest('h1')); // null（因为 h1 不是祖先）&lt;/script&gt;\n实时的集合\n所有的 \"getElementsBy*\" 方法都会返回一个\n实时的（live）\n集合。这样的集合始终反映的是文档的当前状态，并且在文档发生更改时会“自动更新”。\n&lt;div&gt;First div&lt;/div&gt;&lt;script&gt;  let divs = document.getElementsByTagName('div');  alert(divs.length); // 1&lt;/script&gt;&lt;div&gt;Second div&lt;/div&gt;&lt;script&gt;  alert(divs.length); // 2&lt;/script&gt;\n相反，querySelectorAll 返回的是一个\n静态的 集合。就像元素的固定数组。\n&lt;div&gt;First div&lt;/div&gt;&lt;script&gt;  let divs = document.querySelectorAll('div');  alert(divs.length); // 1&lt;/script&gt;&lt;div&gt;Second div&lt;/div&gt;&lt;script&gt;  alert(divs.length); // 1&lt;/script&gt;\n现在我们可以很容易地看到不同之处。在文档中出现新的 div\n后，静态集合并没有增加。\n节点属性\n不同的 DOM 节点可能有不同的属性。例如，标签 &lt;a&gt;\n相对应的元素节点具有链接相关的（link-related）属性，标签\n&lt;input&gt;\n相对应的元素节点具有与输入相关的属性，等。文本节点与元素节点不同。但是所有这些标签对应的\nDOM 节点之间也存在共有的属性和方法，因为所有类型的 DOM\n节点都形成了一个单一层次的结构（single hierarchy）。\n每个 DOM 节点都属于相应的内建类。\n\n修改Document\n&lt;style&gt;.alert {  padding: 15px;  border: 1px solid #d6e9c6;  border-radius: 4px;  color: #3c763d;  background-color: #dff0d8;}&lt;/style&gt;&lt;script&gt;  let div = document.createElement('div');  div.className = \"alert\";  div.innerHTML = \"&lt;strong&gt;Hi there!&lt;/strong&gt; You've read an important message.\";  document.body.append(div);&lt;/script&gt;\n样式和类\n\nclassName ——\n字符串值，可以很好地管理整个类的集合。\nclassList —— 具有\nadd/remove/toggle/contains\n方法的对象，可以很好地支持单个类。\n\n要改变样式：\n\nstyle\n属性是具有驼峰（camelCased）样式的对象。对其进行读取和修改与修改\n\"style\"\n特性（attribute）中的各个属性具有相同的效果。要了解如何应用\nimportant 和其他特殊内容 —— 在 MDN\n中有一个方法列表。\nstyle.cssText 属性对应于整个 \"style\"\n特性（attribute），即完整的样式字符串。\n\n要读取已解析的（resolved）样式（对于所有类，在应用所有 CSS\n并计算最终值之后）：\n\ngetComputedStyle(elem, [pseudo]) 返回与\nstyle 对象类似的，且包含了所有类的对象。只读。\n\nWindow 大小和滚动\n几何：\n\n文档可见部分的 width/height（内容区域的\nwidth/height）：document.documentElement.clientWidth/clientHeight\n整个文档的 width/height，其中包括滚动出去的部分：\nlet scrollHeight = Math.max(  document.body.scrollHeight, document.documentElement.scrollHeight,  document.body.offsetHeight, document.documentElement.offsetHeight,  document.body.clientHeight, document.documentElement.clientHeight);\n\n滚动：\n\n读取当前的滚动：window.pageYOffset/pageXOffset。\n更改当前的滚动：\n\nwindow.scrollTo(pageX,pageY) —— 绝对坐标，\nwindow.scrollBy(x,y) —— 相对当前位置进行滚动，\nelem.scrollIntoView(top) —— 滚动以使 elem\n可见（elem 与窗口的顶部/底部对齐）\n\n\n","categories":["前端","基础知识"],"tags":["Web"]},{"title":"Database 逻辑架构","url":"/2024/06/23/Database-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/","content":"全面解析 MySQL 数据库逻辑架构与 SQL\n执行全过程，从连接管理、查询缓存、解析优化到存储引擎执行细节，厘清各层职责与交互机制。深入剖析\nInnoDB 关键组件设计，结合 SHOW PROFILE、EXPLAIN、SHOW WARNINGS\n等性能分析工具，系统掌握 SQL 调优方法与执行计划解读技巧。\n\n1. 逻辑架构剖析\n1.1 服务器处理客户端请求\n首先MySQL是典型的C/S架构，即Clinet/Server 架构，服务端程序使用的mysqld。\n不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果是：客户端进程向服务器进程发送一段文本（SQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。\n那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为\n例展示：\n1.2 Connectors\nConnectors,\n指的是不同语言中与SQL的交互。MySQL首先是一个网络程序，在TCP之上定义了自己的应用层协议。所以要使用MySQL，我们可以编写代码，跟MySQL\nServer\n建立TCP连接，之后按照其定义好的协议进行交互。或者比较方便的方法是调用SDK，比如Native\nC API、JDBC、PHP等各语言MySQL\nConnecotr,或者通过ODBC。但通过SDK来访问MySQL，本质上还是在TCP连接上通过MySQL协议跟MySQL进行交互\n接下来的MySQL Server结构可以分为如下三层：\n1.3 第一层：连接层\n系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。\n经过三次握手建立连接成功后， MySQL 服务器对 TCP\n传输过来的账号密码做身份认证、权限获取。\n\n用户名或密码不对，会收到一个Access denied for\nuser错误，客户端程序结束执行\n用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限\n\nTCP\n连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。\n所以连接管理的职责是负责认证、管理连接、获取权限信息。\n1.4 第二层：服务层\n第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。\n在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化：如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。\n如果是SELECT语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。\n\nSQL Interface: SQL接口\n\n接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT …\nFROM就是调用SQL Interface\nMySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定\n义函数等多种SQL语言接口\n\nParser: 解析器\n\n在解析器中对 SQL\n语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构\n传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错\n误，那么就说明这个SQL语句是不合理的。\n在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树\n，并根据数据字 典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限\n。创建好语法树后，MySQL还\n会对SQl查询进行语法上的优化，进行查询重写。\n\nOptimizer: 查询优化器\n\nSQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL\n语句的执行路径，生成一个 执行计划 。\n这个执行计划表明应该 使用哪些索引\n进行查询（全表检索还是使用索引检索），表之间的连\n接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将\n查询结果返回给用户。\n它使用“ 选取-投影-连接 ”策略进行查询。例如：\n\nSELECT id,name FROM student WHERE gender = '女';\n这个SELECT查询先根据WHERE语句进行 选取\n，而不是将表全部查询出来以后再进行gender过 滤。\n这个SELECT查询先根据id和name进行属性 投影\n，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 连接\n起来生成最终查询结果。\nCaches &amp; Buffers： 查询缓存组件\n\nMySQL内部维持着一些Cache和Buffer，比如Query\nCache用来缓存一条SELECT语句的执行结\n果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过\n程了，直接将结果反馈给客户端。\n这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等\n。 这个查询缓存可以在 不同客户端之间共享 。\n从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。\n\n\n1.5 第三层：引擎层\n插件式存储引擎层（ Storage\nEngines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样\n我们可以根据自己的实际需要进行选取。\nMySQL 8.0.25默认支持的存储引擎如下：\n1.6 存储层\n所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统\n上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用\nDAS、NAS、SAN等各种存储系统。\n1.7 小结\nMySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：\n简化为三层结构：\n\n连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；\nSQL 层（服务层）：对 SQL\n语句进行查询处理；与数据库文件的存储方式无关；\n存储引擎层：与数据库文件打交道，负责数据的存储和读取。\n\n2. SQL执行流程\n2.1 MySQL中的SQL执行流程\nMySQL的查询流程：\n\n查询缓存：Server 如果在查询缓存中发现了这条 SQL\n语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在\nMySQL8.0 之后就抛弃了这个功能。\n\n总之，因为查询缓存往往弊大于利，查询缓存的失效非常频繁。\n一般建议大家在静态表里使用查询缓存，什么叫静态表呢？就是一般我们极少更新的表。比如，一个系统配置表、字典表，这张表上的查询才适合使用查询缓存。好在MySQL也提供了这种“按需使用”的方式。你可以将\nmy.cnf 参数 query_cache_type 设置成 DEMAND，代表当 sql 语句中有\nSQL_CACHE关键字时才缓存。比如：\n# query_cache_type 有3个值。 0代表关闭查询缓存OFF，1代表开启ON，2代表(DEMAND)query_cache_type=2\n这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以供SQL_CACHE显示指定，像下面这个语句一样：\nSELECT SQl_CACHE * FROM test WHERE ID=5;\n查看当前 mysql 实例是否开启缓存机制\n# MySQL5.7中：show global variables like \"%query_cache_type%\";\n监控查询缓存的命中率：\nshow status like '%Qcache%';\nQcache_free_blocks:\n表示查询缓存中海油多少剩余的blocks，如果该值显示较大，则说明查询缓存中的内部碎片过多了，可能在一定的时间进行整理。\nQcache_free_memory:\n查询缓存的内存大小，通过这个参数可以很清晰的知道当前系统的查询内存是否够用，DBA可以根据实际情况做出调整。\nQcache_hits: 表示有\n多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。\nQcache_inserts:\n表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这也正常。\nQcache_lowmem_prunes:\n该参数记录有多少条查询因为内存不足而被移除出查询缓存。通过这个值，用户可以适当的调整缓存大小。\nQcache_not_cached:\n表示因为query_cache_type的设置而没有被缓存的查询数量。\nQcache_queries_in_cache:\n当前缓存中缓存的查询数量。\nQcache_total_blocks: 当前缓存的block数量。\n\n解析器：在解析器中对 SQL\n语句进行语法分析、语义分析。\n\n如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。SQL语句的分析分为词法分析与语法分析。\n分析器先做“ 词法分析\n”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面\n的字符串分别是什么，代表什么。\nMySQL 从你输入的”select”这个关键字识别出来，这是一个查询语\n句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。\n接着，要做“ 语法分析\n”。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输\n入的这个 SQL 语句是否 满足 MySQL 语法 。\nselect department_id,job_id, avg(salary) from employees group by\ndepartment_id;\n如果SQL语句正确，则会生成一个这样的语法树：\n下图是SQL分词分析的过程步骤:\n至此解析器的工作任务也基本圆满了。\n\n优化器：在优化器中会确定 SQL\n语句的执行路径，比如是根据 全表检索 ，还是根据\n索引检索 等。\n经过解释器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。\n比如：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联\n(join)\n的时候，决定各个表的连接顺序，还有表达式简化、子查询转为连接、外连接转为内连接等。\n举例：如下语句是执行两个表的 join：\n\nselect * from test1 join test2 using(ID)where test1.name='zhangwei' and test2.name='mysql高级课程';\n方案1：可以先从表 test1 里面取出 name='zhangwei'的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 'mysql高级课程'。方案2：可以先从表 test2 里面取出 name='mysql高级课程' 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name的值是否等于 zhangwei。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。\n在查询优化器中，可以分为 逻辑查询 优化阶段和\n物理查询 优化阶段。\n逻辑查询优化就是通过改变SQL语句的内容来使得SQL查询更高效，同时为物理查询优化提供更多的候选执行计划。通常采用的方式是对SQL语句进行等价变换，对查询进行重写，而查询重写的数学基础就是关系代数。对条件表达式进行等价谓词重写、条件简化，对视图进行重写，对子查询进行优化，对连接语义进行了外连接消除、嵌套连接消除等。\n物理查询优化是基于关系代数进行的查询重写，而关系代数的每一步都对应着物理计算，这些物理计算往往存在多种算法，因此需要计算各种物理路径的代价，从中选择代价最小的作为执行计划。在这个阶段里，对于单表和多表连接的操作，需要高效地使用索引，提升查询效率。\n\n执行器：\n\n截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段\n。\n在执行之前需要判断该用户是否 具备权限\n。如果没有，就会返回权限错误。如果具备权限，就执行 SQL\n查询并返回结果。在 MySQL8.0\n以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。\nselect * from test where id=1;\n比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：\n调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。\n至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。\nSQL 语句在 MySQL 中的流程是：\nSQL语句→查询缓存→解析器→优化器→执行器\n。\n2.2 MySQL8中SQL执行原理\n1) 确认profiling是否开启\n了解查询语句底层执行的过程：select @profiling 或者\nshow variables like '%profiling'\n查看是否开启计划。开启它可以让MySQL收集在SQL\n执行时所使用的资源情况，命令如下：\nselect @@profiling;show variables like 'profiling';\nprofiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：\nset profiling=1;\n2) 多次执行相同SQL查询\n然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：\nselect * from employees;\n3) 查看profiles\n查看当前会话所产生的所有 profiles：\nmysql&gt; show profiles; # 显示最近的几次查询\n4) 查看profile\n显示执行计划，查看程序的执行步骤：\n当然你也可以查询指定的 Query ID，比如：\nmysql&gt; show profile for query 7;\n查询 SQL 的执行时间结果和上面是一样的。\n此外，还可以查询更丰富的内容：\nmysql&gt; show profile cpu,block io for query 6;\n1、除了查看cpu、io阻塞等参数情况，还可以查询下列参数的利用情况。\nSyntax:SHOW PROFILE [type [, type] ... ]\t[FOR QUERY n]\t[LIMIT row_count [OFFSET offset]]type: {\t| ALL -- 显示所有参数的开销信息\t| BLOCK IO -- 显示IO的相关开销\t| CONTEXT SWITCHES -- 上下文切换相关开销\t| CPU -- 显示CPU相关开销信息\t| IPC -- 显示发送和接收相关开销信息\t| MEMORY -- 显示内存相关开销信息\t| PAGE FAULTS -- 显示页面错误相关开销信息\t| SOURCE -- 显示和Source_function,Source_file,Source_line 相关的开销信息\t| SWAPS -- 显示交换次数相关的开销信息}\n2、发现两次查询当前情况都一致，说明没有缓存。\n在 8.0 版本之后，MySQL 不再支持缓存的查询。一旦数据表有更新，缓存都将清空，因此只有数据表是静态的时候，或者数据表很少发生变化时，使用缓存查询才有价值，否则如果数据表经常更新，反而增加了\nSQL 的查询时间。\n2.3 MySQL5.7中SQL执行原理\n上述操作在MySQL5.7中测试，发现前后两次相同的sql语句，执行的查询过程仍然是相同的。不是会使用\n缓存吗？这里我们需要 显式开启查询缓存模式 。在MySQL5.7中如下设置：\n1) 配置文件中开启查询缓存\n在 /etc/my.cnf 中新增一行：\nquery_cache_type=1\n2) 重启mysql服务\nsystemctl restart mysqld\n3) 开启查询执行计划\n由于重启过服务，需要重新执行如下指令，开启profiling。\nmysql&gt; set profiling=1;\n4) 执行语句两次：\nmysql&gt; select * from locations;\n5) 查看profiles\n6) 查看profile\n显示执行计划，查看程序的执行步骤：\nmysql&gt; show profile for query 1;\nmysql&gt; show profile for query 2;\n结论不言而喻。执行编号2时，比执行编号1时少了很多信息，从截图中可以看出查询语句直接从缓存中\n获取数据。\n2.4 SQL语法顺序\n随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同\n而动态调整执行顺序。\n3. 数据库缓冲池（buffer pool）\nInnoDB\n存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘\nI/O\n需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS\n会申请占用内存来作为数据缓冲池\n，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool\n之后才可以访问。\n这样做的好处是可以让磁盘活动最小化，从而\n减少与磁盘直接进行 I/O 的时间。要知道，这种策略对提升 SQL\n语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。\n3.1 缓冲池 vs 查询缓存\n缓冲池和查询缓存是一个东西吗？不是。\n1) 缓冲池（Buffer Pool）\n首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。\n在 InnoDB\n存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：\n从图中，你能看到 InnoDB\n缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash\n和数据字典信息等。\n缓存池的重要性：\n缓存原则：\n“ 位置 * 频次 ”这个原则，可以帮我们对 I/O\n访问效率进行优化。\n首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。\n其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有\n200G，但是内存只有 16G，缓冲池大小只有\n1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。\n缓冲池的预读特性:\n缓冲池的作用就是提升 I/O\n效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘\nI/O 操作。\n2) 查询缓存\n那么什么是查询缓存呢？\n查询缓存是提前把\n查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在\nMySQL\n中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表\n发生变化，查询缓存就会失效，因此命中率低。\n3.2 缓冲池如何读取数据\n缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面\n是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。\n缓存在数据库中的结构和作用如下图所示：\n如果我们执行 SQL\n语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗？\n实际上，当我们对数据库中的记录进行修改的时候，首先会修改缓冲池中页里面的记录信息，然后数据库会以一定的频率刷新到磁盘中。注意并不是每次发生更新操作，都会立即进行磁盘回写。缓冲池会采用一种叫做\ncheckpoint 的机制\n将数据回写到磁盘上，这样做的好处就是提升了数据库的整体性能。\n比如，当缓冲池不够用时，需要释放掉一些不常用的页，此时就可以强行采用checkpoint的方式，将不常用的脏页回写到磁盘上，然后再从缓存池中将这些页释放掉。这里的脏页\n(dirty page) 指的是缓冲池中被修改过的页，与磁盘上的数据页不一致。\n3.3 查看/设置缓冲池的大小\n如果你使用的是 MySQL MyISAM\n存储引擎，它只缓存索引，不缓存数据，对应的键缓存参数为key_buffer_size，你可以用它进行查看。\n如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size\n变量来查看缓冲池的大小。命令如下：\nshow variables like 'innodb_buffer_pool_size';\n你能看到此时 InnoDB 的缓冲池大小只有\n134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如改为256MB，方法如下：\nset global innodb_buffer_pool_size = 268435456;\n或者：\n[server]innodb_buffer_pool_size = 268435456\n3.4 多个Buffer Pool实例\n[server]innodb_buffer_pool_instances = 2\n这样就表明我们要创建2个 Buffer Pool 实例。\n我们看下如何查看缓冲池的个数，使用命令：\nshow variables like 'innodb_buffer_pool_instances';\n那每个 Buffer Pool\n实例实际占多少内存空间呢？其实使用这个公式算出来的：\ninnodb_buffer_pool_size/innodb_buffer_pool_instances\n也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool\n实例占用的大小。\n不过也不是说 Buffer Pool 实例创建的越多越好，分别管理各个 Buffer Pool\n也是需要性能开销的，InnDB规定：当innodb_buffer_pool_size的值小于1G的时候设置多个实例是无效的，InnoDB会默认把innodb_buffer_pool_instances的值修改为1。而我们鼓励在\nBuffer Pool 大于等于 1G 的时候设置多个 Buffer Pool 实例。\n3.5 引申问题\nBuffer\nPool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。\n黑盒下的更新数据流程\n当我们查询数据的时候，会先去 Buffer Pool 中查询。如果 Buffer Pool\n中不存在，存储引擎会先将数据从磁盘加载到 Buffer Pool\n中，然后将数据返回给客户端；同理，当我们更新某个数据的时候，如果这个数据不存在于\nBuffer\nPool，同样会先数据加载进来，然后修改内存的数据。被修改的数据会在之后统一刷入磁盘。\n我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？\n答案：Redo Log &amp; Undo Log\n","categories":["Database","Architecture"]},{"title":"Database 性能优化","url":"/2024/02/27/Database-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"数据库性能优化常用手段汇总：包括系统性能参数调优、慢查询日志分析、SHOW PROFILE\n与 EXPLAIN 详解、Trace 跟踪，以及 Sys Schema\n视图监控等，帮助快速定位与解决性能瓶颈。\n\n1. 数据库服务器的优化步骤\n当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。\n整个流程划分成了 观察（Show status） 和\n行动（Action） 两个部分。字母 S\n的部分代表观察（会使用相应的分析工具），字母 A\n代表的部分是行动（对应分析可以采取的行动）。\n我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的\nSQL 都有哪些，查看具体的 SQL 执行计划，甚至是 SQL\n执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。\n2. 查看系统性能参数\n在 MySQL 中，可以使用 SHOW STATUS 语句查询一些 MySQL\n数据库服务器的性能参数、执行频率。\nSHOW STATUS 语句语法如下：\nSHOW [GLOBAL|SESSION] STATUS LIKE '参数';```git一些常用的性能参数如下：* Connections：连接MySQL服务器的次数。* Uptime：MySQL服务器的上线时间。* Slow_queries：慢查询的次数。* Innodb_rows_read：Select查询返回的行数* Innodb_rows_inserted：执行INSERT操作插入的行数* Innodb_rows_updated：执行UPDATE操作更新的 行数* Innodb_rows_deleted：执行DELETE操作删除的行数* Com_select：查询操作的次数。* Com_insert：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。* Com_update：更新操作 的次数。* Com_delete：删除操作的次数。若查询MySQL服务器的连接次数，则可以执行如下语句:```mysqlSHOW STATUS LIKE 'Connections';\n若查询服务器工作时间，则可以执行如下语句:\nSHOW STATUS LIKE 'Uptime';\n若查询 MySQL 服务器的慢查询次数，则可以执行如下语句:\nSHOW STATUS LIKE 'Slow_queries';\n慢查询次数参数可以结合慢查询日志找出查询时间较长的语句，然后针对慢查询语句进行表结构优化或者查询语句优化。\n再比如，如下的指令可以查看相关的指令情况：\nSHOW STATUS LIKE 'Innodb_rows_%';\n3. 统计 SQL 的查询成本:\nlast_query_cost\n一条 SQL\n查询语句在执行前需要查询执行计划，如果存在多种执行计划的话，MySQL\n会计算每个执行计划所需要的成本，从中选择成本最小的一个作为最终执行的执行计划。\n如果我们想要查看某条 SQL 语句的查询成本，可以在执行完这条 SQL\n语句之后，通过查看当前会话中的last_query_cost变量值来得到当前查询的成本。它通常也是我们评价一个查询的执行效率的一个常用指标。这个查询成本对应的是SQL 语句所需要读取的读页的数量。\n我们依然使用 student_info 表为例：\nCREATE TABLE `student_info` (    `id` INT(11) NOT NULL AUTO_INCREMENT,    `student_id` INT NOT NULL ,    `name` VARCHAR(20) DEFAULT NULL,    `course_id` INT NOT NULL ,    `class_id` INT(11) DEFAULT NULL,    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n如果我们想要查询 id=900001\n的记录，然后看查询成本，我们可以直接在聚簇索引上进行查找：\nSELECT student_id, class_id, NAME, create_time FROM student_info WHERE id = 900001;\n运行结果（1 条记录，运行时间为 0.042s ）\n然后再看下查询优化器的成本，实际上我们只需要检索一个页即可：\nmysql&gt; SHOW STATUS LIKE 'last_query_cost';+-----------------+----------+| Variable_name   |   Value  |+-----------------+----------+| Last_query_cost | 1.000000 |+-----------------+----------+\n如果我们想要查询 id 在 900001 到 9000100 之间的学生记录呢？\nSELECT student_id, class_id, NAME, create_time FROM student_info WHERE id BETWEEN 900001 AND 900100;\n运行结果（100 条记录，运行时间为 0.046s ）：\n然后再看下查询优化器的成本，这时我们大概需要进行 20 个页的查询。\nmysql&gt; SHOW STATUS LIKE 'last_query_cost';+-----------------+-----------+| Variable_name   |   Value   |+-----------------+-----------+| Last_query_cost | 21.134453 |+-----------------+-----------+\n你能看到页的数量是刚才的 20\n倍，但是查询的效率并没有明显的变化，实际上这两个 SQL\n查询的时间基本上一样，就是因为采用了顺序读取的方式将页面一次性加载到缓冲池中，然后再进行查找。虽然\n页\n数量（last_query_cost）增加了不少，但是通过缓冲池的机制后并没有增加多少查询时间\n。\n使用场景：它对于比较开销是非常有用的，特别是我们有好几种查询方式可选的时候。\n\nSQL\n查询时一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：\n\n位置决定效率。如果页就在数据库 缓冲池\n中，那么效率是最高的，否则还需要从 内存 或者\n磁盘\n中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。\n批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的(差不多\n10ms)，而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。\n\n所以说，遇到 I/O\n并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是进程使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。\n\n4. 定位执行慢的 SQL：慢查询日志\nMySQL 的慢查询日志，用来记录在 MySQL\n中响应时间超过阈值的语句，具体指运行时间超过long_query_time的值的\nSQL，则会被记录到慢查询日志中。long_query_time\n的默认值为10，意思是运行 10 秒以上（不含 10\n秒）的语句，认为是超出了我们的最大忍耐时间值。\n默认情况下，MySQL\n数据库没有开启慢查询日志，需要我们手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。\n4.1 开启慢查询日志参数\n1. 开启 slow_query_log\n在使用前，我们需要先查下慢查询是否已经开启，使用下面这条命令即可：\nmysql &gt; show variables like '%slow_query_log';\n我们可以看到\nslow_query_log=OFF，我们可以把慢查询日志打开，注意设置变量值的时候需要使用\nglobal，否则会报错：\nmysql &gt; set global slow_query_log='ON';\n然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：\n你能看到这时慢查询分析已经开启，同时文件保存在\n/var/lib/mysql/atguigu02-slow.log 文件 中。\n2. 修改 long_query_time 阈值\n接下来我们来看下慢查询的时间阈值设置，使用如下命令：\nmysql &gt; show variables like '%long_query_time%';\n这里如果我们想把时间缩短，比如设置为 1 秒，可以这样设置：\n#测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句mysql &gt; set global long_query_time = 1;mysql&gt; show global variables like '%long_query_time%';mysql&gt; set long_query_time=1;mysql&gt; show variables like '%long_query_time%';\n补充：配置文件中一并设置参数\n如下的方式相较于前面的命令行方式，可以看做是永久设置的方式。\n修改 my.cnf 文件，[mysqld] 下增加或修改参数\nlong_query_time、slow_query_log 和\nslow_query_log_file 后，然后重启 MySQL 服务器。\n[mysqld]slow_query_log=ON  # 开启慢查询日志开关slow_query_log_file=/var/lib/mysql/atguigu-low.log  # 慢查询日志的目录和文件名信息long_query_time=3  # 设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志log_output=FILE\n如果不指定存储路径，慢查询日志默认存储到 MySQL\n数据库的数据文件夹下。如果不指定文件名，默认文件名为\nhostname_slow.log。\n4.2 查看慢查询数目\n查询当前系统中有多少条慢查询记录\nSHOW GLOBAL STATUS LIKE '%Slow_queries%';\n4.3 案例演示\n步骤 1. 建表\nCREATE TABLE `student` (    `id` INT(11) NOT NULL AUTO_INCREMENT,    `stuno` INT NOT NULL ,    `name` VARCHAR(20) DEFAULT NULL,    `age` INT(3) DEFAULT NULL,    `classId` INT(11) DEFAULT NULL,    PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n步骤 2：设置参数 log_bin_trust_function_creators\n创建函数，假如报错：\nThis function has none of DETERMINISTIC......\n\n命令开启：允许创建函数设置：\n\nset global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。\n步骤 3：创建函数\n随机产生字符串：（同上一章）\nDELIMITER //CREATE FUNCTION rand_string(n INT)\tRETURNS VARCHAR(255) #该函数会返回一个字符串BEGIN\tDECLARE chars_str VARCHAR(100) DEFAULT'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';\tDECLARE return_str VARCHAR(255) DEFAULT '';    DECLARE i INT DEFAULT 0;    WHILE i &lt; n DO    \tSET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));    \tSET i = i + 1;    END WHILE;    RETURN return_str;END //DELIMITER ;# 测试SELECT rand_string(10);\n产生随机数值：（同上一章）\nDELIMITER //CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)BEGIN    DECLARE i INT DEFAULT 0;    SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;    RETURN i;END //DELIMITER ;#测试：SELECT rand_num(10,100);\n步骤 4：创建存储过程\nDELIMITER //CREATE PROCEDURE insert_stu1( START INT , max_num INT )BEGINDECLARE i INT DEFAULT 0;    SET autocommit = 0; #设置手动提交事务    REPEAT #循环    SET i = i + 1; #赋值    INSERT INTO student (stuno, NAME ,age ,classId ) VALUES    ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));    UNTIL i = max_num    END REPEAT;    COMMIT; #提交事务END //DELIMITER ;\n步骤 5：调用存储过程\n#调用刚刚写好的函数, 4000000条记录,从100001号开始CALL insert_stu1(100001,4000000);\n4.4 测试及分析\n1. 测试\nmysql&gt; SELECT * FROM student WHERE stuno = 3455655;+---------+---------+--------+------+---------+|   id    |  stuno  |  name  | age  | classId |+---------+---------+--------+------+---------+| 3523633 | 3455655 | oQmLUr |  19  |    39   |+---------+---------+--------+------+---------+1 row in set (2.09 sec)mysql&gt; SELECT * FROM student WHERE name = 'oQmLUr';+---------+---------+--------+------+---------+|   id    |  stuno  |  name  |  age | classId |+---------+---------+--------+------+---------+| 1154002 | 1243200 | OQMlUR | 266  |   28    || 1405708 | 1437740 | OQMlUR | 245  |   439   || 1748070 | 1680092 | OQMlUR | 240  |   414   || 2119892 | 2051914 | oQmLUr | 17   |   32    || 2893154 | 2825176 | OQMlUR | 245  |   435   || 3523633 | 3455655 | oQmLUr | 19   |   39    |+---------+---------+--------+------+---------+6 rows in set (2.39 sec)\n从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为\n2.09 秒。查询学生姓名为 “oQmLUr”的学生信息花费时间为 2.39\n秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面的小节我们分析一下原因。\n4.5\n慢查询日志分析工具：mysqldumpslow\n在生产环境中，如果要手工分析日志，查找、分析\nSQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow\n。\n查看 mysqldumpslow 的帮助信息\nmysqldumpslow --help\n\n-a: 不将数字抽象成 N，字符串抽象成 S\n-s: 是表示按照何种方式排序：\n\nc: 访问次数\nl: 锁定时间\nr: 返回记录\nt: 查询时间\nal:平均锁定时间\nar:平均返回记录数\nat:平均查询时间 （默认方式）\nac:平均查询次数\n\n-t: 即为返回前面多少条的数据；\n-g: 后边搭配一个正则匹配模式，大小写不敏感的；\n\n举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：\nmysqldumpslow -a -s t -t 5 /var/lib/mysql/atguigu01-slow.log\n工作常用参考：\n#得到返回记录集最多的10个SQLmysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log#得到访问次数最多的10个SQLmysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log#得到按照时间排序的前10条里面含有左连接的查询语句mysqldumpslow -s t -t 10 -g \"left join\" /var/lib/mysql/atguigu-slow.log#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more\n4.6 关闭慢查询日志\nMySQL 服务器停止慢查询日志功能有两种方法：\n方式 1：永久性方式\n[mysqld]slow_query_log=OFF\n或者，把 slow_query_log 一项注释掉 或 删除\n[mysqld]#slow_query_log =OFF\n重启 MySQL 服务，执行如下语句查询慢日志功能。\nSHOW VARIABLES LIKE '%slow%'; #查询慢查询日志所在目录SHOW VARIABLES LIKE '%long_query_time%'; #查询超时时长\n方式 2：临时性方式\n使用 SET 语句来设置。\n（1）停止 MySQL 慢查询日志功能，具体 SQL 语句如下。\nSET GLOBAL slow_query_log=off;\n（2）重启 MySQL 服务，使用 SHOW 语句查询慢查询日志功能信息，具体 SQL\n语句如下。\nSHOW VARIABLES LIKE '%slow%';#以及SHOW VARIABLES LIKE '%long_query_time%';\n4.7 删除慢查询日志\n使用 SHOW 语句显示慢查询日志信息，具体 SQL 语句如下。\nSHOW VARIABLES LIKE `slow_query_log%`;\n从执行结果可以看出，慢查询日志的目录默认为 MySQL\n的数据目录，在该目录下 手动删除慢查询日志文件 即可。\n使用命令 mysqladmin flush-logs\n来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。\nmysqladmin -uroot -p flush-logs slow\n\n慢查询日志都是使用 mysqladmin flush-logs\n命令来删除重建的。使用时一定要注意，一旦执行了这个命令，慢查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。\n\n5. 查看 SQL 执行成本：SHOW\nPROFILE\nshow profile 在《逻辑架构》章节中讲过，这里作为复习。\nshow profile 是 MySQL 提供的可以用来分析当前会话中 SQL\n都做了什么、执行的资源消耗工具的情况，可用于 sql\n调优的测量。默认情况下处于关闭状态，并保存最近 15\n次的运行结果。\n我们可以在会话级别开启这个功能。\nmysql &gt; show variables like 'profiling';\n通过设置 profiling=‘ON’ 来开启 show profile:\nmysql &gt; set profiling = 'ON';\n然后执行相关的查询语句。接着看下当前会话都有哪些\nprofiles，使用下面这条命令：\nmysql &gt; show profiles;\n如果我们想要查看最近一次查询的开销，可以使用：\nmysql &gt; show profile;\nmysql&gt; show profile cpu,block io for query 2\nshow profile 的常用查询参数： \n① ALL：显示所有的开销信息。\n② BLOCK IO：显示块 IO 开销。\n③ CONTEXT SWITCHES：上下文切换开销。\n④ CPU：显示 CPU 开销信息。\n⑤ IPC：显示发送和接收开销信息。\n⑥ MEMORY：显示内存开销信 息。\n⑦ PAGE FAULTS：显示页面错误开销信息。\n⑧ SOURCE：显示和 Source_function，Source_file， Source_line\n相关的开销信息。\n⑨ SWAPS：显示交换次数开销信息。\n日常开发需注意的结论：\n① converting HEAP to MyISAM:\n查询结果太大，内存不够，数据往磁盘上搬了。\n②\nCreating tmp table：创建临时表。先拷贝数据到临时表，用完后再删除临时表。\n③\nCopying to tmp table on disk：把内存中临时表复制到磁盘上，警惕！\n④ locked。\n如果在 show profile 诊断结果中出现了以上 4 条结果中的任何一条，则 sql\n语句需要优化。\n\n不过 SHOW PROFILE 命令将被弃用，我们可以从 information_schema 中的\nprofiling 数据表进行查看。\n\n6. 分析查询语句：EXPLAIN\n6.1 概述\n定位了查询慢的 SQL 之后，我们就可以使用 EXPLAIN 或 DESCRIBE\n工具做针对性的分析查询语句。\nDESCRIBE 语句的使用方法与 EXPLAIN\n语句是一样的，并且分析结果也是一样的。\nMySQL 中有专门负责优化 SELECT\n语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的\nQuery 提供它认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA\n认为是最优的，这部分最耗费时间) 。\n这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL\n为我们提供了 EXPLAIN\n语句来帮助我们查看某个查询语句的具体执行计划，大家看懂 EXPLAIN\n语句的各个输出项，可以有针对性的提升我们查询语句的性能。\n1. 能查看什么？\n\n表的读取顺序\n数据读取操作的操作类型\n哪些索引可以使用\n哪些索引被实际使用\n表之间的引用\n每张表有多少行被优化器查询\n\n2. 官网介绍\nhttps://dev.mysql.com/doc/refman/5.7/en/explain-output.html\nhttps://dev.mysql.com/doc/refman/8.0/en/explain-output.html\n3. 版本情况\n\nMySQL 5.6.3 以前只能 EXPLAIN SELECT ；MYSQL 5.6.3 以后就可以 EXPLAIN\nSELECT，UPDATE，DELETE。\n在 5.7 以前的版本中，想要显示 partitions 需要使用 explain partitions\n命令；想要显示 filtered 需要使用 explain extended 命令。在 5.7\n版本后，默认 explain 直接显示 partitions 和 filtered 中的信息。\n\n6.2 基本语法\nEXPLAIN 或 DESCRIBE 语句的语法形式如下：\nEXPLAIN SELECT select_options或者DESCRIBE SELECT select_options\n如果我们想看查询的执行计划，可以在具体的查询语句前边加一个 EXPLAIN\n，就像这样：\n（EXPALIN 后面的 SQL 语句并不会被执行）\nEXPLAIN SELECT 1;\nEXPLAIN 语句输出的各个列的作用如下：\n在这里把它们都列出来知识为了描述一个轮廓，让大家有一个大致的印象。\n6.3 数据准备\n1. 建表\nCREATE TABLE s1 (    id INT AUTO_INCREMENT,    key1 VARCHAR(100),    key2 INT,    key3 VARCHAR(100),    key_part1 VARCHAR(100),    key_part2 VARCHAR(100),    key_part3 VARCHAR(100),    common_field VARCHAR(100),    PRIMARY KEY (id),    INDEX idx_key1 (key1),    UNIQUE INDEX idx_key2 (key2),    INDEX idx_key3 (key3),    INDEX idx_key_part(key_part1, key_part2, key_part3)) ENGINE=INNODB CHARSET=utf8;\nCREATE TABLE s2 (    id INT AUTO_INCREMENT,    key1 VARCHAR(100),    key2 INT,    key3 VARCHAR(100),    key_part1 VARCHAR(100),    key_part2 VARCHAR(100),    key_part3 VARCHAR(100),    common_field VARCHAR(100),    PRIMARY KEY (id),    INDEX idx_key1 (key1),    UNIQUE INDEX idx_key2 (key2),    INDEX idx_key3 (key3),    INDEX idx_key_part(key_part1, key_part2, key_part3)) ENGINE=INNODB CHARSET=utf8;\n2. 设置参数 log_bin_trust_function_creators\n创建函数，假如报错，需开启如下命令：允许创建函数设置：\nset global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。\n3. 创建函数\nDELIMITER //CREATE FUNCTION rand_string1(n INT)\tRETURNS VARCHAR(255) #该函数会返回一个字符串BEGIN\tDECLARE chars_str VARCHAR(100) DEFAULT'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';    DECLARE return_str VARCHAR(255) DEFAULT '';    DECLARE i INT DEFAULT 0;    WHILE i &lt; n DO        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));        SET i = i + 1;    END WHILE;    RETURN return_str;END //DELIMITER ;\n4. 创建存储过程\n创建往 s1 表中插入数据的存储过程：\nDELIMITER //CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))BEGIN    DECLARE i INT DEFAULT 0;    SET autocommit = 0;    REPEAT    SET i = i + 1;    INSERT INTO s1 VALUES(        (min_num + i),        rand_string1(6),        (min_num + 30 * i + 5),        rand_string1(6),        rand_string1(10),        rand_string1(5),        rand_string1(10),        rand_string1(10));    UNTIL i = max_num    END REPEAT;    COMMIT;END //DELIMITER ;\n创建往 s2 表中插入数据的存储过程：\nDELIMITER //CREATE PROCEDURE insert_s2 (IN min_num INT (10),IN max_num INT (10))BEGIN    DECLARE i INT DEFAULT 0;    SET autocommit = 0;    REPEAT    SET i = i + 1;    INSERT INTO s2 VALUES(        (min_num + i),        rand_string1(6),        (min_num + 30 * i + 5),        rand_string1(6),        rand_string1(10),        rand_string1(5),        rand_string1(10),        rand_string1(10));    UNTIL i = max_num    END REPEAT;    COMMIT;END //DELIMITER ;\n5. 调用存储过程\ns1 表数据的添加：加入 1 万条记录：\nCALL insert_s1(10001,10000);\ns2 表数据的添加：加入 1 万条记录：\nCALL insert_s2(10001,10000);\n6.4 EXPLAIN 各列作用\n1. table\n不论我们的查询语句有多复杂，里边儿 包含了多少个表\n，到最后也是需要对每个表进行 单表访问的，所 以 MySQL 规定 EXPLAIN\n语句输出的每条记录都对应着某个单表的访问方法，该条记录的 table\n列代表着该表的表名（有时不是真实的表名字，可能是简称）。\nmysql &gt; EXPLAIN SELECT * FROM s1;\n这个查询语句只涉及对 s1 表的单表查询，所以 EXPLAIN\n输出中只有一条记录，其中的 table 列的值为 s1，表明这条记录是用来说明对\ns1 表的单表访问方法的。\n下边我们看一个连接查询的执行计划\nmysql &gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                         |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  9895 |   100.00 | NULL                          ||  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10152 |   100.00 | Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+2 rows in set, 1 warning (0.00 sec)\n可以看出这个连接查询的执行计划中有两条记录，这两条记录的 table\n列分别是 s1 和 s2，这两条记录用来分别说明对 s1 表和 s2\n表的访问方法是什么。\n2. id\n我们写的查询语句一般都以 SELECT\n关键字开头，比较简单的查询语句里只有一个 SELECT\n关键字，比如下边这个查询语句：\nSELECT * FROM s1 WHERE key1 = 'a';\n稍微复杂一点的连接查询中也只有一个 SELECT 关键字，比如：\nSELECT * FROM s1 INNER JOIN s2ON s1.key1 = s2.key1WHERE s1.common_field = 'a';\n但是下边两种情况下在一条查询语句中会出现多个 SELECT 关键字：\n\n查询中包含子查询的情况\n\n比如下边这个查询语句中就包含 2 个 SELECT 关键字:\nSELECT * FROM 1WHERE key1 IN (SELECT key3 FROM s2) I.\n\n查询中包含 UNION 语句的情况\n\n比如下边这个查询语句中也包含 2 个 SELECT 关键字:\nSELECT * FROM s1 UNION SELECT * FROM s2;\n查询语句中每出现一个 SELECT 关键字，MySQL 就会为它分配一个唯一的 id\n值。\n这个 id 值就是 EXPLAIN 语句的第一个列，比如下边这个查询中只有一个\nSELECT 关键字，所以 EXPLAIN 的结果中也就只有一条 id 列为 1 的记录:\nmysql &gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+\n对于连接查询来说，一个 SELECT 关键字后边的 FROM\n字句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的\nid 值都是相同的，比如：\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                         |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  9895 |   100.00 | NULL                          ||  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10152 |   100.00 | Using join buffer (hash join) |+----+-------------+-------+------------+------+---------------+------+---------+------+-------+----------+-------------------------------+\n可以看到，上述连接查询中参与连接的 s1 和 s2\n表分别对应一条记录，但是这两条记录对应的id都是\n1。这里需要大家记住的是，在连接查询的执行计划中，每个表都会对应一条记录，这些记录的\nid\n列的值是相同的，出现在前边的表表示驱动表，出现在后面的表表示被驱动表。所以从上边的\nEXPLAIN 输出中我们可以看到，查询优化器准备让 s1 表作为驱动表，让 s2\n表作为被驱动表来执行查询。\n对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的\nid 值，比如这样：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL |  9895 |   100.00 | Using where ||  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 10152 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\n但查询优化器可能对涉及子查询的查询语句进行重写，转变为多表查询的操作。\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = 'a');+----+-------------+-------+------------+--------+---------------+----------+---------+--------------+------+----------+------------------------------------+| id | select_type | table | partitions | type   | possible_keys | key      | key_len | ref          | rows | filtered | Extra                              |+----+-------------+-------+------------+--------+---------------+----------+---------+--------------+------+----------+------------------------------------+|  1 | SIMPLE      | s1    | NULL       | ALL    | idx_key1      | NULL     | NULL    | NULL         | 9895 |   100.00 | Using where                        ||  1 | SIMPLE      | s2    | NULL       | eq_ref | idx_key2      | idx_key2 | 5       | test.s1.key1 |    1 |    10.00 | Using index condition; Using where |+----+-------------+-------+------------+--------+---------------+----------+---------+--------------+------+----------+------------------------------------+\n可以看到，虽然我们的查询语句是一个子查询，但是执行计划中 s1 和 s2\n表对应的记录的id值全部是\n1，这就表明查询优化器将子查询转换为了连接查询。\n对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边的查询：\n# Union去重mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  9895 |   100.00 | NULL            ||  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10152 |   100.00 | NULL            ||  3 | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+\n这个语句的执行计划的第三条记录是什么? 为何 id 值是 3，而且 table\n列也很奇怪?\nUNION！它会把多个查询的结果集合并起来并对结果集中的记录进行去重，怎么去重呢?\nMySQL 使用的是内部的临时表。正如上边的查询计划中所示，UNION 子句是为了把\nid 为 1 的查询和 id 为 2\n的查询的结果集合并起来并去重，所以在内部创建了一个名为\n&lt;union1，2&gt;的临时表（就是执行计划第三条记录的 table\n列的名称），对临时表进行查询的 id 就是 3。\n跟UNION对比起来，UNION ALL 就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含\nUNION ALL 子句的查询的执行计划中，就没有那个 id 为 NULL\n的记录，如下所示:\n小结:\n\nid 如果相同，可以认为是一组，从上往下顺序执行\n在所有组中，id 值越大，优先级越高，越先执行\n关注点：id 号每个号码，表示一趟独立的查询, 一个 sql\n的查询趟数越少越好\n\n3. select_type\n一条大的查询语句里边可以包含若干个 SELECT 关键字，每个 SELECT\n关键字代表着一个小的查询语句，而每个 SELECT 关键字的 FROM\n子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个\nSELECT 关键字中的表来说，它们的 id 值是相同的。\nMySQL 为每一个 SELECT 关键字代表的小查询都定义了一个称之为\nselect_type 的属性，意思是我们只要知道了某个小查询的\nselect_type\n属性，就知道了这个小查询在整个大查询中扮演了一个什么角色，我们看一下\nselect_type 都能取哪些值，请看官方文档:\n具体分析如下：\n\nSIMPLE\n查询语句中不包含UNION或者子查询的查询都算作是SIMPLE类型\n比方说:\nEXPLAIN SELECT * FROM s1;EXPLAIN SELECT * FROM s1 INNER JOIN s2;\nPRIMARY\n对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type的值就是PRIMARY,比方说：\nmysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra           |+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  9895 |   100.00 | NULL            ||  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 10152 |   100.00 | NULL            ||  3 | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  NULL |     NULL | Using temporary |+----+--------------+------------+------------+------+---------------+------+---------+------+-------+----------+-----------------+\n从结果中可以看到，最左边的小查询SELECT * FROM s1对应的是执行计划中的第一条记录，它的select_type的值就是PRIMARY。\nUNION\n对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询意外，其余的小查询的select_type值就是\nUNION，可以对比上一个例子的效果。\nUNION RESULT\nMySQL\n选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT,\n例子上边有。\nSUBQUERY\n如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的select_type就是SUBQUERY，比如下边这个查询：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows  | filtered | Extra       |+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL |  9895 |   100.00 | Using where ||  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 10152 |   100.00 | Using index |+----+-------------+-------+------------+-------+---------------+----------+---------+------+-------+----------+-------------+\nDEPENDENT SUBQUERY\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';\nDEPENDENT UNION\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = 'a' UNION SELECT key1 FROM s1 WHERE key1 = 'b');\nDERIVED\n当查询优化器在执行包含子查询的语句时，选择将子查询物化之后的外层查询进行连接查询时，该子查询对应的select_type属性就是\nDERIVED，比如下边这个查询：\nmysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;\nUNCACHEABLE SUBQUERY\n不常用，就不多说了。\nUNCACHEABLE UNION\n不常用，就不多说了。\n\n4. partitions (可略)\n\n代表分区表中的命中情况，非分区表，该项为NULL。一般情况下我们的额查询语句的执行计划的partitions列的值为NULL。\nhttps://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html\n\n5. type ☆\n执行计划的一条记录就代表着 MySQL 对某个表的\n执行查询时的访问方法 , 又称“访问类型”，其中的\ntype\n列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到type列的值是ref，表明MySQL即将使用ref访问方法来执行对s1表的查询。\n完整的访问方法如下：\nsystem ， const ， eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ， range ， index ， ALL\n。\n(查询性能递减)\n\nsystem\n当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如\nMyISAM、Memory，那么对该表的访问方法就是system。比方说我们新建一个MyISAM表，并为其插入一条记录：\nmysql&gt; CREATE TABLE t(i int) Engine=MyISAM;Query OK, 0 rows affected (0.05 sec)mysql&gt; INSERT INTO t VALUES(1);Query OK, 1 row affected (0.01 sec)\n然后我们看一下查询这个表的执行计划：\nmysql&gt; EXPLAIN SELECT * FROM t;\n可以看到type列的值就是system了，\n\n测试，可以把表改成使用 InnoDB\n存储引擎，试试看执行计划的type列是什么=&gt;ALL\n\nconst\n当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const,\n比如：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\neq_ref\n在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的\n（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较）\n则对该被驱动表的访问方法就是eq_ref，比方说：\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9895 |   100.00 | NULL  ||  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.s1.id |    1 |   100.00 | NULL  |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+\n从执行计划的结果中可以看出，MySQL 打算将 s2 作为驱动表，s1\n作为被驱动表，重点关注 s1 的访问 方法是 eq_ref ，表明在访问\ns1 表的时候可以 通过主键的等值匹配 来进行访问。\nref\n当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref，比方说下边这个查询：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';\nfulltext\n全文索引\nref_or_null\n当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时，那么对该表的访问方法就可能是ref_or_null，比如说：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key1 IS NULL;\nindex_merge\n一般情况下对于某个表的查询只能使用到一个索引，但单表访问方法时在某些场景下可以使用Interseation、union、Sort-Union这三种索引合并的方式来执行查询。我们看一下执行计划中是怎么体现\nMySQL 使用索引合并的方式来对某个表执行查询的：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+\n从执行计划的 type 列的值是 index_merge\n就可以看出，MySQL 打算使用索引合并的方式来执行对 s1 表的查询。\n相当于先合并再回表和先回表再合并的区别\nunique_subquery\n类似于两表连接中被驱动表的eq_ref访问方法，unique_subquery是针对在一些包含IN子查询的查询语句中，如果查询优化器决定将IN子查询转换为EXISTS子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的type列的值就是unique_subquery，比如下边的这个查询语句：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';\nindex_subquery\nindex_subquery 与 unique_subquery\n类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';\nrange\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN ('a', 'b', 'c');\n或者：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'a' AND key1 &lt; 'b';\nindex\n当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是index\n\n覆盖索引（covering\nindex）即从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。\n如下面的例子，查询的条件（key_part3）和最后查询的结果（key_part2）都是在联合索引idx_key_part中出现，则无需查到对应主键\nid 后再进行回表操作。\n\nmysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';\n上述查询中的所有列表中只有 key_part2 一个列，而且搜索条件中也只有\nkey_part3 一个列，这两个列又恰好包含在 idx_key_part\n这个索引中，可是搜索条件 key_part3\n不能直接使用该索引进行ref和range方式的访问，只能扫描整个idx_key_part索引的记录，所以查询计划的type列的值就是index。\n\n再一次强调，对于使用 InnoDB\n存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，也就是扫描聚簇索引的代价更低一些。\n\nALL\n最熟悉的全表扫描，就不多说了，直接看例子：\nmysql&gt; EXPLAIN SELECT * FROM s1;\n\n小结: \n结果值从最好到最坏依次是：\nsystem&gt; const&gt;\neq_ref&gt; ref&gt; fulltext &gt; ref_or_null\n&gt; index_merge &gt; unique_subquery &gt; index_subquery &gt;\nrange&gt; index&gt; ALL\nSQL 性能优化的目标：至少要达到 range 级别，要求是 ref\n级别，最好是 consts 级别。（阿里巴巴 开发手册要求）\n6. possible_keys 和 key\n在 EXPLAIN\n语句输出的执行计划中possible_keys列表示在某个查询语句中，对某个列执行单表查询时可能用到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。\nkey列表示实际用到的索引有哪些，如果为\nNULL，则没有使用索引。比方说下面这个查询：\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z' AND key3 = 'a';\n上述执行计划的possible_keys列的值是idx_key1, idx_key3，表示该查询可能使用到idx_key1, idx_key3两个索引，然后key列的值是idx_key3，表示经过查询优化器计算使用不同索引的成本后，最后决定采用idx_key3。\n7. key_len ☆\n实际使用到的索引长度 (即：字节数)\n帮你检查是否充分的利用了索引，值越大越好，主要针对于联合索引，有一定的参考意义。\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE id = 10005;+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+\n\nint 占用 4 个字节\n\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | const | idx_key2      | idx_key2 | 5       | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------+\n\nkey2 上有一个唯一性约束，是否为 NULL 占用一个字节，那么就是 5\n个字节\n\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+\n\nkey1 VARCHAR(100) 一个字符占 3 个字节，100*3，是否为 NULL 占用 1\n个字节，varchar 的长度信息占两个字节。\n\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = 'a' AND key_part2 = 'b';+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key          | key_len | ref         | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key_part  | idx_key_part | 606     | const,const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+--------------+---------+-------------+------+----------+-------+\n\n联合索引中可以比较，key_len=606 的好于 key_len=303\n\n练习： \nkey_len 的长度计算公式：\nvarchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)\n8. ref\n显示索引的哪一列被使用了，如果可能的话，是一个常数。\n哪些列或常量被用于查找索引列上的值。\n当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是\nconst、eq_ref 、ref 、ref_or_null、 unique_subquery 、index_subquery\n其中之一时，ref\n列展示的就是与索引列作等值匹配的结构是什么，比如只是一个常数或者是某个列。大家看下边这个查询:\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    1 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+\n可以看到ref列的值是const，表明在使用idx_key1索引执行查询时，与key1列作等值匹配的对象是一个常数，当然有时候更复杂一点:\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref        | rows | filtered | Extra |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL       | 9895 |   100.00 | NULL  ||  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | test.s1.id |    1 |   100.00 | NULL  |+----+-------------+-------+------------+--------+---------------+---------+---------+------------+------+----------+-------+\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9895 |   100.00 | NULL                  ||  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+\n9. rows ☆\n预估的需要读取的记录条数，值越小越好。\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z';+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | NULL  |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+\n10. filtered\n某个表经过搜索条件过滤后剩余记录条数的百分比\n如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z' AND common_field = 'a';\n对于单表查询来说，这个 filtered\n的值没有什么意义，我们更关注在连接查询中驱动表对应的执行计划记录的filtered值，它决定了被驱动表要执行的次数\n(即: rows * filtered)\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = 'a';\n从执行计划中可以看出来，查询优化器打算把s1作为驱动表，s2当做被驱动表。我们可以看到驱动表s1表的执行计划的rows列为9688，filtered\n列为10.00，这意味着驱动表s1的扇出值就是9688 x 10.00% = 968.8，这说明还要对被驱动表执行大约968次查询。\n11. Extra ☆\n顾名思义，Extra列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来更准确的理解MySQL到底将如何执行给定的查询语句。MySQL\n提供的额外信息有好几十个，我们就不一个一个介绍了，所以我们只挑选比较重要的额外信息介绍给大家。\n\nNo tables used\n当查询语句没有FROM子句时将会提示该额外信息，比如：\nmysql&gt; EXPLAIN SELECT 1;\nImpossible WHERE\n当查询语句的WHERE子句永远为FALSE时将会提示该额外信息\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;\nUsing where\nNo matching min/max row\n当查询列表处有MIN或者MAX聚合函数，但是并没有符合WHERE子句中的搜索条件的记录时。\nmysql&gt; EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = 'abcdefg';\nUsing index\n当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在Extra列将会提示该额外信息。比方说下边这个查询中只需要用到idx_key1而不需要回表操作:\nmysql&gt; EXPLAIN SELECT key1 FROM s1 WHERE key1 = 'a';\nUsing index condition\n有些搜索条件中虽然出现了索引列，但却不能使用到索引，比如下边这个查询：\nSELECT * FROM s1 WHERE key1 &gt; 'z' AND key1 LIKE '%a';\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; 'z' AND key1 LIKE '%b';\nUsing join buffer (Block Nested Loop)\n在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL\n一般会为其分配一块名叫join buffer的内存块来加快查询速度，也就是我们所讲的基于块的嵌套循环算法。\nmysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;\nNot exists\n当我们使用左(外)连接时，如果WHERE子句中包含要求被驱动表的某个列等于NULL值的搜索条件，而且那个列是不允许存储NULL值的，那么在该表的执行计划的\nExtra 列就会提示这个信息：\nmysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;\nUsing intersect(...) 、 Using union(...) 和 Using sort_union(...)\n如果执行计划的Extra列出现了Using intersect(...)提示，说明准备使用Intersect索引合并的方式执行查询，括号中的...表示需要进行索引合并的索引名称；\n如果出现Using union(...)提示，说明准备使用Union索引合并的方式执行查询;\n如果出现Using sort_union(...)提示，说明准备使用Sort-Union索引合并的方式执行查询。\nmysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |    2 |   100.00 | Using union(idx_key1,idx_key3); Using where |+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+\nZero limit\n当我们的LIMIT子句的参数为0时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息\nmysql&gt; EXPLAIN SELECT * FROM s1 LIMIT 0;\nUsing filesort\n有一些情况下对结果集中的记录进行排序是可以使用到索引的。\nmysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+\n这个查询语句可以利用 idx_key1 索引直接取出 key1 列的 10\n条记录，然后再进行回表操作(key1 已经有序)。\n但是很多情况下排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，MySQL\n把这种在内存中或者磁盘上进行排序的方式统称为文件排序 (英文名：filesort\n)。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的 Extra\n列中显示 Using filesort 提示，比如这样:\nmysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9895 |   100.00 | Using filesort |+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+\n需要注意的是，如果查询中需要使用filesort的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法将使用文件排序的执行方式改为索引进行排序。\nUsing temporary\n在许多查询的执行过程中，MySQL\n可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含\nDISTINCT、GROUP BY、UNION\n等子句的查询过程中，如果不能有效利用索引来完成查询， MYSQL\n很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的\nExtra 列将会显示 Using temporary 提示，比方说这样:\nmysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;\n再比如：\nmysql&gt; EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;\n执行计划中出现Using temporary并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们最好能使用索引来替代掉使用临时表，比方说下边这个包含GROUP BY子句的查询就不需要使用临时表：\nmysql&gt; EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;\n从 Extra 的 Using index\n的提示里我们可以看出，上述查询只需要扫描 idx_key1\n索引就可以搞定了，不再需要临时表了。\n其他\n其它特殊情况这里省略。\n\n12. 小结\n\nEXPLAIN 不考虑各种 Cache\nEXPLAIN 不能显示 MySQL 在执行查询时所作的优化工作\nEXPLAIN\n不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况\n部分统计信息是估算的，并非精确值\n\n7. EXPLAIN 的进一步使用\n7.1 EXPLAIN 四种输出格式\n这里谈谈 EXPLAIN 的输出格式。EXPLAIN 可以输出四种格式：\n传统格式 ，JSON格式 ， TREE格式\n以及 可视化输出\n。用户可以根据需要选择适用于自己的格式。\n1. 传统格式\n传统格式简单明了，输出是一个表格形式，概要说明查询计划。\nmysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;\n2. JSON 格式\n第 1\n种格式中介绍的EXPLAIN语句输出中缺少了一个衡量执行好坏的重要属性\n—— 成本。而 JSON\n格式是四种格式里面输出信息最详尽的格式，里面包含了执行的成本信息。\n\nJSON 格式：在 EXPLAIN 单词和真正的查询语句中间加上 FORMAT=JSON\n。\n\nEXPLAIN FORMAT=JSON SELECT ....\n\nEXPLAIN 的 Column 与 JSON 的对应关系：(来源于 MySQL 5.7 文档)\n\n这样我们就可以得到一个 json\n格式的执行计划，里面包含该计划花费的成本。比如这样：\nmysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = 'a'\\G\n大家可能有疑问 “cost_info”\n里边的成本看着怪怪的，它们是怎么计算出来的？先看 s1 表的\n“cost_info” 部 分：\n\"cost_info\": {    \"read_cost\": \"1840.84\"    \"eval_cost\": \"193.76\",    \"prefix_cost\": \"2034.60\",    \"data_read_per_join\": \"1M\"}\n\nread_cost 是由下边这两部分组成的：\n\nIO 成本\n检测 rows × (1 - filter) 条记录的 CPU 成本\n\n\n小贴士： rows 和 filter 都是我们前边介绍执行计划的输出列，在 JSON\n格式的执行计划中，rows 相当于 rows_examined_per_scan，filtered\n名称不变。\n\neval_cost 是这样计算的：\n检测 rows × filter 条记录的成本。\nprefix_cost 就是单独查询 s1 表的成本，也就是：\nread_cost + eval_cost\ndata_read_per_join\n表示在此次查询中需要读取的数据量。\n\n对于 s2 表的 “cost_info” 部分是这样的：\n\"cost_info\": {    \"read_cost\": \"968.80\",    \"eval_cost\": \"193.76\",    \"prefix_cost\": \"3197.16\",    \"data_read_per_join\": \"1M\"}\n由于 s2\n表是被驱动表，所以可能被读取多次，这里的read_cost 和\neval_cost 是访问多次 s2\n表后累加起来的值，大家主要关注里边儿的 prefix_cost\n的值代表的是整个连接查询预计的成本，也就是单次查询 s1\n表和多次查询 s2 表后的成本的和，也就是：\n968.80 + 193.76 + 2034.60 = 3197.16\n3. TREE 格式\nTREE 格式是 8.0.16 版本之后引入的新格式，主要根据查询的\n各个部分之间的关系 和 各部分的执行顺序\n来描述如何查询。\nmysql&gt; EXPLAIN FORMAT=tree SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHEREs1.common_field = 'a'\\G*************************** 1. row ***************************EXPLAIN: -&gt; Nested loop inner join (cost=1360.08 rows=990)-&gt; Filter: ((s1.common_field = 'a') and (s1.key1 is not null)) (cost=1013.75rows=990)-&gt; Table scan on s1 (cost=1013.75 rows=9895)-&gt; Single-row index lookup on s2 using idx_key2 (key2=s1.key1), with indexcondition: (cast(s1.key1 as double) = cast(s2.key2 as double)) (cost=0.25 rows=1)1 row in set, 1 warning (0.00 sec)\n4. 可视化输出\n可视化输出，可以通过 MySQL Workbench 可视化查看 MySQL\n的执行计划。通过点击 Workbench\n的放大镜图标，即可生成可视化的查询计划。\n7.2 SHOW WARNINGS 的使用\n在我们使用EXPLAIN语句查看了某个查询的执行计划后，紧接着还可以使用SHOW WARNINGS语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：\nmysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;\nmysql&gt; SHOW WARNINGS\\G*************************** 1. row ***************************    Level: Note     Code: 1003Message: /* select#1 */ select `atguigu`.`s1`.`key1` AS `key1`,`atguigu`.`s2`.`key1`AS `key1` from `atguigu`.`s1` join `atguigu`.`s2` where ((`atguigu`.`s1`.`key1` =`atguigu`.`s2`.`key1`) and (`atguigu`.`s2`.`common_field` is not null))1 row in set (0.00 sec)\n大家可以看到SHOW WARNINGS展示出来的信息有三个字段，分别是Level、Code、Message。我们最常见的就是\nCode 为 1003 的信息，当 Code 值为 1003\n时，Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。比如我们上边的查询本来是一个左(外)连接查询，但是有一个\ns2.common_field IS NOT NULL\n的条件，这就会导致查询优化器把左(外)连接查询优化为内连接查询，从SHOW WARNINGS的Message字段也可以看出来，原本的\nLEFE JOIN 已经变成了 JOIN。\n但是大家一定要注意，我们说Message字段展示的信息类似于查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说Message字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解\nMySQL 将如何执行查询语句的一个参考依据而已。\n8. 分析优化器执行计划：trace\nOPTIMIZER_TRACE 是 MySQL 5.6\n引入的一项跟踪功能，它可以跟踪优化器做出的各种决策（比如访问表的方法、各种开销计算、各种转换等)，并将跟踪结果记录到\nINFORMATION_SCHEMA.OPTIMIZER_TRACE 表中。此功能默认关闭。开启\ntrace，并设置格式为 JSON，同时设置 trace\n最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。|\nSET optimizer_trace=\"enabled=on\",end_markers_in_json=on;set optimizer_trace_max_mem_size=1000000;\n开启后，可分析如下语句：\n\nSELECT\nINSERT\nREPLACE\nUPDATE\nDELETE\nEXPLAIN\nSET\nDECLARE\nCASE\nIF\nRETURN\nCALL\n\n测试：执行如下 SQL 语句\nselect * from student where id &lt; 10;\n最后， 查询 information_schema.optimizer_trace 就可以知道 MySQL\n是如何执行 SQL 的 ：\nselect * from information_schema.optimizer_trace\\G\n*************************** 1. row ***************************//第1部分：查询语句QUERY: select * from student where id &lt; 10//第2部分：QUERY字段对应语句的跟踪信息TRACE: {\"steps\": [{    \"join_preparation\": { //预备工作        \"select#\": 1,        \"steps\": [            {            \"expanded_query\": \"/* select#1 */ select `student`.`id` AS            `id`,`student`.`stuno` AS `stuno`,`student`.`name` AS `name`,`student`.`age` AS            `age`,`student`.`classId` AS `classId` from `student` where (`student`.`id` &lt; 10)\"            }        ] /* steps */    } /* join_preparation */},{    \"join_optimization\": { //进行优化    \"select#\": 1,    \"steps\": [        {        \"condition_processing\": { //条件处理        \"condition\": \"WHERE\",        \"original_condition\": \"(`student`.`id` &lt; 10)\",        \"steps\": [        {            \"transformation\": \"equality_propagation\",            \"resulting_condition\": \"(`student`.`id` &lt; 10)\"        },        {            \"transformation\": \"constant_propagation\",            \"resulting_condition\": \"(`student`.`id` &lt; 10)\"        },        {            \"transformation\": \"trivial_condition_removal\",            \"resulting_condition\": \"(`student`.`id` &lt; 10)\"        }        ] /* steps */    } /* condition_processing */    },    {        \"substitute_generated_columns\": { //替换生成的列        } /* substitute_generated_columns */    },    {        \"table_dependencies\": [ //表的依赖关系        {            \"table\": \"`student`\",            \"row_may_be_null\": false,            \"map_bit\": 0,            \"depends_on_map_bits\": [            ] /* depends_on_map_bits */        }    ] /* table_dependencies */    },    {    \"ref_optimizer_key_uses\": [ //使用键        ] /* ref_optimizer_key_uses */        },    {        \"rows_estimation\": [ //行判断        {            \"table\": \"`student`\",            \"range_analysis\": {                \"table_scan\": {                    \"rows\": 3973767,                    \"cost\": 408558            } /* table_scan */, //扫描表            \"potential_range_indexes\": [ //潜在的范围索引                {                    \"index\": \"PRIMARY\",                    \"usable\": true,                    \"key_parts\": [                    \"id\"                    ] /* key_parts */                }            ] /* potential_range_indexes */,        \"setup_range_conditions\": [ //设置范围条件        ] /* setup_range_conditions */,        \"group_index_range\": {            \"chosen\": false,            \"cause\": \"not_group_by_or_distinct\"        } /* group_index_range */,            \"skip_scan_range\": {                \"potential_skip_scan_indexes\": [                    {                        \"index\": \"PRIMARY\",                        \"usable\": false,                        \"cause\": \"query_references_nonkey_column\"                    }                ] /* potential_skip_scan_indexes */            } /* skip_scan_range */,        \"analyzing_range_alternatives\": { //分析范围选项            \"range_scan_alternatives\": [                {                \"index\": \"PRIMARY\",                    \"ranges\": [                        \"id &lt; 10\"                    ] /* ranges */,                \"index_dives_for_eq_ranges\": true,                \"rowid_ordered\": true,                \"using_mrr\": false,                \"index_only\": false,                \"rows\": 9,                \"cost\": 1.91986,                \"chosen\": true                }            ] /* range_scan_alternatives */,        \"analyzing_roworder_intersect\": {            \"usable\": false,            \"cause\": \"too_few_roworder_scans\"        \t} /* analyzing_roworder_intersect */        } /* analyzing_range_alternatives */,        \"chosen_range_access_summary\": { //选择范围访问摘要            \"range_access_plan\": {                \"type\": \"range_scan\",                \"index\": \"PRIMARY\",                \"rows\": 9,                \"ranges\": [                \"id &lt; 10\"                ] /* ranges */                } /* range_access_plan */,                \"rows_for_plan\": 9,                \"cost_for_plan\": 1.91986,                \"chosen\": true                } /* chosen_range_access_summary */                } /* range_analysis */            }        ] /* rows_estimation */    },    {    \"considered_execution_plans\": [ //考虑执行计划    {    \"plan_prefix\": [    ] /* plan_prefix */,        \"table\": \"`student`\",        \"best_access_path\": { //最佳访问路径        \"considered_access_paths\": [        {            \"rows_to_scan\": 9,            \"access_type\": \"range\",            \"range_details\": {            \"used_index\": \"PRIMARY\"        } /* range_details */,        \"resulting_rows\": 9,        \"cost\": 2.81986,        \"chosen\": true    }    ] /* considered_access_paths */    } /* best_access_path */,        \"condition_filtering_pct\": 100, //行过滤百分比        \"rows_for_plan\": 9,        \"cost_for_plan\": 2.81986,        \"chosen\": true    }    ] /* considered_execution_plans */    },    {        \"attaching_conditions_to_tables\": { //将条件附加到表上        \"original_condition\": \"(`student`.`id` &lt; 10)\",        \"attached_conditions_computation\": [        ] /* attached_conditions_computation */,        \"attached_conditions_summary\": [ //附加条件概要    {        \"table\": \"`student`\",        \"attached\": \"(`student`.`id` &lt; 10)\"    }    ] /* attached_conditions_summary */    } /* attaching_conditions_to_tables */    },    {    \"finalizing_table_conditions\": [    {        \"table\": \"`student`\",        \"original_table_condition\": \"(`student`.`id` &lt; 10)\",        \"final_table_condition \": \"(`student`.`id` &lt; 10)\"    }    ] /* finalizing_table_conditions */    },    {    \"refine_plan\": [ //精简计划    {    \t\"table\": \"`student`\"    }    ] /* refine_plan */    }    ] /* steps */    } /* join_optimization */},\t{        \"join_execution\": { //执行            \"select#\": 1,            \"steps\": [            ] /* steps */        \t} /* join_execution */        }    ] /* steps */}//第3部分：跟踪信息过长时，被截断的跟踪信息的字节数。MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0 //丢失的超出最大容量的字节//第4部分：执行跟踪语句的用户是否有查看对象的权限。当不具有权限时，该列信息为1且TRACE字段为空，一般在调用带有SQL SECURITY DEFINER的视图或者是存储过程的情况下，会出现此问题。INSUFFICIENT_PRIVILEGES: 0 //缺失权限1 row in set (0.00 sec)\n9. MySQL 监控分析视图-sys\nschema\n9.1 Sys schema 视图摘要\n\n主机相关：以 host_summary 开头，主要汇总了 IO\n延迟的信息。\nInnodb 相关：以 innodb 开头，汇总了 innodb buffer\n信息和事务等待 innodb 锁的信息。\nI/O 相关：以 io 开头，汇总了等待 I/O、I/O\n使用量情况。\n内存使用情况：以 memory\n开头，从主机、线程、事件等角度展示内存的使用情况\n连接与会话信息：processlist 和 session\n相关视图，总结了会话相关信息。\n表相关：以 schema_table\n开头的视图，展示了表的统计信息。\n索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。\n语句相关：以 statement\n开头，包含执行全表扫描、使用临时表、排序等的语句信息。\n用户相关：以 user 开头的视图，统计了用户使用的文件\nI/O、执行语句统计信息。\n等待事件相关信息：以 wait\n开头，展示等待事件的延迟情况。\n\n9.2 Sys schema 视图使用场景\n索引情况\n#1. 查询冗余索引select * from sys.schema_redundant_indexes;#2. 查询未使用过的索引select * from sys.schema_unused_indexes;#3. 查询索引的使用情况select index_name,rows_selected,rows_inserted,rows_updated,rows_deletedfrom sys.schema_index_statistics where table_schema='dbname';\n表相关\n# 1. 查询表的访问量select table_schema,table_name,sum(io_read_requests+io_write_requests) as io fromsys.schema_table_statistics group by table_schema,table_name order by io desc;# 2. 查询占用bufferpool较多的表select object_schema,object_name,allocated,datafrom sys.innodb_buffer_stats_by_table order by allocated limit 10;# 3. 查看表的全表扫描情况select * from sys.statements_with_full_table_scans where db='dbname';\n语句相关\n#1. 监控SQL执行的频率select db,exec_count,query from sys.statement_analysisorder by exec_count desc;#2. 监控使用了排序的SQLselect db,exec_count,first_seen,last_seen,queryfrom sys.statements_with_sorting limit 1;#3. 监控使用了临时表或者磁盘临时表的SQLselect db,exec_count,tmp_tables,tmp_disk_tables,queryfrom sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0order by (tmp_tables+tmp_disk_tables) desc;\nIO 相关\n#1. 查看消耗磁盘IO的文件select file,avg_read,avg_write,avg_read+avg_write as avg_iofrom sys.io_global_by_file_by_bytes order by avg_read limit 10;\nInnodb 相关\n#1. 行锁阻塞情况select * from sys.innodb_lock_waits;\n\n风险提示: 通过 sys 库去查询时，MySQL\n会消耗大量资源去收集相关信息，严重的可能会导致业务请求被阻塞，从而引起故障。建议生产上不要频繁的去查询\nsys 或者 performance_schema、information_schema\n来完成监控、巡检等工作。\n\n10. 小结\n查询是数据库中最频繁的操作，提高查询速度可以有效地提高 MySQL\n数据库的性能。通过对查询语句的分析可以了解查询语句的执行情况，找出查询语句执行的瓶颈，从而优化查询语句。\n","categories":["Database","Performance"],"tags":["SQL,Performance"]},{"title":"Dynamic Programming Algorithm","url":"/2022/12/14/Dynamic-Programming-Algorithm/","content":"动态规划的常见模型与技巧，涵盖线性 DP、区间 DP、树形 DP、状态压缩\nDP、数位 DP 等典型类型，重点介绍最长公共子序列、最长上升子序列、01\n背包及其扩展（完全背包、多重背包、混合背包），并深入讲解状态设计、转移方程、边界初始化、滚动数组优化及单调队列优化等核心技巧。\n\n线性DP\n理解题目递推的顺序\n守望者的逃离 摆花 线段 乌龟棋 最长公共子序列\ns1 = io[0]; s2 = io[1];n = s1.length(); m = s2.length();dp = new int[n+1][m+1];for (int i = 1;i &lt;= n;i++){    for (int j = 1;j &lt;= m;j++){        if (s1.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = dp[i-1][j-1]+1;        else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);    }}out.println(dp[n][m]);\nP1439\n【模板】最长上升子序列\n把题目转换一下 两个序列其中一个转换为1 2 … n 排列 置换另一个\n计算最长上升子序列即可\nO(n2)\nstatic int[] a = new int[N], dp = new int[N]; //dp[i] 以i结尾最长递增子序列长度static void solve() throws Exception {n = ni();for (int i = 1;i &lt;= n;i++) a[i] = ni();for (int i = 1;i &lt;= n;i++){    dp[i] = 1; //初始化     for (int j = i-1;j &gt;= 1;j--){        // 遍历之前的 如果大于a[j] 就更新取最大值        if (a[i] &gt; a[j]) dp[i] = max(dp[i], dp[j]+1);     }}int ans = 0; // 最长递增子序列长度不一定在末尾取到 所以要遍历所有下标for (int i = 1;i &lt;= n;i++) ans = max(ans, dp[i]);out.println(ans);}\n\n优化：原来的dp数组的存储由数值换成该序列中，上升子序列长度为i的上升子序列，的最小末尾数值\n\n这其实就是一种近贪心的思想：我们当前的上升子序列长度如果已经确定，那么如果这种长度的子序列的结尾元素越小，后面的元素就可以有更大概率地加入到这条上升子序列中。\nO(nlog n)\nstatic int[] a = new int[N], dp = new int[N];//dp[i] : 长度为i+1的上升子序列中末尾最小的数值static void solve() throws Exception {    n = ni();    for (int i = 1;i &lt;= n;i++) a[i] = ni();    Arrays.fill(dp, 0, n, 1&lt;&lt;30); //dp[i]存最小值 所以初始化为无穷    int len = 0; // len表示最长上升子序列长度（答案）    for (int i = 1;i &lt;= n;i++){        int cur = a[i];        int l = 0, r = len-1; //二分找到第一个大于当前值的末尾值 用cur替换        while (l &lt;= r){            int mid = l+r &gt;&gt; 1;            if (dp[mid] &lt; cur) l = mid+1;            else r = mid-1;        }        if (l == len) ++len; //如果都小于当前值 说明子序列长度可以加1了        dp[l] = min(dp[l], cur); //更新末尾最小值    }    out.println(len);}\n\n背包DP\n01背包\nstatic int[][] dp = new int[N][M];static int[] w = new int[N], v = new int[N]; // w[i]:第i个物品体积 v[i]:第i个物品价for (int i = 1;i &lt;= n;i++){    for (int j = 0;j &lt;= m;j++){        if (j &gt;= w[i]) dp[i][j] = max(dp[i-1][j-w[i]]+v[i], dp[i-1][j]);        else dp[i][j] = dp[i-1][j];    }}out.println(dp[n][m]);\nstatic int[] dp = new int[M];static int[] w = new int[N], v = new int[N]; // w[i]:第i个物品体积 v[i]:第i个物品价值// dp[i][j] = max(dp[i-1][j-w[i]]+v[i], dp[i-1][j]); 第i行只与前一行有关，滚动数组优化for (int i = 1;i &lt;= n;i++){    for (int j = m;j &gt;= 0;j--){        if (j &gt;= w[i]) dp[j] = max(dp[j-w[i]]+v[i], dp[j]);        //else dp[j] = dp[j];    }}out.println(dp[m]);\nP1048 采药 P1049 装箱问题\nP1164 小A点菜\n计数问题：装满背包的方案数\nstatic int[] dp = new int[M];static int[] w = new int[N]; // w[i]:第i个物品体积dp[0] = 1; //装满容量为0的背包方案数为1 就是什么都不装for (int i = 1;i &lt;= n;i++){    for (int j = m;j &gt;= 0;j--){        if (j &gt;= w[i]) dp[j] += dp[j-w[i]];     }}out.println(dp[m]);\nP1507\nNASA的食物计划 二维01背包（就又加了个限制条件而已）\nint[][] dp = new int[M][M]; //从三维压缩到二维int[] w1 = new int[N], w2 = new int[N], v = new int[N]; //w1:体积 w2:重量 v:价值for (int i = 1;i &lt;= n;i++){     for (int j = m;j &gt;= w1[i];j--){// 二维就多一个循环而已        for (int k = t;k &gt;= w2[i];k--) {            dp[j][k] = max(dp[j-w1[i]][k-w2[i]]+v[i], dp[j][k]);        }    }}out.println(dp[m][t]);\n\n完全背包\nstatic int[] dp = new int[M];static int[] w = new int[N], v = new int[N];for (int i = 1;i &lt;= n;i++){for (int k = 0;k*w[i] &lt;= m;k++){ //暴力 无限个物品 一一枚举 直接转换成01背包    for (int j = m;j &gt;= k*w[i];--j)        dp[j] = max(dp[j], dp[j-k*w[i]]+k*v[i]);    }} //会TLE\n// 完全背包正解for (int i = 1;i &lt;= n;i++){    for (int j = w[i];j &lt;= m;++j)        dp[j] = max(dp[j], dp[j-w[i]]+v[i]);}out.println(dp[m]);\n首先考虑二维:dp[i][j]\n怎么得到（其实就是上面写的暴力）\n两式联立即可导出\n考虑压缩到一维：\ndp[i][j]更新要用到dp[i − 1][j], dp[i][j − v]\n即第i层的j 要用到第i层的j − v来更新\n所以==第二层遍历顺序应该从小到大（与01背包的区别）==\nUSACO08NOV]Buying\nHay S P1853\n投资的最大效益\n\n多重背包\n\n暴力（物品可使用k次看成k个物品转换成01背包）多重背包问题 I\n\nfor (int i = 1;i &lt;= n;i++) {    for (int j = m;j &gt;= v[i];j--) {        for (int k = 1;k &lt;= s[i] &amp;&amp; j&gt;=k*v[i];k++){            dp[j] = max(dp[j], dp[j-k*v[i]]+k*w[i]);        }    }}out.println(dp[m]);\n\n二进制优化 多重背包问题\nII\n\nstatic int[] dp = new int[M];static int[] w = new int[N], v = new int[N]; // N = N*Log(s) int cnt = 1;for (int i = 1;i &lt;= n;i++){    int wi = ni(), vi = ni(), s = ni(); // 体积 价值 数量    for (int c = 1;c &lt;= s;c &lt;&lt;= 1){  // 二进制拆分        w[cnt] = c*wi; v[cnt++] = c*vi; // 1 2 4 8 ... 个物品分别作为一组        s -= c;    }    if (s != 0) {w[cnt] = s*wi; v[cnt++] = s*vi;} // 1 2 4 8...拆完可能还剩}for (int i = 1;i &lt; cnt;i++){ //无脑01背包    for (int j = m;j &gt;= w[i];--j)        dp[j] = max(dp[j], dp[j-w[i]]+v[i]);}out.println(dp[m]);\n\n单调队列优化 P1776\n宝物筛选\n\n\n混合背包\n物品分三类：\n\n第一类物品只能用 1 次（01背包）；\n第二类物品可以用无限次（完全背包）；\n第三类物品最多只能用 s 次（多重背包）；\n\nstatic int[] dp = new int[M];static int[] w = new int[N], v = new int[N], kind = new int[N]; //kind[]存背包类型int n, m， cnt = 1;for (int i = 1;i &lt;= n;i++){    int wi = ni(), vi = ni(), s = ni();    if (s == 0){         w[cnt] = wi; v[cnt] = vi; kind[cnt++] = 1;//无限次 完全背包 kind = 1    }else{        for (int k = 1;k &lt;= s;k &lt;&lt;= 1){ //否则 多重背包转为01背包 kind = 0            w[cnt] = wi*k; v[cnt] = vi*k; kind[cnt++] = 0;            s -= k;        }        if (s != 0) {w[cnt] = wi*s; v[cnt] = vi*s; kind[cnt++] = 0;}    }}for (int i = 1;i &lt; cnt;i++){    if (kind[i] == 0){ //完全背包        for (int j = m;j &gt;= w[i];--j) dp[j] = max(dp[j], dp[j-w[i]]+v[i]);    }else{    //01背包        for (int j = w[i];j &lt;= m;++j) dp[j] = max(dp[j], dp[j-w[i]]+v[i]);    }}out.println(dp[m]);\n分组背包\n有 N 组物品和一个容量是 V 的背包。\n每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij\n，价值是 wij ，其中 i 是组号，j 是组内编号。\n求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\n常出现在树形DP中\nclass Solution {    int mod = (int)1e9+7;    public int numRollsToTarget(int n, int m, int t) {        int[][] f = new int[n + 1][t + 1];        f[0][0] = 1;        // 枚举物品组        for (int i = 1; i &lt;= n; i++) {            // 枚举背包容量            for (int j = 0; j &lt;= t; j++) {                // 枚举每个组中每个物品 (相当于每个组中进行0-1背包)                for (int k = 1; k &lt;= m; k++) {                    if (j &gt;= k) {                        f[i][j] = (f[i][j] + f[i-1][j-k]) % mod;                    }                }            }        }         return f[n][t];    }}\n\n区间DP\n区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由\n前一阶段的哪些元素合并而来有很大的关系。令状态 f(i, j)\n表示将下标位置 i 到 j 的所有元素合\n并能获得的价值的最大值，那么 f(i, j) = max {f(i, k) + f(k + 1, j) + cost}，cost\n为将这 两组元素合并起来的代价。\n注意：f(i, j) 由 f(i, k) 和 f(k + 1, j)\n得到 所以 直接两层循环i和j是不行的\n比如 i循环到1 j循环到5 需要【1， 3】【4， 5】此时【4，\n5】还没有求出来（因为i才循环到1）\n所以我们要枚举区间长度 从小到大\nP1063\n能量项链\nfor (int i = 1;i &lt;= n;i++) {    a[i-1][1] = a[i][0] = nl(); // a[i][0] a[i][1] 分别表示项链的首尾    a[i-1+n] = a[i-1]; // 断环成链的技巧}a[n][1] = a[1][0];long res = 0;for (int len = 2;len &lt;= n;len++){ //从小到大枚举区间长度 （1就不用枚举了 一个项链不好合并）    for (int i = 1;i+len-1 &lt; 2*n;i++){ //枚举左端点 注意要从1到2*n都要考虑        int j = i+len-1; //算出右端点        for (int k = i;k &lt; j;k++){            dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j]+                            a[i][0]*a[k+1][0]*a[j][1]);            if (dp[i][j] &gt; res) res = dp[i][j];        }    }}out.println(res);\n\n状态压缩DP\nCows in a Skyscraper\nG\n给出n个物品，体积为w[i]，现把其分成若干组，要求每组总体积&lt;=k，问最小分组。(n&lt;=18)\n我们用1代表这个奶牛已经在电梯里了,0则还没坐电梯\n那么我们可以直接定义一维的数组,f[i]就代表当前状态为i时最小的乘电梯次数\n最终的答案就是f[(1&lt;&lt;n)-1];\n我们可以开一个数组g来记录当前状态下电梯内剩余的体积\nstatic void solve() throws Exception {n = ni(); k = ni();for (int i = 0;i &lt; n;i++) a[i] = ni();Arrays.fill(dp, 1&lt;&lt;30);dp[0] = 1; g[0] = k;for (int i = 0;i &lt; (1&lt;&lt;n);i++){//枚举状态     for (int j = 0;j &lt; n;j++){//枚举每一头奶牛        if ((i&gt;&gt;j &amp; 1) == 1) continue;        if (g[i] &gt;= a[j]){//如果这个电梯坐得下            dp[i | (1&lt;&lt;j)] = dp[i]; // 不用新开一个电梯            g[i | (1&lt;&lt;j)] = max(g[i | (1&lt;&lt;j)], g[i]-a[j]);        }else if (dp[i | (1&lt;&lt;j)] &gt;= dp[i]+1) {//如果这个电梯坐不下             dp[i | (1&lt;&lt;j)] = dp[i]+1;// 新开一个电梯            g[i | (1&lt;&lt;j)] = max(g[i | (1&lt;&lt;j)], k-a[j]);        }    }}out.println(dp[(1&lt;&lt;n)-1]);}\n\n数位DP\n数位\nDP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：\n\n要求统计满足一定条件的数的数量（即，最终目的为计数）；\n这些条件经过转化后可以使用「数位」的思想去理解和判断；\n输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；\n上界很大，暴力枚举验证会超时。\n\n\n一般的数位dp中，任何为0的数位都对结果都不影响；但对于某些题目，最高位为0时，对结果不影响，但非最高位为0时会对答案有贡献；此时需要添加前导零标记，以用于判断当前位置是否为最高位。\n\nwindy 数\n不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy\n想知道，在 a 和 b 之间，包括 a和 b，总共有多少个 windy 数？\nstatic int[] a = new int[N];static int[][] d = new int[N][N];// len表示已经搜到了第len位（从高到低 last表示前一位所填的数// flag表示之前的每一位是否 都 已经紧贴上界 // zero表示表示之前的每一位是否 都 是0static int dfs(int len, int pre, boolean f, boolean z){    if (len == 0) return 1; //全部遍历完了 返回1    if (!f &amp;&amp; !z &amp;&amp; d[len][pre] != -1) return d[len][pre];    //f为true, 那么当前位置最大只能够是区间上界数字的当前位的数值    //否则,这一位能够填写0~9,因为这种情况下不管怎么填写,数字都不会超过给定范围.    int res = 0, max = f?a[len]:9;     for (int i = 0;i &lt;= max;i++){        //条件:相邻两个数字之间的差值必须不小于2,并且是没有前导零的情况        if (abs(i-pre) &lt; 2 &amp;&amp; !z) continue;        res += dfs(len-1, i, f&amp;&amp;i==a[len], z&amp;&amp;i==0);    }    if (!f &amp;&amp; !z) d[len][pre] = res;    return res;}static int get(int x){ // 求区间[1, x] 满足条件的数的数量    n = 0;    while (x &gt; 0){ // 把数拆成每一位        a[++n] = x%10;        x /= 10;    }    for (int i = 0;i &lt; 11;i++) Arrays.fill(d[i], -1);    return dfs(n, 11, true, true);}static void solve() throws Exception {    int l = ni(), r = ni(); // 求区间[l, r] 满足条件的数量    out.println(get(r)-get(l-1));}\n\n树形DP\n树形 dp\n的主要实现形式是 dfs ，在 dfs 中 dp ，主要的实现形式是 dp[i][j][2]\n基本的 dp 方程\n选择节点类\n\n树形背包类\n\nP1352\n没有上司的舞会\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 r。\n但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\nstatic int[] a = new int[N], dp[] = new int[N][2];// f[x][0]表示以x为根,且x不参加的最大快乐值   f[x][1]表示以x为根，且x参加了的最大快乐值static List&lt;Integer&gt;[] g = new List[N];static void dfs(int u){    dp[u][0] = a[u];    for (int v : g[u]) {        dfs(v); //自底向上遍历        dp[u][0] += dp[v][1];        dp[u][1] += max(dp[v][1], dp[v][0]);    }}\nP2016\n战略游戏\nstatic void dfs(int u, int p){dp[u][0] = 0;dp[u][1] = 1;for (int v : g[u]){    if (v == p) continue;        dfs(v, u);        dp[u][0] += dp[v][1];        dp[u][1] += min(dp[v][1], dp[v][0]);    }}\n","categories":["Algorithm","Template"],"tags":["动态规划","Template"]},{"title":"InnoDB 存储引擎","url":"/2024/02/24/InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"InnoDB数据库物理存储结构\n\n1. 数据库的存储结构：页\n索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。\n由于InnoDB是MySQL的默认存储引擎，所以本章剖析InooDB存储引擎的数据存储结构。\n1.1 磁盘与内存交互基本单位：页\nInnoDB将数据划\n分为若干个页，InnoDB中页的大小默认为16KB。\n以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页。一个页中可以存储多个行记录。\n\n记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。\n\n1.2 页结构概述\n页a、页b、页c…页n这些页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。\n1.3 页的大小\n不同的数据库管理系统（简称DBMS）的页大小不同。比如在 MySQL 的 InnoDB\n存储引擎中，默认页的大小是\n16KB，我们可以通过下面的命令来进行查看：\nshow variables like '%innodb_page_size%'\nSQL Server 中页的大小为 8KB，而在 Oracle 中我们用术语\n“块” （Block）来表示 “页”，Oracle 支持的快大小为2KB, 4KB,\n8KB, 16KB, 32KB 和 64KB。\n1.4 页的上层结构\n另外在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）的概念。行、页、区、段、表空间的关系如下图所示：\n区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。\n段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。\n表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。\n2. 页的内部结构\n页如果按类型划分的话，常见的有\n数据页（保存B+树节点）、系统表、Undo 页 和 事务数据页\n等。数据页是我们最常使用的页。\n数据页的 16KB\n大小的存储空间被划分为七个部分，分别是文件头（File Header）、页头（Page\nHeader）、最大最小记录（Infimum + supremum）、用户记录（User\nRecords）、空闲空间（Free Space）、页目录（Page\nDirectory）和文件尾（File Tailer）。\n页结构的示意图如下表所示：\n我们可以把这7个结构分为3个部分。\n2.1 第1部分：文件头部和文件尾部\n2.1.1 File\nHeader（文件头部）（38字节）\n作用：\n描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）\n大小：38字节\n\n\n\n\n\n\n\n\n名称\n占用空间大小\n描述\n\n\n\n\nFIL_PAGE_SPACE_OR_CHKSUM\n4字节\n页的校验和（checksum值）\n\n\nFIL_PAGE_OFFSET\n4字节\n页号\n\n\nFIL_PAGE_PREV\n4字节\n上一个页的页号\n\n\nFIL_PAGE_NEXT\n4字节\n下一个页的页号\n\n\nFIL_PAGE_LSN\n8字节\n页面被最后修改时对应的日志序列位置\n\n\nFIL_PAGE_TYPE\n2字节\n该页的类型\n\n\nFIL_PAGE_FILE_FLUSH_LSN\n8字节\n仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值\n\n\nFIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID\n4字节\n页属于哪个表空间\n\n\n\n\nFIL_PAGE_OFFSET（4字节）：每一个页都有一个单独的页号，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。\nFIL_PAGE_TYPE（2字节）：这个代表当前页的类型。\n\n\n\n\n\n\n\n\n\n类型名称\n十六进制\n描述\n\n\n\n\nFIL_PAGE_TYPE_ALLOCATED\n0x0000\n最新分配，还没有使用\n\n\nFIL_PAGE_UNDO_LOG\n0x0002\nUndo日志页\n\n\nFIL_PAGE_INODE\n0x0003\n段信息节点\n\n\nFIL_PAGE_IBUF_FREE_LIST\n0x0004\nInsert Buffer空闲列表\n\n\nFIL_PAGE_IBUF_BITMAP\n0x0005\nInsert Buffer位图\n\n\nFIL_PAGE_TYPE_SYS\n0x0006\n系统页\n\n\nFIL_PAGE_TYPE_TRX_SYS\n0x0007\n事务系统数据\n\n\nFIL_PAGE_TYPE_FSP_HDR\n0x0008\n表空间头部信息\n\n\nFIL_PAGE_TYPE_XDES\n0x0009\n扩展描述页\n\n\nFIL_PAGE_TYPE_BLOB\n0x000A\n溢出页\n\n\nFIL_PAGE_INDEX\n0x45BF\n索引页，也就是我们所说的数据页\n\n\n\n\nFIL_PAGE_PREV（4字节）和FIL_PAGE_NEXT（4字节）：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。\nFIL_PAGE_SPACE_OR_CHKSUM（4字节）：代表当前页面的校验和（checksum）。文件头部和文件尾部都有属性：FIL_PAGE_SPACE_OR_CHKSUM\n\nInnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。\n为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以通过文件尾的校验和（checksum\n值）与文件头的校验和做比对，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。\n\nFIL_PAGE_LSN（8字节）：页面被最后修改时对应的日志序列位置（英文名是：Log\nSequence Number）\n\n2.1.2 File\nTrailer（文件尾部）（8字节）\n\n前4个字节代表页的校验和：这个部分是和File\nHeader中的校验和相对应的。\n后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。\n\n2.2\n第2部分：空闲空间、用户记录和最小最大记录\n2.2.1 Free Space (空闲空间)\n我们自己存储的记录会按照指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User\nRecords这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free\nSpace部分的空间全部被User\nRecords部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。\n2.2.2 User Records (用户记录)\nUser Records中的这些记录按照指定的行格式一条一条摆在User\nRecords部分，相互之间形成单链表。\n2.2.3 Infimum +\nSupremum（最小最大记录）\n记录可以比较大小吗？\n是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。\nInnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。\n这两条记录不是我们自己定义的记录，所以它们并不存放在页的User\nRecords部分，他们被单独放在一个称为Infimum + Supremum的部分\n2.3 第3部分：页目录和页面头部\n2.3.1 Page Directory（页目录）\n为什么需要页目录？\n在页中，记录是以单向链表的形式进行存储的。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。\n页目录（分组=&gt;组内二分查找）\n\n将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。\n第 1 组，也就是最小记录所在的分组只有 1 个记录；\n最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在\n4-8 条之间。 这样做的好处是，除了第 1\n组（最小记录所在组）以外，其余组的记录数会尽量平分。\n在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为\nn_owned 字段。\n页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。\n\n2.3.2 Page Header（页面头部）\n为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page\nHeader的部分，这个部分占用固定的56个字节，专门存储各种状态信息。\n\n\n\n\n\n\n\n\n名称\n占用空间大小\n描述\n\n\n\n\nPAGE_N_DIR_SLOTS\n2字节\n在页目录中的槽数量\n\n\nPAGE_HEAP_TOP\n2字节\n还未使用的空间最小地址，也就是说从该地址之后就是Free Space\n\n\nPAGE_N_HEAP\n2字节\n本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）\n\n\nPAGE_FREE\n2字节\n第一个已经标记为删除的记录的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）\n\n\nPAGE_GARBAGE\n2字节\n已删除记录占用的字节数\n\n\nPAGE_LAST_INSERT\n2字节\n最后插入记录的位置\n\n\nPAGE_DIRECTION\n2字节\n记录插入的方向\n\n\nPAGE_N_DIRECTION\n2字节\n一个方向连续插入的记录数量\n\n\nPAGE_N_RECS\n2字节\n该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）\n\n\nPAGE_MAX_TRX_ID\n8字节\n修改当前页的最大事务ID，该值仅在二级索引中定义\n\n\nPAGE_LEVEL\n2字节\n当前页在B+树中所处的层级\n\n\nPAGE_INDEX_ID\n8字节\n索引ID，表示当前页属于哪个索引\n\n\nPAGE_BTR_SEG_LEAF\n10字节\nB+树叶子段的头部信息，仅在B+树的Root页定义\n\n\nPAGE_BTR_SEG_TOP\n10字节\nB+树非叶子段的头部信息，仅在B+树的Root页定义\n\n\n\n2.4\n从数据库页的角度看B+树如何查询\n一颗B+树按照字节类型可以分为两部分：\n\n叶子节点，B+ 树最底层的节点，节点的高度为0，存储行记录。\n非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。\n\n当我们从页结构来理解 B+\n树的结构的时候，可以帮我们理解一些通过索引进行检索的原理：\n3. InnoDB行格式（或记录格式）\n每个行记录按照插入顺序依次存储在磁盘上，但通过单链表结构实现有序链接。\n3.1 指定行格式的语法\nCREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称\nALTER TABLE 表名 ROW_FORMAT=行格式名称\n3.2 COMPACT行格式\n一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。\n3.2.1 变长字段长度列表\nMySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。\n\n注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是反过来的。\n\n3.2.2 NULL值列表\nCompact行格式会把可以为NULL的列统一管理起来，存在一个标记为NULL值列表中。如果表中没有允许存储\nNULL 的列，则 NULL值列表也不存在了。\n为什么定义NULL值列表？\n之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：\n\n二进制位的值为1时，代表该列的值为NULL。\n二进制位的值为0时，代表该列的值不为NULL。\n\n\n注意：同样顺序也是反过来存放的\n\n3.2.3 记录头信息（5字节）\n\n\n\n\n\n\n\n\n名称\n大小（单位：bit）\n描述\n\n\n\n\n预留位1\n1\n没有使用\n\n\n预留位2\n1\n没有使用\n\n\ndelete_mask\n1\n标记该记录是否被删除\n\n\nmin_rec_mask\n1\nB+树的每层非叶子节点中的最小记录都会添加该标记\n\n\nn_owned\n4\n表示当前记录拥有的记录数\n\n\nheap_no\n13\n表示当前记录在记录堆的位置信息\n\n\nrecord_type\n3\n表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录\n\n\nnext_record\n16\n表示下一条记录的相对位置\n\n\n\n\ndelete_mask：这个属性标记着当前记录是否被删除，占用1个二进制位。\n被删除的记录为什么还在页中存储呢？\n你以为它删除了，可它还在真实的磁盘上。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗。所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。\nmin_rec_mask：B+树的每层非叶子节点中的最小记录都会添加该标记，值为1。\nrecord_type：这个属性表示当前记录的类型，一共有4种类型的记录：\n\n0：表示普通记录\n1：表示B+树非叶节点记录\n2：表示最小记录\n3：表示最大记录\n\nheap_no：这个属性表示当前记录在本页中的位置。\n怎么不见heap_no值为0和1的记录呢？\nMySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录。最小记录和最大记录的heap_no值分别是0和1，也就是说它们的位置最靠前。\n（相当于链表中的哨兵节点）\nn_owned：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为\nn_owned 字段。\nnext_record：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。\n\n3.2.4 记录的真实数据\n除了自己定义的列外，有以下隐藏列\n\n\n\n列名\n是否必须\n占用空间\n描述\n\n\n\n\nrow_id\n否\n6字节\n行ID，唯一标识一条记录\n\n\ntransaction_id\n是\n6字节\n事务ID\n\n\nroll_pointer\n是\n7字节\n回滚指针\n\n\n\n一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的。\n3.3 Dynamic和Compressed行格式\n我们可以知道一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录，这种现象称为行溢出\n在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中进行分页存储，然后记录的真实数据处用20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为页的扩展。\n在MySQL\n8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧\n\nCompressed和Dynamic两种记录格式对于存放在BLOB中的数据采用了完全的行溢出的方式。如在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off\nPage（溢出页）中。\nCompact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。\n\n4. 区、段与碎片区\n4.1 为什么要有区？\nB+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/O。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I/O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/O。\n引入区的概念，一个区就是物理位置上连续的64个页。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是64*16KB=1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页的单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，功大于过！\n4.2 为什么要有段？\n对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。\n除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。\n在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。\n段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。\n4.3 为什么要有碎片区？\n默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M（64*16KB=1024KB）存储空间，所以默认情况下一个只存在几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。\n为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。\n所以此后为某个段分配存储空间的策略是这样的：\n\n在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。\n当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。\n\n所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面已经一些完整的区的集合。\n4.4 区的分类\n区大体上可以分为4种类型：\n\n空闲的区 (FREE) : 现在还没有用到这个区中的任何页面。\n有剩余空间的碎片区 (FREE_FRAG)：表示碎片区中还有可用的页面。\n没有剩余空间的碎片区\n(FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。\n附属于某个段的区\n(FSEG)：每一个索引都可以分为叶子节点段和非叶子节点段。\n\n处于FREE、FREE_FRAG 以及 FULL_FRAG\n这三种状态的区都是独立的，直属于表空间。\n而处于 FSEG 状态的区是附属于某个段的。\n\n如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于\nFSEG 的区全部隶属于某个段，而处于 FREE、FREE_FRAG 以及 FULL_FRAG\n这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。\n\n5. 表空间\n表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。\n表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为\n系统表空间（System\ntablespace）、独立表空间 (File-per-table\ntablespace）、撤销表空间 (Undo Tablespace)\n和临时表空间 (Temporary Tablespace) 等。\n5.1 独立表空间\n独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间\n(即：单表) 可以在不同的数据库之间进行 迁移。\n空间可以回收 (DROP TABLE\n操作可自动回收表空间；其他情况，表空间不能自己回收)\n。如果对于统计分析或是日志表，删除大量数据后可以通过：alter table\nTableName engine=innodb;\n回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。\n独立表空间结构\n独立表空间由段、区、页组成。\n真实表空间对应的文件大小\n我们到数据目录里看，会发现一个新建的表对应的 .ibd 文件只占用了\n96K，才6个页面大小\n(MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些\n.ibd\n文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。\n查看 InnoDB 的表空间类型：\nshow variables like 'innodb_file_per_table'\n你能看到 innodb_file_per_table=ON, 这就意味着每张表都会单词保存一个\n.ibd 文件。\n5.2 系统表空间\n系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。\nInnoDB数据字典\n每当我们向一个表中插入一条记录的时候，MySQL挍验过程如下:\n先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说：\n\n某个表属于哪个表空间, 表里边有多少列\n表对应的每一个列的类型是什么\n该表有多少索引, 每个索引对应哪几个字段,\n该索引对应的根页面在哪个表空间的哪个页面\n该表有哪些外键, 外键对应哪个表的哪些列\n某个表空间对应文件系统上文件路径是什么\n……\n\n这些数据并不是我们使用 INSERT\n语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得以引入的一些额外数据，这些数据页称为元数据。InnoDB\n存储引擎特意定义了一些列的 内部系统表 (internal system table)\n来记录这些元数据：\n\n这些系统表也称为 数据字典，它们都是以 B+\n树的形式保存在系统表空间的某个页面中。其中\nSYS_TABLES、SYS_COLUMNS、SYS_INDEXES、SYS_FIELDS\n这四个表尤其重要，称之为基本系统表 (basic system tables)。\n注意：用户不能直接访问 InnoDB\n的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库\ninformation_schema 中提供了一些以 innodb_sys\n开头的表:\nUSE information_schema;\nSHOW TABLES LIKE 'innodb_sys%';\n在 information_scheme 数据库中的这些以\nINNODB_SYS 开头的表并不是真正的内部系统表\n(内部系统表就是我们上边以 SYS\n开头的那些表)，而是在存储引擎启动时读取这些以 SYS\n开头的系统表，然后填充到这些以 INNODB_SYS 开头的表中。以\nINNODB_SYS 开头的表和以 SYS\n开头的表中的字段并不完全一样，但仅供大家参考已经足矣。\n","categories":["Database","InnoDB"],"tags":["InnoDB"]},{"title":"Graph Algorithm","url":"/2023/01/05/Graph-Algorithm/","content":"图论的常见算法与应用，涵盖图的存储结构、图的遍历、拓扑排序、最小生成树（Kruskal\n和\nPrim）、最短路径算法（Floyd、Dijkstra、Bellman-Ford、SPFA、Johnson）等。还涉及分层图、差分约束、二分图、欧拉图及树相关算法，如\nLCA、树的直径、重构树和树链剖分等。\n\n存储结构\n\n邻接矩阵\n\n无脑存\nint[][] g = new int[n][m];for (int i = 0;i &lt; n;i++)for (int j = 0;j &lt; m;j++)  ...\n\n邻接表\n\nList&lt;Integer&gt;[] g = new List[; //List&lt;int[]&gt;[] g;可以存边权等附加信息。for (int i = 0;i &lt; n; i++) g[i] = new ArrayList&lt;&gt;(); //千万别忘for (int i = 0;i &lt; n;i++){ for (int v : g[i]) ...}\n\n链式前向星\n\nclass E{    // 边的终点 下一条边在edge中的编号 边的权值    int to, ne, wt;    E(int t, int n, int w){to = t;ne = n;wt = w;}    E(int t, int n){to = t;ne = n;}}E[] edge = new E[m]; //如果是无向图 new E[m*2]要开两倍int[] hd = new int[n]; //hd[i]：顶点i为起点的第一条边void add(int u, int v, int idx){    edge[idx] = new E(v, hd[v]);// 存边u-&gt;v    hd[u] = idx;}for (int i = hd[v];i != 0;i = edge[i].ne){int u = edge[i].to;...}\n\n图的遍历\n\n没啥好说的 与树遍历差别在于图遍历需要 visited[]数组\n考虑到图可能不连通，需要对每一个点进行扫描\n\nfor (int i = 0;i &lt; n;i++){    if (!vis[i]) DFS(i) //或BFS(i)}\nDFS\nvoid dfs(int u) {    vis[u] = 1;    for (int i = head[u]; i; i = e[i].x) {        if (!vis[e[i].t]) {            dfs(v);        }    }}\nBFS\nvoid bfs(int u) {    Q.push(u);    vis[u] = 1;    while (!Q.empty()) {        u = Q.front();Q.pop();        for (int i = head[u]; i; i = e[i].next) {            if (!vis[e[i].to]) {                Q.push(e[i].to);                vis[e[i].to] = 1;            }        }    }}\n\n拓扑排序\n前提：有向无环图（DAG）\n核心：维护入度为 0 的顶点集合\nList&lt;Integer&gt;[] g = new List[N];int[] indeg = new int[N]; //入度List&lt;Integerres; //拓扑排序结果for (int i = 0;i &lt; m;i++){    int u, v;    indeg[v]++;    g[u].add(v);}Deque&lt;Integerq = new LinkedList&lt;&gt;();for (int i = 1;i &lt;= n;i++) if (indeg[i] == 0) q.offerLast(i);while (!q.isEmpty()){    int u = q.pollFirst();    res.add(u);    for (int v : g[u]){        if (--indeg[v] == 0) q.offerLast(v);    }}if (res.size() == n) // DAG 可以拓扑排序else // 无法拓扑排序\n\n求字典序最大/最小的拓扑排序\n将算法中的队列替换成最大堆/最小堆实现的优先队列即可,此时总的时间复杂度为\nO(E + Vlog V)\n。\n\n\n最小生成树\nKruskal（优先使用）\npublic int kruskal(int n, int[][] edges){    //用堆代替边集数组排序    PriorityQueue&lt;int[]g = new PriorityQueue&lt;&gt;((o1, o2) -o1[2] - o2[2]);    Collections.addAll(g, edges);    int ans = 0, cnt = 0;    while (cnt != n-1){        int[] e = g.poll();        int v = find(e[0]), u = find(e[1]);        if ( v != u ){            union(u, v);            ans += e[2];            cnt++;        }    }    return ans; //最小总权值}// ...省略并查集操作\n\nO(mlog m)\n\nPrim\npublic int primHeap(int n, int[][] edges) {    int res = 0;    //邻接表存图（适用边较少，稀疏图） &lt;顶点v,[]{顶点u, 距离}&gt;    List&lt;List&lt;int[]&gt;g = new ArrayList&lt;&gt;();    for (int i = 0;i &lt; n;i++) g.add(new ArrayList&lt;&gt;());    for (int[] e : edges){        g.get(e[0]).add(new int[]{e[1], e[2]});        g.get(e[1]).add(new int[]{e[0], e[2]});    }    int[] vis = new int[n];    PriorityQueue&lt;int[]q = new PriorityQueue&lt;&gt;((o1,o2)-&gt;o1[1]-o2[1]);    q.offer(new int[]{0,0}); //从第0个节点开始构造    while (n 0){        int[] cur = q.poll();        if (vis[cur[0]] == 1) continue;        vis[cur[0]] = 1;        res += cur[1];        --n;        for (int[] p : g.get(cur[0])){            q.offer(new int[]{p[0], p[1]});        }    }    return res;}\n\nO((m + n)log n)\n\n\n最短路\n\n性质\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。\n对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。\n对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数  &lt;  = n，边数  &lt;  = n − 1。\n\nFloyd\n求任意两个结点之间的最短路的。\n适用于任何图，不管有向无向，边权正负，但是最短路必须存在。（==不能有个负环==）\nfor (k = 1; k &lt;= n; k++) {    for (x = 1; x &lt;= n; x++) {        for (y = 1; y &lt;= n; y++) {                f[x][y] = min(f[x][y], f[x][k] + f[k][y]); //每次以k为中转点（动态规划）        }    }}\n\nf[x][k]+f[k][y]==可能会爆 int==。\n\nDijkstra\n对于边 (u, v)\n，松弛操作对应下面的式子： dis (v) = min (dis (v), dis (u) + w(u, v))\n。\n非负权图 上单源最短路径的算法。\nint[] dijkstra (int n, int k){  int[] vis = new int[n+1], dis = new int[n+1];  Arrays.fill(dis,0x3f3f3f3f);  dis[k] = 0; //k为源点  for (int t = 1;t &lt;= n;t++){      int minidx = -1;      for (int i = 1;i &lt;= n;i++){          if (vis[i]==0 &amp;&amp; (minidx==-1||dis[i]&lt;dis[minidx])) minidx = i;      }      vis[minidx] = 1;      for (int[] e : g[minidx]){          int v = e[0], w = e[1];          dis[v] = Math.min(dis[v], dis[minidx]+w);      }  }  return dis;}\nvector&lt;int&gt; dis(n, 0), vis(n, 0);function&lt;void(int)&gt; dijkstra = [&amp;](int u){    dis.assign(n, 1e9), vis.assign(n, 0);    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;    pq.push({0, u});    dis[u] = 0;    while (pq.size()){        int cur = pq.top().second; pq.pop();         if (vis[cur] == 1) continue;        for (vector&lt;int&gt;&amp; e : g[cur]){            int v = e[0], w = e[1];            if (dis[v] &gt; dis[cur]+w){                dis[v] = dis[cur]+w;                pq.push({dis[v], v});            }        }    }};\n时间复杂度\n\n暴力：O(n2 + m) = O(n2)\n优先队列：O(mlog m)\n在稀疏图中，m = O(n)，优先队列；\n在稠密图中，m = O(n2)，暴力。\n\nBellman-Ford\nBellman-Ford\n算法所做的，就是不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。\n在最短路存在的情况下，由于一次松弛操作会使最短路的边数至少+1 ，而最短路的边数最多为n − 1 ，因此整个算法最多执行n − 1\n轮松弛操作。故总时间复杂度为O(mn) 。\n但还有一种情况，如果从S\n点出发，抵达一个负环时，松弛操作会无休止地进行下去。因此如果第 n轮循环时仍然存在能松弛的边，说明从\nS点出发，能够抵达一个负环。\n需要注意的是，以 点为源点跑 Bellman-Ford\n算法时，如果没有给出存在负环的结果，只能说明从 S点出发不能抵达一个负环，而不能说明图上不存在负环。\n因此如果需要判断整个图上是否存在负环，最严谨的做法是建立一个超级源点，向图上每个节点连一条权值为\n0 的边，然后以超级源点为起点执行 Bellman-Ford 算法。\nint[] bellman(int n, int k){    int[] dis = new int[n+1];    Arrays.fill(dis, 0x3f3f3f3f)    dis[k] = 0;    for (int t = 1 ; t &lt;= n-1;t++){        int flag = 1;// 如果此次循环没有边更新 说明松弛提前结束        //对每条边进行遍历更新        for (int[] e : g){            int u = e[0], v = e[1], w = e[2];            if (dis[v] dis[u]+w) {                dis[v] = dis[u]+w;                flag = 0;            }        }        if (flag == 1) break;    }    boolean exist = true;//判断是否有负环    for (int[] e : g){        int u = e[0], v = e[1], w = e[2];        if (dis[v] dis[u]+w) {            exist = false;break;        }    }    return exist ? dis:new int[]{};}\nSPFA\npublic int[] spfa(int n, int k) {\tboolean exist = true;\tint[] cnt = new int[n+1];//用于判断负环(一个节点至多加入队列n-1次 反之存在负环)//vis判断该节点是否在队列中（访问过后出队列 vis[i]=0）//跟其他算法不同（其他算法大都表示有没有访问过该元素）    for (int i = 1;i &lt;= n;i++) h[i] = INF;    Deque&lt;Integerq = new LinkedList&lt;&gt;();    q.offerLast(k);cnt[k]++;vis[k] = 1;h[k] = 0;    while (!q.isEmpty() &amp;&amp; !exist){        int v = q.pollFirst();vis[v] = 0;        for (int i = hd[v];i != 0;i = edge[i].ne){            int u = edge[i].to, w = edge[i].wt;            if (h[u] &lt; h[v]+w){                h[u] = h[v]+w;                if (vis[u] == 1) continue;                q.offerLast(u);cnt[u]++;vis[u]=1;                if (cnt[u]==n+1) exist = true;            }        }    }\treturn exist?dis:new int[]{};}\nJohnson 全源最短路径\n我们新建一个虚拟节点（在这里我们就设它的编号为 0\n）。从这个点向其他所有点连一条边权为 0 的边。 接下来用\nBellman-Ford(SPFA) 算法求出从 0 号点到其他所有点的最短路，记为 hi 。\n假如存在一条从 u 点到 v 点，边权为 w 的边，则我们将该边的边权重新设置为\nw + hu − hv\n。 接下来以每个点为起点，跑 n\n轮 Dijkstra 算法即可求出任意两点间的最短路了。 一开始的 Bellman-Ford\n算法并不是时间上的瓶颈，若使用 priority_queue 实现 Dijkstra 算法，\n该算法的时间复杂度是 O(nmlog m)\n。\npublic class Main{    static int n, m, N = 5010, M = 9010, INF = 0x3f3f3f3f;    static E[] edge = new E[M];// 链式前向星存图    static int[] hd = new int[N], vis = new int[N];    static int[] dis = new int[N],h = new int[N];    public static void main(String[] args) throws IOException {        for (int i = 1;i &lt;= m;i++) add(i, u, v, w);        for (int i = 1;i &lt;= n;i++) add(m+i, 0, i, 0); //超级源点0 到其他点距离都为0        int tp = SPFA(0); //此时图里一共有n+1个点 要松弛n次（不是n-1）        if (tp == -1){            System.out.println(-1); return; //有负环 寄        }        for (int i= 1;i &lt;= n;i++)        for (int k = hd[i];k !=0;k = edge[k].ne)            edge[k].wt += h[i]-h[edge[k].to]; //w+h[u]-h[v] 更新权值        for (int i = 1;i &lt;= n;i++){            dijkstra(i);// 每个点跑一遍最短路            for (int k = 1;k &lt;= n;k++){                if (dis[k] == INF) System.out.println(INF);                //把之前加的权值减去就是实际最短路长度                else System.out.println(dis[k]-h[i]+h[k]);            }        }    }    private static void dijkstra(int k) {...}    private static int SPFA(int k) {...}}\n0-1 最短路\n0-1BFS 用来解决：边权值为 0 或\n1，或者能够转化为这种边权值的最短路问题，时间复杂度 O( NM\n)。\n主要操作：用 deque，从 0 边扩展到的点 push 到队首，反之则到队尾。\n==不需要 vis[]数组==\nint[] dis = new int[n*m];Arrays.fill(dis, 1 &lt;&lt; 30);Deque&lt;int[]pq = new LinkedList&lt;&gt;();pq.add(new int[]{0, 0}); dis[0] = 0;while (!pq.isEmpty()){    int[] cur = pq.pollFirst();    int u = cur[0];    for (int v : g[u]){        int p = grid[x][y], nd = dis[u]+p;        if (nd &lt; dis[v]){            dis[v] = nd;            if (p == 0) pq.offerFirst(new int[]{nd, v}); //边为0 加入队首            else pq.offerLast(new int[]{nd, v}); //边为1 加入队尾        }    }}\n不同方法的比较\n\n\n\n\n\n\n\n\n\n\nBellman-Ford\n最短路算法\nFloyd\nDijkstra\nJohnson\n\n\n\n\n单源最短路\n最短路类型\n每对结点间的最短路\n单源最短路\n每对结点间的最短路\n\n\n任意图\n作用于\n任意图\n非负权图\n任意图\n\n\n能\n能否检测负环？\n能\n不能\n能\n\n\n中/小\n作用图的大小\n小\n大/中\n大/中\n\n\nO(NM)\n时间复杂度\nO(N3)\nO((M + N)log M)\nO(NMlog M)\n\n\n\n注：表中的 Dijkstra 算法在计算复杂度时均用\npriority_queue 实现。\n分层图最短路\n分层图最短路，如：有 k\n次零代价通过一条路径，求总的最小花费。对于这种题目，我们可以采 用 DP\n相关的思想，设 disi, j\n表示当前从起点 i\n号结点，使用了 j\n次免费通行权限后的最短路径。 显然，dis 数组可以这么转移:\ndisi, j = min {min {disfrom, j − 1}, min {disfrom, j + w}}\n其中， from 表示 i\n的父亲节点， w\n表示当前所走的边的边权。当 j − 1 ≥ k 时， disfrom, j = ∞\n。 事实上，这个 DP 就相当于把每个结点拆分成了 k + 1\n个结点，每个新结点代表使用不同多次免费\n通行后到达的原图结点。换句话说，就是每个结点 ui 表示使用\ni 次免费通行权限后到达 u 结点。\nP4568 [JLOI2011]\n飞行路线 - 洛谷 | 计算机科学教育新生态\nstatic int test, N = 10010, M = (int)1e9+7;static int n, m, k;static List&lt;int[]&gt;[] g = new List[N];static int[][] dis = new int[N][11], vis = new int[N][11];static void solve() throws Exception {    n = ni(); m = ni(); k = ni();    int s = ni(), t = ni();    for (int i = 0;i &lt; n;i++){        g[i] = new ArrayList&lt;&gt;();        Arrays.fill(dis[i], M);    }    for (int i = 1;i &lt;= m;i++){        int u = ni(), v = ni(), w = ni();        g[u].add(new int[]{v, w});        g[v].add(new int[]{u, w});    }    PriorityQueue&lt;int[]pq = new PriorityQueue&lt;&gt;((x, y)-&gt;        x[2]==y[2] ? x[1]-y[1] : x[2]-y[2]    );    pq.add(new int[]{s, 0, 0}); dis[s][0] = 0;    while (!pq.isEmpty()){        int[] cur = pq.poll();        int u = cur[0], c = cur[1], d = cur[2];        if (vis[u][c] == 1) continue;        vis[u][c] = 1;        for (int[] ne : g[u]){            int v = ne[0], w = ne[1];            if (dis[v][c] d+w){                dis[v][c] = d+w;                pq.add(new int[]{v, c, dis[v][c]});            }            if (c+1 &lt;= k &amp;&amp; dis[v][c+1] d){                dis[v][c+1] = d;                pq.add(new int[]{v, c+1, dis[v][c+1]});            }        }    }    int ans = M;    for (int i = 0;i &lt;= k;i++) ans = min(ans, dis[t][i]);    pw.println(ans);}\n\n差分约束（不等式）\n差分约束系统 是一种特殊的 n\n元一次不等式组，它包含 n\n个变量 x1, x2, …, xn\n以及 m\n个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 xi − xj ≤ ck\n，其中1 ≤ i, j ≤ n, i ≠ j, 1 ≤ k ≤ m\n并且 ck\n是常数（可以是非负数，也可以是负数）。\n我们要解决的问题是: 求解 x1 = a1, x2 = a2, …, xn = an\n，使得所有约束条件得到满足，否则无解。\n差分约束系统中的每个约束条件 xi − xj ≤ ck\n都可以变形成 xi ≤ xj + ck\n，这与单源最短路中 的三角形不等式 dist [y] ≤ dist [x] + z\n非常相似。因此，我们可以把每个变量 xi 看做图中的一\n个结点，对于每个约束条件 xi − xj ≤ ck\n，从结点 j 向结点 i 连一条长度为 ck\n的有向边。\n注意到，如果 {a1, a2, …, an}\n是该差分约束系统的一组解，那么对于任意的常数 d ， {a1 + d, a2 + d, …, an + d}\n显然也是该差分约束系统的一组解，因为这样做差后 d 刚好被消掉。\n设 dist [0] = 0\n并向每一个点连一条权重为 0\n边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解；否则， xi = dist [i]\n为该差分约束系统的一组解。即建立超级源点0后跑 SPFA.\n\n判断是否有解\n小 K\n的农场\n题目大意: 求解差分约束系统，有 m 条约束条件，每条都为形如 xa − xb ≥ ck\n， xa − xb ≤ ck\n或 xa = xb\n的形式，判断该差分约束系统有没有解。\n\n\n\n\n\n\n\n\n题意\n转化\n连边\n\n\n\n\nxa − xb ≥ ck\nxb − xa ≤ −c\nadd(a, b, -c);\n\n\nxa − xb ≤ ck\nxa − xb ≤ ck\nadd(b, a, c);\n\n\nxa = xb\nxa − xb ≤ 0, xb − xa ≤ 0\nadd(b, a, 0), add(a, b, 0);\n\n\n\n求最值解\n差分约束问题可以转化为最短路或最长路问题，所以两种转化也就形成了两种不同的连边方法。\n\n\n连边后求最短路 将 xj − xi ≤ k\n形式不动，即从 i 到 j 连一条边权为 k\n的边。==加入超级源点后求最短路，得到 xi ≤ 0 所有\nx 最大解==。\n连边后求最长路 将 xj − xi ≤ k\n变形为 xi − xj ≥ −k\n，即从 j 到 i 连一条边权为 −k 的边。==加入超级源点后求最长\n路，得到 xi ≥ 0 所有\nx 最小解==。\n\n\n最长路\n最长路问题即为在给定的图中，计算从源点到所有顶点的最长路。保证图中没有正环。\n其中一种实现方法为若 du + w &gt; dv，则将\ndv 更新为\ndu + w（实际上就是把最短路中的大于号改成小于号），并在初始化时将\ndis数组全部初始化为一个极小值（−INF），其余部分和用\nSPFA 求最短路一样。\n分糖果\n\n\n二分图\n\n定义 节点由两个集合组成，且两个集合内部没有边的图。\n性质\n如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。\n二分图不存在长度为奇数的环\n二分图判断\n染色法：首先将任意的一个顶点染成红色，再把这个点相邻的顶点染成蓝色，如果按照这种染色方式可以将所有的顶点全部着色，并且相邻的顶点的颜色不同，那么该图就是一个二分图。\n\nstatic boolean solve() {    for (int i = 1;i &lt;= n;i++){// 可能图不连通 要对每个点都判断一遍        if (color[i] == 0) {            if (!dfs(i, 1)) return false;        }    }    return true;}static boolean dfs(int v, int c){ // 0-未染色 1-白色 -1-黑色    color[v] = c;    for (int u : g[v]){    if (color[u] == c) return false;    if (color[u] == 0 &amp;&amp; !dfs(u, -c)) return false;    }    return true;}\n\n二分图最大匹配 求一个二分图中最大匹配的边数\n\nstatic int[] match = new int[N]; //match[u] = v 表示右集合中u点匹配的是左集合中的v点static int[] vis = new int[N];public static void main(String[] args) throws Exception{    // 对左集合中每个点进行匹配    for (int i = 1;i &lt;= n;i++) {        Arrays.fill(vis, 0); //每一次寻找中 每个点只能访问一次        if (find(i)) ++ans;    }    System.out.println(ans);}private static boolean find(int u) {    for (int v : g[u]) {    if (vis[v]==1) continue;        vis[v] = 1;        // 右集合中的点v没有匹配 || v匹配的左集合中的点match[v]可以再找到一个新的匹配            // 就可以让v成为u的匹配        if (match[v]==0 || find(match[v])) {        match[v] = u;        return true;        }    }    return false;}\n\n最小路径覆盖\n定义：通俗点将，就是在一个有向图中，找出最少的路径，使得这些路径经过了所有的点。\n最小路径覆盖分为最小不相交路径覆盖和最小可相交路径覆盖。\n最小不相交路径覆盖：每一条路径经过的顶点各不相同。如图，其最小路径覆盖数为\n3。即 1-&gt;3&gt;4，2，5。\n最小可相交路径覆盖：每一条路径经过的顶点可以相同。如果其最小路径覆盖数为\n2。即 1-&gt;3-&gt;4，2-&gt;3&gt;5。\n特别的，每个点自己也可以称为是路径覆盖，只不过路径的长度是\n0。\n\nKönig 定理: 一个二分图中的最大匹配数等于这个图中的最小点覆盖数\n最小路径覆盖数 =\n图中节点数 -\n最小点覆盖数\n（如果是最小可相交路径覆盖，只要求出原图的传递闭包，再新建一个图进行计算即可）\n2549. 估计人数\n- AcWing 题库\nstatic int[][] a = new int[22][22];static int[] v = new int[210], match = new int[210];static boolean[][] g = new boolean[210][210];// 二分图求最大匹配static boolean find(int u){    for (int i = 1;i &lt;= cnt;i++){        if (!g[u][i] || v[i]==1) continue;        v[i] = 1;        if (match[i]==0 || find(match[i])){            match[i] = u;            return true;        }    }return false;}static void solve() throws IOException{    io = in.readLine().split(\" \");    n = ni(io[0]); m = ni(io[1]);    for (int i = 0;i &lt; n;i++){        char[] c = in.readLine().toCharArray();        for (int j = 0;j &lt; m;j++){            if (c[j] == '1') a[i][j] = ++cnt;        }    }    // 按题目意思建图（无向图邻接矩阵）    for (int i = 0;i &lt; n;i++){        for (int j = 0;j &lt; m;j++){            if (a[i][j]*a[i][j+1] != 0) g[a[i][j]][a[i][j+1]] = true;            if (a[i][j]*a[i+1][j] != 0) g[a[i][j]][a[i+1][j]] = true;        }    }    // 这题求可相交，所以先跑以便Floyd求传递闭包。    for (int i = 1;i &lt;= cnt;i++){        for (int j = 1;j &lt;= cnt;j++){            for (int k = 1;k &lt;= cnt;k++){                g[i][j] |= g[i][k] &amp; g[k][j];            }        }    }    // 求最大匹配    for (int i = 1;i &lt;= cnt;i++){        Arrays.fill(v, 0);        if (find(i)) res++;    }    // 最小路径覆盖 = 节点数量 - 最小点覆盖    out.println(cnt-res);}\n\n欧拉图\n\n定义\n\n\n欧拉回路：通过图中每条边恰好一次的回路\n欧拉通路：通过图中每条边恰好一次的通路\n欧拉图：具有欧拉回路的图\n半欧拉图：具有欧拉通路但不具有欧拉回路的图\n\n\n判断\n\n无向图是欧拉图当且仅当：\n\n非零度顶点是连通的\n顶点的度数都是偶数 无向图是半欧拉图当且仅当：\n非零度顶点是连通的\n恰有 2 个奇度顶点 有向图是欧拉图当且仅当：\n非零度顶点是强连通的\n每个顶点的入度和出度相等\n有向图是半欧拉图当且仅当：\n非零度顶点是弱连通的\n仅有一个顶点的出度与入度之差为 1\n仅有一个顶点的出度与入度之差为 -1\n其他顶点的入度和出度相等\n\n\n求解\n\nstatic int n, m, idx;static int[] deg = new int[501], ans = new int[5001];static Deque&lt;Integer&gt;[] g = new Deque[501];static void dfs(int u){    Deque&lt;Integercur = g[u];    while (!cur.isEmpty()){        int v = cur.pollFirst();        g[v].remove(u);        dfs(v);    }    // 存路径    ans[idx++] = u;}static void solve() throws IOException{    m = ni();    for (int i = 1;i &lt;= 500;i++) g[i] = new LinkedList&lt;&gt;();    for (int i = 1;i &lt;= m;i++){        int u = ni(), v = ni();        // 无向图直接++；有向图起点--，终点++        deg[u]++; deg[v]++;        g[u].offerFirst(v); g[v].offerFirst(u);        n = max(n, max(u, v));    }    int start = 1;    for (int i = n;i &gt;= 1;i--){        // 如果有奇数度，则为半欧拉图，dfs起点必须从奇数度的那个节点开始        // 如果是有向图，dfs起点必须从度为-1的那个节点开始        if (deg[i]%2==1) start = i;        // 求字典序最小/最大的欧拉路，需要对边按题目要求进行排序        Collections.sort((List&lt;Integer&gt;)g[i]);    }    dfs(start);    // 路径倒着遍历    for (int i = idx-1;i &gt;= 0;i--) out.println(ans[i]);}\n树相关\n\nLCA\nLCA（Least Common Ancestors），是指在有根树中，找出某两个结点 u 和 v\n最近的公共祖先。\n\n核心：倍增 首先我们要记录各个点的深度和他们2j级的的祖先，用数组deep[i]表示每个节点的深度，f[i][j]表示节点i的2j级祖先。（例如上图 17\n的 1 级祖先是 14， 2 级是 10， 4 级是 3， 以此来推）\nfa[u][i] = fa[fa[u][i-1]][i-1]：f[i][j] 就是i的2j级祖先，那f[i][j − 1]就是i的2j − 1 级祖先。 又因为\n2j − 1 + 2j − 1 = 2j，所以i的 2j − 1 级祖先的2j − 1级祖先 就是i的2j 级祖先。\n\nstatic void dfs(int u, int f) { //u当前节点 f为父节点 搜索从根节点开始即dfs(root, 0)    deep[u] = deep[f]+1;    fa[u][0] = f; //u的2^0级祖先 即 u的1级祖先是其父节点    for (int i = 1;(1 &lt;&lt; i) &lt;= deep[u];i++){    \tfa[u][i] = fa[fa[u][i-1]][i-1];    }    for (int v : g[u]) if (v != f) dfs(v, u); //父节点不再访问}\nstatic int LCA(int u, int v) {    if (deep[u] deep[v]) {int tp = v;v = u;u = tp;} //让v的深度始终是大于u的    int dis = deep[v]-deep[u]; //深度差    //将u的深度变得与v相同    for (int i = 0;(1&lt;&lt;i) &lt;= dis;i++){        //快速加的意思 任意正整数都可以表示为几个2的幂次的和        if (((dis&gt;&gt;i) &amp; 1) == 1) v = fa[v][i];    }    if (u == v) return u;    for (int i = 19;i &gt;= 0;i--){        if (fa[u][i] != fa[v][i]){            u = fa[u][i];            v = fa[v][i];        }    }    return fa[u][0];}\n用欧拉序列转化为 RMQ 问题\n定义\n对一棵树进行\nDFS，无论是第一次访问还是回溯，每次到达一个结点时都将编号记录下来，可以得\n到一个长度为 2n − 1\n的序列，这个序列被称作这棵树的欧拉序列。\n在下文中，把结点 u\n在欧拉序列中第一次出现的位置编号记为 pos (u) （也称作节点 u 的欧拉 序)，把欧拉序列本身记作\nE[1...2n − 1] 。\n过程\n有了欧拉序列， LCA 问题可以在线性时间内转化为 RMQ 问题，即 pos (LCA(u, v)) = min {pos (k) ∣ k ∈ E[pos (u)..pos (v)]}\n。\n这个等式不难理解: 从 u 走到\nv 的过程中一定会经过 LCA(u, v)\n，但不会经过 LCA(u, v)\n的祖先。 因此，从 u 走到 v 的过程中经过的欧拉序最小的结点就是\nLCA(u, v)\n。\n用 DFS 计算欧拉序列的时间复杂度是 O(n) ，且欧拉序列的长度也是\nO(n) ，所以 LCA\n问题可以在 O(n)\n的时间内转化成等规模的 RMQ 问题。\n\n树的直径\n树上任意两节点之间最长的简单路径即为树的「直径」。\nstatic int n, m, ans;static List&lt;Integer&gt;[] g;static int[] d1, d2; // d1[i]存储节点i到叶子节点的最大距离 d2[i]存储节点i到叶子节点的第二大距离static void solve() throws Exception{    dfs(1, 0);    out.println(ans);}static void dfs(int u, int f){    d1[u] = d2[u] = 0;    for (int v : g[u]){        if (v == f) continue;        dfs(v, u);        int t = d1[v]+1;        if (t d1[u]){            d2[u] = d1[u]; d1[u] = t;        }else if (t d2[u]){            d2[u] = t;        }    }    ans = max(ans, d1[u]+d2[u]);}\nKruskal 重构树\n设 fi\n为 i 所在联通块的根。\n算法流程和 Kruskal 最小生成树的过程非常类似:\n\n将所有边按边权从小到大排序\n顺序遍历每条边 (u, v, w) ，若\nu, v\n已经联通跳过，否则建立一个新点 x ，让 x 作为 fu 与 fv 的父亲（即连\nx ⇒ fu\n和 时间复杂度 O(mlog m + nlog n)\n。 最后，以最后一个建立的新点作为 rt\n，就是一颗重构树了（下面是一个无向图联通变成重构树的例子，排序后第 i 条边的编 号是 n + i\n，点权是红色，蓝色是新点，黑色是原来的点）。\n\n这棵树有如下性质：\n\n原树若有 n\n个节点，那么新树有 2n − 1\n个节点，根是 2n − 1\n。因为建的新点就是合并两个点的次数，合并 n − 1 次。最\n后一次合并作为根，凑成了整个树。\n所有原来的点就是叶子节点。因为建新图过程中我们没有让原来的点当父亲。\n对于任意的 x 点，\n它的祖先链从下往上点权都是非严格递增的。因为每次合并的时候，只有  ≤ w 的边都构造好了，所以此时 fu 的点权也\n ≤ w。\n因此重构树的点权是一个大根堆。跟上一个性质的等价的。\n对于一个 x 和一个值\nv 。从 x 出发只经过  ≤ v 的边能到达的点集  = x 的祖先节点中深度最小的点权\n ≤ v 的点 z 的子树中的\n原来的点集。（证明：这颗子树外的点显然不行，因为再往上点权  &gt; v ，说明再往上其他的点使通过\n &gt; v 的边才和 x 点连上\n的，所以不行；这颗子树内的点显然可以，因为这是一个大根堆，所以子树内的点都可以用\n ≤ v 的边互相可达，他们在新树\n上的路径，经过的所有编号就是原树上经过的所有边。\n对于任意 x, y\n，其最小瓶颈边权 (使其最大边最小的路径的最大边) 为 x, y 在新树上的 LCA 点权。\nx, y 在经过 LCA\n这条边 后恰好联通，由于从小到大顺序执行，说明这条边是路径上最大的边。\n如果求最大生成树，反着排序，那么偏序关系都反转，就不赘述了。\n\nfor (int i = 0;i &lt; m;i++){    int u = ni(), v = ni(), w = ni();    e[i][0] = u; e[i][1] = v; e[i][2] = w;}Arrays.sort(e, 0, m, (x, y)-&gt;y[2]-x[2]);int cur = n;for (int i = 0;i &lt; m;i++){    int u = e[i][0], v= e[i][1], w = e[i][2];    int x = find(u), y = find(v);    if (x != y){        ++cur;        fa[x] = fa[y] = cur;        g[cur].add(x); g[cur].add(y);        val[cur] = w;    }}\n\n树上差分\n树上差分有什么作用？举个例子，如果题目要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数，树上差分就可以派上用场了。这就是树上差分的基本操作。\n树上差分，就是利用差分的性质，对路径上的重要节点进行修改（而不是暴力全改），作为其差分数组的值，最后在求值时，利用\ndfs 遍历求出差分数组的前缀和，就可以达到降低复杂度的目的。\n点差分\n设将两点 u,v 之间路径上的所有点权增加 x，o=LCA(u,v),o 的父亲节点为\np，则操作如下：\ndiff[u]+=x,diff[v]+=x,diff[o]-=x,diff[p]-=x;\n这样，只要 dfs\n一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点的最终权值！\n是不是很厉害\n就是差分的思想，这里就不多说了。 边差分\n思想一样，讲一下操作。\n设将两点 u,v 之间路径上的所有边权增加\nx，o=LCA(u,v)，以每条边两端深度较大的节点存储该边的差分数组，则操作如下：\ndiff[u]+=x,diff[v]+=x,diff[o]-=2*x;\n同样地，只要 dfs\n一遍，遍历时统计以每个节点为根的树的节点的权值和，就是当前节点到父亲节点的边的最终权值了！\nstatic void cal(int u, int fa) throws Exception{    dep[u] = dep[fa]+1;    f[u][0] = fa;    for (int i = 1;(1&lt;&lt;i) &lt;= dep[u];i++) f[u][i] = f[f[u][i-1]][i-1];    for (int[] t : g[u]){        int v = t[0], idx = t[1];        if (v == fa) continue;        cal(v, u);        e[v] = idx; //以深度更大的点代表这条边    }}for (int i = 1;i &lt; n;i++){    int u = ni(), v = ni();    //建图把边的编号记录下来    g[u].add(new int[]{v, i});    g[v].add(new int[]{u, i});}\n\n树链剖分\n先来回顾两个问题：\n\n将树从 x 到 y 结点最短路径上所有节点的值都加上 z\n这也是个模板题了吧\n我们很容易想到，树上差分可以以\nO(n+m)的优秀复杂度解决这个问题\n求树从 x 到 y 结点最短路径上所有节点的值之和\nlca 大水题，我们又很容易地想到，dfs O(n)预处理每个节点的\ndis（即到根节点的最短路径长度）\n然后对于每个询问，求出 x,y 两点的 lca，利用 lca 的性质 distance\n(x,y)=dis(x)+dis(y)-2*dis(lca) 求出结果\n时间复杂度 O(mlogn+n)\n\n现在来思考一个 bug：\n如果刚才的两个问题结合起来，成为一道题的两种操作呢？\n刚才的方法显然就不够优秀了（每次询问之前要跑 dfs 更新 dis）\n\n树剖是通过轻重边剖分将树分割成多条链，然后利用数据结构来维护这些链（本质上是一种优化暴力）\n首先明确概念：\n\n重儿子：父亲节点的所有儿子中子树结点数目最多（size\n最大）的结点；\n轻儿子：父亲节点中除了重儿子以外的儿子；\n重边：父亲结点和重儿子连成的边；\n轻边：父亲节点和轻儿子连成的边；\n重链：由多条重边连接而成的路径；\n轻链：由多条轻边连接而成的路径；\n\n比如上面这幅图中，用黑线连接的结点都是重结点，其余均是轻结点，\n2-11 就是重链，2-5\n就是轻链，用红点标记的就是该结点所在重链的起点，也就是下文提到的 top\n结点，\n还有每条边的值其实是进行 dfs 时的执行序号。\n变量声明：\nstatic int n, m, root, time = 0;static long[] f = new long[N&lt;&lt;2], lazy = new long[N&lt;&lt;2];static int[] siz = new int[N], dep = new int[N], son = new int[N];static int[] dfn = new int[N], top = new int[N], faz = new int[N];static long[] w = new long[N], rk = new long[N];static List&lt;Integer&gt;[] g = new List[N];\ntime 时间戳\nroot 根节点\nf[u] 保存结点 u 的父亲节点\nd[u] 保存结点 u 的深度值\nsize[u] 保存以 u 为根的子树节点个数\nson[u] 保存重儿子\ntop[u] 保存当前节点所在链的顶端节点\ndfn[u] 保存树中每个节点剖分以后的新编号（DFS 序）\nrk[u] 保存当前 dfs 标号在树中所对应的节点的权值\n树链剖分的实现\n1，对于一个点我们首先求出它所在的子树大小,找到它的重儿子（即处理出\nsize,son 数组），\n解释:比如说点 1，它有三个儿子 2，3，4\n2 所在子树的大小是 5\n3 所在子树的大小是 2\n4 所在子树的大小是 6\n那么 1 的重儿子是 4\nps:如果一个点的多个儿子所在子树大小相等且最大\n那随便找一个当做它的重儿子就好了\n叶节点没有重儿子，非叶节点有且只有一个重儿子\n2，在 dfs 过程中顺便记录其父亲以及深度（即处理出 f,d\n数组），操作 1,2 可以通过一遍 dfs 完成\ndfs 跑完大概是这样的，大家可以手动模拟一下\n3，第二遍 dfs，然后连接重链，同时标记每一个节点的 dfs\n序，并且为了用数据结构来维护重链，我们在 dfs 时保证一条重链上各个节点\ndfs 序连续（即处理出数组 top,dfn,rk）\ndfs 跑完大概是这样的，大家可以手动模拟一下\n4，两遍 dfs 就是树链剖分的主要处理，通过 dfs\n我们已经保证一条重链上各个节点 dfs\n序连续，那么可以想到，我们可以通过数据结构（以线段树为例）来维护一条重链的信息\n回顾上文的那个题目，修改和查询操作原理是类似的，以查询操作为例，其实就是个\nLCA，不过这里使用了 top 来进行加速，因为 top\n可以直接跳转到该重链的起始结点，轻链没有起始结点之说，他们的 top\n就是自己。需要注意的是，每次循环只能跳一次，并且让结点深的那个来跳到 top\n的位置，避免两个一起跳从而插肩而过。\nwhile (top[u] != top[v]){    if (dep[top[u]] &lt; dep[top[v]]) {int tp = u;u = v;v = tp;}    upd(1, 1, n, dfn[top[u]], dfn[u], val);    u = faz[top[u]];}if (dep[u] dep[v]) {int tp = u;u = v;v = tp;}upd(1, 1, n, dfn[u], dfn[v], val);\n5，树链剖分的时间复杂度\n树链剖分的两个性质：\n1，如果(u,v)是一条轻边，那么 size(v)&lt;size(u)/2；\n2，从根结点到任意结点的路所经过的轻重链的个数必定都小于 logn；\n可以证明，树链剖分的时间复杂度为\nP3384\n【模板】重链剖分/树链剖分 - 洛谷 | 计算机科学教育新生态\npublic class Main {    static String ss, io[];    static int test, N = 100010, M = 1000000007;    static int n, m, root, time = 0;    static long[] f = new long[N&lt;&lt;2], lazy = new long[N&lt;&lt;2];    static int[] siz = new int[N], dep = new int[N], son = new int[N];    static int[] dfn = new int[N], top = new int[N], faz = new int[N];    static long[] w = new long[N], rk = new long[N];    static List&lt;Integer&gt;[] g = new List[N];    //===================================线段树==============================================    static void up(int k){        f[k] = f[k*2]+f[k*2+1]; f[k] %= M;    }    static void down(int k, int l, int m, int r){        if (lazy[k] == 0) return;        f[k*2] += lazy[k]*(m-l+1); f[k*2] %= M;        f[k*2+1] += lazy[k]*(r-m); f[k*2+1] %= M;        lazy[k*2] += lazy[k]; lazy[k*2] %= M;        lazy[k*2+1] += lazy[k]; lazy[k*2+1] %= M;        lazy[k] = 0;    }    static void build(int k, int l, int r){        if (l == r){            f[k] = rk[l]%M;            return;        }        int mid = l+r &gt;1;        build(k*2, l, mid);        build(k*2+1, mid+1, r);        up(k);    }    static void upd(int k, int l, int r, int s, int t, long val){        if (s &lt;= l &amp;&amp; r &lt;= t){            f[k] += (r-l+1)*val; f[k] %= M;            lazy[k] += val; lazy[k] %= M;            return;        }        int mid = l+r &gt;1;        down(k, l, mid, r);        if (s &lt;= mid) upd(k*2, l, mid, s, t, val);        if (t mid) upd(k*2+1, mid+1, r, s, t, val);        up(k);    }    static long qry(int k, int l, int r, int s, int t){        if (s &lt;= l &amp;&amp; r &lt;= t) return f[k];        int mid = l+r &gt;1;        long res = 0;        down(k, l, mid, r);        if (s &lt;= mid) res = (res+qry(k*2, l, mid, s, t))%M;        if (t mid) res = (res+qry(k*2+1, mid+1, r, s, t))%M;        up(k);        return res;    }    static void dfs(int u, int fa, int depth){        dep[u] = depth; faz[u] = fa;        siz[u] = 1; son[u] = 0;        for (int v : g[u]){            if (v == fa) continue;            dfs(v, u, depth+1);            siz[u] += siz[v];            if (siz[v] siz[son[u]]) son[u] = v;        }    }    static void dfs1(int u, int topf){        dfn[u] = ++time; rk[time] = w[u];        top[u] = topf;        if (son[u] == 0) return;        dfs1(son[u], topf);        for (int v : g[u]){            if (v == faz[u] || v == son[u]) continue;            dfs1(v, v);        }    }    //================================查询和更新任意两个节点==================================    static void upd2(int u, int v, long val){        while (top[u] != top[v]){            if (dep[top[u]] &lt; dep[top[v]]) {int tp = u;u = v;v = tp;}            upd(1, 1, n, dfn[top[u]], dfn[u], val);            u = faz[top[u]];        }        if (dep[u] dep[v]) {int tp = u;u = v;v = tp;}        upd(1, 1, n, dfn[u], dfn[v], val);    }    static void qry2(int u, int v){        long res = 0;        while (top[u] != top[v]){            if (dep[top[u]] &lt; dep[top[v]]) {int tp = u;u = v;v = tp;}            res = (res+qry(1, 1, n, dfn[top[u]], dfn[u]))%M;            u = faz[top[u]];        }        if (dep[u] dep[v]) {int tp = u;u = v;v = tp;}        res = (res+qry(1, 1, n, dfn[u], dfn[v]))%M;        out.println(res);    }    //================================查询和更新一个子树==================================    //此时不涉及树链剖分，跑一遍dfs序，建立线段树即可。    static void upd1(int u, long val){        upd(1, 1, n, dfn[u], dfn[u]+siz[u]-1, val);    }    static void qry1(int u){        out.println(qry(1, 1, n, dfn[u], dfn[u]+siz[u]-1));    }    static void solve() throws Exception{        n = ni(); m = ni(); root = ni(); M = ni();        for (int i = 1;i &lt;= n;i++){            g[i] = new ArrayList&lt;&gt;();            w[i] = ni();        }        for (int i = 2;i &lt;= n;i++){            int u = ni(), v = ni();            g[u].add(v); g[v].add(u);        }        dfs(root, 0, 1);        dfs1(root, root);        build(1, 1, n);        for (int i = 1;i &lt;= m;i++){            int op = ni();            if (op == 1) upd2(ni(), ni(), nl()%M);            else if (op == 2) qry2(ni(), ni());            else if (op == 3) upd1(ni(), nl()%M);            else qry1(ni());        }    }}\n","categories":["Algorithm","Template"],"tags":["Template","Graph"]},{"title":"Javascript 基础","url":"/2023/12/12/Javascript-%E5%9F%BA%E7%A1%80/","content":"基础和常用的知识点\n\n反引号\nlet name = \"John\";// 嵌入一个变量alert( `Hello, ${name}!` ); // Hello, John!// 嵌入一个表达式alert( `the result is ${1 + 2}` ); // the result is 3\n类型转换\nlet apples = \"2\";let oranges = \"3\";// 在二元运算符加号起作用之前，所有的值都被转化为了数字alert( +apples + +oranges ); // 5// 更长的写法// alert( Number(apples) + Number(oranges) ); // 5\n??运算符\na ?? b == (a !== null &amp;&amp; a !== undefined) ? a :\nb;\nlet firstName = null;let lastName = null;let nickName = \"Supercoder\";// 显示第一个真值：alert(firstName || lastName || nickName || \"Anonymous\"); // Supercoder\n函数\n回调函数\nfunction ask(question, yes, no) {  if (confirm(question)) yes()  else no();}// 1function showOk() {  alert( \"You agreed.\" );}function showCancel() {  alert( \"You canceled the execution.\" );}ask(\"Do you agree?\", showOk, showCancel);// 2ask(  \"Do you agree?\",  function() { alert(\"You agreed.\"); },  function() { alert(\"You canceled the execution.\"); });\n箭头函数\nlet func = (arg1, arg2, ..., argN) =&gt; expression;let func = function(arg1, arg2, ..., argN) {  return expression;};let double = n =&gt; n * 2;// let double = function(n) { return n * 2; }let sum = (a, b) =&gt; a + b;// let sum = function(a, b) { return a + b; };let sum = (a, b) =&gt; {  // 花括号表示开始一个多行函数  let result = a + b;  return result; };// 如果我们使用了花括号，那么我们需要一个显式的 “return”\n可选链\n\nobj?.prop —— 如果 obj 存在则返回\nobj.prop，否则返回 undefined。\nobj?.[prop] —— 如果 obj 存在则返回\nobj[prop]，否则返回 undefined。\nobj.method?.() —— 如果 obj.method\n存在则调用 obj.method()，否则返回\nundefined。\n\n对象类型\nlet user = {  name: \"json\",  sex: \"male\"};\n对象中所有key的类型均是字符串或Symbol\n\nuser.age = 1:\n“.”访问方式中的key默认就是一个字符串。(age默认转成字符串”age”)\nuser[age] = 1 or user[“age”]:\n“[]”访问方式中的key可以是一个变量，也可以是一个字符串；如果是变量，最终存储的key值即为该变量对应的值（如果该变量值不是字符串，会被强制转为字符串）。\n\n对象强制类型转换\n依次自动尝试对象中以下存在的方法：\n[Symbol.toPrimitive]\nobj[Symbol.toPrimitive] = function(hint) {  // 这里是将此对象转换为原始值的代码  // 它必须返回一个原始值  // hint 为 \"string\"、\"number\" 或 \"default\" 中的一个  // 除了Date对象，所有hint=default调用默认使用hint=number的方法}let user = {  name: \"John\",  money: 1000,  [Symbol.toPrimitive](hint) {    alert(`hint: ${hint}`);    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;  }};// 转换演示：alert(user); // hint: string -&gt; {name: \"John\"}alert(+user); // hint: number -&gt; 1000alert(user + 500); // hint: default -&gt; 1500\ntoString/valueOf\nlet user = {name: \"John\"};alert(user); // [object Object]alert(user.valueOf() === user); // truelet user = {  name: \"John\",  money: 1000,  // 对于 hint=\"string\"  toString() {    return `{name: \"${this.name}\"}`;  },  // 对于 hint=\"number\" 或 \"default\"  valueOf() {    return this.money;  }};alert(user); // toString -&gt; {name: \"John\"}alert(+user); // valueOf -&gt; 1000alert(user + 500); // valueOf -&gt; 1500\n内建对象比较方法\n有一个特殊的内建方法 Object.is，它类似于\n=== 一样对值进行比较，但它对于两种边缘情况更可靠：\n\n它适用于\nNaN：Object.is(NaN, NaN) === true，这是件好事。\n值 0 和 -0\n是不同的：Object.is(0, -0) === false，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。\n\n在所有其他情况下，Object.is(a, b) 与\na === b 相同。\n","categories":["前端","Javascript"],"tags":["Javascript,Basic"]},{"title":"JDBC 实践","url":"/2024/06/29/JDBC-%E5%AE%9E%E8%B7%B5/","content":"JDBC 核心功能与实践技巧全解析，涵盖数据库连接管理、PreparedStatement\n与 Statement 的对比、事务控制、转账案例实现及 Druid\n连接池的配置与优化，助力高效构建 Java\n数据访问层并提升数据库操作性能。\n\n1 JDBC概念\njdbc概念总结\n\njdbc是(Java Database\nConnectivity)单词的缩写,翻译为java连接数据库\njdbc是java程序连接数据库的技术统称\njdbc由java语言的规范(接口)和各个数据库厂商的实现驱动(jar)组成\njdbc是一种典型的面向接口编程\njdbc优势\n\n只需要学习jdbc规范接口的方法,即可操作所有的数据库软件\n项目中期切换数据库软件,只需要更换对应的数据库驱动jar包,不需要更改代码\n\n\n2 JDBC API使用\nDriverManager获取连接；接着建立连接；PreparedStatement（最常用）发送sql语句；若是查询操作，则对应的查询结果放在Result中。\n\nDriverManager\n\n将第三方数据库厂商的实现驱动jar注册到程序中\n可以根据数据库连接信息获取connection\n\nConnection [建立连接]\n\n和数据库建立的连接,在连接对象上,可以多次执行数据库curd动作\n可以获取statement和 preparedstatement,callablestatement对象\n\nStatement【适用静态sql路线 没有动态值的】 |\nPreparedStatement【预编译sql 有动态值语句】 |\nCallableStatement\n\n具体发送SQL语句到数据库管理软件的对象\n不同发送方式稍有不同! preparedstatement\n使用为重点!\n\nResult【对查询语句才有】（查询的结果）\n\n面向对象思维的产物(抽象成数据库的查询结果表)\n存储DQL查询数据库结果的对象\n需要我们进行解析,获取具体的数据库数据\n\n\n具体步骤如下：\n\n注册驱动【依赖的jar包 进行安装】\n获取连接【connection建立连接】\n创建发送sql语句对象【statement 创建发送sql语句的statement】\n发送sql语句，并获取返回结果【statement发送sql语句到数据库\n并且取得返回结构】\n结果集解析【将result结果解析出来】\n资源关闭【释放resultset、statement、connection】\n\n基于statement\npublic static void main(String[] args) throws SQLException {    // 注册驱动 使用mysql的驱动    DriverManager.registerDriver(new Driver());    // 连接指定数据库    Connection connection = DriverManager.getConnection(\"jdbc:mysql://192.168.74.131:3306/test\",                                                        \"root\",                                                        \"root1234\");    // 通过statement创建sql语句    Statement statement = connection.createStatement();    String sql = \"select id,account,password,nickname from t_user ;\";    // 执行并获取结果    ResultSet resultSet =  statement.executeQuery(sql);    while (resultSet.next()){        int id = resultSet.getInt(\"id\");        String account = resultSet.getString(\"account\");        String password = resultSet.getString(\"password\");        String nickname = resultSet.getString(\"nickname\");        System.out.println(id+\"::\"+account+\"::\"+password+\"::\"+nickname);    }    // 依次关闭资源    resultSet.close();    statement.close();    connection.close();}\n模拟账户登陆\npublic class JdbcStatementLoginPart {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        //1.输入账号和密码        Scanner scanner = new Scanner(System.in);        String account = scanner.nextLine();        String password = scanner.nextLine();        scanner.close();        //2.jdbc的查询使用        /**         * 类加载： java文件 -&gt; 编译 -&gt; 【 class字节码文件 --&gt;  类加载 --&gt; jvm虚拟中  --&gt; Class对象】         * 类加载具体步骤：  加载 【class文件转成对象加载到虚拟机中】-&gt;         *                连接 【验证（检查类文件） -&gt; 准备 (静态变量赋默认值) -&gt; 解析 (调用静态代码块) 】 -&gt;         *                初始化 -&gt; (赋真实值)         * 以下7种方式会触发类加载：         *\tnew指令：程序创建一个类的实例对象时         * \tgetstatic指令：当程序访问类的静态变量时         *  putstatic指令：当程序给静态变量赋值时         *\tinvokestatic指令：当程序调用静态方法时 注：程序访问类的静态常量不会触发类加载机制         *    1. new关键字         *    2. 调用静态属性         *    3. 调用静态方法         *    4. 接口 包含1.8 新特性 default关键字         *    5. 反射 【Class.forName() 类名.class】         *    6. 子类调用会触发父类的静态代码块         *    7. 触发类的入口方法main         */        \t\t\t//new Driver() 类静态代码块会注册一次驱动 要避免重复注册        //1:DriverManager.registerDriver(new Driver());调用两次。不用        //2:new Driver()  频繁修改不优雅        //注册一次驱动 方法三        Class.forName(\"com.mysql.cj.jdbc.Driver\");        /**获取数据库连接         * 重写： 为了子类扩展父类的方法！父类也间接的规范了子类方法的参数和返回！         * 重载： 重载一般应用在第三方的工具类上，为了方便用户多种方式传递参数形式！简化形式！         */        /**         * 三个参数：         *    String URL: 连接数据库地址         *    String user: 连接数据库用户名         *    String password: 连接数据库用户对应的密码         * 数据库URL语法：         *    JDBC:         *        ip port         *        jdbc:mysql | jdbc:oracle :// 127.0.0.1 | localhost : 3306 / 数据库名         *        jdbc:mysql://localhost:3306/day01         *        192.168.33.45         *        jdbc:mysql://192.168.33.45/3306/day01         *        当前电脑的省略写法！ 注意：本机和端口3306         *        jdbc:mysql://localhost:3306/day01 = jdbc:mysql:///day01         *         * 两个参数：         *     String URL : 写法还是jdbc的路径写法！         *     Properties : 就是一个参数封装容器！至少要包含 user / password key!存储连接账号信息！         *         * 一个参数：         *    String URL: URl可以携带目标地址，可以通过?分割，在后面key=value&amp;key=value形式传递参数         *                jdbc:mysql:///day01?user=root&amp;password=123456         * 扩展路径参数(了解):              *    8.0.25以后，自动识别时区 serverTimezone=Asia/Shanghai 不用添加              *    8版本以后， 默认使用utf-8格式, useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true 不用添加              *    serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true         */        //获取连接        Connection connection = DriverManager.getConnection(\"jdbc:mysql:///atguigu\", \"root\", \"root\");        //固定方法固定剂        //创建statement        Statement statement = connection.createStatement();        //执行SQL语句 [动态SQL语句,需要字符串拼接]        String sql = \"select * from t_user where account = '\"+account+\"' and password = '\"+password+\"' ;\";        /**         *  sql分类： DDL(容器创建,修改,删除) DML(插入,修改,删除) DQL(查询) DCL(权限控制) TPL(事务控制)         *  ResultSet 结果集对象 = executeQuery(DQL语句)         *  int响应行数  = executeUpdate(非DQL语句)         */        ResultSet resultSet = statement.executeQuery(sql);        //ResultSet == 小海豚  你必须有面向对象的思维：Java是面向对象编程的语言 OOP！        /**         *         * TODO:1.需要理解ResultSet的数据结构和小海豚查询出来的是一样，需要在脑子里构建结果表！         * TODO:2.有一个光标指向的操作数据行，默认指向第一行的上边！我们需要移动光标，指向行，在获取列即可！         *        boolean = next()         *              false: 没有数据，也不移动了！         *              true:  有更多行，并且移动到下一行！         *       推荐：推荐使用if 或者 while循环，嵌套next方法，循环和判断体内获取数据！         *       if(next()){获取列的数据！} ||  while(next()){获取列的数据！}         *         *TODO：3.获取当前行列的数据！         *         get类型(int columnIndex | String columnLabel)         *        列名获取  //lable 如果没有别名，等于列名， 有别名label就是别名，他就是查询结果的标识！         *        列的角标  //从左到右 从1开始！ 数据库全是从1开始！         */        //进行结果集对象解析        if (resultSet.next()){            //只要向下移动，就是有数据 就是登录成功！            System.out.println(\"登录成功！\");        }else{            System.out.println(\"登录失败！\");        }        //关闭资源        resultSet.close();        statement.close();        connection.close();    }}\n存在问题\n\nSQL语句需要字符串拼接,比较麻烦（示例代码在：执行SQL语句\n[动态SQL语句,需要字符串拼接]）\n只能拼接字符串类型,其他的数据库类型无法处理\n可能发生注入攻击\n\n动态值充当了SQL语句结构,影响了原有的查询结果!\n\n\n基于PreparedStatement\npublic class JdbcPreparedStatementLoginPart {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        //1.输入账号和密码        Scanner scanner = new Scanner(System.in);        String account = scanner.nextLine();        String password = scanner.nextLine();        scanner.close();        //2.jdbc的查询使用        //注册驱动        Class.forName(\"com.mysql.cj.jdbc.Driver\");        //获取连接        Connection connection = DriverManager.getConnection(\"jdbc:mysql:///atguigu\", \"root\", \"root\");        //创建preparedStatement        //connection.createStatement();        //TODO 需要传入SQL语句结构        //TODO 要的是SQL语句结构，动态值的部分使用 ? ,  占位符！        //TODO ?  不能加 '?'  ? 只能替代值，不能替代关键字和容器名        String sql = \"select * from t_user where account = ? and password = ? ;\";        PreparedStatement preparedStatement = connection.prepareStatement(sql);        //占位符赋值        //给占位符赋值！ 从左到右，从1开始！        /**         *  int 占位符的下角标         *  object 占位符的值         */        preparedStatement.setObject(2,password);        preparedStatement.setObject(1,account);        //这哥们内部完成SQL语句拼接！        //执行SQL语句即可        ResultSet resultSet = preparedStatement.executeQuery();        //preparedStatement.executeUpdate()        //进行结果集对象解析        if (resultSet.next()){            //只要向下移动，就是有数据 就是登录成功！            System.out.println(\"登录成功！\");        }else{            System.out.println(\"登录失败！\");        }        //关闭资源        resultSet.close();        preparedStatement.close();        connection.close();    }}\n使用总结\n//1.注册驱动方案1: 调用静态方法,但是会注册两次DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());方案2: 反射触发Class.forName(\"com.mysql.cj.jdbc.Driver\");//2.获取连接Connection connection = DriverManager.getConnection();3 (String url,String user,String password)2 (String url,Properties info(user password))1 (String url?user=账号&amp;password=密码 )//3.创建statement//静态Statement statement = connection.createStatement();//预编译PreparedStatement preparedstatement = connection.preparedStatement(sql语句结构);//4.占位符赋值preparedstatement.setObject(?的位置从左向右从1开始,?的值)//5.发送sql语句获取结果int rows = executeUpdate(); //非DQLResultset = executeQuery(); //DQL//6.查询结果集解析//移动光标指向行数据 next();  if(next())  while(next())//获取列的数据即可   get类型(列的下标 从1开始 | 别名或列名)//获取列的信息   getMetadata(); ResultsetMetaData对象 包含的就是列的信息                getColumnCount(); //列的数量                getCloumnLebal(index); //列的别名，没有别名直接取列名//7.关闭资源close(); \n3 全新JDBC扩展提升\n自增长主键回显\n/** * 返回插入的主键！ * 主键：数据库帮助维护的自增长的整数主键！ * @throws Exception */@Testpublic void  returnPrimaryKey() throws Exception{    //1.注册驱动    Class.forName(\"com.mysql.cj.jdbc.Driver\");    //2.获取连接    Connection connection = DriverManager.getConnection(                          \"jdbc:mysql:///atguigu?user=root&amp;password=root\");    //3.编写SQL语句结构    String sql = \"insert into t_user (account,password,nickname) values (?,?,?);\";    //4.创建预编译的statement，传入SQL语句结构    /**     * TODO: 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS     *       告诉statement携带回数据库生成的主键！     */    PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);    //5.占位符赋值    statement.setObject(1,\"towgog\");    statement.setObject(2,\"123456\");    statement.setObject(3,\"二狗子\");    //6.执行SQL语句 【注意：不需要传入SQL语句】 DML    int i = statement.executeUpdate();    //7.结果集解析    System.out.println(\"i = \" + i);    //一行一列的数据！里面就装主键值！固定用getGeneratedKeys    ResultSet resultSet = statement.getGeneratedKeys();    resultSet.next();    int anInt = resultSet.getInt(1);//指向第一列    System.out.println(\"anInt = \" + anInt);    //8.释放资源    statement.close();    connection.close();}\n批量插入数据\n/** *改动了三处：（1）路径（2）必写values，且后面不加;（3）装货addBatch()最后executeBatch(); * 批量细节： *    1.url?rewriteBatchedStatements=true *    2.insert 语句必须使用 values *    3.语句后面不能添加分号; *    4.语句不能直接执行，每次需要装货  addBatch() 最后 executeBatch(); * * 批量插入优化！ * @throws Exception */@Testpublic void  batchInsertYH() throws Exception{    //1.注册驱动    Class.forName(\"com.mysql.cj.jdbc.Driver\");    //2.获取连接    Connection connection = DriverManager.getConnection          (\"jdbc:mysql:///atguigu?rewriteBatchedStatements=true\",\"root\",\"root\");    //3.编写SQL语句结构    String sql = \"insert into t_user (account,password,nickname) values (?,?,?)\";    //4.创建预编译的statement，传入SQL语句结构    /**     * TODO: 第二个参数填入 1 | Statement.RETURN_GENERATED_KEYS     *       告诉statement携带回数据库生成的主键！     */    long start = System.currentTimeMillis();    PreparedStatement statement = connection.prepareStatement(sql);    for (int i = 0; i &lt; 10000; i++) {        //5.占位符赋值        statement.setObject(1,\"ergouzi\"+i);        statement.setObject(2,\"lvdandan\");        statement.setObject(3,\"驴蛋蛋\"+i);        //6.装车        statement.addBatch();    }    //发车！ 批量操作！    statement.executeBatch();    long end = System.currentTimeMillis();    System.out.println(\"消耗时间：\"+(end - start));    //7.结果集解析    //8.释放资源    connection.close();}\n事务实现\n// 事务概念   数据库事务就是一种SQL语句执行的缓存机制,不会单条执行完毕就更新数据库数据,最终根据缓   存内的多条语句执行结果统一判定!   一个事务内所有语句都成功及事务成功,我们可以触发commit提交事务来结束事务,更新数据!   一个事务内任意一条语句失败,及事务失败,我们可以触发rollback回滚结束事务,   数据回到事务之前状态!      举个例子:            临近高考,你好吃懒做,偶尔还瞎花钱,父母也只会说'你等着!',待到高考完毕!           成绩600+,翻篇,庆祝!           成绩200+,翻旧账,男女混合双打!           //优势   允许我们在失败情况下,数据回归到业务之前的状态!    //场景   **一个业务****涉及****多条修改****数据库语句!**   例如: 经典的转账案例,转账业务(加钱和减钱)            批量删除(涉及多个删除)         批量添加(涉及多个插入)              // 事务特性  1. 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，  要么都不发生。   2. 一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。  3. 隔离性（Isolation）事务的隔离性是指一个事务的执行不能被其他事务干扰，  即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。  4. 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，  接下来的其他操作和数据库故障不应该对其有任何影响// 事务类型    自动提交 : 每条语句自动存储一个事务中,执行成功自动提交,执行失败自动回滚! (MySQL)  手动提交:  手动开启事务,添加语句,手动提交或者手动回滚即可!  // sql开启事务方式【事务都在一个连接中】   针对自动提交: 关闭自动提交即可,多条语句添加以后,最终手动提交或者回滚! (推荐)           SET autocommit = off; //关闭当前连接connection自动事务提交方式      # 只有当前连接有效      # 编写SQL语句即可      SQL      SQL      SQL      #手动提交或者回滚 【结束当前的事务】      COMMIT / ROLLBACK ;          手动开启事务: 开启事务代码,添加SQL语句,事务提交或者事务回滚! (不推荐)// 呼应jdbc技术   try{    connection.setAutoCommit(false); //关闭自动提交了    //connection.setAutoCommit(false)也就类型于SET autocommit = off        //注意,只要当前connection对象,进行数据库操作,都不会自动提交事务    //数据库动作!    //statement - 单一的数据库动作 c u r d     //connection - 操作事务         connection.commit();  }catch(Execption e){    connection.rollback();  }\n\n数据库表数据\n\n-- 继续在atguigu的库中创建银行表CREATE TABLE t_bank(   id INT PRIMARY KEY AUTO_INCREMENT COMMENT '账号主键',   account VARCHAR(20) NOT NULL UNIQUE COMMENT '账号',   money  INT UNSIGNED COMMENT '金额,不能为负值') ;   INSERT INTO t_bank(account,money) VALUES  ('ergouzi',1000),('lvdandan',1000);\n\njdbc事务实现\n\n测试类\n\n\n/** * @Author 赵伟风 * Description: 测试类 */public class BankTest {    @Test    public void testBank() throws Exception {        BankService bankService = new BankService();        bankService.transfer(\"ergouzi\", \"lvdandan\",                500);    }}\n\nBankService\n\n/** * @Author 赵伟风 * Description: bank表业务类,添加转账业务 */public class BankService {//一个事物最基本的是在同一个连接中connection，一个转账方法是一个事物，将connection传入dao//实现层即可，dao层不用关闭connection，由事物统一关闭    /**     * 转账业务方法     * @param addAccount  加钱账号     * @param subAccount  减钱账号     * @param money  金额     */    public void transfer(String addAccount,String subAccount, int money) throws ClassNotFoundException, SQLException {        System.out.println(\"addAccount = \" + addAccount + \", subAccount = \" + subAccount + \", money = \" + money);        //注册驱动        Class.forName(\"com.mysql.cj.jdbc.Driver\");        //获取连接        Connection connection = DriverManager.getConnection                                (\"jdbc:mysql:///atguigu\", \"root\", \"root\");        int flag = 0;        //利用try代码块,调用dao        try {            //开启事务(关闭事务自动提交)            connection.setAutoCommit(false);            BankDao bankDao = new BankDao();            //调用加钱 和 减钱            bankDao.addMoney(addAccount,money,connection);            System.out.println(\"--------------\");            bankDao.subMoney(subAccount,money,connection);            flag = 1;            //不报错,提交事务            connection.commit();        }catch (Exception e){            //报错回滚事务            connection.rollback();            throw e;        }finally {            connection.close();        }        if (flag == 1){            System.out.println(\"转账成功!\");        }else{            System.out.println(\"转账失败!\");        }    }}\n\nBankDao：具体操作方法\n\n/** * @Author 赵伟风 * Description: 数据库访问dao类 */public class BankDao {    /**     * 加钱方法     * @param account     * @param money     * @param connection 业务传递的connection和减钱是同一个! 才可以在一个事务中!     * @return 影响行数     */    public int addMoney(String account, int money,Connection connection) throws ClassNotFoundException, SQLException {        String sql = \"update t_bank set money = money + ? where account = ? ;\";        PreparedStatement preparedStatement = connection.prepareStatement(sql);        //占位符赋值        preparedStatement.setObject(1, money);        preparedStatement.setString(2, account);        //发送SQL语句        int rows = preparedStatement.executeUpdate();        //输出结果        System.out.println(\"加钱执行完毕!\");        //关闭资源close        preparedStatement.close();        return rows;    }    /**     * 减钱方法     * @param account     * @param money     * @param connection 业务传递的connection和加钱是同一个! 才可以在一个事务中!     * @return 影响行数     */    public int subMoney(String account, int money,Connection connection) throws ClassNotFoundException, SQLException {        String sql = \"update t_bank set money = money - ? where account = ? ;\";        PreparedStatement preparedStatement = connection.prepareStatement(sql);        //占位符赋值        preparedStatement.setObject(1, money);        preparedStatement.setString(2, account);        //发送SQL语句        int rows = preparedStatement.executeUpdate();        //输出结果        System.out.println(\"减钱执行完毕!\");        //关闭资源close        preparedStatement.close();        return rows;    }}\n4 国货之光Druid\n4.1连接性能消耗问题分析\n4.2 数据库连接池作用\n总结缺点:\n（1）不使用数据库连接池，每次都通过DriverManager获取新连接，用完直接抛弃断开，\n连接的利用率太低，太浪费。\n（2）对于数据库服务器来说，压力太大了。我们数据库服务器和Java程序对连接数也无法控制\n，很容易导致数据库服务器崩溃。\n我们就希望能管理连接。\n\n我们可以建立一个连接池，这个池中可以容纳一定数量的连接对象，一开始，\n我们可以先替用户先创建好一些连接对象，等用户要拿连接对象时，就直接从池中拿，\n不用新建了，这样也可以节省时间。然后用户用完后，放回去，别人可以接着用。\n可以提高连接的使用率。当池中的现有的连接都用完了，那么连接池可以向服务器申\n请新的连接放到池中。\n直到池中的连接达到“最大连接数”，就不能在申请新的连接了，如果没有拿到连接的用户只能等待。\n\n4.3市面常见连接池产品和对比\nJDBC 的数据库连接池使用\njavax.sql.DataSource接口进行规范,所有的第三方连接池都实现此接口,自行添加具体实现!也就是说,所有连接池获取连接的和回收连接方法都一样,不同的只有性能和扩展功能!\n\nDBCP\n是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG\nC3P0\n是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以\nProxool\n是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点\nDruid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool\n优点于一身 的数据库连接池,妥妥国货之光!!!!\n\n4.4国货之光 druid连接池使用\n\n记得导入druid工具类jar\n\n\n硬编码方式(了解,不推荐)\n\n/** * 创建druid连接池对象，使用硬编码进行核心参数设置！ *   必须参数： 账号 *             密码 *             url *             driverClass *   非必须参数： *           初始化个数 *           最大数量等等  不推荐设置 注意他要做的，注册驱动，获取连接，规定最大数量 直接使用代码设置连接池连接参数方式 */@Testpublic void druidHard() throws SQLException {   //1.连接池对象   DruidDataSource dataSource = new DruidDataSource();   //2.设置四个必须参数   dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");   dataSource.setUsername(\"root\");   dataSource.setPassword(\"root\");   dataSource.setUrl(\"jdbc:mysql:///day01\");   //非必须   dataSource.setInitialSize(5); 初始化数量   dataSource.setMaxActive(10); 最大数量      //3.获取连接   Connection connection = dataSource.getConnection();   // JDBC的步骤 正常curd   //4.回收连接   connection.close();}\n\n软编码方式\n\n外部配置存放在src/druid.properties\n# druid连接池需要的配置参数,key固定命名driverClassName=com.mysql.cj.jdbc.Driverusername=rootpassword=rooturl=jdbc:mysql:///atguigu\n\n\n/** * 不直接在java代码编写配置文件！ * 利用工厂模式，传入配置文件对象，创建连接池！ * @throws Exception */@Test//druid.properties直接放在src目录下public void druidSoft() throws Exception {    Properties properties = new Properties();    InputStream ips = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\");    properties.load(ips);    DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);}\n\ndruid配置(了解)\n\n\n\n\n\n\n\n\n\n配置\n缺省\n说明\n\n\n\n\nname\n\n配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。\n如果没有配置，将会生成一个名字，格式是：”DataSource-” +\nSystem.identityHashCode(this)\n\n\njdbcUrl\n\n连接数据库的url，不同数据库不一样。例如：mysql :\njdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto\n\n\nusername\n\n连接数据库的用户名\n\n\npassword\n\n连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter\n\n\ndriverClassName\n\n根据url自动识别\n这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)\n\n\ninitialSize\n0\n初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时\n\n\nmaxActive\n8\n最大连接池数量\n\n\nmaxIdle\n8\n已经不再使用，配置了也没效果\n\n\nminIdle\n\n最小连接池数量\n\n\nmaxWait\n\n获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。\n\n\npoolPreparedStatements\nfalse\n是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。\n\n\nmaxOpenPreparedStatements\n-1\n要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100\n\n\nvalidationQuery\n\n用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。\n\n\ntestOnBorrow\ntrue\n申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。\n\n\ntestOnReturn\nfalse\n归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能\n\n\ntestWhileIdle\nfalse\n建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。\n\n\ntimeBetweenEvictionRunsMillis\n\n有两个含义： 1) Destroy线程会检测连接的间隔时间 2)\ntestWhileIdle的判断依据，详细看testWhileIdle属性的说明\n\n\nnumTestsPerEvictionRun\n\n不再使用，一个DruidDataSource只支持一个EvictionRun\n\n\nminEvictableIdleTimeMillis\n\n\n\n\nconnectionInitSqls\n\n物理连接初始化的时候执行的sql\n\n\nexceptionSorter\n\n根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接\n\n\nfilters\n\n属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：\n监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall\n\n\nproxyFilters\n\n类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系\n\n\n\n5\n全新JDBC使用优化以及工具类封装\n过程：1.注册驱动 2.获取连接 3.编写SQL语句 4.创建statement\n5.占位符赋值 6.发送SQL语句 7.结果解析 8.回收资源\n下面v1.0和v2.0针对128进行封装\nBaseDao针对34567进行封装，进行增删改查\njdbc工具类封装v1.0\n\n我们封装一个工具类,内部包含连接池对象,同时对外提供连接的方法和回收连接的方法!\n\n外部配置文件\n位置: src/druid.properties\n# druid连接池需要的配置参数,key固定命名driverClassName=com.mysql.cj.jdbc.Driverusername=rootpassword=rooturl=jdbc:mysql:///atguigu\n工具类代码\nimport com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;public class JDBCToolsVersion1 {    private static DataSource ds;    static{//静态代码块，JDBCToolsVersion1类初始化执行        try {            Properties pro = new Properties();            pro.load(ClassLoader.getSystemResourceAsStream(\"druid.properties\"));            ds = DruidDataSourceFactory.createDataSource(pro);        } catch (Exception e) {            e.printStackTrace();        }    }    public static Connection getConnection() throws SQLException {        return ds.getConnection();//这么写，不能保证同一个线程，两次getConnection()得到的是同一个Connection对象                            //如果不能保证是同一个连接对象，就无法保证事务的管理    }    public static void free(Connection conn) throws SQLException {        conn.setAutoCommit(true);        conn.close();//还给连接池    }}\njdbc工具类封装v.2.0\n\n优化工具类v1.0版本,考虑事务的情况下!如何一个线程的不同方法获取同一个连接!\n\nThreadLocal的介绍：线程本地变量：为同一个线程存储共享变量JDK 1.2 的版本中就提供 java.lang.ThreadLocal，为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。通常用来在在多线程中管理共享数据库连接、Session等ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程对象中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值。\nv2.0版本工具类\nimport com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;//事物时，Service和dao属于同一线程，不用再传参数了/*这个工具类的作用就是用来给所有的SQL操作提供“连接”，和释放连接。这里使用ThreadLocal的目的是为了让同一个线程，在多个地方getConnection得到的是同一个连接。这里使用DataSource的目的是为了（1）限制服务器的连接的上限（2）连接的重用性等 */public class JDBCTools {    private static DataSource ds;    private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();    static{//静态代码块，JDBCToolsVersion1类初始化执行        try {            Properties pro = new Properties();            pro.load(ClassLoader.getSystemResourceAsStream(\"druid.properties\"));            ds = DruidDataSourceFactory.createDataSource(pro);        } catch (Exception e) {            e.printStackTrace();        }    }    public static Connection getConnection() throws SQLException {         Connection connection = tl.get();         if(connection  == null){//当前线程还没有拿过连接，就给它从数据库连接池拿一个             connection = ds.getConnection();             tl.set(connection);         }         return connection;    }    public static void free() throws SQLException {        Connection connection = tl.get();        if(connection != null){            tl.remove();            connection.setAutoCommit(true);//避免还给数据库连接池的连接不是自动提交模式（建议）            connection.close();        }    }}\n高级应用层封装BaseDao\n\n基本上每一个数据表都应该有一个对应的DAO接口及其实现类，发现对所有表的操作（增、删、改、查）代码重复度很高，所以可以抽取公共代码，给这些DAO的实现类可以抽取一个公共的父类，我们称为BaseDao\n\n针对DQL查询和非DQL进行，分成两类\npublic abstract class BaseDao {    /*    通用的增、删、改的方法    String sql：sql    Object... args：给sql中的?设置的值列表，可以是0~n     */    protected int update(String sql,Object... args) throws SQLException {//        创建PreparedStatement对象，对sql预编译        Connection connection = JDBCTools.getConnection();        PreparedStatement ps = connection.prepareStatement(sql);        //设置?的值        if(args != null &amp;&amp; args.length&gt;0){            for(int i=0; i&lt;args.length; i++) {                ps.setObject(i+1, args[i]);//?的编号从1开始，不是从0开始，数组的下标是从0开始            }        }        //执行sql        int len = ps.executeUpdate();        ps.close();        //这里检查下是否开启事务,开启不关闭连接,业务方法关闭!        //connection.getAutoCommit()为false，不要在这里回收connection,由开启事务的地方回收        //connection.getAutoCommit()为true，正常回收连接        //没有开启事务的话,直接回收关闭即可!        if (connection.getAutoCommit()) {            //回收            JDBCTools.free();        }        return len;    }    /*    通用的查询多个Javabean对象的方法，例如：多个员工对象，多个部门对象等    这里的clazz接收的是T类型的Class对象，    如果查询员工信息，clazz代表Employee.class，    如果查询部门信息，clazz代表Department.class，    返回List&lt;T&gt; list     */    protected &lt;T&gt; ArrayList&lt;T&gt; query(Class&lt;T&gt; clazz,String sql, Object... args) throws Exception {        //        创建PreparedStatement对象，对sql预编译        Connection connection = JDBCTools.getConnection();        PreparedStatement ps = connection.prepareStatement(sql);        //设置?的值        if(args != null &amp;&amp; args.length&gt;0){            for(int i=0; i&lt;args.length; i++) {                ps.setObject(i+1, args[i]);//?的编号从1开始，不是从0开始，数组的下标是从0开始            }        }        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();        ResultSet res = ps.executeQuery();        /*        获取结果集的元数据对象。        元数据对象中有该结果集一共有几列、列名称是什么等信息         */         ResultSetMetaData metaData = res.getMetaData();        int columnCount = metaData.getColumnCount();//获取结果集列数        //遍历结果集ResultSet，把查询结果中的一条一条记录，变成一个一个T 对象，放到list中。        while(res.next()){            //循环一次代表有一行，代表有一个T对象            T t = clazz.newInstance();//要求这个类型必须有公共的无参构造            //把这条记录的每一个单元格的值取出来，设置到t对象对应的属性中。            for(int i=1; i&lt;=columnCount; i++){                //for循环一次，代表取某一行的1个单元格的值                Object value = res.getObject(i);                //这个值应该是t对象的某个属性值                //获取该属性对应的Field对象                //String columnName = metaData.getColumnName(i);//获取第i列的字段名                //这里再取别名可能没办法对应上                String columnName = metaData.getColumnLabel(i);//获取第i列的字段名或字段的别名                Field field = clazz.getDeclaredField(columnName);                field.setAccessible(true);//这么做可以操作private的属性                field.set(t, value);            }            list.add(t);        }        res.close();        ps.close();        //这里检查下是否开启事务,开启不关闭连接,业务方法关闭!        //没有开启事务的话,直接回收关闭即可!        if (connection.getAutoCommit()) {            //回收            JDBCTools.free();        }        return list;    }    protected &lt;T&gt; T queryBean(Class&lt;T&gt; clazz,String sql, Object... args) throws Exception {        ArrayList&lt;T&gt; list = query(clazz, sql, args);        if(list == null || list.size() == 0){            return null;        }        return list.get(0);    }}\n","categories":["后端","Spring"],"tags":["JDBC","Persistence Layer"]},{"title":"Javascript 对象属性配置","url":"/2023/12/15/Javascript-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE/","content":"JavaScript 中对象属性的 writable、enumerable、configurable\n标志及其默认行为；演示属性描述符的获取与定义方法；简要说明 getter 和\nsetter 的用法及访问器属性的特点。\n\n属性标志\n对象属性（properties），除 value\n外，还有三个特殊的特性（attributes），也就是所谓的“标志”：\n\nwritable — 如果为\ntrue，则值可以被修改，否则它是只可读的。\nenumerable — 如果为\ntrue，则会被在循环中列出，否则不会被列出。\nconfigurable — 如果为\ntrue，则此属性可以被删除，这些特性也可以被修改，否则不可以。\n\nlet user = {  name: \"John\"};let descriptor = Object.getOwnPropertyDescriptor(user, 'name');alert( JSON.stringify(descriptor, null, 2 ) );/* 属性描述符：{  \"value\": \"John\",  \"writable\": true,  \"enumerable\": true,  \"configurable\": true}*/\nlet user = {};Object.defineProperty(user, \"name\", {  value: \"John\"});let descriptor = Object.getOwnPropertyDescriptor(user, 'name');alert( JSON.stringify(descriptor, null, 2 ) );/*{  \"value\": \"John\",  \"writable\": false,  \"enumerable\": false,  \"configurable\": false} */\n\n不提供标志，默认创建的标志都为false。\n请注意：configurable: false\n防止更改和删除属性标志，但是允许更改属性的值。\n对于不可配置的属性，我们可以将 writable: true 更改为\nfalse，从而防止其值被修改（以添加另一层保护）。\n\nObject.defineProperties(user, {  name: { value: \"John\", writable: false },  surname: { value: \"Smith\", writable: false },  // ...});\n通常，当我们克隆一个对象时，我们使用赋值的方式来复制属性，像这样：\nfor (let key in user) {  clone[key] = user[key]}\n……但是，这并不能复制标志。所以如果我们想要一个“更好”的克隆，那么\nObject.defineProperties 是首选。\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n另一个区别是 for..in 会忽略 symbol\n类型的和不可枚举的属性，但是\nObject.getOwnPropertyDescriptors 返回包含 symbol\n类型的和不可枚举的属性在内的 所有 属性描述符。\ngetter 和 setter\n访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用\nget 和 set 表示：\nlet user = {  name: \"John\",  surname: \"Smith\",  get fullName() {    return `${this.name} ${this.surname}`;  },  set fullName(value) {    [this.name, this.surname] = value.split(\" \");  }};// set fullName 将以给定值执行user.fullName = \"Alice Cooper\";alert(user.name); // Alicealert(user.surname); // Cooper\n\n从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式\n调用 user.fullName，我们正常\n读取 它：getter 在幕后运行。\n\n","categories":["前端","Javascript"],"tags":["Javascript"]},{"title":"Javascript 异步处理","url":"/2023/12/20/Javascript-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/","content":"JavaScript\n异步处理方法梳理，内容涵盖回调函数的基本用法与错误处理、Promise\n的创建与链式调用、常用 API 如 all、race、allSettled、any\n等使用方式，以及 async/await 的基本语法与典型示例。\n\n回调\nfunction loadScript(src, callback) {  let script = document.createElement('script');  script.src = src;  script.onload = () =&gt; callback(script);  document.head.append(script);}loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script =&gt; {  alert(`酷，脚本 ${script.src} 加载完成`);  alert( _ ); // _ 是所加载的脚本中声明的一个函数});\n这被称为“基于回调”的异步编程风格。异步执行某项功能的函数应该提供一个\ncallback\n参数用于在相应事件完成时调用。（译注：上面这个例子中的相应事件是指脚本加载）\n处理 Error\n在上述示例中，我们并没有考虑出现 error\n的情况。如果脚本加载失败怎么办？我们的回调应该能够对此作出反应。\nfunction loadScript(src, callback) {  let script = document.createElement('script');  script.src = src;  script.onload = () =&gt; callback(null, script);  script.onerror = () =&gt; callback(new Error(`Script load error for ${src}`));  document.head.append(script);}loadScript('/my/script.js', function(error, script) {  if (error) {    // 处理 error  } else {    // 脚本加载成功  }});\n加载成功时，它会调用 callback(null, script)，否则调用\ncallback(error)。\nPromise\nPromise 对象的构造器（constructor）语法如下：\nlet promise = new Promise(function(resolve, reject) {  // executor});\n传递给 new Promise 的函数被称为\nexecutor。当 new Promise 被创建，executor\n会自动运行。它包含最终应产出结果的生产者代码。\n它的参数 resolve 和 reject 是由 JavaScript\n自身提供的回调。我们的代码仅在 executor 的内部。\n当 executor\n获得了结果，无论是早还是晚都没关系，它应该调用以下回调之一：\n\nresolve(value) —— 如果任务成功完成并带有结果\nvalue。\nreject(error) —— 如果出现了 error，error\n即为 error 对象。\n\n由 new Promise 构造器返回的 promise\n对象具有以下内部属性：\n\nstate —— 最初是 \"pending\"，然后在\nresolve 被调用时变为 \"fulfilled\"，或者在\nreject 被调用时变为 \"rejected\"。\nresult —— 最初是 undefined，然后在\nresolve(value) 被调用时变为 value，或者在\nreject(error) 被调用时变为 error。\n\nlet promise = new Promise(function(resolve, reject) {  // 当 promise 被构造完成时，自动执行此函数  // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\"  setTimeout(() =&gt; resolve(\"done\"), 1000);});let promise = new Promise(function(resolve, reject) {  // 1 秒后发出工作已经被完成的信号，并带有 error  setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 1000);});\n\n只能有一个结果或一个error：第一次调用resolve或reject后，函数就执行结束了。\nstate 和 result\n都是内部的：无法直接访问。\n\nthen\npromise.then(  function(result) { /* handle a successful result */ },  function(error) { /* handle an error */ });\n.then 的第一个参数是一个函数，该函数将在 promise\nresolved 且接收到结果后执行。\n.then 的第二个参数也是一个函数，该函数将在 promise\nrejected 且接收到 error 信息后执行。\nlet promise = new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(\"done!\"), 1000);});// resolve 运行 .then 中的第一个函数promise.then(  result =&gt; alert(result), // 1 秒后显示 \"done!\"  error =&gt; alert(error) // 不运行);// ------------------------------------------------------let promise = new Promise(function(resolve, reject) {  setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 1000);});// reject 运行 .then 中的第二个函数promise.then(  result =&gt; alert(result), // 不运行  error =&gt; alert(error) // 1 秒后显示 \"Error: Whoops!\");\n\nthen中第一个函数必须是对successful处理，第二个是对error处理，不能调换。\n\ncatch\n如果我们只对 error 感兴趣，那么我们可以使用 null\n作为第一个参数：.then(null, errorHandlingFunction)。或者我们也可以使用\n.catch(errorHandlingFunction)，其实是一样的：\nlet promise = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; reject(new Error(\"Whoops!\")), 1000);});// .catch(f) 与 promise.then(null, f) 一样promise.catch(alert); // 1 秒后显示 \"Error: Whoops!\"\nfinally\nnew Promise((resolve, reject) =&gt; {  /* 做一些需要时间的事，之后调用可能会 resolve 也可能会 reject */})  // 在 promise 为 settled 时运行，无论成功与否  .finally(() =&gt; stop loading indicator)  // 所以，加载指示器（loading indicator）始终会在我们继续之前停止  .then(result =&gt; show result, err =&gt; show error)\n\nfinally不关心Promise结果\n\nPromise 链\nnew Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(1), 1000); // (*)}).then(function(result) { // (**)  alert(result); // 1  return result * 2;}).then(function(result) { // (***)  alert(result); // 2  return result * 2;}).then(function(result) {  alert(result); // 4  return result * 2;});\n它的想法是通过 .then 处理程序（handler）链进行传递\nresult。\n\n下面的不是链\nlet promise = new Promise(function(resolve, reject) {setTimeout(() =&gt; resolve(1), 1000);});promise.then(function(result) {alert(result); // 1return result * 2;});promise.then(function(result) {alert(result); // 1return result * 2;});promise.then(function(result) {alert(result); // 1return result * 2;});\n我们在这里所做的只是一个 promise 的几个处理程序。它们不会相互传递\nresult；相反，它们之间彼此独立运行处理任务。\n\n一个完整的例子\nfunction loadJson(url) {  return fetch(url)    .then(response =&gt; response.json());}function loadGithubUser(name) {  return loadJson(`https://api.github.com/users/${name}`);}function showAvatar(githubUser) {  return new Promise(function(resolve, reject) {    let img = document.createElement('img');    img.src = githubUser.avatar_url;    img.className = \"promise-avatar-example\";    document.body.append(img);    setTimeout(() =&gt; {      img.remove();      resolve(githubUser);    }, 3000);  });}// 使用它们：loadJson('/article/promise-chaining/user.json')  .then(user =&gt; loadGithubUser(user.name))  .then(showAvatar)  .then(githubUser =&gt; alert(`Finished showing ${githubUser.name}`));\npromise 进行错误处理\npromise 链在错误（error）处理中十分强大。当一个 promise 被 reject\n时，控制权将移交至最近的 rejection 处理程序。\nfetch('/article/promise-chaining/user.json')  .then(response =&gt; response.json())  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))  .then(response =&gt; response.json())  .then(githubUser =&gt; new Promise((resolve, reject) =&gt; {    let img = document.createElement('img');    img.src = githubUser.avatar_url;    img.className = \"promise-avatar-example\";    document.body.append(img);    setTimeout(() =&gt; {      img.remove();      resolve(githubUser);    }, 3000);  }))  .catch(error =&gt; alert(error.message));\n通常情况下，这样的 .catch\n根本不会被触发。但是如果上述任意一个 promise\nrejected（网络问题或者无效的 json 或其他），.catch\n就会捕获它。\n未处理的 rejection\n在浏览器中，我们可以使用 unhandledrejection\n事件来捕获这类 error：\nwindow.addEventListener('unhandledrejection', function(event) {  // 这个事件对象有两个特殊的属性：  alert(event.promise); // [object Promise] —— 生成该全局 error 的 promise  alert(event.reason); // Error: Whoops! —— 未处理的 error 对象});new Promise(function() {  throw new Error(\"Whoops!\");}); // 没有用来处理 error 的 catch\nPromise API 示例\nPromise.all\nlet names = ['iliakan', 'remy', 'jeresig'];let requests = names.map(name =&gt; fetch(`https://api.github.com/users/${name}`));Promise.all(requests)  .then(responses =&gt; {    // 所有响应都被成功 resolved    for(let response of responses) {      alert(`${response.url}: ${response.status}`); // 对应每个 url 都显示 200    }    return responses;  })  // 将响应数组映射（map）到 response.json() 数组中以读取它们的内容  .then(responses =&gt; Promise.all(responses.map(r =&gt; r.json())))  // 所有 JSON 结果都被解析：\"users\" 是它们的数组  .then(users =&gt; users.forEach(user =&gt; alert(user.name)));\n\n如果任意一个 promise 被 reject，由 Promise.all\n返回的 promise 就会立即 reject，并且带有的就是这个 error。\n\nPromise 类有 6 种静态方法：\n\nPromise.all(promises) —— 等待所有 promise 都 resolve\n时，返回存放它们结果的数组。如果给定的任意一个 promise 为\nreject，那么它就会变成 Promise.all 的 error，所有其他\npromise 的结果都会被忽略。\nPromise.allSettled(promises)（ES2020 新增方法）——\n等待所有 promise 都 settle\n时，并以包含以下内容的对象数组的形式返回它们的结果：\n\nstatus: \"fulfilled\" 或\n\"rejected\"\nvalue（如果 fulfilled）或 reason（如果\nrejected）。\n\nPromise.race(promises) —— 等待第一个 settle 的\npromise，并将其 result/error 作为结果返回。\nPromise.any(promises)（ES2021 新增方法）—— 等待第一个\nfulfilled 的 promise，并将其结果作为结果返回。如果所有 promise 都\nrejected，Promise.any 则会抛出 AggregateError\n错误类型的 error 实例。\nPromise.resolve(value) —— 使用给定 value 创建一个\nresolved 的 promise。\nPromise.reject(error) —— 使用给定 error 创建一个\nrejected 的 promise。\n\nasync/await\nasync function\n该函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的\npromise 中\nasync function f() {  return 1;   // 等价于  // return Promise.resolve(1);}f().then(alert); // 1\nawait\n等待特定的promise完成\nasync function f() {  let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(\"done!\"), 1000)  });  let result = await promise; // 等待，直到 promise resolve (*)  alert(result); // \"done!\"}f();\n非 async 函数中调用 async 函数\n如果我们尝试在非 async 函数中使用\nawait，则会报语法错误：\nfunction f() {  let promise = Promise.resolve(1);  let result = await promise; // Syntax error}\n只需要把 async 调用当作 promise 对待，并在它的后面加上\n.then 即可：\nasync function wait() {  await new Promise(resolve =&gt; setTimeout(resolve, 1000));  return 10;}function f() {  // 1 秒后显示 10  wait().then(result =&gt; alert(result));}f();\n","categories":["前端","Javascript"],"tags":["Javascript,Promise,async/await"]},{"title":"Javascript 数据类型","url":"/2023/12/14/Javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","content":"JavaScript\n数据类型与核心用法速览，涵盖原始类型包装、常用数据结构操作、对象转换及\nJSON 处理。\n\n原始类型对象\nlet str = \"Hello\";alert( str.toUpperCase() ); // HELLO\n很简单，对吧？以下是 str.toUpperCase()\n中实际发生的情况：\n\n字符串 str\n是一个原始值。因此，在访问其属性时，会创建一个包含字符串字面值的特殊对象，并且具有可用的方法，例如\ntoUpperCase()。\n该方法运行并返回一个新的字符串（由 alert 显示）。\n特殊对象被销毁，只留下原始值 str。\n\n即原始类型在调用方法时，会自动生成一个对象[String Number Boolean\nSymbol BigInt]。没有undefined和null\n数字\nMath对象\n与python，Java提供的API类似。\nMath.floorMath.ceilMath.round num.toFixed(precision)num.toString(radix)alert( parseInt('100px') ); // 100alert( parseFloat('12.5em') ); // 12.5alert( parseInt('12.3') ); // 12alert( parseFloat('12.3.4') ); // 12.3alert( parseInt('a123') ); // NaNalert( parseInt('0xff', 16) ); // 255alert( parseInt('ff', 16) ); // 255alert( parseInt('2n9c', 36) ); // 123456\nNumber对象\nlet num = 255;alert( num.toString(16) );  // ffalert( num.toString(2) );   // 11111111let num = 12.36;alert( num.toFixed(1) ); // \"12.4\"let num = 12.34;alert( num.toFixed(5) ); // \"12.34000\"，在结尾添加了 0，以达到小数点后五位\n字符串\nstr.codePointAt(pos)：返回在 pos 位置的字符代码。\nString.fromCodePoint(code)：通过数字 code 创建字符。\nstr.substring(start, end)\nstr.trim()： 删除字符串前后的空格。\nstr.repeat(n)：重复字符串 n 次。\n数组\n声明和初始化\nlet arr = new Array();let arr = [];let n = 1e5;// vector&lt;int&gt;(n, -1);let arr = new Array(n).fill(-1);\n负索引：\narr.at(i)\n\n如果 i &gt;= 0，则与 arr[i]\n完全相同。\n对于 i 为负数的情况，它则从数组的尾部向前数。\n\n添加/删除\n\npush 在末端添加一个元素\nshift 取出队列首端的一个元素\npop 从末端取出一个元素\nunshift 在队列首端加一个元素\n\npush 和 unshift\n方法都可以一次添加多个元素：\nlet fruits = [\"Apple\"];fruits.push(\"Orange\", \"Peach\");// 或者使用展开语法：...fruits.push(...[\"Orange\", \"Peach\"]);// [\"Apple\", \"Orange\", \"Peach\"]\nsplice\narr.splice(start[, deleteCount, elem1, ..., elemN])\n它从索引 start 开始修改 arr：删除\ndeleteCount 个元素并在当前位置插入\nelem1, ..., elemN。最后返回被删除的元素所组成的数组。\nlet arr = [\"I\", \"study\", \"JavaScript\", \"right\", \"now\"];// 删除数组的前三项，并使用其他内容代替它们let r = arr.splice(0, 3, \"dance\");alert( arr ) // [\"dance\", \"right\", \"now\"]alert( r ) // [\"I\", \"study\", \"JavaScript\"]\nslice\narr.slice([start], [end])\n数组赋值，与字符串切片类似。\nconcat\narr.concat(arg1, arg2...)let arr = [1, 2];// 从 arr、[3,4]、5 和 6 创建一个新数组alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n数组会被展开。\nforEach\narr.forEach(function(item, index, array) {  // ... do something with each item});\nfind\n与forEach类似，只传入一个参数时，默认传入的是item。\nlet result = arr.find(function(item, index, array) {  // 如果返回 true，则返回 item 并停止迭代  // 搜索不到，则返回 undefined});let users = [  {id: 1, name: \"John\"},  {id: 2, name: \"Pete\"},  {id: 3, name: \"Mary\"}];let user = users.find(item =&gt; item.id == 1);alert(user.name); // John\nfindIndex/findLastIndex\n与arr.find具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回-1。\nfilter\n语法与find大致相同，但是filter返回的是所有匹配元素组成的数组：\nlet results = arr.filter(function(item, index, array) {  // 如果 true item 被 push 到 results，迭代继续  // 如果什么都没找到，则返回空数组});\nmap\n对数组的每个元素都调用函数，并返回结果数组。\nlet result = arr.map(function(item, index, array) {  // 返回新值而不是当前元素})let lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item =&gt; item.length);alert(lengths); // 5,7,6\nsort\n默认会当成字符串类型排序。\n// 数字从小到大arr.sort( (a, b) =&gt; a - b );arr.sort( (a, b) =&gt; a &lt; b ? -1 : 1);\nArray.from(arrayLike, mapFn)\n将类数组或可迭代对象转换成数组。\nMap\n\nnew Map() —— 创建 map。\nmap.set(key, value) —— 根据键存储值。\nmap.get(key) —— 根据键来返回值，如果 map\n中不存在对应的 key，则返回 undefined。\nmap.has(key) —— 如果 key 存在则返回\ntrue，否则返回 false。\nmap.delete(key) —— 删除指定键的值。\nmap.clear() —— 清空 map。\nmap.size —— 返回当前元素个数。\nmap.forEach((value, key, map) =&gt; {}\n\nmap中的key类型可以是任意类型（不同于对象，key只能为str或Symbol）。\nlet map = new Map([  ['1',  'str1'],  [1,    'num1'],  [true, 'bool1']]);// 或者let obj = {  name: \"John\",  age: 30};let map = new Map(Object.entries(obj));\nSet\n\nnew Set(iterable) —— 创建一个\nset，如果提供了一个 iterable\n对象（通常是数组），将会从数组里面复制值到 set 中。\nset.add(value) —— 添加一个值，返回 set 本身\nset.delete(value) —— 删除值，如果 value\n在这个方法调用的时候存在则返回 true ，否则返回\nfalse。\nset.has(value) —— 如果 value 在 set\n中，返回 true，否则返回 false。\nset.clear() —— 清空 set。\nset.size —— 返回元素个数。\nset.forEach((value, valueAgain, set)=&gt;{}\n\n对象转换\n实现map，filter等功能。\nlet prices = {  banana: 1,  orange: 2,  meat: 4,};let doublePrices = Object.fromEntries(  // 将价格转换为数组，将每个键/值对映射为另一对  // 然后通过 fromEntries 再将结果转换为对象  Object.entries(prices).map(entry =&gt; [entry[0], entry[1] * 2]));\nJson\nJSON.stringify(value[, replacer,space])\nlet meetup = {  title: \"Conference\",  participants: [{name: \"John\"}, {name: \"Alice\"}],  place: \"aaa\" // meetup 引用了 room};x =  JSON.stringify(meetup, function replacer(key, value) {  return (key == 'place') ? undefined : value;});//'{\"title\":\"Conference\",\"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}]}'\nreplace:替换指定key对应的value（value为undefined的不显示在序列化结果中）。\nJSON.parse(str, [reviver])\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';let meetup = JSON.parse(str, function(key, value) {  if (key == 'date') return new Date(value);  return value;});alert( meetup.date.getDate() ); \n","categories":["前端","Javascript"],"tags":["Javascript,DataType"]},{"title":"Javascript 模块","url":"/2023/12/22/Javascript-%E6%A8%A1%E5%9D%97/","content":"JavaScript 模块机制详解，涵盖模块定义与作用域特性、export 与 import\n的多种用法、默认导出与命名导出、模块在浏览器环境中的加载行为、以及动态导入\nimport() 表达式的用法与应用场景。\n\n模块概念\n一个模块（module）就是一个文件。一个脚本就是一个模块。就这么简单。\n模块可以相互加载，并可以使用特殊的指令 export 和\nimport 来交换功能，从另一个模块调用一个模块的函数：\n\nexport\n关键字标记了可以从当前模块外部访问的变量和函数。\nimport 关键字允许从其他模块导入功能。\n\n模块特点\n\n始终使用 “use strict”\n模块级作用域\n\n每个模块都有自己的顶级作用域（top-level\nscope）。换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。\n只能通过export和import来实现。\n\n模块代码仅在第一次导入时被解析\n模块代码仅在第一次导入时被解析\nimport.meta\n包含关于当前模块的信息。\n它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的\nURL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。\n\n浏览器特定功能\n\n模块脚本是延迟的\n\n模块脚本 总是 被延迟的\n\n下载外部模块脚本 &lt;script type=\"module\" src=\"...\"&gt;\n不会阻塞 HTML 的处理，它们会与其他资源并行加载。\n模块脚本会等到 HTML 文档完全准备就绪（即使它们很小并且比 HTML\n加载速度更快），然后才会运行。\n保持脚本的相对顺序：在文档中排在前面的脚本先执行。\n\n例如：\n&lt;script type=\"module\"&gt;  alert(typeof button); // object：脚本可以“看见”下面的 button  // 因为模块是被延迟的（deferred，所以模块脚本会在整个页面加载完成后才运行&lt;/script&gt;相较于下面这个常规脚本：&lt;script&gt;  alert(typeof button); // button 为 undefined，脚本看不到下面的元素  // 常规脚本会立即运行，常规脚本的运行是在在处理页面的其余部分之前进行的&lt;/script&gt;&lt;button id=\"button\"&gt;Button&lt;/button&gt;\n导出和导入\n在声明前导出\n// 导出数组export let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];// 导出 const 声明的变量export const MODULES_BECAME_STANDARD_YEAR = 2015;// 导出类export class User {  constructor(name) {    this.name = name;  }}\n\n导出 class/function 后没有分号\n\n导出与声明分开\n// 📁 say.jsfunction sayHi(user) {  alert(`Hello, ${user}!`);}function sayBye(user) {  alert(`Bye, ${user}!`);}export {sayHi, sayBye}; // 导出变量列表\n也可以把 export 放在函数上面。\nImport*\n通常，我们把要导入的东西列在花括号 import {...}\n中，就像这样：\n// 📁 main.jsimport {sayHi, sayBye} from './say.js';sayHi('John'); // Hello, John!sayBye('John'); // Bye, John!\n但是如果有很多要导入的内容，我们可以使用\nimport * as &lt;obj&gt;\n将所有内容导入为一个对象，例如：\n// 📁 main.jsimport * as say from './say.js';say.sayHi('John');say.sayBye('John');\n\nimport和export都可以使用as来重命名\n\nExport default\n在实际中，主要有两种模块。\n\n包含库或函数包的模块，像上面的 say.js。\n声明单个实体的模块，例如模块 user.js 仅导出\nclass User。\n\n将 export default 放在要导出的实体前：\n// 📁 user.jsexport default class User { // 只需要添加 \"default\" 即可  constructor(name) {    this.name = name;  }}// 📁 main.jsimport User from './user.js'; // 不需要花括号 {User}，只需要写成 User 即可new User('John');\n每个文件应该只有一个 export default：\n\n\n\n命名的导出\n默认的导出\n\n\n\n\nexport class User {...}\nexport default class User {...}\n\n\nimport {User} from ...\nimport User from ...\n\n\n\n动态导入\nimport() 表达式\nimport(module) 表达式加载模块并返回一个 promise，该\npromise resolve\n为一个包含其所有导出的模块对象。我们可以在代码中的任意位置调用这个表达式。\n&lt;!doctype html&gt;&lt;script&gt;  async function load() {    let say = await import('./say.js');    say.hi(); // Hello!    say.bye(); // Bye!    say.default(); // Module loaded (export default)!  }&lt;/script&gt;&lt;button onclick=\"load()\"&gt;Click me&lt;/button&gt;\n\n动态导入在常规脚本中工作时，它们不需要\nscript type=\"module\".\nimport()\n看起来像一个函数调用，但它只是一种特殊语法，只是恰好使用了括号\n\n","categories":["前端","Javascript"],"tags":["Javascript,Module"]},{"title":"Javascript 类","url":"/2023/12/16/Javascript-%E7%B1%BB/","content":"Class\nJavaScript 中，类是一种函数\nclass User {  constructor(name) { this.name = name; }  sayHi() { alert(this.name); }}// 佐证：User 是一个函数alert(typeof User); // function\nclass User {...} 构造实际上做了如下的事儿：\n\n创建一个名为 User\n的函数，该函数成为类声明的结果。该函数的代码来自于\nconstructor\n方法（如果我们不编写这种方法，那么它就被假定为空）。\n存储类中的方法，例如 User.prototype 中的\nsayHi。\n\n类表达式\nlet User = class {  sayHi() {    alert(\"Hello\");  }};\n类似于命名函数表达式（Named Function\nExpressions），类表达式可能也应该有一个名字。\n如果类表达式有名字，那么该名字仅在类内部可见。\n类字段\n“类字段”是一种允许添加任何属性的语法。\nclass User {  name = \"John\";  sayHi() {    alert(`Hello, ${this.name}!`);  }}new User().sayHi(); // Hello, John!\n\n类字段重要的不同之处在于，它们会在每个独立对象中被设好，而不是设在\nUser.prototype：\n即类字段只在实例化时进行。\n\n类继承\nclass Animal {  constructor(name) {    this.speed = 0;    this.name = name;  }  run(speed) {    this.speed = speed;    alert(`${this.name} runs with speed ${this.speed}.`);  }  stop() {    this.speed = 0;    alert(`${this.name} stands still.`);  }}class Rabbit extends Animal {  hide() {    alert(`${this.name} hides!`);  }  stop() {    super.stop(); // 调用父类的 stop    this.hide(); // 然后 hide  }}let rabbit = new Rabbit(\"White Rabbit\");rabbit.run(5); // White Rabbit runs with speed 5.rabbit.stop(); // White Rabbit stands still. White Rabbit hides!\n静态属性和静态方法\n静态方法：属于类本身的方法。\nclass Article {  constructor(title, date) {    this.title = title;    this.date = date;  }  static compare(articleA, articleB) {    return articleA.date - articleB.date;  }}// 用法let articles = [  new Article(\"HTML\", new Date(2019, 1, 1)),  new Article(\"CSS\", new Date(2019, 0, 1)),  new Article(\"JavaScript\", new Date(2019, 11, 1))];articles.sort(Article.compare);alert( articles[0].title ); // CSS\n静态属性\nclass Article {  static publisher = \"Levi Ding\";}alert( Article.publisher ); // Levi Ding\n\n静态方法和属性只能通过类名调用，而不能通过对象实例。\n静态方法和属性都可以继承。\n\n私有属性与方法\n\n受保护的字段以 _\n开头。这是一个众所周知的约定，不是在语言级别强制执行的。程序员应该只通过它的类和从它继承的类中访问以\n_ 开头的字段。\n私有字段以 # 开头。JavaScript\n确保我们只能从类的内部访问它们。\n\n类检查\ninstanceof\nclass Rabbit {}let rabbit = new Rabbit();// rabbit 是 Rabbit class 的对象吗？alert( rabbit instanceof Rabbit ); // true// 这里是构造函数，而不是 classfunction Rabbit() {}alert( new Rabbit() instanceof Rabbit ); // truelet arr = [1, 2, 3];alert( arr instanceof Array ); // truealert( arr instanceof Object ); // true\n让我们总结一下我们知道的类型检查方法：\n\n\n\n\n\n\n\n\n\n用于\n返回值\n\n\n\n\ntypeof\n原始数据类型\nstring\n\n\n{}.toString\n原始数据类型，内建对象，包含\nSymbol.toStringTag 属性的对象\nstring\n\n\ninstanceof\n对象\ntrue/false\n\n\n\n","categories":["前端","Javascript"],"tags":["Javascript,Class"]},{"title":"Leetcode 2023-07-05 题目分享","url":"/2023/07/05/Leetcode-2023-07-05-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"1671.\n得到山形数组的最少删除次数 [Hard] 题解\n\n得到山形数组的最少删除次数\n我们定义 arr 是 山形数组\n当且仅当它满足：\n\narr.length &gt;= 3\n存在某个下标 i (1&lt;=i&lt;=arr.length-2)\n\narr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i]\narr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]\n\n\n给你整数数组 nums ，请你返回将 nums 变成\n山形状数组 的 最少 删除次数。\n示例 1：\n输入：nums = [1,3,1]输出：0解释：数组本身就是山形数组，所以我们不需要删除任何元素。\n示例 2：\n输入：nums = [2,1,1,5,6,2,3,1]输出：3解释：一种方法是将下标为 0，1 和 5 的元素删除，剩余元素为 [1,5,6,3,1] ，是山形数组。\n提示：\n\n3 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 10^9\n题目保证 nums 删除一些元素后一定能得到山形数组。\n\n思路\n\n山脉题经典思路=&gt;前后缀分解\n题解里很多是反向来思考的=&gt;删除的最少，意味着剩下的前后缀递增长度最长。\n这就变成了常见问题：最长上升子序列。由于数据规模只有1000，可以直接线性DP求解。\n但这里我提供一种正向思考的方法：dp[i]表示前[0，i]个数，选中了第i个数后最少删除次数，使得这些数严格递增。\n有一个坑就是，题目的山顶不能在数组开始或结束。就是说[1，2，3]和[3，2，1]是不符合题意的。在最后枚举山顶时，要判断山顶两边是不是没有其他数字了。\n\n代码\nvar minimumMountainRemovals = function(nums) {    let handle = arr =&gt; {        let n = arr.length;        // 最坏情况 第i个数将它左边所有数都删除，只剩一个数。即 dp[i] = i。        // JS有没有更优雅的方法实现 dp[i] = i ???        let dp = new Array(n).fill(0).map((v, i)=&gt;i);        for (let i = 1;i &lt; n;i++){            for (let j = 0;j &lt; i;j++){                if (arr[i] &lt;= arr[j]) continue;                 // 枚举之前遍历过的数，如果比当前小，就可以更新。                // 即[0，j]删除次数 加上 i-j-1（两个数之间所有其他数都删除）                dp[i] = Math.min(dp[i], dp[j]+i-j-1);            }        }        return dp;    };    let left = handle(nums), right = handle(nums.reverse()).reverse();    let n = nums.length, ans = n-3;    for (let i = 0;i &lt; n;i++){        // 判断山顶两边是不是没有其它数字了        if (left[i]==i || right[i]==n-1-i) continue;        ans = Math.min(ans, left[i]+right[i]);    }    return ans;};\n复杂度分析\n\n时间：O(n2)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","前后缀分解"]},{"title":"Leetcode 2023-08-21 题目分享","url":"/2023/08/21/Leetcode-2023-08-21-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2337.\n移动片段得到字符串 [Medium] 题解\n\nLeetcode\n\n2337.\n移动片段得到字符串 - 力扣（LeetCode）\n给你两个字符串 start 和 target ，长度均为\nn 。每个字符串 仅 由字符\n'L'、'R' 和 '_' 组成，其中：\n\n字符 'L' 和 'R' 表示片段，其中片段\n'L' 只有在其左侧直接存在一个 空位 时才能向\n左 移动，而片段 'R'\n只有在其右侧直接存在一个 空位 时才能向\n右 移动。\n字符 '_' 表示可以被 任意\n'L' 或 'R' 片段占据的空位。\n\n如果在移动字符串 start 中的片段任意次之后可以得到字符串\ntarget ，返回 true ；否则，返回\nfalse 。\n示例 1：\n输入：start = \"_L__R__R_\", target = \"L______RR\"输出：true解释：可以从字符串 start 获得 target ，需要进行下面的移动：- 将第一个片段向左移动一步，字符串现在变为 \"L___R__R_\" 。- 将最后一个片段向右移动一步，字符串现在变为 \"L___R___R\" 。- 将第二个片段向右移动散步，字符串现在变为 \"L______RR\" 。可以从字符串 start 得到 target ，所以返回 true 。\n示例 2：\n输入：start = \"R_L_\", target = \"__LR\"输出：false解释：字符串 start 中的 'R' 片段可以向右移动一步得到 \"_RL_\" 。但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。\n示例 3：\n输入：start = \"_R\", target = \"R_\"输出：false解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。\n提示：\n\nn == start.length == target.length\n1 &lt;= n &lt;= 10^5\nstart 和 target 由字符\n'L'、'R' 和 '_' 组成\n\n\n思路\n\n明确L和R不能相互穿过，所以去除’__’后，两个字符串肯定是相等的。\n从右到左遍历，依次取出两个字符串start 和\ntarget的第一个有效字符进行判断。\n\n不等: false\n等于R且i &gt; j:\nfalse\n等于L且i &lt; j:\nfalse\n\n最后跳出循环后，可能还有字符串存在有效字符，此时返回false,否则true。\n\n代码\nclass Solution {public:    bool canChange(string start, string target) {        int n = start.size(), i = n-1, j = n-1;        for (;i &gt;= 0, j &gt;= 0;i--, j--){            while (i &gt;= 0 &amp;&amp; start[i] == '_') i--;            while (j &gt;= 0 &amp;&amp; target[j] == '_') j--;            if (i &lt; 0 || j &lt; 0) break;            if (start[i] != target[j]) return false;            if (start[i]=='R' &amp;&amp; i &gt; j) return false;            if (start[i]=='L' &amp;&amp; i &lt; j) return false;        }        for (;i &gt;= 0;i--) if (start[i] != '_') return false;        for (;j &gt;= 0;j--) if (target[j] != '_') return false;        return 1;    }};\n复杂度分析\n\n时间复杂度: O(1) 。\n空间复杂度: O(n)\n。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["双指针","字符串"]},{"title":"Leetcode 2023-08-27 题目分享","url":"/2023/08/27/Leetcode-2023-08-27-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB-1/","content":"2835.\n使子序列的和等于目标的最少操作次数 [Hard] 题解\n\nLeetcode\n\n2835.\n使子序列的和等于目标的最少操作次数 - 力扣（LeetCode）\n给你一个下标从 0 开始的数组 nums\n，它包含 非负 整数，且全部为 2\n的幂，同时给你一个整数 target 。\n一次操作中，你必须对数组做以下修改：\n\n选择数组中一个元素 nums[i] ，满足\nnums[i] &gt; 1 。\n将 nums[i] 从数组中删除。\n在 nums 的 末尾 添加\n两个 数，值都为 nums[i] / 2 。\n\n你的目标是让 nums 的一个 子序列\n的元素和等于 target ，请你返回达成这一目标的\n最少操作次数 。如果无法得到这样的子序列，请你返回\n-1 。\n数组中一个 子序列\n是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。\n示例 1：\n输入：nums = [1,2,8], target = 7输出：1解释：第一次操作中，我们选择元素 nums[2] 。数组变为 nums = [1,2,4,4] 。这时候，nums 包含子序列 [1,2,4] ，和为 7 。无法通过更少的操作得到和为 7 的子序列。\n示例 2：\n输入：nums = [1,32,1,2], target = 12输出：2解释：第一次操作中，我们选择元素 nums[1] 。数组变为 nums = [1,1,2,16,16] 。第二次操作中，我们选择元素 nums[3] 。数组变为 nums = [1,1,2,16,8,8] 。这时候，nums 包含子序列 [1,1,2,8] ，和为 12 。无法通过更少的操作得到和为 12 的子序列。\n示例 3：\n输入：nums = [1,32,1], target = 35输出：-1解释：无法得到和为 35 的子序列。\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 2^30\nnums 只包含非负整数，且均为 2 的幂。\n1 &lt;= target &lt; 2^31\n\n\n思路\n数组中每个数最后都可以分成若干个 1 ，因此如果数组元素和小于 target\n返回-1，否则一定有解。 然后将 target\n分解到每一位，从低位到高位依次遍历，遍历过程中一同计算未被使用的数值和\npre。\n\n如果 target 的第 i 位是 0\n，跳过。\n如果 target 的第 i 位是 1\n：\n\npre 大于等于2i，说明这一位代表的数值可以被之前遍历到的数相加得到。（因为每个数最后都可以变为\n1，所以只要大于等于它，就一定可以表示出）\n反之说明需要往前找到 target 第一个 1\n的位置，将它不断一分为二到当前位，同时更新 ans。\n\n\n代码\nint minOperations(vector&lt;int&gt;&amp; nums, int target) {    int n = nums.size();    unordered_map&lt;int, int&gt; mp;    for (int i = 0;i &lt;= 30;i++) mp[(1&lt;&lt;i)] = i;    // cnt[i]表示nums中的数等于1&lt;&lt;i的数量    vector&lt;int&gt; cnt(31, 0);    for (int i = 0;i &lt; n;i++) cnt[mp[nums[i]]]++;    int ans = 0;    long long pre = 0;    // 从低到高遍历每一位    for (int i = 0;i &lt;= 30;i++){        pre += 1L*cnt[i]*(1&lt;&lt;i);        int x = (target &gt;&gt; i &amp; 1), val = x*(1&lt;&lt;i);        // 小于pre 直接可以凑出 1&lt;&lt;i 了，减去被使用的值        if (val &lt;= pre){            pre -= val;            continue;        }      \t// 向前找到第一个1        int f = 0, j = i+1;        for (;j &lt;= 30 &amp;&amp; f == 0;j++){            if (cnt[j] != 0){                f = 1;                break;            }            cnt[j]++;            ans++;        }        if (f == 0) return -1;        cnt[j]--;        ans++;        pre += (1&lt;&lt;i);    }    return ans;}\n复杂度分析\n\n时间复杂度: O(log n) 。\n空间复杂度: O(log n) 。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["贪心","位运算"]},{"title":"Leetcode 2023-08-27 题目分享","url":"/2023/08/27/Leetcode-2023-08-27-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2835.\n使子序列的和等于目标的最少操作次数 [Hard] 题解\n​\n\nLeetcode\n\n2835.\n使子序列的和等于目标的最少操作次数 - 力扣（LeetCode）\n给你一个下标从 0 开始的数组 nums\n，它包含 非负 整数，且全部为 2\n的幂，同时给你一个整数 target 。\n一次操作中，你必须对数组做以下修改：\n\n选择数组中一个元素 nums[i] ，满足\nnums[i] &gt; 1 。\n将 nums[i] 从数组中删除。\n在 nums 的 末尾 添加\n两个 数，值都为 nums[i] / 2 。\n\n你的目标是让 nums 的一个 子序列\n的元素和等于 target ，请你返回达成这一目标的\n最少操作次数 。如果无法得到这样的子序列，请你返回\n-1 。\n数组中一个 子序列\n是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。\n示例 1：\n输入：nums = [1,2,8], target = 7输出：1解释：第一次操作中，我们选择元素 nums[2] 。数组变为 nums = [1,2,4,4] 。这时候，nums 包含子序列 [1,2,4] ，和为 7 。无法通过更少的操作得到和为 7 的子序列。\n示例 2：\n输入：nums = [1,32,1,2], target = 12输出：2解释：第一次操作中，我们选择元素 nums[1] 。数组变为 nums = [1,1,2,16,16] 。第二次操作中，我们选择元素 nums[3] 。数组变为 nums = [1,1,2,16,8,8] 。这时候，nums 包含子序列 [1,1,2,8] ，和为 12 。无法通过更少的操作得到和为 12 的子序列。\n示例 3：\n输入：nums = [1,32,1], target = 35输出：-1解释：无法得到和为 35 的子序列。\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 2^30\nnums 只包含非负整数，且均为 2 的幂。\n1 &lt;= target &lt; 2^31\n\n\n思路\n数组中每个数最后都可以分成若干个1\n，因此如果数组元素和小于target返回-1，否则一定有解。\n然后将target分解到每一位，从低位到高位依次遍历，遍历过程中一同计算未被使用的数值和\npre。\n\n如果 target 的第 i 位是 0\n，跳过。\n如果 target 的第 i 位是 1\n：\n\npre大于等于2i，说明这一位代表的数值可以被之前遍历到的数相加得到。（因为每个数最后都可以变为1，所以只要大于等于它，就一定可以表示出）\n反之说明需要往前找到target第一个1的位置，将它不断一分为二到当前位，同时更新ans。\n\n\n代码\nint minOperations(vector&lt;int&gt;&amp; nums, int target) {    int n = nums.size();    unordered_map&lt;int, int&gt; mp;    for (int i = 0;i &lt;= 30;i++) mp[(1&lt;&lt;i)] = i;    // cnt[i]表示nums中的数等于1&lt;&lt;i的数量    vector&lt;int&gt; cnt(31, 0);    for (int i = 0;i &lt; n;i++) cnt[mp[nums[i]]]++;    int ans = 0;    long long pre = 0;    // 从低到高遍历每一位    for (int i = 0;i &lt;= 30;i++){        pre += 1L*cnt[i]*(1&lt;&lt;i);        int x = (target &gt;&gt; i &amp; 1), val = x*(1&lt;&lt;i);        // 小于pre 直接可以凑出 1&lt;&lt;i 了，减去被使用的值        if (val &lt;= pre){            pre -= val;            continue;        }      \t// 向前找到第一个1        int f = 0, j = i+1;        for (;j &lt;= 30 &amp;&amp; f == 0;j++){            if (cnt[j] != 0){                f = 1;                break;            }            cnt[j]++;            ans++;        }        if (f == 0) return -1;        cnt[j]--;        ans++;        pre += (1&lt;&lt;i);    }    return ans;}\n复杂度分析\n\n时间复杂度: O(log n) 。\n空间复杂度: O(log n) 。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["贪心"]},{"title":"Leetcode 2023-12-06 题目分享","url":"/2023/12/06/Leetcode-2023-12-06-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2646.\n最小化旅行的价格总和 [Hard] 题解\n\nLeetcode 2646.\n最小化旅行的价格总和\n现有一棵无向、无根的树，树中有 n 个节点，按从\n0 到 n - 1 编号。给你一个整数 n\n和一个长度为 n - 1 的二维整数数组 edges ，其中\nedges[i] = [ai, bi] 表示树中节点 ai 和\nbi 之间存在一条边。\n每个节点都关联一个价格。给你一个整数数组 price ，其中\nprice[i] 是第 i 个节点的价格。\n给定路径的 价格总和\n是该路径上所有节点的价格之和。\n另给你一个二维整数数组 trips ，其中\ntrips[i] = [starti, endi] 表示您从节点 starti\n开始第 i 次旅行，并通过任何你喜欢的路径前往节点\nendi 。\n在执行第一次旅行之前，你可以选择一些 非相邻节点\n并将价格减半。\n返回执行所有旅行的最小价格总和。\n示例 1：\n输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]输出：23解释：上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。\n示例 2：\n输入：n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]输出：1解释：上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。\n提示：\n\n1 &lt;= n &lt;= 50\nedges.length == n - 1\n0 &lt;= ai, bi &lt;= n - 1\nedges 表示一棵有效的树\nprice.length == n\nprice[i] 是一个偶数\n1 &lt;= price[i] &lt;= 1000\n1 &lt;= trips.length &lt;= 100\n0 &lt;= starti, endi &lt;= n - 1\n\n思路\n\n首先肯定要根据访问的路径来统计每个节点最终会被访问多少次。\n\n由于是一颗树，每次将起点当做根节点向下搜索即可。遇到终点就返回true，根据返回值来判断当前节点访问次数是否要++。\n\n然后就是经典的01-DP问题：对于任何一个节点：\n\n选择价格降低一半：那所有子节点都必须是原来价格\n不选择：那那所有子节点可以减半，也可以不减半–取两者最小值\n\n\n代码\nclass Solution {public:    int minimumTotalPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; price, vector&lt;vector&lt;int&gt;&gt;&amp; trips) {        vector&lt;int&gt; g[n];        for (vector&lt;int&gt;&amp; e : edges){            g[e[0]].push_back(e[1]);            g[e[1]].push_back(e[0]);        }        vector&lt;int&gt; cnt(n);        function&lt;bool(int, int, int)&gt; count = [&amp;](int u, int fa, int end){            if (u == end){                cnt[u]++;                return true;            }            for (int v : g[u]){                if (v == fa) continue;                if (count(v, u, end)){                    cnt[u]++;                    return true;                }            }            return false;        };        for (vector&lt;int&gt;&amp; t : trips) count(t[0], -1, t[1]);        typedef pair&lt;int, int&gt; pii;        function&lt;pii(int, int)&gt; dp = [&amp;](int u, int fa){            int select = price[u]/2*cnt[u], ignore = price[u]*cnt[u];            for (int v : g[u]){                if (v == fa) continue;                pii cur = dp(v, u);                select += cur.second;                ignore += min(cur.first, cur.second);            }            return pair(select, ignore);        };        pii res = dp(0, -1);        return min(res.first, res.second);    }};\n复杂度分析\n\n时间：O(n*t+n)=O(n*t)。n，t分别是节点数量和旅行次数。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","DFS","树"]},{"title":"Leetcode 2023-12-21 题目分享","url":"/2023/12/21/Leetcode-2023-12-21-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2866.\n美丽塔 II [Medium] 题解\n\nLeetcode 美丽塔 II\n给你一个长度为 n 下标从 0\n开始的整数数组 maxHeights 。\n你的任务是在坐标轴上建 n 座塔。第 i\n座塔的下标为 i ，高度为 heights[i] 。\n如果以下条件满足，我们称这些塔是 美丽 的：\n\n1 &lt;= heights[i] &lt;= maxHeights[i]\nheights 是一个 山脉 数组。\n\n如果存在下标 i 满足以下条件，那么我们称数组\nheights 是一个 山脉 数组：\n\n对于所有 0 &lt; j &lt;= i ，都有\nheights[j - 1] &lt;= heights[j]\n对于所有 i &lt;= k &lt; n - 1 ，都有\nheights[k + 1] &lt;= heights[k]\n\n请你返回满足 美丽塔\n要求的方案中，高度和的最大值 。\n示例 1：\n输入：maxHeights = [5,3,4,1,1]输出：13解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：- 1 &lt;= heights[i] &lt;= maxHeights[i]  - heights 是个山脉数组，峰值在 i = 0 处。13 是所有美丽塔方案中的最大高度和。\n示例 2：\n输入：maxHeights = [6,5,3,9,2,7]输出：22解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：- 1 &lt;= heights[i] &lt;= maxHeights[i]- heights 是个山脉数组，峰值在 i = 3 处。22 是所有美丽塔方案中的最大高度和。\n示例 3：\n输入：maxHeights = [3,2,5,5,2,3]输出：18解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：- 1 &lt;= heights[i] &lt;= maxHeights[i]- heights 是个山脉数组，最大值在 i = 2 处。注意，在这个方案中，i = 3 也是一个峰值。18 是所有美丽塔方案中的最大高度和。\n提示：\n\n1 &lt;= n == maxHeights &lt;= 10^5\n1 &lt;= maxHeights[i] &lt;= 10^9\n\n思路\n\n山脉=&gt;从左到右递增，从右到左递减。\n容易联想到前后缀分解：分别处理前缀和后缀递增数组，找到对应的最大和。\n构造递增数组，使和最大=&gt;维护单调递增栈。\n\n代码\nvar maximumSumOfHeights = function(maxHeights) {    let handler = arr =&gt; {        let n = arr.length, sum = 0;        let res = new Array(n).fill(0), st = [[]];        for (let i = 0;i &lt; n;i++) {            let cnt = 1, cur = arr[i];            while (st.length != 0 &amp;&amp; st.at(-1)[0] &gt;= cur){                let pre = st.pop();                sum -= pre[0]*pre[1];                cnt++;            }            sum += cnt*cur;            st.push([cur, cnt]);            res[i] = sum;        }        return res;    };    let left = handler(maxHeights);    let right = handler(maxHeights.reverse()).reverse();    let n = maxHeights.length, ans = Math.max(left[n-1], right[0]);    for (let i = 0;i &lt; n-1;i++){        ans = Math.max(ans, left[i]+right[i+1]);    }    return ans;};\n复杂度分析\n\n时间：O(n)，每个元素至多被push一次和pop一次。\n空间：O(1)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["单调栈"]},{"title":"Javascript 函数","url":"/2023/12/15/Javascript-%E5%87%BD%E6%95%B0/","content":"JavaScript\n函数机制详解，涵盖定时调度方法、嵌套定时器的自适应调度技巧、函数装饰器模式与缓存优化实现、this\n丢失问题的成因与 bind\n绑定解决方案等实用编程模式与技巧。\n\n函数调度\nsetTimeout\nsetTimeout(func,[delay], [arg1], [arg2], …)\nfunc必须是函数，不能写成调用的形式。\n// 错的！setTimeout(sayHi(), 1000);\nsetInterval\nsetInterval(func,[delay], [arg1], [arg2], …)\n// 每 2 秒重复一次let timerId = setInterval(() =&gt; alert('tick'), 2000);// 5 秒之后停止setTimeout(() =&gt; { clearInterval(timerId); alert('stop'); }, 5000);\n嵌套的 setTimeout\n周期性调度有两种方式。\n一种是使用 setInterval，另外一种就是嵌套的\nsetTimeout，就像这样：\n/** instead of:let timerId = setInterval(() =&gt; alert('tick'), 2000);*/let timerId = setTimeout(function tick() {  alert('tick');  timerId = setTimeout(tick, 2000); // (*)}, 2000);\n例如，我们要实现一个服务（server），每间隔 5\n秒向服务器发送一个数据请求，但如果服务器过载了，那么就要降低请求频率，比如将间隔增加到\n10、20、40 秒等。\nlet delay = 5000;let timerId = setTimeout(function request() {  ...发送请求...  if (request failed due to server overload) {    // 下一次执行的间隔是当前的 2 倍    delay *= 2;  }  timerId = setTimeout(request, delay);}, delay);\n\n使用 setInterval 时，func\n函数的实际调用间隔要比代码中设定的时间间隔要短！\n这也是正常的，因为 func\n的执行所花费的时间“消耗”了一部分间隔时间。\n\n装饰器模式和转发\n透明缓存\nfunction slow(x) {  // 这里可能会有重负载的 CPU 密集型工作  alert(`Called with ${x}`);  return x;}function cachingDecorator(func) {  let cache = new Map();  return function(x) {    if (cache.has(x)) {          return cache.get(x);     }    let result = func(x);      cache.set(x, result);     return result;  };}slow = cachingDecorator(slow);alert( slow(1) ); \n函数绑定\n丢失this\nlet user = {  firstName: \"John\",  sayHi() {    alert(`Hello, ${this.firstName}!`);  }};setTimeout(user.sayHi, 1000); // Hello, undefined!\n浏览器中的 setTimeout 方法有些特殊：它为函数调用设定了\nthis=window。所以对于\nthis.firstName，它其实试图获取的是\nwindow.firstName，这个变量并不存在。\n\n解决方案 1：包装器\n\nlet user = {  firstName: \"John\",  sayHi() {    alert(`Hello, ${this.firstName}!`);  }};setTimeout(function() {  user.sayHi(); // Hello, John!}, 1000);// orsetTimeout(() =&gt; user.sayHi(), 1000); \n\n解决方案 2：bind\n\nlet user = {  firstName: \"John\",  say(phrase) {    alert(`${phrase}, ${this.firstName}!`);  }};let say2 = user.say.bind(user);user = null;say2(\"Hello\"); // Hello, John!say2(\"Bye\"); // Bye, John!\n\nsay中会存储user对象对应的引用。\n即改变user.say函数后，say2方法内容也会改变\n\n","categories":["前端","Javascript"],"tags":["Javascript,Function"]},{"title":"Leetcode 2024-08-21 题目分享","url":"/2024/12/18/Leetcode-2024-08-21-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"162.\n寻找峰值 [Medium] 题解\n\nLeetcode 寻找峰值\n峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组\nnums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回\n任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n示例 1：\n输入：nums = [1,2,3,1]输出：2解释：3 是峰值元素，你的函数应该返回其索引 2。\n示例 2：\n输入：nums = [1,2,1,3,5,6,4]输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n-231 &lt;= nums[i] &lt;= 231 - 1\n对于所有有效的 i 都有\nnums[i] != nums[i + 1]\n\n思路\n\n常规做法很简单，遍历一遍，找到符合条件的下标即可\n题目要求O(log n)，直接想到分治。\n但题解里都是用二分做的，没看到用分治的。因为二分更简单⭕\n\n代码\n/** * @param {number[]} nums * @return {number} */var findPeakElement = function(nums) {    let n = nums.length;    let find = (l, r) =&gt; {        if (l == r){            if ((l==0||nums[l]&gt;nums[l-1]) &amp;&amp; (l==n-1||nums[l]&gt;nums[l+1])) return l;            return -1;        }        let mid = l+r &gt;&gt; 1;        let x = find(l, mid), y = find(mid+1, r);        if (x != -1) return x;        else if (y != -1) return y;        else return -1;    };    return find(0, n-1);};\n复杂度分析\n\n时间：O(log n)。\n空间：O(1)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["二分","分治"]},{"title":"Leetcode 2024-11-27 题目分享","url":"/2024/11/27/Leetcode-2024-11-27-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"907.\n子数组的最小值之和 [Medium] 题解\n\nLeetcode\n\n907.\n子数组的最小值之和\n给定一个整数数组 arr，找到 min(b)\n的总和，其中 b 的范围为 arr\n的每个（连续）子数组。\n由于答案可能很大，因此 返回答案模\n10^9 + 7 。\n示例 1：\n输入：arr = [3,1,2,4]输出：17解释：子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。\n示例 2：\n输入：arr = [11,81,94,43,3]输出：444\n提示：\n\n1 &lt;= arr.length &lt;= 3 * 10^4\n1 &lt;= arr[i] &lt;= 3 * 10^4\n\n\n思路\n明显贡献法求解。\n对于遍历到的第i个数，他有a[i：i]，a[i-1：i]…a[1：i]\n总共i个连续子数组。\n找到第一个a[j]&lt;a[i]的分割点：\n\n对于所有a[1：k]，k&lt;=j的子数组，它的最小值肯定都是a[1：k]中的最小值。\n对于所有a[k：i]，k&gt;j的子数组，它的最小值肯定都是a[i]。\n\n所以维护每个位置上的连续子数组最小值的和dp[i]：\n​ dp[i] = dp[j]+arr[i]*(i-j)\n为了快速找到最小值，使用树状数组。\n代码\nclass Solution {public:    int sumSubarrayMins(vector&lt;int&gt;&amp; arr) {        int n = arr.size(), N = 3e4+10;        typedef long long ll;        vector&lt;int&gt; tr(N, 0);        function&lt;void(int, int)&gt; upd = [&amp;](int idx, int val){            for (int i = idx;i &lt; N;i += i&amp;-i) tr[i] = max(tr[i], val);        };        function&lt;int(int)&gt; qry = [&amp;](int idx){            int ans = 0;            for (int i = idx;i &gt; 0;i -= i&amp;-i) ans = max(ans, tr[i]);            return ans;        };        ll M = 1e9+7, res = 0;        vector&lt;ll&gt; ans(n+1, 0);        for (int i = 1;i &lt;= n;i++){            int pre = qry(arr[i-1]-1);            ans[i] = (ans[pre]+arr[i-1]*(i-pre))%M;            res = (res+ans[i])%M;            upd(arr[i-1], i);        }        return (int)res;    }};\n复杂度分析\n\n时间复杂度: O(nlogn)\n。\n空间复杂度: O(n)\n。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","贡献法"]},{"title":"Leetcode 2024-02-05 题目分享","url":"/2024/02/05/Leetcode-2024-02-05-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"跳跃游戏 VI\n[Medium] 题解\n经典DP和延迟删除问题\n\n跳跃游戏 VI\n给你一个下标从 0 开始的整数数组 nums\n和一个整数 k 。\n一开始你在下标 0 处。每一步，你最多可以往前跳\nk 步，但你不能跳出数组的边界。也就是说，你可以从下标\ni 跳到 [i + 1， min(n - 1, i + k)]\n包含 两个端点的任意位置。\n你的目标是到达数组最后一个位置（下标为 n - 1 ），你的\n得分 为经过的所有数字之和。\n请你返回你能得到的 最大得分 。\n示例 1：\n输入：nums = [1,-1,-2,4,-7,3], k = 2输出：7解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。\n示例 2：\n输入：nums = [10,-5,-2,4,0,3], k = 3输出：17解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。\n提示：\n\n1 &lt;= nums.length, k &lt;= 10^5\n-10^4 &lt;= nums[i] &lt;= 10^4\n\n思路\n\n题意很简单，一眼DP问题。\n写出原始DP转移方程：设dp[i]表示跳跃到第i个位置时最大得分。\n则根据第i个位置可以由第i-1，i-2，…i-k个位置跳跃而来有以下转移方程\ndp[i] =max(dp[i-1],dp[i-2],...,dp[i-k]+nums[i])\n很明显，接下来的问题就是要动态维护前k个dp最大值。\n但动态维护需要删除操作，去除那些不在前k的值。此时我们可以使用延迟删除方法。\n这样可以保证每个值最多只会有一次push和一次pop操作。\n\n代码\nclass Solution {public:    int maxResult(vector&lt;int&gt;&amp; nums, int k) {        typedef pair&lt;int, int&gt; pii;        int n = nums.size(), ans = 0;        priority_queue&lt;pii&gt; pq;        for (int i = 0;i &lt; n;i++){            int cur = nums[i];            // 延迟删除             // 判断当前队列里最大值是不是在前k个位置中            while (pq.size() &amp;&amp; pq.top().second &lt; i - k){                pq.pop();            }            if (pq.size()) cur += pq.top().first;            pq.push({cur, i});            ans = cur;        }        return ans;    }};\n复杂度分析\n\n时间：O(n * log n)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","延迟删除"]},{"title":"Leetcode 2023-12-26 题目分享","url":"/2023/12/26/Leetcode-2023-12-26-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"1349.\n参加考试的最大学生数 [Hard] 题解\n\n参加考试的最大学生数\n给你一个 m * n 的矩阵 seats\n表示教室中的座位分布。如果座位是坏的（不可用），就用 '#'\n表示；否则，用 '.' 表示。\n学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的同时参加考试且无法作弊的\n最大 学生人数。\n示例 1：\n输入：seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],              [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],              [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]输出：4解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。\n示例 2：\n输入：seats = [[\".\",\"#\"],              [\"#\",\"#\"],              [\"#\",\".\"],              [\"#\",\"#\"],              [\".\",\"#\"]]输出：3解释：让所有学生坐在可用的座位上。\n示例 3：\n输入：seats = [[\"#\",\".\",\".\",\".\",\"#\"],              [\".\",\"#\",\".\",\"#\",\".\"],              [\".\",\".\",\"#\",\".\",\".\"],              [\".\",\"#\",\".\",\"#\",\".\"],              [\"#\",\".\",\".\",\".\",\"#\"]]输出：10解释：让学生坐在第 1、3 和 5 列的可用座位上。\n提示：\n\nseats 只包含字符 '.' 和``'#'\nm == seats.length\nn == seats[i].length\n1 &lt;= m &lt;= 8\n1 &lt;= n &lt;= 8\n\n思路\n\n首先是图上的搜索问题，结合数据量，完全可以 DFS+记忆化搜索解决。\n但这个问题本质上是“选和不选”：‘1’代表选择这个座位，‘0’代表不选。所以很自然想到状态压缩+DP。\n对每一行数据进行处理，枚举所有可能的情况：\n\n判断这一行是否有效：检查每个‘1’左右是否都为‘0‘\n枚举前一行的所有情况，判断是否有效：检查当前行每个‘1’的前一行左右是否都为‘0’\n\n有效则可以更新 DP 数组\n\n\n\n代码\nclass Solution {public:    int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) {        int n = seats.size(), m = seats[0].size(), INF = -1e9;        // 判断当前行是否有效        function&lt;bool(int,vector&lt;char&gt;)&gt; ckrow = [&amp;](int st, vector&lt;char&gt; g){            for (int j = 0;j &lt; m;j++){                // 选择第j个座位 但该座位是坏的 或 右边已经有人了                if ((st&gt;&gt;j&amp;1)==1 &amp;&amp; (g[j]=='#' || (j&gt;0&amp;&amp;st&gt;&gt;(j-1)&amp;1)==1)){                    return false;                }            }            return true;        };        // 判断当前行和上一行合在一起是否有效        function&lt;bool(int,int)&gt; ckpre = [&amp;](int cur, int pre){            for (int k = 0;k &lt; m;k++){                int x = cur&gt;&gt;k&amp;1; // 当前行第k个座位状态                int y = k==0?0:pre&gt;&gt;(k-1)&amp;1; // 前一行第k-1座位状态                int z = k==m-1?0:pre&gt;&gt;(k+1)&amp;1; // 前一行第k+1座位状态                // x有人坐 但y或z也已经有人坐了                if (x==1 &amp;&amp; (y==1 || z==1)){                    return false;                }            }            return true;        };        vector&lt;int&gt; pre(1 &lt;&lt; m, 0);        for (int i = 0;i &lt; n;i++){            vector&lt;char&gt; g = seats[i];            vector&lt;int&gt; cur(1 &lt;&lt; m, INF), cnt(1 &lt;&lt; m);            // 枚举当前行所有状态            for (int st = 0;st &lt; (1&lt;&lt;m);st++){                if (!ckrow(st, g)) continue;                for (int j = 0;j &lt; m;j++) if (st&gt;&gt;j&amp;1) cnt[st]++;                // 枚举前一行所有状态                for (int j = 0;j &lt; (1&lt;&lt;m);j++){                    if (pre[j] == INF || !ckpre(st, j)) continue;                    cur[st] = max(cur[st], pre[j]+cnt[st]);                }            }            pre = cur;        }        return *max_element(pre.begin(), pre.end());    }};\n复杂度分析\n\n时间：O( n * 2m * (m + 2m) = n * 4m\n)。\n空间：O( 2m\n)。\n\n\n类似记得蓝桥杯也很喜欢出这种题\n贴一个以前的蓝桥杯真题，也是 DP+状态压缩：玉米田\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","二进制枚举"]},{"title":"Leetcode 2025-01-04 题目分享","url":"/2025/01/04/Leetcode-2025-01-04-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2397.\n被列覆盖的最多行数 [Medium] 题解\n\n2397.\n被列覆盖的最多行数\n给你一个下标从 0 开始、大小为 m x n\n的二进制矩阵 matrix ；另给你一个整数\nnumSelect，表示你必须从 matrix 中选择的\n不同 列的数量。\n如果一行中所有的 1 都被你选中的列所覆盖，则认为这一行被\n覆盖 了。\n形式上，假设\ns = {c1, c2, ...., cnumSelect}\n是你选择的列的集合。对于矩阵中的某一行 row\n，如果满足下述条件，则认为这一行被集合 s\n覆盖：\n\n对于满足 matrix[row][col] == 1 的每个单元格\nmatrix[row][col]（0 &lt;= col &lt;= n - 1），col\n均存在于 s 中，或者\nrow 中 不存在 值为 1\n的单元格。\n\n你需要从矩阵中选出 numSelect\n个列，使集合覆盖的行数最大化。\n返回一个整数，表示可以由 numSelect 列构成的集合\n覆盖 的 最大行数 。\n示例 1：\n输入：matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2输出：3解释：图示中显示了一种覆盖 3 行的可行办法。选择 s = {0, 2} 。- 第 0 行被覆盖，因为其中没有出现 1 。- 第 1 行被覆盖，因为值为 1 的两列（即 0 和 2）均存在于 s 中。- 第 2 行未被覆盖，因为 matrix[2][1] == 1 但是 1 未存在于 s 中。- 第 3 行被覆盖，因为 matrix[2][2] == 1 且 2 存在于 s 中。因此，可以覆盖 3 行。另外 s = {1, 2} 也可以覆盖 3 行，但可以证明无法覆盖更多行。\n示例 2：\n输入：matrix = [[1],[0]], numSelect = 1输出：2解释：选择唯一的一列，两行都被覆盖了，因为整个矩阵都被覆盖了。所以我们返回 2 。\n提示：\n\nm == matrix.length\nn == matrix[i].length\n1 &lt;= m, n &lt;= 12\nmatrix[i][j] 要么是 0 要么是\n1\n1 &lt;= numSelect &lt;= n\n\n思路\n\n题目读完，感觉有点饶。\n大致意思就是：选择某些列，使得覆盖的行数最大；而覆盖行指的是该行里的所有值为1的列都在你选择的列中。\n读完题立马看看数据范围：12？=&gt;二进制枚举。（12*12*2^12）\n二进制枚举所有可能的选择，判断选中的列数是不是等于numSelect。\n遍历matrix，计算覆盖行数。\n\n代码\nvar maximumRows = function(matrix, numSelect) {    let ans = 0, n = matrix.length, m = matrix[0].length;    // 计算二进制中1出现的次数 O(log n)    let countBit = (x) =&gt; {        let ans = 0;        for (;x;x -= x&amp;-x) ans++;        return ans;    };    for (let k = 0;k &lt; (1&lt;&lt;m);k++){        if (countBit(k) != numSelect) continue;        let cur = 0;        for (let i = 0;i &lt; n;i++){            let flag = 0;            for (let j = 0;j &lt; m;j++){                // 有1但没选，说明这行肯定没有覆盖 直接break                if (matrix[i][j]==1 &amp;&amp; (k&gt;&gt;j&amp;1)==0){                    flag = 1;                    break;                }            }            if (flag == 0) cur++;        }        ans = Math.max(ans, cur);    }    return ans;};\n复杂度分析\n\n时间：O(2n * n * m)。\n空间：O(1)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["二进制枚举"]},{"title":"Leetcode 2025-01-21 题目分享","url":"/2025/01/21/Leetcode-2025-01-21-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"410.\n分割数组的最大值 [Hard] 题解\n\n410.\n分割数组的最大值\n给定一个非负整数数组 nums 和一个整数 k\n，你需要将这个数组分成 k 个非空的连续子数组。\n设计一个算法使得这 k 个子数组各自和的最大值最小。\n示例 1：\n输入：nums = [7,2,5,10,8], k = 2输出：18解释：一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。\n示例 2：\n输入：nums = [1,2,3,4,5], k = 2输出：9\n示例 3：\n输入：nums = [1,4,4], k = 3输出：4\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n0 &lt;= nums[i] &lt;= 10^6\n1 &lt;= k &lt;= min(50, nums.length)\n\n思路\n\n题面很简洁，只需要注意到’最大值最小’==&gt;二分。\n二分是最直接解决“最大值最小，最小值最大”等一系列极值问题的。\n常见两种思路：1）二分所要求的答案 2）二分关键的中间值\n这题很明显就是二分答案：\n\n单调性：如果最大值为v，可以分成t个子数组（t&lt;=k）；\n那么最大值比v大时，分成的子数组数量一定小于等于t。（因为每个子数组能包含的值更大了，一些数值较小的子数组可以合并到其他子数组）\n\n\n上界：最大的和，肯定是整个数组的和（此时t=1，只有一个子数组）。\n下界：数组中元素最大值（此时每个元素作为一个子数组）。\n\n每次二分得到一个最大值，我们要让这个最大值尽可能小。\ncheck函数中遍历数组，依次累加。\n等累加值超出当前二分的最大值时，说明需要重新再开一个子数组。\n看最后子数组的数量是不是小于k即可。\n\n代码\nfunction splitArray(nums: number[], k: number): number {    let sum = 0, max = 0;    nums.forEach(x =&gt; {        sum += x;        max = max &gt; x ? max : x;    });    let check = (mid:number):boolean =&gt; {        let t = 1, cur = 0;        nums.forEach(v =&gt; {            cur += v;            if (cur &gt; mid){                cur = v;                t++;            }        });        return t &lt;= k;    };    let l = max, r = sum;    while (l &lt;= r){        let mid = l+r &gt;&gt; 1;        if (check(mid)) r = mid-1;        else l = mid+1;    }    return l;};\n复杂度分析\n\n时间：O(n * log ∑nums)。\n空间：O(1)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["二分"]},{"title":"Leetcode 2024-12-12 题目分享","url":"/2024/12/12/Leetcode-2024-12-12-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2454.\n下一个更大元素 IV [Hard] 题解\n\nLeetcode 2454.\n下一个更大元素 IV\n给你一个下标从 0 开始的非负整数数组\nnums 。对于 nums\n中每一个整数，你必须找到对应元素的 第二大 整数。\n如果 nums[j] 满足以下条件，那么我们称它为\nnums[i] 的 第二大 整数：\n\nj &gt; i\nnums[j] &gt; nums[i]\n恰好存在 一个 k 满足\ni &lt; k &lt; j 且 nums[k] &gt; nums[i]\n。\n\n如果不存在 nums[j] ，那么第二大整数为 -1\n。\n\n比方说，数组 [1, 2, 4, 3] 中，1\n的第二大整数是 4 ，2 的第二大整数是\n3 ，3 和 4 的第二大整数是\n-1 。\n\n请你返回一个整数数组 answer ，其中\nanswer[i]是 nums[i] 的第二大整数。\n示例 1：\n输入：nums = [2,4,0,9,6]输出：[9,6,6,-1,-1]解释：下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。所以我们返回 [9,6,6,-1,-1] 。\n示例 2：\n输入：nums = [3,3]输出：[-1,-1]解释：由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。\n提示：\n\n1 &lt;= nums.length &lt;= 10^5\n0 &lt;= nums[i] &lt;= 10^9\n\n思路\n一眼感觉就是单调栈的题目，但还是无脑树状数组\n\n首先看范围：1e9? ==&gt; 离散化一下。\n如果是求下一个更大的元素，那直接从后往前依次添加到树状数组；查询时取下标最小值即可（由于树状数组维护的是前缀信息，所以离散化时需要将大小翻转一下）。\n\n\n[2,4,0,9,6] ==&gt; mp[9:1, 6:2, 4:3, 2:4, 0:5]\n查询0时，已有数组a：[0, 3, 4, 0, 0, 0]\n（3，4分别是数字9和6在nums的下标）。\n0对应大小为5，所以比它大的肯定存储在数组a[1-4]位置上。\n利用树状数组求出这个a[1-4]中维护的下标最小值，得到结果：nums[3] =\n9。\n\n\n如果是求第二大的元素，那其实与上面类似，仍然用树状数组维护，但查询时每次要维护两个比当前元素大的值，且他们在nums中下标最小。最后取两个中下标较大的为答案。\n\n\n[2,4,0,9,6] ==&gt; mp[9:1, 6:2, 4:3, 2:4, 0:5]\n查询2时，已有数组a：[0, 3, 4, 1, 0, 2]\n（3，4，1，2分别是数字9，6，4，0在nums的下标）。\n2对应大小为4，所以比它大的肯定存储在数组a[1-3]位置上。\n则此时需要用树状数组维护a[1-3]中下标最小的和次小的：分别是1，3。\n所以最终nums[3]=9是nums[0]=2的第二大的值。\n\n\n但有一个问题：如果有两个相同的数字呢？树状数组同一个位置上要存储两个最小的下标\n\n\n[2,4,4,6,4,4] ==&gt; mp[6:1, 4:2, 2:3]\n查询2时，已有数组a：[0, 3, {1,2,4,5}, 0]\n（3，{1,2,4,5}分别是数字6，4在nums的下标）。\n2对应大小为3，所以比它大的肯定存储在数组a[1-2]位置上。\n则此时需要用树状数组维护a[1-2]中下标中最小的和次小的。\n即3 + {1,2,4,5} = {1,2,3,4,5} 中最小的和次小的\n所以最终nums[2]=4是nums[0]=2的第二大的值。\n可以发现对4维护的下标1，2，4，5中4和5都是无用的：因为如果一个数比4小，那么最后最终取最小和次小下标时，4和5是肯定不会选中的，所以每次只要维护两个最小值即可\n\n代码\nclass Solution {public:    vector&lt;int&gt; secondGreaterElement(vector&lt;int&gt;&amp; nums) {        // 离散化        vector&lt;int&gt; tp = nums;        sort(tp.begin(), tp.end());        tp.erase(unique(tp.begin(), tp.end()), tp.end());        unordered_map&lt;int, int&gt; mp;        int n = nums.size(), m = tp.size();        for (int i = 0;i &lt; m;i++){            mp[tp[i]] = m-i;  // 大小翻转        }        // 树状数组模版        typedef pair&lt;int, int&gt; pii;        vector&lt;pii&gt; tr(m+1, pii(1e9, 1e9));        vector&lt;int&gt; ans(n, 0);        function&lt;void(int,int)&gt; upd = [&amp;](int dx, int val){            for (int i = dx;i &lt;= m;i += i&amp;-i){                // 因为nums下标是从后往前前遍历，后来的下标肯定比之前的小，所以直接更新即可。                tr[i].second = tr[i].first;                tr[i].first = val;            }        };        function&lt;int(int)&gt; qry = [&amp;](int dx){            int x = 1e9, y = 1e9;            for (int i = dx;i &gt; 0;i -= i&amp;-i){                // 每次取当前位置两个下标最小值和已经得到的进行对比                vector&lt;int&gt; cur = {x, y, tr[i].first, tr[i].second};                sort(cur.begin(), cur.end());                x = cur[0], y = cur[1];            }            return y == 1e9 ? -1 : nums[y];        };        for (int i = n-1;i &gt;= 0;i--){            ans[i] = qry(mp[nums[i]]-1);            upd(mp[nums[i]], i);        }              return ans;    }};\n复杂度分析\n\n时间：O(nlog n)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["树状数组","离散化"]},{"title":"Leetcode 2024-12-21 题目分享","url":"/2024/12/21/Leetcode-2024-12-21-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"2719.\n统计整数数目 [Hard] 题解\n经典数位DP题目+剪枝操作。\n\n2719.\n统计整数数目\n给你两个数字字符串 num1 和 num2\n，以及两个整数 max_sum 和 min_sum\n。如果一个整数 x 满足以下条件，我们称它是一个好整数：\n\nnum1 &lt;= x &lt;= num2\nmin_sum &lt;= digit_sum(x) &lt;= max_sum.\n\n请你返回好整数的数目。答案可能很大，请返回答案对\n10^9 + 7 取余后的结果。\n注意，digit_sum(x) 表示 x\n各位数字之和。\n示例 1：\n输入：num1 = \"1\", num2 = \"12\", min_num = 1, max_num = 8输出：11解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。\n示例 2：\n输入：num1 = \"1\", num2 = \"5\", min_num = 1, max_num = 5输出：5解释：数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。\n提示：\n\n1 &lt;= num1 &lt;= num2 &lt;= 10^22\n1 &lt;= min_sum &lt;= max_sum &lt;= 400\n\n思路\n\n针对数位问题，并且给了上界和下界；数据量超大 =&gt; 数位DP。\n详细解释在代码里。\n\n代码\nfunction count(num1: string, num2: string, min_sum: number, max_sum: number): number {    let N = 24, T = 401, M = 1e9 + 7;    // 用数组保存各个数位和，方便dfs使用。    let val = new Array(N).fill(0);    // DP数组：当前处理到第 i 位，数位和为 j 时的方案数。    let dp = new Array(N).fill(0).map(() =&gt; new Array(T).fill(-1));    // 记忆化搜索：当前处理到第 len 位，数位和为 sum，且上界限制为 f 时的方案数。    let dfs = (len: number, sum: number, f: boolean): number =&gt; {        // 遍历完了，看一下数位和是否满足条件。        if (len == 0) return sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum ? 1 : 0;        // 记忆化：（不考虑上界限制为true的，因为这种状态只可能有一种）        if (!f &amp;&amp; dp[len][sum] != -1) return dp[len][sum];        // up是可枚举的数位最大值：如果没有上界限制，可以一直枚举到9。        let res = 0, up = f ? val[len] : 9;        for (let i = 0; i &lt;= up; i++) {            // 剪枝操作：            // 1. sum已经超过了max，即使后面都选0，最终也是大于max的，不计入答案            // 2. sum加上后面所有数位都选最大值，仍然小于min，这也不会计入答案            if (sum + i &gt; max_sum || sum + i + (len - 1) * 9 &lt; min_sum) continue;            res = (res + dfs(len - 1, sum + i, f &amp;&amp; i == up)) % M;        }        if (!f) dp[len][sum] = res;        return res;    };    let getCnt = (num: string): number =&gt; {        val.fill(0);        for (let i = 0, n = num.length; i &lt; n; i++) {            val[i + 1] = parseInt(num[n - i - 1]);        }        return dfs(N - 1, 0, true);    };    // 单独检查一下num1是不是满足条件    // 因为最后dfs结果相减，求的是[num1+1, num2]区间答案。    let checkNum = (num: string): number =&gt; {        let sum = num.split('').reduce((pre: number, cur: string) =&gt; {            return parseInt(cur) + pre;        }, 0);        return sum &gt;= min_sum &amp;&amp; sum &lt;= max_sum ? 1 : 0;    };    return (getCnt(num2) - getCnt(num1) + checkNum(num1) + M) % M;};\n复杂度分析\n\n时间：O(10 * log num2 * max_sum)。DP数组一共有log num2 * max_sum个状态（数字的位数*各个数位和），而每一个状态需要10次遍历求解（枚举当前数位从0一直到9）。\n空间：O(log num2 * max_sum)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["动态规划","二分"]},{"title":"Leetcode 2025-02-24 题目分享","url":"/2025/02/24/Leetcode-2025-02-24-%E9%A2%98%E7%9B%AE%E5%88%86%E4%BA%AB/","content":"二叉搜索树最近节点查询\n[Medium] 题解\n有坑\n\n二叉搜索树最近节点查询\n给你一个 二叉搜索树 的根节点 root\n，和一个由正整数组成、长度为 n 的数组 queries\n。\n请你找出一个长度为 n 的 二维 答案数组\nanswer ，其中 answer[i] = [mini, maxi] ：\n\nmini 是树中小于等于 queries[i] 的\n最大值 。如果不存在这样的值，则使用 -1\n代替。\nmaxi 是树中大于等于 queries[i] 的\n最小值 。如果不存在这样的值，则使用 -1\n代替。\n\n返回数组 answer 。\n示例 1 ：\n输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]输出：[[2,2],[4,6],[15,-1]]解释：按下面的描述找出并返回查询的答案：- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。\n示例 2 ：\n输入：root = [4,null,9], queries = [3]输出：[[-1,4]]解释：树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。\n提示：\n\n树中节点的数目在范围 [2, 10^5] 内\n1 &lt;= Node.val &lt;= 10^6\nn == queries.length\n1 &lt;= n &lt;= 10^5\n1 &lt;= queries[i] &lt;= 10^6\n\n思路\n\n在搜索树中查找最大最小值问题，很容易让我们联想到使用搜索树的性质。\n- 中序遍历结果是有序的\n-\n左子树所有节点值小于根节点值；右子树所有节点值大于根节点值\n所以自然可以想到从上面两个性质出发去解决。\n但第一种方法需要将树遍历一次，然后再写二分来查找。\n我觉得麻烦，所以直接使用了第二种思路，得到如下代码。\n具体就是按性质 2\n遍历二叉搜索树：求出所有比目标值小的值中的最大值，以及比目标值大的值中的最小值。\n\nfunction closestNodes(root: TreeNode | null, queries: number[]): number[][] {    let ans:number[][] = [];    // 寻找最大最小值    const get = (val:number):number[] =&gt; {        let minv = -1, maxv = 1e7;        // dfs搜索        const search = (node:TreeNode) =&gt; {            let cur = node.val;            // 小于等于待查询值：更新minv，让minv变大            if (cur &lt;= val) minv = Math.max(minv, cur);            // 大于等于待查询值：更新maxv，让maxv变小            if (cur &gt;= val) maxv = Math.min(maxv, cur);            if (cur &gt; val &amp;&amp; node.left != null) search(node.left);            else if (cur &lt; val &amp;&amp; node.right != null) search(node.right);            else return;        };        search(root!);        return [minv, maxv==1e7?-1:maxv];    };    for (let q of queries) ans.push(get(q));    return ans;};\n\n看似复杂度是 O(n * log n)，但这是要求搜索树是平衡条件下！。\n对于一个不平衡的树，例如树退化为一条链。\n我们每次遍历仍需要遍历每一个节点，是 O(n)时间。\n只有在平衡的时候，每一次遍历才能节省一半的搜索数量！\n正解就是用二分 🙌\n\nfunction closestNodes(root: TreeNode | null, queries: number[]): number[][] {    let ans:number[][] = [], arr:number[] = [];    // 搞成有序数组    const dfs = (root:TreeNode | null) =&gt; {        if (root == null) return;        dfs(root!.left);        arr.push(root!.val);        dfs(root!.right);    };    // 二分查找    const get = (val:number):number[] =&gt; {        let l = 0, r = arr.length-1;        while (l &lt;= r){            let mid = l+r &gt;&gt; 1;            if (arr[mid] &lt;= val) l = mid+1;            else r = mid-1;        }        // 注意边界值 arr[r]代表小于val的最大值        if (r == -1) return [-1, arr[0]];        if (arr[r] == val) return [val, val];        return [arr[r], r==arr.length-1?-1:arr[r+1]];    };    dfs(root);    for (let q of queries) ans.push(get(q));    return ans;};\n复杂度分析\n\n时间：O(n * log n)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["二分","树"]},{"title":"Leetcode 331场周赛","url":"/2025/02/05/Leetcode-331%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 从数量最多的堆取走礼物\n[Easy] 题解\nQ2 6347.\n统计范围内的元音字符串数 - 力扣（Leetcode） [Medium] 题解\nQ3 6346.\n打家劫舍 IV - 力扣（LeetCode） [Medium] 题解\nQ4 6345.\n重排水果 - 力扣（LeetCode） [Hard] 题解\n\nQ1\n\n从数量最多的堆取走礼物\n给你一个整数数组 gifts\n，表示各堆礼物的数量。每一秒，你需要执行以下操作：\n\n选择礼物数量最多的那一堆。\n如果不止一堆都符合礼物数量最多，从中选择任一堆即可。\n选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。\n\n返回在 k 秒后剩下的礼物数量。\n示例 1：\n输入：gifts = [25,64,9,4,100], k = 4\n输出：29\n解释： \n按下述方式取走礼物：\n- 在第一秒，选中最后一堆，剩下 10 个礼物。\n- 接着第二秒选中第二堆礼物，剩下 8 个礼物。\n- 然后选中第一堆礼物，剩下 5 个礼物。\n- 最后，再次选中最后一堆礼物，剩下 3 个礼物。\n最后剩下的礼物数量分别是 [5,8,9,4,3] ，所以，剩下礼物的总数量是 29 。\n示例 2：\n输入：gifts = [1,1,1,1], k = 4\n输出：4\n解释：\n在本例中，不管选中哪一堆礼物，都必须剩下 1 个礼物。 \n也就是说，你无法获取任一堆中的礼物。 \n所以，剩下礼物的总数量是 4 。\n提示：\n\n1 &lt;= gifts.length &lt;= 10^3\n1 &lt;= gifts[i] &lt;= 10^9\n1 &lt;= k &lt;= 10^3\n\n\n思路\n​ 搞个堆模拟即可\n代码\nclass Solution {    public long pickGifts(int[] gifts, int k) {        long ans = 0;        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((x, y)-&gt;y-x);        for (int i : gifts) pq.add(i);        for (int i = 0;i &lt; k;i++){            int x = pq.poll();            int ne = (int)Math.floor(Math.sqrt(x));            pq.add(ne);        }        while (!pq.isEmpty()) ans += pq.poll();        return ans;    }}\n复杂度分析\n\n时间复杂度：O(klog n)\n空间复杂度：O(n)\n\nQ2\n\n6347.\n统计范围内的元音字符串数 - 力扣（Leetcode）\n给你一个下标从 0 开始的字符串数组 words\n以及一个二维整数数组 queries 。\n每个查询 queries[i] = [li, ri] 会要求我们统计在\nwords 中下标在 li 到 ri\n范围内（包含\n这两个值）并且以元音开头和结尾的字符串的数目。\n返回一个整数数组，其中数组的第 i 个元素对应第\ni 个查询的答案。\n注意：元音字母是\n'a'、'e'、'i'、'o'\n和 'u' 。\n示例 1：\n输入：words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]输出：[2,3,0]解释：以元音开头和结尾的字符串是 \"aba\"、\"ece\"、\"aa\" 和 \"e\" 。查询 [0,2] 结果为 2（字符串 \"aba\" 和 \"ece\"）。查询 [1,4] 结果为 3（字符串 \"ece\"、\"aa\"、\"e\"）。查询 [1,1] 结果为 0 。返回结果 [2,3,0] 。\n示例 2：\n输入：words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]输出：[3,2,1]解释：每个字符串都满足这一条件，所以返回 [3,2,1] 。\n提示：\n\n1 &lt;= words.length &lt;= 10^5\n1 &lt;= words[i].length &lt;= 40\nwords[i] 仅由小写英文字母组成\nsum(words[i].length) &lt;= 3 * 10^5\n1 &lt;= queries.length &lt;= 10^5\n0 &lt;= queries[j][0] &lt;= queries[j][1] &lt; words.length\n\n\n思路\nn, m数量级很容易让我们想到\nO(n) 预处理和 O(1)\n查询。因为题目中需要求一段区间里的符合条件数量，所以想到用前缀和。\n代码\nclass Solution:    def vowelStrings(self, w: List[str], q: List[List[int]]) -&gt; List[int]:        n, m = len(w), len(q)        ans = []        cnt = [0]*(n+1)        hs = set(['a', 'e', 'i', 'o', 'u'])        for i in range(1, n+1):            cur = w[i-1]            cnt[i] = cnt[i-1]            if cur[0] in hs and cur[len(cur)-1] in hs:                cnt[i] += 1        for i in range(m):            x, y = q[i][0], q[i][1]            ans.append(cnt[y+1]-cnt[x])        return ans\n复杂度分析\n\n时间复杂度：O(n + m)\n空间复杂度：O(n)\n\nQ3\n\n6346.\n打家劫舍 IV - 力扣（LeetCode）\n沿街有一排连续的房屋。每间房屋内都藏有一定的现金。现在有一位小偷计划从这些房屋中窃取现金。由于相邻的房屋装有相互连通的防盗系统，所以小偷\n不会窃取相邻的房屋 。小偷的 窃取能力\n定义为他在窃取过程中能从单间房屋中窃取的 最大金额\n。\n给你一个整数数组 nums\n表示每间房屋存放的现金金额。形式上，从左起第 i 间房屋中放有\nnums[i] 美元。另给你一个整数数组 k\n，表示窃贼将会窃取的 最少 房屋数。小偷总能窃取至少\nk 间房屋。返回小偷的 最小 窃取能力。\n示例 1：\n输入：nums = [2,3,5,9], k = 2输出：5解释：小偷窃取至少 2 间房屋，共有 3 种方式：- 窃取下标 0 和 2 处的房屋，窃取能力为 max(nums[0], nums[2]) = 5 。- 窃取下标 0 和 3 处的房屋，窃取能力为 max(nums[0], nums[3]) = 9 。- 窃取下标 1 和 3 处的房屋，窃取能力为 max(nums[1], nums[3]) = 9 。因此，返回 min(5, 9, 9) = 5 。\n示例 2：\n输入：nums = [2,7,9,3,1], k = 2输出：2解释：共有 7 种窃取方式。窃取能力最小的情况所对应的方式是窃取下标 0 和 4 处的房屋。返回 max(nums[0], nums[4]) = 2 。\n提示：\n\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^9\n1 &lt;= k &lt;= (nums.length + 1)/2\n\n\n思路\n最小的最大偷窃金额，完美符合最大化最小值和最小化最大值问题，一眼二分。\n再来思考给定一个最大偷窃金额 t，如何判断是否能偷 k 个。\n这里用贪心，从左往右遍历，如果金额小于 t,\n在判断前一个有没有偷：如果没偷，答案加一；如果偷了，那这次就不偷。\n代码\nclass Solution {    public int minCapability(int[] nums, int k) {        int n = nums.length;        int l = 1, r = (int)1e9;        while (l &lt;= r){            int m = l+r &gt;&gt; 1;            if (ck(nums, m, k)) r = m-1;            else l = m+1;        }return l;    }    public boolean ck(int[] nums, int t, int k){        int pre = -2, s = 0;        for (int i = 0;i &lt; nums.length;i++){            if (nums[i] &lt;= t){                if (i-pre &gt;= 2){                    s++;                    pre = i;                }            }        }return s &gt;= k;    }}\n复杂度分析\n\n时间复杂度：O(nlog m), m = max (nums[i])\n空间复杂度：O(1)\n\nTips\n\n最大化最小值和最小化最大值一般都是二分的代名词。具体主要思考两个问题：\n\n二分什么？（直接二分答案、二分第一个大于 a[i] 的数···）\ncheck()\n函数怎么实现？\n\n\nQ4\n\n6345.\n重排水果 - 力扣（LeetCode）\n你有两个果篮，每个果篮中有 n 个水果。给你两个下标从\n0 开始的整数数组 basket1 和\nbasket2 ，用以表示两个果篮中每个水果的成本。\n你希望两个果篮相等。为此，可以根据需要多次执行下述操作：\n\n选中两个下标 i 和 j ，并交换\nbasket1 中的第 i 个水果和 basket2\n中的第 j 个水果。\n交换的成本是 min(basket1i,basket2j) 。\n\n根据果篮中水果的成本进行排序，如果排序后结果完全相同，则认为两个果篮相等。\n返回使两个果篮相等的最小交换成本，如果无法使两个果篮相等，则返回\n-1 。\n示例 1：\n输入：basket1 = [4,2,2,2], basket2 = [1,4,1,2]输出：1解释：交换 basket1 中下标为 1 的水果和 basket2 中下标为 0 的水果，交换的成本为 1 。此时，basket1 = [4,1,2,2] 且 basket2 = [2,4,1,2] 。重排两个数组，发现二者相等。\n示例 2：\n输入：basket1 = [2,3,4,1], basket2 = [3,2,5,1]输出：-1解释：可以证明无法使两个果篮相等。\n提示：\n\nbasket1.length == bakste2.length\n1 &lt;= basket1.length &lt;= 1^05\n1 &lt;= basket1i,basket2i &lt;= 10^9\n\n\n思路\n首先统计每种水果的总数，如果某种水果出现奇数次答案为 False。\n其次统计两个篮子中多出的水果 X, Y\n，即需要交换掉的水果。对于每个水果，有两种删除方式：\n\n用 x 和 y\n里的最小值与另一个数组里的最大值进行配对。这样经过一次操作就能删除 x 和 y 里各一个元素。\n借助所有水果里的最小值进行配对。假设最小值为 k, 则将第一个篮子中 k1与 k 交换，消耗 k ；再将第二个篮子中 k2 与 k 交换， 消耗 k，且 k 这个水果重新回到原来的篮子。\n\n代码\nclass Solution:    def minCost(self, b1: List[int], b2: List[int]) -&gt; int:        d1,d2 = defaultdict(int),defaultdict(int)        d = defaultdict(int)        for i in b1: d1[i] += 1        for i in b2: d2[i] += 1        for i in b1+b2: d[i] += 1        for i in d:            if d[i]%2 == 1: return -1        a = []        for i in d1:            if d1[i]&gt;d[i]//2: a.extend([i]*(d1[i]-d[i]//2))        for i in d2:            if d2[i]&gt;d[i]//2: a.extend([i]*(d2[i]-d[i]//2))        a.sort()        ans, minv = 0, min(i for i in d)        for i in range(len(a)//2):            ans += min(2*minv, a[i])        return ans\n复杂度分析\n\n时间复杂度：O(nlog n)\n空间复杂度：O(n)\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["模拟","贪心","二分","前缀和","构造"]},{"title":"Leetcode 332场周赛","url":"/2025/02/12/Leetcode-332%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 6354.\n找出数组的串联值 - 力扣（Leetcode） [Easy] 题解\nQ2 6355.\n统计公平数对的数目 - 力扣（LeetCode） [Medium] 题解\nQ3 6356.\n子字符串异或查询 - 力扣（Leetcode） [Medium] 题解\nQ4 6357.\n最少得分子序列 - 力扣（Leetcode） [Hard] 题解\n\nQ1\n\n6354.\n找出数组的串联值 - 力扣（Leetcode）\n给你一个下标从 0 开始的整数数组 nums\n。\n现定义两个数字的 串联\n是由这两个数值串联起来形成的新数字。\n\n例如，15 和 49 的串联是 1549\n。\n\nnums 的 串联值 最初等于 0\n。执行下述操作直到 nums 变为空：\n\n如果 nums 中存在不止一个数字，分别选中\nnums 中的第一个元素和最后一个元素，将二者串联得到的值加到\nnums 的 串联值 上，然后从\nnums 中删除第一个和最后一个元素。\n如果仅存在一个元素，则将该元素的值加到 nums\n的串联值上，然后删除这个元素。\n\n返回执行完所有操作后 nums 的串联值。\n示例 1：\n输入：nums = [7,52,2,4]输出：596\n示例 2：\n输入：nums = [5,14,13,8,12]输出：673\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 10^4\n\n\n思路\n​ 遍历模拟\n代码\nclass Solution:    def findTheArrayConcVal(self, nums: List[int]) -&gt; int:        ans = 0        n = len(nums)        for i in range(n//2):            tp = str(nums[i])+str(nums[n-i-1])            ans += int(tp)        if n%2 == 1:            ans += nums[n//2]        return ans\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\nQ2\n\n6355.\n统计公平数对的数目 - 力扣（LeetCode）\n给你一个下标从 0 开始、长度为 n\n的整数数组 nums ，和两个整数 lower 和\nupper ，返回 公平数对的数目 。\n如果 (i, j) 数对满足以下情况，则认为它是一个\n公平数对 ：\n\n0 &lt;= i &lt; j &lt; n，且\nlower &lt;= nums[i] + nums[j] &lt;= upper\n\n示例 1：\n输入：nums = [0,1,7,4,4,5], lower = 3, upper = 6输出：6解释：共计 6 个公平数对：(0,3)、(0,4)、(0,5)、(1,3)、(1,4) 和 (1,5) 。\n示例 2：\n输入：nums = [1,7,9,2,5], lower = 11, upper = 11输出：1解释：只有单个公平数对：(2,3) 。\n提示：\n\n1 &lt;= nums.length &lt;= 10^5\nnums.length == n\n-109 &lt;= nums[i] &lt;= 10^9\n-109 &lt;= lower &lt;= upper &lt;= 10^9\n\n\n思路\n😅😅😅\n最初想法就是，顺序遍历，对于遍历到的nums[i], 找到前面在 [lower − nums[i], upper − nums[i]]范围中的数：离散化+树状数组。\n但，这是Q2。。。随即又想到了SortedList，但不知道有没有这种数据结构。（得单独写个API使用文档👨‍🦲）\n写完第三题，回来看才想到排序。。。因为最后要求的是数对数量，和元素顺序没有关系。\n这样就不用SortedList了，直接排序后两次二分就行了。\n代码\nclass Solution {    public long countFairPairs(int[] nums, int lower, int upper) {        long ans = 0;        int n = nums.length;        Arrays.sort(nums);        for(int i = 0;i &lt; n;i++){            int lo = lower-nums[i], up = upper-nums[i];            int l = i+1, r = n-1;            while (l &lt;= r){                int m = l+r &gt;&gt; 1;                if (nums[m] &gt;= lo) r = m-1;                else l = m+1;            }            int l1 = i+1, r1 = n-1;            while (l1 &lt;= r1){                int m = l1+r1 &gt;&gt; 1;                if (nums[m] &lt;= up) l1 = m+1;                else r1 = m-1;            }            if (l&lt;=n-1 &amp;&amp; r1 &gt; i) ans += (r1-l+1);        }        return ans;    }}\n复杂度分析\n\n时间复杂度：O(nlog n)\n空间复杂度：O(1)\n\nQ3\n\n6356.\n子字符串异或查询 - 力扣（Leetcode）\n给你一个 二进制字符串 s 和一个整数数组\nqueries ，其中 queries[i] = [firsti, secondi]\n。\n对于第 i 个查询，找到 s 的\n最短子字符串 ，它对应的 十进制值\nval 与 firsti 按位异或 得到\nsecondi ，换言之，val ^ firsti == secondi\n。\n第 i 个查询的答案是子字符串 [lefti, righti]\n的两个端点（下标从 0\n开始），如果不存在这样的子字符串，则答案为 [-1, -1]\n。如果有多个答案，请你选择 lefti 最小的一个。\n请你返回一个数组 ans ，其中\nans[i] = [lefti, righti] 是第 i\n个查询的答案。\n子字符串 是一个字符串中一段连续非空的字符序列。\n示例 1：\n输入：s = \"101101\", queries = [[0,5],[1,2]]输出：[[0,2],[2,3]]解释：第一个查询，端点为 [0,2] 的子字符串为 \"101\" ，对应十进制数字 5 ，且 5 ^ 0 = 5 ，所以第一个查询的答案为 [0,2]。第二个查询中，端点为 [2,3] 的子字符串为 \"11\" ，对应十进制数字 3 ，且 3 ^ 1 = 2 。所以第二个查询的答案为 [2,3] 。\n示例 2：\n输入：s = \"0101\", queries = [[12,8]]输出：[[-1,-1]]解释：这个例子中，没有符合查询的答案，所以返回 [-1,-1] 。\n提示：\n\n1 &lt;= s.length &lt;= 104\ns[i] 要么是 '0' ，要么是 '1'\n。\n1 &lt;= queries.length &lt;= 10^5\n0 &lt;= firsti, secondi &lt;= 10^9\n\n\n思路\n异或性质val ^ firsti = secondi =&gt; val == secondi ^ firsti\n所以对于每个查询，找到两个数异或值有没有在s中出现就行。\n但s长度很大，要预处理。对于查询中的任何两个数异或都是32位范围内，所以枚举每一个s[i]作为起点，再枚举二进制数的长度1~31，暴力求出所有可能的值。\n代码\nclass Solution:    def substringXorQueries(self, s: str, q: List[List[int]]) -&gt; List[List[int]]:        m = len(q)        n = len(s)        ans = [[-1, -1] for i in range(m)]        dic = {}        for i in range(n):            for j in range(i, min(i+32, n)):                v = s[i:j+1]                if v not in dic or j-i &lt; dic[v][1]-dic[v][0]:                    dic[v] = [i, j]        for i in range(m):            v = q[i][0]^q[i][1]            x = bin(v)[2:]            if x in dic:                ans[i] = dic[x]        return ans\n复杂度分析\n\n时间复杂度：O(nlog m), m = max (nums[i])\n空间复杂度：O(nlog m)\n\nQ4\n\n6357.\n最少得分子序列 - 力扣（Leetcode）\n给你两个字符串 s 和 t 。你可以从字符串\nt 中删除任意数目的字符。\n如果没有从字符串 t 中删除字符，那么得分为 0\n，否则：\n\n令 left 为删除字符中的最小下标。\n令 right 为删除字符中的最大下标。\n\n字符串的得分为 right - left + 1 。请你返回使\nt 成为 s 子序列的最小得分。\n一个字符串的 子序列\n是从原字符串中删除一些字符后（也可以一个也不删除），剩余字符不改变顺序得到的字符串。（比方说\n\"ace\" 是 \"abcde\" 的子序列，但是\n\"aec\" 不是）。\n示例 1：\n输入：s = \"abacaba\", t = \"bzaa\"输出：1解释：这个例子中，我们删除下标 1 处的字符 \"z\" （下标从 0 开始）。字符串 t 变为 \"baa\" ，它是字符串 \"abacaba\" 的子序列，得分为 1 - 1 + 1 = 1 。1 是能得到的最小得分。\n示例 2：\n输入：s = \"cde\", t = \"xyz\"输出：3解释：这个例子中，我们将下标为 0， 1 和 2 处的字符 \"x\" ，\"y\" 和 \"z\" 删除（下标从 0 开始）。字符串变成 \"\" ，它是字符串 \"cde\" 的子序列，得分为 2 - 0 + 1 = 3 。3 是能得到的最小得分。\n提示：\n\n1 &lt;= s.length, t.length &lt;= 10^5\ns 和 t 都只包含小写英文字母。\n\n\n思路\n因为得分是 right − left + 1，只与两端的位置有关。所以为了更可能删除后能匹配s的子序列，我们需要把\nleft, right\n间所有字符删除。于是，题目变成删除t中的子字符串 s[left, right]\n后能与s子序列匹配。\n即若 t[0, left − 1]\n是 s[0, k] 子序列，\nt[right + 1, m − 1]\n是 s[k + 1, n − 1]\n子序列，则答案是right − left + 1\n则我们需要预处理 s[ : i] 对应的 t\n的最长前缀的结束下标，s[i : ] 对应的 t\n的最长后缀的开始下标​。\n代码\nclass Solution:    def minimumScore(self, s: str, t: str) -&gt; int:        n, m = len(s), len(t)        pre, suf = [0]*n, [0]*n        p, ans = 0, m        # 预处理前缀 pre[i] = k: t[0:k-1]是s[0:i]的子序列        for i in range(n):            if p &lt; m and s[i] == t[p]: p += 1            pre[i] = p        p = m-1        # 预处理前缀 suf[i] = k: t[k+1:m-1]是s[i:n-1]的子序列        for i in range(n-1, -1, -1):            if p &gt;= 0 and s[i] == t[p]: p -= 1            suf[i] = p        for i in range(n-1):            x, y = pre[i], suf[i+1]            ans = min(ans, y-x+1)        # 单独处理 边界情况 全是前缀和全是后缀        ans = min(ans, m-pre[n-1], suf[0]+1)        return max(ans, 0) #负数代表不用删，就是0\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["模拟","二分","异或","位枚举","子序列"]},{"title":"Leetcode 344场周赛","url":"/2023/02/26/Leetcode-344%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 6369.\n左右元素和的差值 - 力扣（Leetcode） [Easy] 题解\nQ2 6368.\n找出字符串的可整除数组 - 力扣（Leetcode） [Medium] 题解\nQ3 6367.\n求出最多标记下标 - 力扣（Leetcode） [Medium] 题解\nQ4 6366.\n在网格图中访问一个格子的最少时间 - 力扣（Leetcode） [Hard] 题解\n\nQ1\n\n6369.\n左右元素和的差值 - 力扣（Leetcode）\n求出数组中每个数左边所有数和右边所有数的差的绝对值。\n\n思路\n​ 遍历模拟，可以用前缀和加快处理。\n代码\nclass Solution:    def leftRigthDifference(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        l, r = [0]*(n+2), [0]*(n+2)        for i in range(1, n+1):            l[i] = l[i-1]+nums[i-1]        for i in range(n, 0, -1):            r[i] = r[i+1]+nums[i-1]        ans = [0]*n        for i in range(n):            ans[i] = abs(l[i]-r[i+2])        return ans\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n\nQ2\n\n6368.\n找出字符串的可整除数组 - 力扣（Leetcode）\n给你一个下标从 0 开始的字符串 word\n，长度为 n ，由从 0 到 9\n的数字组成。另给你一个正整数 m 。\nword 的 可整除数组 div\n是一个长度为 n 的整数数组，并满足：\n\n如果 word[0,...,i] 所表示的 数值 能被\nm 整除，div[i] = 1\n否则，div[i] = 0\n\n返回 word 的可整除数组。\n\n思路\n从左到右遍历，并维持word[0,…i]的和。\n在求和过程中，把每次求出的和对m取模，这样不会影响判断。\n当和为0，说明可以整除。\n代码\nclass Solution:    def divisibilityArray(self, word: str, m: int) -&gt; List[int]:        n = len(word)        ans, tp = [0]*n, 0        for i in range(n):            tp = (tp*10%m+int(word[i]))%m            if tp == 0:                ans[i] = 1        return ans\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\nQ3\n\n6367.\n求出最多标记下标 - 力扣（Leetcode）\n给你一个下标从 0 开始的整数数组 nums\n。\n一开始，所有下标都没有被标记。你可以执行以下操作任意次：\n\n选择两个 互不相同且未标记 的下标 i 和\nj ，满足 2 * nums[i] &lt;= nums[j] ，标记下标\ni 和 j 。\n\n请你执行上述操作任意次，返回 nums\n中最多可以标记的下标数目。\n\n思路\n\n首先这题所求i和j并没有位置约束，所以可以先对数组排序。\n贪心思考。假设可以标记 2 * m\n个下标（标记成对出现），那么选择前m个最小的数，和后m个最大的数是最优的。\n如果可以标记k对，那么一定可以标记k-1对。从k对中任意删去一对即可。二分答案。\n\n代码\nclass Solution {    boolean ck(int[] nums, int t, int n){        for (int i = 0;i &lt; t;i++){            if (nums[i]*2 &gt; nums[n-t+i]) return false;        }return true;    }    public int maxNumOfMarkedIndices(int[] nums) {        int n = nums.length;        Arrays.sort(nums);        int l = 0, r = n/2;        while (l &lt;= r){            int m = l+r &gt;&gt; 1;            if (ck(nums, m, n)) l = m+1;            else r = m-1;        }return r*2;    }}\n复杂度分析\n\n时间复杂度：O(nlog n)。\n空间复杂度：O(1)\n\nQ4\n\n6366.\n在网格图中访问一个格子的最少时间 - 力扣（Leetcode）\n给你一个 m x n 的矩阵 grid ，每个元素都为\n非负 整数，其中 grid[row][col]\n表示可以访问格子 (row, col) 的 最早\n时间。也就是说当你访问格子 (row, col)\n时，最少已经经过的时间为 grid[row][col] 。\n你从 最左上角 出发，出发时刻为 0\n，你必须一直移动到上下左右相邻四个格子中的 任意\n一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。\n请你返回 最早\n到达右下角格子的时间，如果你无法到达右下角的格子，请你返回\n-1 。\n\n思路\n\n不考虑grid限制，就是一个BFS最短路。\n考虑grid限制，在BFS转移时有三种情况：\n\n\n大于等于最少经过时间，直接在原时间上+1\n最少经过时间与当前时间同奇偶，转移后时间为最少经过时间+1\n最少经过时间与当前时间同奇偶，转移后时间为最少经过时间\n\n\n这样BFS每走一步时间不一定只增加1，所以需要用优先队列来获得当前最短的时间\n\n代码\nclass Solution {    public int minimumTime(int[][] g) {        if (g[0][1]&gt;1 &amp;&amp; g[1][0]&gt;1) return -1;        int n = g.length, m = g[0].length;        boolean[][] v = new boolean[n][m];        int[] dx={0,0,-1,1}, dy={1,-1,0,0};        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(            (x, y) -&gt; x[2]-y[2]        );        pq.add(new int[]{0, 0, 0});        while (!pq.isEmpty()){            int[] cur = pq.poll();            int x = cur[0], y = cur[1], c = cur[2];            if (x == n-1 &amp;&amp; y == m-1) return c;            if (v[x][y]) continue;            v[x][y] = true;            for (int k = 0;k &lt; 4;k++){                int nx = x+dx[k], ny = y+dy[k];                if (nx&lt;0||ny&lt;0||nx&gt;=n||ny&gt;=m) continue;                if (c+1 &gt;= g[nx][ny]){                    pq.add(new int[]{nx, ny, c+1});                }else if (g[nx][ny]%2 == c%2){                    pq.add(new int[]{nx, ny, g[nx][ny]+1});                }else{                    pq.add(new int[]{nx, ny, g[nx][ny]});                }            }        }return -1;    }}\n复杂度分析\n\n时间复杂度：O(nmlog nm)\n空间复杂度：O(nm)\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["模拟","贪心","二分","BFS","前缀和","优先队列"]},{"title":"Leetcode 360场周赛","url":"/2023/08/27/Leetcode-360%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q4 2835.\n使子序列的和等于目标的最少操作次数 - 力扣（LeetCode） [Hard]\n题解\n\nLeetcode\n\n2835.\n使子序列的和等于目标的最少操作次数 - 力扣（LeetCode）\n给你一个下标从 0 开始的数组 nums\n，它包含 非负 整数，且全部为 2\n的幂，同时给你一个整数 target 。\n一次操作中，你必须对数组做以下修改：\n\n选择数组中一个元素 nums[i] ，满足\nnums[i] &gt; 1 。\n将 nums[i] 从数组中删除。\n在 nums 的 末尾 添加\n两个 数，值都为 nums[i] / 2 。\n\n你的目标是让 nums 的一个 子序列\n的元素和等于 target ，请你返回达成这一目标的\n最少操作次数 。如果无法得到这样的子序列，请你返回\n-1 。\n数组中一个 子序列\n是通过删除原数组中一些元素，并且不改变剩余元素顺序得到的剩余数组。\n示例 1：\n输入：nums = [1,2,8], target = 7输出：1解释：第一次操作中，我们选择元素 nums[2] 。数组变为 nums = [1,2,4,4] 。这时候，nums 包含子序列 [1,2,4] ，和为 7 。无法通过更少的操作得到和为 7 的子序列。\n示例 2：\n输入：nums = [1,32,1,2], target = 12输出：2解释：第一次操作中，我们选择元素 nums[1] 。数组变为 nums = [1,1,2,16,16] 。第二次操作中，我们选择元素 nums[3] 。数组变为 nums = [1,1,2,16,8,8] 。这时候，nums 包含子序列 [1,1,2,8] ，和为 12 。无法通过更少的操作得到和为 12 的子序列。\n示例 3：\n输入：nums = [1,32,1], target = 35输出：-1解释：无法得到和为 35 的子序列。\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 2^30\nnums 只包含非负整数，且均为 2 的幂。\n1 &lt;= target &lt; 2^31\n\n\n思路\n数组中每个数最后都可以分成若干个1\n，因此如果数组元素和小于target返回-1，否则一定有解。\n然后将target分解到每一位，从低位到高位依次遍历，遍历过程中一同计算未被使用的数值和\npre。\n\n如果 target 的第 i 位是 0\n，跳过。\n如果 target 的第 i 位是 1\n：\n\npre大于等于2i，说明这一位代表的数值可以被之前遍历到的数相加得到。（因为每个数最后都可以变为1，所以只要大于等于它，就一定可以表示出）\n反之说明需要往前找到target第一个1的位置，将它不断一分为二到当前位，同时更新ans。\n\n\n代码\nint minOperations(vector&lt;int&gt;&amp; nums, int target) {    int n = nums.size();    unordered_map&lt;int, int&gt; mp;    for (int i = 0;i &lt;= 30;i++) mp[(1&lt;&lt;i)] = i;    // cnt[i]表示nums中的数等于1&lt;&lt;i的数量    vector&lt;int&gt; cnt(31, 0);    for (int i = 0;i &lt; n;i++) cnt[mp[nums[i]]]++;    int ans = 0;    long long pre = 0;    // 从低到高遍历每一位    for (int i = 0;i &lt;= 30;i++){        pre += 1L*cnt[i]*(1&lt;&lt;i);        int x = (target &gt;&gt; i &amp; 1), val = x*(1&lt;&lt;i);        // 小于pre 直接可以凑出 1&lt;&lt;i 了，减去被使用的值        if (val &lt;= pre){            pre -= val;            continue;        }      \t// 向前找到第一个1        int f = 0, j = i+1;        for (;j &lt;= 30 &amp;&amp; f == 0;j++){            if (cnt[j] != 0){                f = 1;                break;            }            cnt[j]++;            ans++;        }        if (f == 0) return -1;        cnt[j]--;        ans++;        pre += (1&lt;&lt;i);    }    return ans;}\n复杂度分析\n\n时间复杂度: O(log n)\n空间复杂度: O(log n)\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["贪心","位运算"]},{"title":"Leetcode 374场周赛","url":"/2023/12/10/Leetcode-374%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 100143.\n统计已测试设备 [Easy] 题解\nQ2 100155.\n双模幂运算 [Medium] 题解\nQ3 100137.\n统计最大元素出现至少 K 次的子数组 [Hard] 题解\nQ4 100136.\n统计好分割方案的数目 [Hard] 题解\n\n100143.\n统计已测试设备\n给你一个长度为 n 、下标从 0\n开始的整数数组 batteryPercentages ，表示 n\n个设备的电池百分比。\n你的任务是按照顺序测试每个设备 i，执行以下测试操作：\n\n如果 batteryPercentages[i]大于 0：\n\n增加 已测试设备的计数。\n将下标在 [i + 1, n - 1] 的所有设备的电池百分比减少\n1，确保它们的电池百分比 不会低于\n0 ，即\nbatteryPercentages[j] = max(0, batteryPercentages[j] - 1)。\n移动到下一个设备。\n\n否则，移动到下一个设备而不执行任何测试。\n\n返回一个整数，表示按顺序执行测试操作后 已测试设备\n的数量。\n思路\n​ 暴力模拟一下\n代码\nclass Solution {public:    int countTestedDevices(vector&lt;int&gt;&amp; batteryPercentages) {        int n = batteryPercentages.size();        int ans = 0;        for (int i = 0;i &lt; n;i++){            if (batteryPercentages[i] &gt; 0){                ans++;                for (int j = i+1;j &lt; n;j++){                    batteryPercentages[j] = max(0, batteryPercentages[j] - 1);                }            }        }        return ans;    }};\n复杂度分析\n\n时间：O(n)。\n空间：O(1)。\n\n100155.\n双模幂运算\n给你一个下标从 0 开始的二维数组\nvariables ，其中\nvariables[i] = [ai, bi, ci, mi]，以及一个整数\ntarget 。\n如果满足以下公式，则下标 i 是\n好下标：\n\n0 &lt;= i &lt; variables.length\n((ai^bi % 10)^ci) % mi == target\n\n返回一个由 好下标\n组成的数组，顺序不限 。\n思路\n\n用 python 自带的pow函数，可以传入取模参数。\nC++手写一个快速幂。\n\n代码\npython\nclass Solution:    def getGoodIndices(self, variables: List[List[int]], target: int) -&gt; List[int]:        ans = []        x = 0        for a, b, c, m in variables:            tp = pow(a, b, 10)            if pow(tp, c, m) == target:                ans.append(x)            x += 1        return ans\nC++\nclass Solution {public:    vector&lt;int&gt; getGoodIndices(vector&lt;vector&lt;int&gt;&gt;&amp; variables, int target) {        vector&lt;int&gt; ans;        typedef long long ll;        function&lt;int(ll, ll, ll)&gt; qpow = [&amp;](ll a, ll b, ll m){            ll res = 1;            while (b){                if (b&amp;1) res = (res*a)%m;                a = a*a%m;                b &gt;&gt;= 1;            }            return (int)res;        };        int x = 0;        for (vector&lt;int&gt;&amp; x : variables){            int a = x[0], b = x[1], c = x[2], m = x[3];            if (qpow(qpow(a, b, 10), c, m) == target){                ans.push_back(x);            }            x += 1;        }        return ans;    }};\n复杂度分析\n\n时间：O(n*log v)。n，v\n分别是 variables 数组长度和 bi, ci 最大值。\n空间：O(1)。\n\n100137.\n统计最大元素出现至少 K 次的子数组\n给你一个整数数组 nums 和一个 正整数\nk 。\n请你统计有多少满足 「 nums 中的 最大\n元素」至少出现 k\n次的子数组，并返回满足这一条件的子数组的数目。\n子数组是数组中的一个连续元素序列。\n思路\n​ 一开始看成恰好出现 k 次了\n​ 枚举子数组的结尾i，再维护下标 j (nums[j]=MAXV)表示区间 [j, i]中有\nk 个最大值，那么区间 [1, i], [2, i], ⋯,\n[j, i]都是符合要求的区间。因此答案增加 j。\n代码\nclass Solution {public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size(), maxv = *max_element(nums.begin(), nums.end()), cnt = 0;        vector&lt;int&gt; idx;        for (int i = 0;i &lt; n;i++){            if (nums[i] == maxv){                idx.push_back(i);                cnt++;            }        }        if (cnt &lt; k) return 0;        long long ans = 0;        for (int i = 0, j = 0;i &lt; n;i++){            if (j &lt; cnt &amp;&amp; idx[j] &lt;= i) j++;            if (j &gt;= k){                ans += idx[j-k]+1L;            }        }        return ans;    }};\n复杂度分析\n\n时间：O(n)。\n空间：O(n)。\n\n100136.\n统计好分割方案的数目\n给你一个下标从 0 开始、由 正整数\n组成的数组 nums。\n将数组分割成一个或多个 连续\n子数组，如果不存在包含了相同数字的两个子数组，则认为是一种\n好分割方案 。\n返回 nums 的 好分割方案 的\n数目。\n由于答案可能很大，请返回答案对 109 + 7\n取余 的结果。\n思路\n\n首先找出该数组究竟可以分成几段区间\n\n利用哈希表记录所有元素最后出现的位置\n依次遍历，同时维护遍历到的元素最后出现位置的最大值。\n如果遍历的下标大于之前遍历的元素最后出现位置的最大值，则说明可以成为一段\n\n\n分割方案就相当于：对这 t 个不相交的区间有多少种合并方式。相当于往 t\n个区间中插入\n0,1,2…(t-1)个板子，两两板子之间的区间进行合并。组合数学中经典隔板法。\n\n\n代码\nclass Solution {public:    int numberOfGoodPartitions(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        unordered_map&lt;int, int&gt; mp;        for (int i = 0;i &lt; n;i++){            mp[nums[i]] = i;        }        int cnt = 0;        for (int i = 0;i &lt; n;){            int j = i, ed = mp[nums[j]];            while (j &lt;= ed){                ed = max(ed, mp[nums[j]]);                j++;            }            cnt++;            i = j;        }        typedef long long ll;        function&lt;int(ll, ll, ll)&gt; qpow = [&amp;](ll a, ll b, ll m){            ll res = 1;            while (b){                if (b&amp;1) res = (res*a)%m;                a = a*a%m;                b &gt;&gt;= 1;            }            return (int)res;        };        long long M = 1e9+7, ans = qpow(2, cnt-1, M);        return (int)ans;    }};\n复杂度分析\n\n时间：O(n)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["模拟","动态规划","滑动窗口","快速幂"]},{"title":"Leetcode 383场周赛","url":"/2024/02/04/Leetcode-383%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 100214.\n边界上的蚂蚁 [Easy] 题解\nQ2 100189.\n找出网格的区域平均强度 [Medium] 题解\nQ3 100203.\n将单词恢复初始状态所需的最短时间 [Hard] 题解\n\n100214.\n边界上的蚂蚁\n边界上有一只蚂蚁，它有时向 左 走，有时向\n右 走。\n给你一个 非零 整数数组 nums\n。蚂蚁会按顺序读取 nums\n中的元素，从第一个元素开始直到结束。每一步，蚂蚁会根据当前元素的值移动：\n\n如果 nums[i] &lt; 0 ，向 左 移动\n-nums[i]单位。\n如果 nums[i] &gt; 0 ，向 右 移动\nnums[i]单位。\n\n返回蚂蚁 返回 到边界上的次数。\n注意：\n\n边界两侧有无限的空间。\n只有在蚂蚁移动了 |nums[i]|\n单位后才检查它是否位于边界上。换句话说，如果蚂蚁只是在移动过程中穿过了边界，则不会计算在内。\n\n示例 1：\n输入：nums = [2,3,-5]输出：1解释：第 1 步后，蚂蚁距边界右侧 2 单位远。第 2 步后，蚂蚁距边界右侧 5 单位远。第 3 步后，蚂蚁位于边界上。所以答案是 1 。\n示例 2：\n输入：nums = [3,2,-3,-4]输出：0解释：第 1 步后，蚂蚁距边界右侧 3 单位远。第 2 步后，蚂蚁距边界右侧 5 单位远。第 3 步后，蚂蚁距边界右侧 2 单位远。第 4 步后，蚂蚁距边界左侧 2 单位远。蚂蚁从未返回到边界上，所以答案是 0 。\n提示：\n\n1 &lt;= nums.length &lt;= 100\n-10 &lt;= nums[i] &lt;= 10\nnums[i] != 0\n\n思路\n​ 模拟一下即可。\n代码\nfunction returnToBoundaryCount(nums: number[]): number {    let ans = 0, sum = 0;    nums.forEach(v =&gt; {        sum += v;        if (sum == 0){            ans++;        }    });    return ans;};\n复杂度分析\n\n时间：O(n)。\n空间：O(1)。\n\n100189.\n找出网格的区域平均强度\n给你一个下标从 0 开始、大小为 m x n\n的网格 image ，表示一个灰度图像，其中\nimage[i][j] 表示在范围 [0..255]\n内的某个像素强度。另给你一个 非负 整数\nthreshold 。\n如果 image[a][b] 和 image[c][d] 满足\n|a - c| + |b - d| == 1 ，则称这两个像素是\n相邻像素 。\n区域 是一个 3 x 3\n的子网格，且满足区域中任意两个 相邻\n像素之间，像素强度的 绝对差 小于或等于\nthreshold 。\n区域 内的所有像素都认为属于该区域，而一个像素\n可以 属于 多个 区域。\n你需要计算一个下标从 0 开始、大小为\nm x n 的网格 result ，其中\nresult[i][j] 是 image[i][j] 所属区域的\n平均 强度，向下取整\n到最接近的整数。如果 image[i][j]\n属于多个区域，result[i][j] 是这些区域的\n“取整后的平均强度” 的 平均值，也\n向下取整 到最接近的整数。如果 image[i][j]\n不属于任何区域，则 result[i][j] 等于\nimage[i][j] 。\n返回网格 result 。\n示例 1：\n\n\nimg\n\n输入：image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]解释：图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 9 ，而第二个区域的平均强度为 9.67 ，向下取整为 9 。两个区域的平均强度为 (9 + 9) / 2 = 9 。由于所有像素都属于区域 1 、区域 2 或两者，因此 result 中每个像素的强度都为 9 。注意，在计算多个区域的平均值时使用了向下取整的值，因此使用区域 2 的平均强度 9 来进行计算，而不是 9.67 。\n示例 2：\n\n\nimg\n\n输入：image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]解释：图像中存在两个区域，如图片中的阴影区域所示。第一个区域的平均强度为 25 ，而第二个区域的平均强度为 30 。两个区域的平均强度为 (25 + 30) / 2 = 27.5 ，向下取整为 27 。图像中第 0 行的所有像素属于区域 1 ，因此 result 中第 0 行的所有像素为 25 。同理，result 中第 3 行的所有像素为 30 。图像中第 1 行和第 2 行的像素属于区域 1 和区域 2 ，因此它们在 result 中的值为 27 。\n示例 3：\n输入：image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1输出：[[5,6,7],[8,9,10],[11,12,13]]解释：图像中不存在任何区域，因此对于所有像素，result[i][j] == image[i][j] 。\n提示：\n\n3 &lt;= n, m &lt;= 500\n0 &lt;= image[i][j] &lt;= 255\n0 &lt;= threshold &lt;= 255\n\n思路\n​ 阅读理解题。\n\n遍历每一个3X3方格。\n维护一个dp数组：dp(i)(j)[0]表示该像素所属区域强度和，dp(i)(j)[1]表示该像素总共属于多少个区域。\n判断该方格是否为一个区域：即判断相邻格子像素差是否小于threshold\n如果是区域：则再次遍历区域中每一个像素，维护dp数组值。\n最后dp(i)(j)[0]/dp(i)(j)[1]则是每个像素所属区域强度和的均值；\n如果dp(i)(j)[0]等于0，说明像素不属于任何一个区域，答案是它自己像素值。\n\n代码\nclass Solution {public:    vector&lt;vector&lt;int&gt;&gt; resultGrid(vector&lt;vector&lt;int&gt;&gt;&amp; image, int threshold) {        int n = image.size(), m = image[0].size();        vector&lt;vector&lt;int&gt;&gt; ans(n, vector&lt;int&gt;(m, 0));        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(2, 0)));        for (int i = 0;i &lt;= n-3;i++){            for (int j = 0;j &lt;= m-3;j++){                int flag = 1, sum = 0;                for (int k = 0;k &lt; 3 &amp;&amp; flag==1;k++){                    for (int l = 0;l &lt; 3 &amp;&amp; flag==1;l++){                        int cur = image[i+k][j+l];                        sum += cur;                        int left = l==2?cur:image[i+k][j+l+1];                        int down = k==2?cur:image[i+k+1][j+l];                        if (abs(cur-left) &gt; threshold || abs(cur-down) &gt; threshold){                            flag = 0;                        }                    }                }                if (flag == 1){                    for (int k = 0;k &lt; 3;k++){                        for (int l = 0;l &lt; 3;l++){                            dp[i+k][j+l][0] += sum/9;                            dp[i+k][j+l][1]++;                        }                    }                }            }        }        for (int i = 0;i &lt; n;i++){            for (int j = 0;j &lt; m;j++){                if (dp[i][j][1] &gt; 0){                    ans[i][j] = dp[i][j][0]/dp[i][j][1];                }else{                    ans[i][j] = image[i][j];                }            }        }        return ans;    }};\n复杂度分析\n\n时间：O(n*m*9)。\n空间：O(n*m)。\n\n100203.\n将单词恢复初始状态所需的最短时间\n给你一个下标从 0 开始的字符串 word\n和一个整数 k 。\n在每一秒，你必须执行以下操作：\n\n移除 word 的前 k 个字符。\n在 word 的末尾添加 k 个任意字符。\n\n注意\n添加的字符不必和移除的字符相同。但是，必须在每一秒钟都执行\n两种 操作。\n返回将 word 恢复到其 初始 状态所需的\n最短 时间（该时间必须大于零）。\n示例 1：\n输入：word = \"abacaba\", k = 3输出：2解释：第 1 秒，移除 word 的前缀 \"aba\"，并在末尾添加 \"bac\" 。因此，word 变为 \"cababac\"。第 2 秒，移除 word 的前缀 \"cab\"，并在末尾添加 \"aba\" 。因此，word 变为 \"abacaba\" 并恢复到始状态。可以证明，2 秒是 word 恢复到其初始状态所需的最短时间。\n示例 2：\n输入：word = \"abacaba\", k = 4输出：1解释：第 1 秒，移除 word 的前缀 \"abac\"，并在末尾添加 \"caba\" 。因此，word 变为 \"abacaba\" 并恢复到初始状态。可以证明，1 秒是 word 恢复到其初始状态所需的最短时间。\n示例 3：\n输入：word = \"abcbabcd\", k = 2输出：4解释：每一秒，我们都移除 word 的前 2 个字符，并在 word 末尾添加相同的字符。4 秒后，word 变为 \"abcbabcd\" 并恢复到初始状态。可以证明，4 秒是 word 恢复到其初始状态所需的最短时间。\n提示：\n\n1 &lt;= word.length &lt;= 10^5\n1 &lt;= k &lt;= word.length\nword仅由小写英文字母组成。\n\n思路\n\n由于可以往s的末尾添加任意字符，这意味着只要s[k:]是s的前缀，就能让s恢复成其初始值，其中s[k:]表示从s[k]开始的后缀。\n即需要找到最小的t，使得s[tk:]是s的前缀。\ns = abacaba，k = 4 时第一秒后，s[4:]=aba，是s的前缀。相当于最前面删除abac，最后面加上caba。\ns = abacaba，k = 3 时第一秒后，s[3:]=caba，不是s的前缀。第二秒后，s[6:]=a，是s的前缀。相当于最前面删除aba和cab，最后面加上bac和aba。\n判断前后缀一般有两种方法：\n\nKMP\n字符串哈希\n\n\n代码\nKMP\n\nnext[i]表示最长相同前后缀的长度。\n例如：next(s = abacaba) = [0,0,1,0,1,2,3]，k = 3。\n一开始相同前后缀长度 len = next[n-1] = 3。(此时前后缀为aba)。\n但需要删除abac四个字符，不是k的整数倍。再次寻找次短相同前后缀长度。\nlen = next[len-1] = next[2] = 1。（此时前后缀为a）。\n需要删除abacab六个字符，是k的两倍，符合题意。\n\nclass Solution {public:    // 基础的KMP计算next数组    vector&lt;int&gt; calcLSP(string s){        int n = s.size();        vector&lt;int&gt; next(n, 0);        for (int i = 1, j = 0;i &lt; n;i++){            while (j &amp;&amp; s[i] != s[j]) j = next[j - 1];            if (s[i] == s[j]) j++;            next[i] = j;        }        return next;    }    int minimumTimeToInitialState(string word, int k){        int n = word.size();        vector&lt;int&gt; next = calcLSP(word);        for (int len = next[n-1];;){            // 枚举每一个可能的相同前后缀长度            if ((n-len)%k == 0) return (n-len+k-1)/k;            // 下一个相同前后缀长度（肯定比现在长度小）            len = next[len-1];        }        return (n+k-1)/k;    }};\n\n时间：O(n)。\n空间：O(n)。\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["模拟","字符串"]},{"title":"Leetcode 384场周赛","url":"/2024/02/11/Leetcode-384%E5%9C%BA%E5%91%A8%E8%B5%9B/","content":"Q1 100230.\n修改矩阵 [Easy] 题解\nQ2 100219.\n回文字符串的最大数量 [Medium] 题解\nQ3 100186.\n匹配模式数组的子数组数目 [Hard] 题解\n\n100230.\n修改矩阵\n给你一个下标从 0 开始、大小为 m x n\n的整数矩阵 matrix ，新建一个下标从 0\n开始、名为 answer 的矩阵。使 answer 与\nmatrix 相等，接着将其中每个值为 -1\n的元素替换为所在列的 最大 元素。\n返回矩阵 answer 。\n示例 1：\n\n\nimg\n\n输入：matrix = [[1,2,-1],[4,-1,6],[7,8,9]]输出：[[1,2,9],[4,8,6],[7,8,9]]解释：上图显示了发生替换的元素（蓝色区域）。- 将单元格 [1][1] 中的值替换为列 1 中的最大值 8 。- 将单元格 [0][2] 中的值替换为列 2 中的最大值 9 。\n示例 2：\n\n\nimg\n\n输入：matrix = [[3,-1],[5,2]]输出：[[3,2],[5,2]]解释：上图显示了发生替换的元素（蓝色区域）。\n提示：\n\nm == matrix.length\nn == matrix[i].length\n2 &lt;= m, n &lt;= 50\n-1 &lt;= matrix[i][j] &lt;= 100\n测试用例中生成的输入满足每列至少包含一个非负整数。\n\n思路\n​ 三层循环暴力修改一下即可。\n代码\nfunction modifiedMatrix(matrix: number[][]): number[][] {\tfor (let i = 0, n = matrix.length; i &lt; n; i++) {\t\tfor (let j = 0, m = matrix[i].length; j &lt; m; j++) {\t\t\tif (matrix[i][j] === -1) {\t\t\t\tfor (let k = 0; k &lt; n; k++) {\t\t\t\t\tmatrix[i][j] = Math.max(matrix[i][j], matrix[k][j]);\t\t\t\t}\t\t\t}\t\t}\t}\treturn matrix;}\n复杂度分析\n\n时间：O(n * m * m)。\n空间：O(1)。\n\n100219.\n回文字符串的最大数量\n给你一个下标从 0 开始的字符串数组 words\n，数组的长度为 n ，且包含下标从 0\n开始的若干字符串。\n你可以执行以下操作 任意\n次数（包括零次）：\n\n选择整数i、j、x和y，满足0 &lt;= i, j &lt; n，0 &lt;= x &lt; words[i].length，0 &lt;= y &lt; words[j].length，交换\n字符 words[i][x] 和 words[j][y] 。\n\n返回一个整数，表示在执行一些操作后，words\n中可以包含的回文字符串的 最大 数量。\n注意：在操作过程中，i 和 j\n可以相等。\n示例 1：\n输入：words = [\"abbb\",\"ba\",\"aa\"]输出：3解释：在这个例子中，获得最多回文字符串的一种方式是：选择 i = 0, j = 1, x = 0, y = 0，交换 words[0][0] 和 words[1][0] 。words 变成了 [\"bbbb\",\"aa\",\"aa\"] 。words 中的所有字符串都是回文。因此，可实现的回文字符串的最大数量是 3 。\n示例 2：\n输入：words = [\"abc\",\"ab\"]输出：2解释：在这个例子中，获得最多回文字符串的一种方式是：选择 i = 0, j = 1, x = 1, y = 0，交换 words[0][1] 和 words[1][0] 。words 变成了 [\"aac\",\"bb\"] 。选择 i = 0, j = 0, x = 1, y = 2，交换 words[0][1] 和 words[0][2] 。words 变成了 [\"aca\",\"bb\"] 。两个字符串都是回文 。因此，可实现的回文字符串的最大数量是 2。\n示例 3：\n输入：words = [\"cd\",\"ef\",\"a\"]输出：1解释：在这个例子中，没有必要执行任何操作。words 中有一个回文 \"a\" 。可以证明，在执行任何次数操作后，无法得到更多回文。因此，答案是 1 。\n提示：\n\n1 &lt;= words.length &lt;= 1000\n1 &lt;= words[i].length &lt;= 100\nwords[i] 仅由小写英文字母组成。\n\n思路\n\n每次执行可以选择 words[i]和\nwords[j]中任意两个字符进行交换（i!=j）\n每次执行可以选择 words[i]中任意两个字符进行位置交换\n由于操作可执行任意次，则所有的字符都可以重新进行排列。\n这样只需要统计字符的数量，依次进行回文串构造就可以。\n需要先对字符串进行排序，优先构造最短的回文串。\n\n代码\nclass Solution {   public:    int maxPalindromesAfterOperations(vector&lt;string&gt;&amp; words) {        int n = words.size(), ans = 0;        // 贪心：优先从长度较短的字符串开始构造        sort(words.begin(), words.end(), [](string&amp; a, string&amp; b) {            return a.size() &lt; b.size();        });        vector&lt;int&gt; cnt(26, 0);        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; words[i].size(); j++) {                cnt[words[i][j] - 'a']++;            }        }        for (int i = 0; i &lt; n; i++) {            int s = words[i].size();            // 先构造成对的字符：每次消耗两个相同字符            for (int j = 0; j &lt; 26 &amp;&amp; s &gt;= 2; j++) {                int minv = min(s, cnt[j]);                if (minv % 2 == 1) minv--;                cnt[j] -= minv;                s -= minv;            }            // 如果还剩一个字符：优先消耗奇数个字符            for (int i = 0; i &lt; 26 &amp;&amp; s == 1; i++) {                if (cnt[i] % 2 == 1){                    cnt[i]--;                    s--;                }            }            // 如果还剩一个字符并且没有奇数个字符：随便选一个            for (int i = 0; i &lt; 26 &amp;&amp; s == 1; i++) {                if (cnt[i] &gt; 0){                    cnt[i]--;                    s--;                }            }            // 贪心构造：如果当前已经构造不出回文串，那么比它还长的肯定也构造不出            if (s == 0) ans++;            else break;        }        return ans;    }};\n复杂度分析\n\n时间：O(n*m)。\n空间：O(1)。\n\n100186.\n匹配模式数组的子数组数目\n给你一个下标从 0 开始长度为 n\n的整数数组 nums ，和一个下标从 0 开始长度为\nm 的整数数组 pattern ，pattern\n数组只包含整数 -1 ，0 和 1 。\n大小为 m + 1 的子数组 nums[i..j]\n如果对于每个元素 pattern[k]\n都满足以下条件，那么我们说这个子数组匹配模式数组 pattern\n：\n\n如果 pattern[k] == 1 ，那么\nnums[i + k + 1] &gt; nums[i + k]\n如果 pattern[k] == 0 ，那么\nnums[i + k + 1] == nums[i + k]\n如果 pattern[k] == -1 ，那么\nnums[i + k + 1] &lt; nums[i + k]\n\n请你返回匹配 pattern 的 nums 子数组的\n数目 。\n示例 1：\n输入：nums = [1,2,3,4,5,6], pattern = [1,1]输出：4解释：模式 [1,1] 说明我们要找的子数组是长度为 3 且严格上升的。在数组 nums 中，子数组 [1,2,3] ，[2,3,4] ，[3,4,5] 和 [4,5,6] 都匹配这个模式。所以 nums 中总共有 4 个子数组匹配这个模式。\n示例 2：\n输入：nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]输出：2解释：这里，模式数组 [1,0,-1] 说明我们需要找的子数组中，第一个元素小于第二个元素，第二个元素等于第三个元素，第三个元素大于第四个元素。在 nums 中，子数组 [1,4,4,1] 和 [3,5,5,3] 都匹配这个模式。所以 nums 中总共有 2 个子数组匹配这个模式。\n提示：\n\n2 &lt;= n == nums.length &lt;= 10^6\n1 &lt;= nums[i] &lt;= 10^9\n1 &lt;= m == pattern.length &lt; n\n-1 &lt;= pattern[i] &lt;= 1\n\n思路\n\n首先我们可以根据题意将原数组都变成 1，0，-1 的形式\n下面就是找出与 pattern 相同的子数组=&gt;经典 KMP 匹配问题\n(有一说一，知识点和上周的重了)\n\n代码\nclass Solution {   public:    // 获取next数组    vector&lt;int&gt; calcLSP(vector&lt;int&gt;&amp; s) {        int n = s.size();        vector&lt;int&gt; next(n, 0);        for (int i = 1, j = 0; i &lt; n; i++) {            while (j &amp;&amp; s[i] != s[j]) j = next[j - 1];            if (s[i] == s[j]) j++;            next[i] = j;        }        return next;    }    int countMatchingSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; pattern) {        vector&lt;int&gt; next = calcLSP(pattern);        int n = nums.size(), m = pattern.size(), count = 0;        // 做一下转换        for (int i = 0; i &lt; n - 1; i++) {            if (nums[i + 1] &gt; nums[i]) nums[i] = 1;            else if (nums[i + 1] &lt; nums[i]) nums[i] = -1;            else nums[i] = 0;        }        // 进行匹配计数        for (int i = 0, j = 0; i &lt; n; i++) {            while (j &amp;&amp; nums[i] != pattern[j]) j = next[j - 1];            if (nums[i] == pattern[j]) j++;            if (j == m) {                count++;                j = next[j - 1];            }        }        return count;    }};\n复杂度分析\n\n时间：O(n+m)。\n空间：O(m)。\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["贪心","KMP","回文串"]},{"title":"Leetcode 97场双周赛","url":"/2023/02/05/Leetcode-97%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/","content":"Q1 6303.\n分割数组中数字的数位 [Easy] 题解\nQ2 6304.\n从一个范围内选择最多整数 I [Medium] 题解\nQ3 6331.\n两个线段获得的最多奖品 [Medium] 题解\nQ4 6305.\n二进制矩阵中翻转最多一次使路径不连通 [Medium] 题解\n\nQ1\n\n6303.\n分割数组中数字的数位 - 力扣（Leetcode）\n给你一个正整数数组 nums ，请你返回一个数组\nanswer ，你需要将 nums\n中每个整数进行数位分割后，按照 nums 中出现的\n相同顺序\n放入答案数组中。对一个整数进行数位分割，指的是将整数各个数位按原本出现的顺序排列成数组。\n\n比方说，整数 10921 ，分割它的各个数位得到\n[1,0,9,2,1] 。\n\n示例 1：\n输入：nums = [13,25,83,77]输出：[1,3,2,5,8,3,7,7]解释：- 分割 13 得到 [1,3] 。- 分割 25 得到 [2,5] 。- 分割 83 得到 [8,3] 。- 分割 77 得到 [7,7] 。answer = [1,3,2,5,8,3,7,7] 。answer 中的数字分割结果按照原数字在数组中的相同顺序排列。\n示例 2：\n输入：nums = [7,1,3,9]输出：[7,1,3,9]解释：nums 中每个整数的分割是它自己。answer = [7,1,3,9] 。\n提示：\n\n1 &lt;= nums.length &lt;= 1000\n1 &lt;= nums[i] &lt;= 100000\n\n\n思路\n​ 简单模拟\n代码\nclass Solution:    def separateDigits(self, nums: List[int]) -&gt; List[int]:        ans = []        for i in nums:            t = i            tp = []            while t &gt; 0:                tp.append(t%10)                t //= 10            for j in tp[::-1]:                ans.append(j)        return ans\n复杂度分析\n\n时间复杂度：O(nlog m), m = max(nums)\n空间复杂度：O(1)\n\nQ2\n\n6304.\n从一个范围内选择最多整数 I - 力扣（Leetcode）\n给你一个整数数组 banned 和两个整数 n 和\nmaxSum 。你需要按照以下规则选择一些整数：\n被选择整数的范围是 [1, n] 。每个整数\n至多 选择 一次 。被选择整数不能在数组\nbanned 中。 被选择整数的和不超过 maxSum\n。请你返回按照上述规则 最多 可以选择的整数数目。\n示例 1：\n输入：banned = [1,6,5], n = 5, maxSum = 6输出：2解释：你可以选择整数 2 和 4 。2 和 4 在范围 [1, 5] 内，且它们都不在 banned 中，它们的和是 6 ，没有超过 maxSum 。\n示例 2：\n输入：banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1输出：0解释：按照上述规则无法选择任何整数。\n示例 3：\n输入：banned = [11], n = 7, maxSum = 50输出：7解释：你可以选择整数 1, 2, 3, 4, 5, 6 和 7 。它们都在范围 [1, 7] 中，且都没出现在 banned 中，它们的和是 28 ，没有超过 maxSum 。\n提示：\n1 &lt;= banned.length &lt;= 10000\n1 &lt;= banned[i], n &lt;= 10000\n1 &lt;= maxSum &lt;= 10^9\n\n思路\n​ 选的数的总和有限制，又要选的数最多，那肯定是从小到大选择。即遍历\n[1, n]\n遇到在banned里的数就跳过，直到遍历结束或者总和大于maxSum。\n代码\nclass Solution:    def maxCount(self, banned: List[int], n: int, maxSum: int) -&gt; int:        hs = set(banned)        ans = 0        s = 0        for i in range(1, n+1):            if i in hs: continue            if i+s &gt; maxSum: break            s += i            ans += 1        return ans\n复杂度分析\n\n时间复杂度：O(m + n)\n空间复杂度：O(m)\n\nQ3\n\n6331.\n两个线段获得的最多奖品 - 力扣（Leetcode）\n在 X轴 上有一些奖品。给你一个整数数组\nprizePositions ，它按照 非递减\n顺序排列，其中 prizePositions[i] 是第 i\n件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数\nk 。你可以选择两个端点为整数的线段。每个线段的长度都必须是\nk\n。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。\n\n比方说 k = 2 ，你可以选择线段 [1, 3] 和\n[2, 4] ，你可以获得满足\n1 &lt;= prizePositions[i] &lt;= 3 或者\n2 &lt;= prizePositions[i] &lt;= 4 的所有奖品 i 。\n\n请你返回在选择两个最优线段的前提下，可以获得的 最多\n奖品数目。\n示例 1：\n输入：prizePositions = [1,1,2,2,3,3,5], k = 2输出：7解释：这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。\n示例 2：\n输入：prizePositions = [1,2,3,4], k = 0输出：2解释：这个例子中，一个选择是选择线段 [3, 3] 和 [4, 4] ，获得 2 个奖品。\n提示：\n\n1 &lt;= prizePositions.length &lt;= 10^5\n1 &lt;= prizePositions[i] &lt;= 10^9\n0 &lt;= k &lt;= 10^9\nprizePositions 有序非递减。\n\n\n思路\n用双指针处理第二条线段，同时，用一个数组 ms[i]\n记录线段右端点不超过 p[i]\n时最多可以覆盖多少个奖品。\n第二条线段处理时，需要用二分找到最左边可以覆盖到的端点 l ，这样第二条线段可获得的奖品为\ni − l + 1 。再加上\nms[l − 1]，就是第一条线段右端点不超过\np[l − 1]\n时最大奖品数量。用这个更新 ans。 ans = max (ans, i − l + 1 + ms[l − 1])\n不要忘了跟新 ms ms[i] = max(i − l + 1, ms[i − 1])\n代码\nclass Solution:    def maximizeWin(self, p: List[int], k: int) -&gt; int:        n, ans = len(p), 0        ms = [0]*(n+1)        for i in range(1, n+1):            l = 1            r = i            while l &lt;= r:                m = l+r &gt;&gt; 1                if p[i-1]-p[m-1]&lt;=k: r = m-1                else: l = m+1            ans = max(ans, i-l+1+ms[l-1])            ms[i] = max(i-l+1, ms[i-1])        return ans\n复杂度分析\n\n时间复杂度：O(nlog n)，\n主要是二分的时间复杂度。\n空间复杂度：O(n)\n\nTips\n\n这题也可以用双指针，可以做到 O(n)时间复杂度。\n\nQ4\n\n6305.\n二进制矩阵中翻转最多一次使路径不连通 - 力扣（Leetcode）\n给你一个下标从 0 开始的 m x n\n二进制 矩阵 grid 。你可以从一个格子\n(row, col) 移动到格子 (row + 1, col) 或者\n(row, col + 1) ，前提是前往的格子值为 1\n。如果从 (0, 0) 到 (m - 1, n - 1)\n没有任何路径，我们称该矩阵是 不连通 的。你可以翻转\n最多一个 格子的值（也可以不翻转）。你\n不能翻转 格子 (0, 0) 和\n(m - 1, n - 1) 。\n如果可以使矩阵不连通，请你返回 true ，否则返回\nfalse 。\n注意 ，翻转一个格子的值，可以使它的值从\n0 变 1 ，或从 1 变 0\n。\n示例 1：\n输入：grid = [[1,1,1],[1,0,0],[1,1,1]] 输出：true\n解释：按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2)\n没有路径。\n示例 2：\n输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：false\n解释：无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。\n提示：\n\nm == grid.length\nn == grid[i].length\n1 &lt;= m, n &lt;= 1000\n1 &lt;= m * n &lt;= 10^5\ngrid[0][0] == grid[m - 1][n - 1] == 1\n\n\n思路\n\n赛时想到了求割点，但发现不会写。\n\n这题其实用不到割点，因为这个图的路径走法是很固定的，只有往右下方走。\n所以我们只要求出是否有一个点，所有合法路径都要经过它（割点），那我们翻转成0就可以使得所有路径不通。\n记 f(i, j) 表示从\n(0, 0) 走到 (i, j) 的方案数。记 g(i, j) 表示从\n(n − 1, m − 1)\n倒着走到 (i, j)\n的方案数。 由这两个值很容易算出从 (0, 0) 走到 (i, j) ，且中途必须经过\n(i, j) 的方案数，即为\nf(i, j) × g(i, j)\n因此只要找到 i，j\n满足 f(i, j) × g(i, j) = f(n − 1, m − 1)\n，就说明想要从 (0, 0) 走到 (n − 1, m − 1) ，则必须经过\n(i, j)\n，即找到了答案。\n代码\nclass Solution {    public boolean isPossibleToCutPath(int[][] g) {        int n = g.length, m = g[0].length;        int M1 = (int)1e9+777777, M2 = (int)1e9+133333;        int[][][] f = new int[n+2][m+2][2];        int[][][] h = new int[n+2][m+2][2];        f[0][1][0] = f[0][1][1] = 1;        h[n+1][m][0] = h[n+1][m][1] = 1;        for (int i = 1;i &lt;= n;i++){            for (int j = 1;j &lt;= m;j++){                if (g[i-1][j-1] == 0) continue;                f[i][j][0] = (f[i-1][j][0]+f[i][j-1][0])%M1;                f[i][j][1] = (f[i-1][j][1]+f[i][j-1][1])%M2;            }        }        for (int i = n;i &gt;= 1;i--){            for (int j = m;j &gt;= 1;j--){                if (g[i-1][j-1] == 0) continue;                h[i][j][0] = (h[i+1][j][0]+h[i][j+1][0])%M1;                h[i][j][1] = (h[i+1][j][1]+h[i][j+1][1])%M2;            }        }        long x = f[n][m][0], y = f[n][m][1];        if (x==0&amp;&amp;y==0) return true;        for (int i = 1;i &lt;= n;i++){            for (int j = 1;j &lt;= m;j++){                if (i+j==2 || i+j==m+n) continue;                long t1 = f[i][j][0]*1L*h[i][j][0]%M1;                long t2 = f[i][j][1]*1L*h[i][j][1]%M2;                if (x==t1 &amp;&amp; y==t2) return true;            }        }        return false;    }}\n复杂度分析\n\n时间复杂度：O(nm)\n空间复杂度：O(nm)\n\nTips\n\n计算方法数时可能溢出，所以要取模。考虑到哈希冲突，可以使用两个模数来降低冲突概率。一般算法题中两个哈希的冲突概率已经非常小了。\n还有一种类似贪心的dfs算法，详见6305.\n二进制矩阵中翻转最多一次使路径不连通 - 力扣（Leetcode）\n\n","categories":["Algorithm","Problem","Leetcode","Contest"],"tags":["贪心","二分","DFS"]},{"title":"Math Algorithm","url":"/2022/09/08/Math-Algorithm/","content":"常见的数学算法包括：快速幂、矩阵运算、欧拉函数与欧拉定理、欧几里得算法及其扩展、中国剩余定理（CRT）、高斯消元、乘法逆元、组合数求解、质数筛选、博弈论模型及其他杂项技巧。\n\n快速幂\n快速幂的目的就是做到快速求幂，假设我们要求 a^b,按照朴素算法就是把 a\n连乘 b\n次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(log\nn).\n例如当 b=11 时, 将 b 写成二进制格式 1011，即1 * 23 + 0 * 22 + 1 * 21 + 1 * 20：\na11 = a(20 + 21 + 23)\nint qpow(int a, int b) {int ans = 1, base = a;  while (b != 0) {      if ((b &amp; 1) != 0) ans *= base;      base *= base;      b &gt;&gt;= 1;  }  return ans;}\n快速幂模块\n另附快速乘法 (mod  p)意义下\nlong qmul(long a,long b,long mod) {  long res=0;   while(b&gt;0) {       if((b&amp;1)==1) res=(res+a)%mod;       a=(a+a)%mod;       b&gt;&gt;=1;   }   return res;}\n\n矩阵\n\n矩阵快速幂\n矩阵快速幂就是把快速幂里的乘法换成矩阵乘法 求解 A = matK,\nmat为原矩阵，A是答案\n\nstatic long n, N, k, P = (long)1e9+7;static long[][] mat, A;private static void qmpow() {    A = new long[N][N];    for (int i = 0;i &lt; n;i++) A[i][i] = 1; //A首先构造成一个单位矩阵（相当于 1）    while (k != 0){        if ((k &amp; 1) != 0) A = mul(A, mat); //把快速幂中的乘法换成矩阵乘法就行        mat = mul(mat, mat);        k &gt;&gt;= 1;    }}private static long[][] mul(long[][] x, long[][] y) {    long[][] res = new long[x.length][y[0].length];    for (int i = 0;i &lt; x.length;i++) for (int j = 0;j &lt; y[0].length;j++){    for (int k = 0;k &lt; y.length;k++)        res[i][j] = (res[i][j]+x[i][k]*y[k][j]%P)%P;    }    return res;}\n\n矩阵加速（数列）板子\n\n那么我们可以维护两个我们首先要确定目标矩阵。下面这个矩阵就是我想要的矩阵.\n\n并且有递推式 F[i] = F[i-1]+F[i-3]\n那么这个矩阵每个元素就可以表示成如下\n\n通过每一项的系数可以得出Mi与Mi − 1递推关系\n记\n则写个两三项可发现 F[i] = Ai − 3[0][0] + Ai − 3[0][1] + Ai − 3[0][2]\n\n用矩阵快速幂求出Ai − 3即可\n\n欧拉函数&amp;欧拉定理\n\n欧拉函数 Euler’s totient function，即 φ(n) ，表示的是小于等于\nn 和 n 互质的数的个数。  其中 p1, p2, p3, ⋯, pk\n是 n 的所有不重复的素因子。\n对应下方代码中 ans = ans/i * (i − 1);\n\nint euler_phi(int n) {     // 分解质因数过程中计算   int ans = n;   for (int i = 2; i * i &lt;= n; i++)        if (n % i == 0) {            ans = ans / i * (i - 1);            while (n % i == 0) n /= i;        }   if (n &gt; 1) ans = ans / n * (n - 1);   return ans;}\n\n欧拉定理 若 gcd (a, m) = 1 ，则 aφ(m) ≡ 1( mod  m)\n。\n拓展欧拉定理\n\n\n筛法求欧拉函数\n注意到在线性笑中，每一个合数都是被最小的质因子笑掉。比如设 p1 是 n 的最小质因子， \n，那么线性篮的过程中 n 通过\nn′ × p1\n篮掉。 观察线性篮的过程，我们还需要处理两个部分，下面对 n′ mod  p1\n分情况讨论。 如果 n′ mod  p1 = 0\n，那么 n′ 包含了\nn 的所有质因子。 \n那如果 n′ mod  p1 ≠ 0\n呢，这时 n′ 和\np1\n是互质的，根据欧拉函数性质，我们有:\n\nstatic void euler(int n){    phi[1] = 1;    for (int i = 2;i &lt;= n;i++){        if (is[i] == 0){            prime[++cnt] = i;            phi[i] = i-1;        }        for (int j = 1;i*prime[j] &lt;= n;j++){            is[i*prime[j]] = 1;            if (i % prime[j] != 0){                phi[i*prime[j]] = phi[i]*(prime[j]-1);            }else{                phi[i*prime[j]] = phi[i]*prime[j];                break;            }        }    }}\n\n欧几里得定理\n辗转相除法\n\n最大公因数 GCD(a, b)\n最小公倍数 LCM(a, b) = a/GCD(a, b)*b\n\nint gcd(int a, int b){\treturn b==0 ? a : gcd(b, a%b);}\nint lcm(int a, int b){\treturn a/gcd(a, b)*b;}\nBinary GCD\n\na, b\n均为偶数。对于这种情况，显然 2 是公约数之一，直接将两个数都除以 2\n，再递归 下去求  即可， \na, b\n中有且仅有一个偶数。不妨设 a\n是偶数，那么显然 2 不是公约数之一，直接将 a 除 以 2 求  即可, \na, b\n均为奇数。不妨设 a &gt; b ，那么有  。 设 a = k1gcd (a, b), b = k2gcd (a, b)\n且 gcd (k1, k2) = 1\n，先考虑证明 gcd (a − b, b) = gcd (a, b)\na − b = (k1 − k2)gcd (a, b), b = k2gcd (a, b)\n，那么有gcd (a − b, b) = gcd (k1 − k2, k2) ⋅ gcd (a, b)\n， 即证 gcd (k1 − k2, k2) = 1\n考虑反证法，假设 gcd (k1 − k2, k2) = m\n其中 m ∈ ℕ*, m &gt; 1\n，再设 k1 − k2 = t1m, k2 = t2m\n就有 k1 = (t1 + t2)m\n，那么 gcd (k1, k2) = m ⋅ gcd (t1 + t2, t2) &gt; 1\n与 k1, k2\n互质矛 盾，得证 gcd (k1 − k2, k2) = 1\n\nint bgcd(int a, int b){  if (a == 0) return b;  if (b == 0) return a;  int p = 0;  while (((a|b)&amp;1) == 0){      a &gt;&gt;= 1; b &gt;&gt;= 1; p++;  }  if (a &gt; b) return bgcd(a-b, b)&lt;&lt;p;  else return bgcd(a, b-a)&lt;&lt;p;}\n拓展欧几里得\n贝祖定理：a、b 是整数，那么一定存在整数 x、y 使得\nax+by=gcd(a,b)。\n\n如果 ax+by=1 有解，那么gcd(a,b)=1；\n\n解方程：ax+by=m (a, b, m 均为正整数)\n首先解 ax+by=gcd(a, b).\n递归边界：b = 0, a = gcd(a, b); 显然 x\n= 1, y = 0. 递归推导：当前层为 a, b; 求解 ax+by=gcd(a, b).\n由递归下一层 b, a%b, 可得 bx1+(a%b)y1=gcd(a, b).\n由于 a%b = a - (a/b)b. —(3) 联立(2)(3) 解得 ay1 + b(x1 - (a/b)y1) = gcd(a, b). 对比\n(1) 式 解得 x = y1,\ny = x1-a/b*y1.\nstatic int x, y;static int exgcd(int a, int b){    if (b == 0){        x = 1; y = 0;        return a;    }    int gcd = exgcd(b, a%b);    int tp = x;    x = y;    y = tp-a/b*y;    return gcd;}\n解 ax+by=m 若 方程 ax+by=m 的一组整数解为(x，y).\n则它的任意整数解都可以写成(x + k _ b’，y - k _ a’)。 其中 a’ = a / gcd(a，b), b’ = b\n/ gcd(a，b)，k\n取任意整数\nax+by=m 有解的充分条件 ==gcd(a，b)\n| m== //m 能整除gcd(a, b)\n设（x1， y1）是\nax+by=gcd(a, b) 解\n则 ax+by=m 的解为 x = x1c/gcd(a，b), y =\ny1c/gcd(a，b),\npublic static void main(String[] args){    //a*x+b*y=m    int d = exgcd(a, b, x, y);    if (m % d != 0) out.println(\"无解\");    else{        x = m/d*x; // x为一个特解        y = m/d*y; // y为一个特解        int kx = b/gcd, ky = a/gcd; //即为上面的 b' 和 a'        int minx = (x%kx+kx)%kx; // 求此时x的最小非负整数解        int miny = (y%ky+ky)%ky; // 求此时y的最小非负整数解        int maxx = (c-miny*b)/a; // 求y为最小非负整数，此时x的最大整数解        int maxy = (c-minx*a)/b; // 求x为最小非负整数，此时y的最大整数解    }}\n青蛙约会\n\n中国剩余定理（CRT）\n求解如下形式的一元线性同余方程组==最小正整数解==。(注意b1,b2,⋯,bk两两不一定互质，拓展版)\n设两个方程分别是 x ≡ a1( mod  m1)、x ≡ a2( mod  m2)\n； 将它们转化为不定方程: x = m1p + a1 = m2q + a2\n，其中 p, q\n是整数，则有 m1p − m2q = a2 − a1\n由 裴蜀定理，当 a2 − a1\n不能被 gcd (m1, m2)\n整除时，无解； 其他情况下，可以通过扩展欧几里得算法 解出来一组可行解\n(p, q) ；\n则原来的两方程组成的模方程组的解为 x ≡ b( mod  M)\n，其中 b = m1p + a1，M = lcm (m1, m2)\nstatic void solve() throws Exception {    //  x = py+r =&gt; x==r(mod p)    n = ni();    long p1 = ni(), r1 = ni();    for (int i = 2;i &lt;= n;i++){        long p2 = ni(), r2 = ni();        long gcd = exgcd(p1, p2);        if (abs(r2-r1)%gcd != 0){            out.println(-1);            return;        }        x = x*(r2-r1)/gcd;        long mod = Math.abs(p2)/gcd;        x = (x%mod+mod)%mod;        r1 = x*p1+r1;        p1 = p1/gcd*p2;    }    out.println(r1);}\n\n高斯消元（解一次方程组）\n1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。\n2.通过加减消元，消掉其它方程中的这个未知数。\n3.重复以上步骤，直到把每一行都变成只有一项有系数。（转换为对角矩阵）\n4.输出时记得除以方程主元的系数。\nstatic double[][] a = new double[N][N]; //double 存static void solve() throws Exception {    n = ni();    for (int i = 1;i &lt;= n;i++) // n行        for (int j = 1;j &lt;= n+1;j++) // n+1列            a[i][j] = ni();    for (int i = 1;i &lt;= n;i++){        int max = i;        for (int j = i+1;j &lt;= n;j++) //找到每一列中 最大的那个数            if (abs(a[j][i]) &gt; abs(a[max][i])) max = j;        for (int j = 1;j &lt;= n+1;j++){//交换            double tp = a[i][j];            a[i][j] = a[max][j];            a[max][j] = tp;        }        if (a[i][i] == 0){            out.println(\"不存在唯一解\");            return;        }        for (int j = 1;j &lt;= n;j++){// 消除系数            if (i == j) continue;            double tp = a[j][i]/a[i][i];            for (int k = i+1;k &lt;= n+1;k++)                a[j][k] -= a[i][k]*tp;        }    }    for (int i = 1;i &lt;= n;i++)        //最终每一个未知数解要除以它的系数（a[i][i]）        out.printf(\"%.2f\\n\", a[i][n+1]/a[i][i]);}\n\n乘法逆元\n定义：如果一个线性同余方程 ax ≡ 1\n( p) ，则 x 称为 a  p 的逆元，记作 。\n所以我们可以知道：a 除以一个数模 p，等于 a 乘这个数的乘法逆元模 p.\n\n拓展欧几里得\n\nint main() {     //b%mod的逆元     int b,mod;     while(cin&gt;&gt;b&gt;&gt;mod){        // x=0;y=0;         extend_Euclid(b,mod);         cout&lt;&lt;(x%mod+mod)%mod&lt;&lt;endl;     }     return 0; }\n\n快速幂 费马小定理（==此时 p 一定为素数==）\n\nint qpow(long a, long b) {    int ans = 1;    a = (a % p + p) % p; //让a变成正数（模p的意义下）    while (b != 0) {        if (b &amp; 1) ans = (a * ans) % p;        a = (a * a) % p;        b &gt;&gt;= 1;    }    return ans;}\n\n线性算法求一连串数字的逆元（==此时 p 一定是素数==）\n用于求一连串数字对于一个 mod  p的逆元。洛谷 P3811\n只能用这种方法，别的算法都比这些要求一串要慢。\n首先我们有一个, 1−1 ≡ 1 (mod  p)\n然后设 p = k * i + r, (1 &lt; r &lt; i &lt; p)也就是\nk是 p/i的商，r 是余数 。\n再将这个式子放到 (mod  p)意义下就会得到：\nk * i + r ≡ 0 (mod  p)\n然后乘上i−1, r−1就可以得到:\n\n于是，我们就可以从前面推出当前的逆元了。\n\ninv[1] = 1;for(int i = 2; i &lt;= n; ++ i)    inv[i] = (p - p / i) * inv[p % i] % p;\n\n组合数(模P意义下)\n\n\n打表（杨辉三角）\n\nfor(int i=0;i&lt;=n;i++){    c[i][0]=c[i][i]=1;    for(int j=1;j&lt;i;j++){        c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;    }}\n预处理 O(nm) 查询 O(1)\n\n乘法逆元+快速幂+阶乘\n\nint pow(int x,int y){...} //快速幂//求逆元 这里用欧拉定理，只能适用p为素数;可以用拓欧求逆元。int inv(int x,int p){    return pow(x,p-2);}fac[0]=1;for(int i=1;i&lt;=n;i++)    fac[i]=fac[i-1]*i; //预处理出阶乘return ((fac[n]*inv(fac[m],p))%p*inv(fac[n-m],p))%p;\n预处理 O(n) 查询 O(log p)\n\n分解质因数\nstatic void solve() throws Exception{    long t = nl();    // cnt[i][0]:第i个质数 cnt[i][1]:第i个质因数出现的次数    int cnt[][] = new int[(int)1e6][2], len = 0;    for (int i = 2;(long)i*i &lt;= t;i++){        if (t % i == 0){            cnt[len][0] = i;            while (t % i == 0){                cnt[len][1]++;                t /= i;            }len++;        }    }}\n质数\n\n埃氏筛 O(Nlog2log2N)\nbool numlist[100000001]; //true:合数 false:素数int prime[20000001]; //存储从小到大的素数（2，3，5，···）int cnt; //存储素数数量void work(int n){    for(int i=2; i&lt;=n; i++){        if(numlist[i]==false){            prime[++cnt] = i ;            for(int j=i; i*j&lt;=n; j++)                numlist[i*j] = true;        }    }    return;}\n欧拉筛 O(N)\nbool numlist[100000001];int prime[20000001], cnt;void work(int n){    for(int i=2; i&lt;=n; i++){        if(numlist[i]==false) prime[++cnt] = i ;        for(int j=1; j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n; j++){            numlist[i*prime[j]] = true ;            if(i%prime[j]==0)                break;        }    }    return;}\n\n\n博弈论\nnim\n游戏\nnim\n游戏的规则是这样的：地上有 n\n堆石子，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这\nn 堆石子的数量，他想知道是否存在先手必胜的策略。\nint t = 0;while (n-- &gt; 0) t ^= ni();out.println((t==0?\"No\":\"Yes\"));\n\n杂项\n\n三角形面积\n\n海伦公式：假设在平面内，有一个三角形，边长分别为\na、b、c\n，三角形的面积 S 可由以下公式\n求得:\n\n而公式里的 p 为半周长\n(周长的一半) :\n\n向量积：\n\n\n任意多边形面积\n\n对于任意一个多边形，如果已知其各个顶点的坐标 A1(x1, y1), A2(x2, y2), …, An(xn, yn)\n，那么这个多边形的面积为:\n\n其中 xn + 1 = x1, yn + 1 = y1。\n","categories":["Algorithm","Template"],"tags":["Template","Math"]},{"title":"Maven 入门到进阶","url":"/2024/06/05/Maven-%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/","content":"详解 Java 项目高效构建过程，涵盖 Maven\n的安装与环境配置、依赖管理、构建流程、继承与聚合特性，以及实战中的常见问题与优化技巧。\n\n1 Maven简介和快速入门\n1.1 Maven介绍\nhttps://maven.apache.org/what-is-maven.html\nMaven就是一个软件，掌握软件安装、配置、以及基本功能\n（项目构建、依赖管理） 使用就是本课程的主要目标！\n1.2 Maven主要作用理解\n\n场景概念\n场景1：\n例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整！\n场景2：\n项目开发完成后，想要将项目打成.jar文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn\npackage）快速项目构建和打包！节省大量时间！\n依赖管理：\nMaven\n可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过\nMaven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可。\n构建管理：\n项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程！\nMaven\n可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven\n可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven\n的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。\n\n1.3 Maven安装和配置\nhttps://maven.apache.org/docs/history.html\n\n安装\n安装条件：\nmaven需要本机安装java环境、必需包含java_home环境变量！\n软件结构：\n环境变量\n环境变量： 配置maven_home 和 path\n命令测试\nmvn -v # 输出版本信息即可，如果错误，请仔细检查环境变量即可！# 友好提示，如果此处错误，绝大部分原因都是java_home变量的事，请仔细检查！！\n配置文件\n\n我们需要需改maven/conf/settings.xml配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：1.依赖本地缓存位置（本地仓库位置）2.maven下载镜像3.maven选用编译项目的jdk版本！\n\n配置本地仓库地址\n&lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;--&gt;&lt;!-- conf/settings.xml 55行 --&gt;&lt;localRepository&gt;D:\\repository&lt;/localRepository&gt;\n配置国内阿里镜像\n&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;name&gt;aliyun maven&lt;/name&gt;    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;\n配置jdk17版本项目构建\n&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;&lt;profile&gt;    &lt;id&gt;jdk-17&lt;/id&gt;    &lt;activation&gt;      &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;jdk&gt;17&lt;/jdk&gt;    &lt;/activation&gt;    &lt;properties&gt;      &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;      &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;      &lt;maven.compiler.compilerVersion&gt;17&lt;/maven.compiler.compilerVersion&gt;    &lt;/properties&gt;&lt;/profile&gt;\n\n\nidea配置本地maven\n\n我们需要将配置好的maven软件，配置到idea开发工具中即可！\n注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！\n\n\n2 基于IDEA的Maven工程创建\n2.1梳理Maven工程GAVP属性\n\nMaven工程相对之前的工程，多出一组gavp属性，gav需要我们在创建项目的时指定，p有默认值，后期通过配置文件修改。既然要填写的属性，我们先行了解下这组属性的含义!\n\nMaven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging\n等四个属性的缩写，其中前三个是必要的，而 Packaging\n属性为可选项。这四个属性主要为每个项目在maven仓库总做一个标识，类似人的《姓-名》。有了具体标识，方便maven软件对项目进行管理和互相引用！\nGAVP遵循一下规则：\n1） GroupID 格式：com.{公司/BU\n}.业务线.[子业务线]，最多 4 级。\n说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU\n一级；子业务线可选。\n正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang\ncom.atguigu.java\n2） ArtifactID\n格式：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。\n正例：tc-client / uic-api / tair-tool / bookstore\n3） Version版本号格式推荐：主版本号.次版本号.修订号\n1.0.0\n1） 主版本号：当做了不兼容的 API\n修改，或者增加了能改变产品方向的新功能。\n2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。\n3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API\n兼容性。\n例如： 初始→1.0.0 修改bug → 1.0.1 功能调整 → 1.1.1等\nPackaging定义规则：\n指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！\npackaging 属性为\njar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。\npackaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。\npackaging 属性为 pom，代表不会打包，用来做继承的父工程。\n2.2 Idea构建Maven JavaSE工程\n注意：此处省略了version，直接给了一个默认值&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n自己后期可以在项目中随意修改！\n2.3 Idea构建Maven JavaEE工程\n\n手动创建\n\n创建一个javasemaven工程\n手动添加web项目结构文件\n注意：结构和命名固定\n修改pom.xml文件打包方式\n修改位置：项目下/pom.xml\n&lt;groupId&gt;com.atguigu&lt;/groupId&gt;&lt;artifactId&gt;maven_parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 新增一列打包方式packaging --&gt;&lt;packaging&gt;war&lt;/packaging&gt;\n刷新和校验\n\n插件方式创建\n\n安装插件JBLJavaToWeb\nfile / settings / plugins / marketplace\n创建一个javasemaven工程\n右键、使用插件快速补全web项目\n\n\n2.4 Maven工程项目结构说明\nMaven\n是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是\nMaven Web 程序的文件结构及每个文件的作用：\n|-- pom.xml                               # Maven 项目管理文件 |-- src    |-- main                              # 项目主要代码    |   |-- java                          # Java 源代码目录    |   |   `-- com/example/myapp         # 开发者代码主目录    |   |       |-- controller            # 存放 Controller 层代码的目录    |   |       |-- service               # 存放 Service 层代码的目录    |   |       |-- dao                   # 存放 DAO 层代码的目录    |   |       `-- model                 # 存放数据模型的目录    |   |-- resources                     # 资源目录，存放配置文件、静态资源等    |   |   |-- log4j.properties          # 日志配置文件    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件    |   |   `-- static                    # 存放静态资源的目录    |   |       |-- css                   # 存放 CSS 文件的目录    |   |       |-- js                    # 存放 JavaScript 文件的目录    |   |       `-- images                # 存放图片资源的目录    |   `-- webapp                        # 存放 WEB 相关配置和资源    |       |-- WEB-INF                   # 存放 WEB 应用配置文件    |       |   |-- web.xml               # Web 应用的部署描述文件    |       |   `-- classes               # 存放编译后的 class 文件    |       `-- index.html                # Web 应用入口页面    `-- test                              # 项目测试代码        |-- java                          # 单元测试目录        `-- resources                     # 测试资源目录\n\npom.xml：Maven\n项目管理文件，用于描述项目的依赖和构建配置等信息。\nsrc/main/java：存放项目的 Java 源代码。\nsrc/main/resources：存放项目的资源文件，如配置文件、静态资源等。\nsrc/main/webapp/WEB-INF：存放 Web 应用的配置文件。\nsrc/main/webapp/index.html：Web 应用的入口页面。\nsrc/test/java：存放项目的测试代码。\nsrc/test/resources：存放测试相关的资源文件，如测试配置文件等。\n\n3 Maven核心功能依赖和构建管理\n3.1 依赖管理和配置\nMaven 依赖管理是 Maven 软件中最重要的功能之一。Maven\n的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。\n我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven\n仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。\n重点: 编写pom.xml文件!\nmaven项目信息属性配置和读取：\n&lt;!-- 模型版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;&lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;&lt;artifactId&gt;project&lt;/artifactId&gt;&lt;!-- 版本号 --&gt;&lt;version&gt;1.0.0&lt;/version&gt;&lt;!--打包方式    默认：jar    jar指的是普通的java项目打包方式！ 项目打成jar包！    war指的是web项目打包方式！项目打成war包！    pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念--&gt;&lt;packaging&gt;jar/pom/war&lt;/packaging&gt;\n依赖管理和添加：\n&lt;!--    通过编写依赖jar包的gav必要属性，引入第三方依赖！   scope属性是可选的，可以指定依赖生效范围！   依赖信息查询方式：      1. maven仓库信息官网 https://mvnrepository.com/      2. mavensearch插件搜索 --&gt;&lt;dependencies&gt;    &lt;!-- 引入具体的依赖包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j&lt;/artifactId&gt;        &lt;version&gt;1.2.17&lt;/version&gt;        &lt;!--            生效范围            - compile ：main目录 test目录  打包 [默认]            - provided：main目录 test目录  Servlet            - runtime： 打包运行           MySQL            - test:    test目录           junit         --&gt;        &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n依赖版本提取和维护:\n&lt;!--声明版本--&gt;&lt;properties&gt;  &lt;!--命名随便,内部制定版本号即可！--&gt;  &lt;junit.version&gt;4.11&lt;/junit.version&gt;  &lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt;  &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;  &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;!--引用properties声明版本 --&gt;    &lt;version&gt;${junit.version}&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n3.2依赖传递和冲突\n依赖传递指的是当一个模块或库 A 依赖于另一个模块或库\nB，而 B 又依赖于模块或库 C，那么 A 会间接依赖于\nC。这种依赖传递结构可以形成一个依赖树。当我们引入一个库或框架时，构建工具（如\nMaven、Gradle）会自动解析和加载其所有的直接和间接依赖，确保这些依赖都可用。\n依赖传递的作用是：\n\n减少重复依赖：当多个项目依赖同一个库时，Maven\n可以自动下载并且只下载一次该库。这样可以减少项目的构建时间和磁盘空间。\n自动管理依赖: Maven\n可以自动管理依赖项，使用依赖传递，简化了依赖项的管理，使项目构建更加可靠和一致。\n确保依赖版本正确性：通过依赖传递的依赖，之间都不会存在版本兼容性问题，确实依赖的版本正确性！\n\n依赖传递演示：\n项目中，需要导入jackson相关的依赖，通过之前导入经验，jackson需要导入三个依赖，分别为：\n通过查看网站介绍的依赖传递特性：data-bind中，依赖其他两个依赖\n最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖\n&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt;\n依赖冲突演示：\n当直接引用或者间接引用出现了相同的jar包!\n这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！\nmaven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！\n解决依赖冲突（如何选择重复依赖）方式：\n\n自动选择原则\n\n短路优先原则（第一原则）\nA—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)\nA—&gt;F—&gt;X(version 0.0.2)\n则A依赖于X(version 0.0.2)。\n依赖路径长度相同情况下，则“先声明优先”（第二原则）\nA—&gt;E—&gt;X(version 0.0.1)\nA—&gt;F—&gt;X(version 0.0.2)\n在&lt;depencies&gt;&lt;/depencies&gt;中，先声明的，路径相同，会优先选择！\n\n\n小思考:\n前提：   A 1.1 -&gt; B 1.1 -&gt; C 1.1    F 2.2 -&gt; B 2.2    pom声明：   F 2.2   A 1.1    B 2.2 (C 1.1也不会被导入)\n3.3 依赖导入失败场景和解决方案\n在使用 Maven\n构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：\n\n下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven\n仓库，从而无法下载依赖。\n依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致\nMaven 下载的依赖项与实际需要的不一致，从而引发错误。\n本地 Maven 仓库或缓存被污染或损坏，导致 Maven\n无法正确地使用现有的依赖项，并且也无法重新下载！\n\n解决方案：\n\n检查网络连接和 Maven 仓库服务器状态。\n确保依赖项的版本号与项目对应的版本号匹配，并检查 POM\n文件中的依赖项是否正确。\n清除本地 Maven 仓库缓存（lastUpdated\n文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！\n例如： pom.xml依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid&lt;/artifactId&gt;  &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt;\n脚本使用：\n清理maven错误缓存.bat\n@echo offrem 这里写你的仓库路径set REPOSITORY_PATH=D:\\Maven\\repositoryrem 正在搜索...for /f \"delims=\" %%i in ('dir /b /s \"%REPOSITORY_PATH%\\*lastUpdated*\"') do (    del /s /q %%i)rem 搜索完毕pause\n\n3.4 扩展构建管理和插件配置\n构建概念:\n项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。\n主动触发场景：\n\n重新编译 : 编译不充分, 部分文件没有被编译!\n打包 : 独立部署到外部服务器软件,打包部署\n部署本地或者私服仓库 :\nmaven工程加入到本地或者私服仓库,供其他工程使用\n\n命令方式构建:\n语法: mvn 构建命令 构建命令….\n\n\n\n命令\n描述\n\n\n\n\nmvn clean\n清理编译或打包后的项目结构,删除target文件夹\n\n\nmvn compile\n编译项目，生成target文件\n\n\nmvn test\n执行测试源码 (测试)\n\n\nmvn site\n生成一个项目依赖信息的展示页面\n\n\nmvn package\n打包项目，生成war / jar 文件\n\n\nmvn install\n打包后上传到maven本地仓库(本地部署)\n\n\nmvn deploy\n只打包，上传到maven私服仓库(私服部署)\n\n\n\n可视化方式构建:\n构建命令周期:\n构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！也是一种简化构建的思路!\n\n清理周期：主要是对项目编译生成文件进行清理\n包含命令：clean\n默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分\n包含命令：compile - test - package - install / deploy\n报告周期\n包含命令：site\n打包: mvn clean package 本地仓库: mvn clean install\n\n最佳使用方案:\n打包: mvn clean package重新编译: mvn clean compile本地部署: mvn clean install \n周期，命令和插件:\n周期→包含若干命令→包含若干插件!\n使用周期命令构建，简化构建过程！\n最终进行构建的是插件！\n插件配置:\n&lt;build&gt;   &lt;!-- jdk17 和 war包版本插件不匹配 --&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;            &lt;version&gt;3.2.2&lt;/version&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;\n4 Maven继承和聚合特性\n4.1 Maven工程继承关系\n\n继承概念\nMaven 继承是指在 Maven\n的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。\n继承作用\n作用：在父工程中统一管理项目中的依赖信息,进行统一版本管理!\n它的背景是：\n\n对一个比较大型的项目进行了模块拆分。\n一个 project 下面，创建了很多个 module。\n每一个 module 都需要配置自己的依赖信息。 它背后的需求是：\n多个模块要使用同一个框架，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一管理。\n使用框架时所需要的 jar\n包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。\n通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的\njar 包；又能够将以往的经验沉淀下来，节约时间和精力。\n\n继承语法\n\n父工程\n\n&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;&lt;packaging&gt;pom&lt;/packaging&gt;\n\n\n子工程\n\n&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;&lt;parent&gt;  &lt;!-- 父工程的坐标 --&gt;  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;  &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;!-- 子工程的坐标 --&gt;&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;\n\n父工程依赖统一管理\n\n父工程声明版本\n&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;&lt;dependencyManagement&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;      &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;      &lt;version&gt;4.0.0.RELEASE&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/dependencyManagement&gt;\n子工程引用版本\n&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n4.2 Maven工程聚合关系\n\n聚合概念\nMaven\n聚合是指将多个项目组织到一个父级项目中，通过触发父工程的构建,统一按顺序触发子工程构建的过程!!\n聚合作用\n\n统一管理子项目构建：通过聚合，可以将多个子项目组织在一起，方便管理和维护。\n优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。\n\n聚合语法\n父项目中包含的子项目列表。\n&lt;project&gt;  &lt;groupId&gt;com.example&lt;/groupId&gt;  &lt;artifactId&gt;parent-project&lt;/artifactId&gt;  &lt;packaging&gt;pom&lt;/packaging&gt;  &lt;version&gt;1.0.0&lt;/version&gt;  &lt;modules&gt;    &lt;module&gt;child-project1&lt;/module&gt;    &lt;module&gt;child-project2&lt;/module&gt;  &lt;/modules&gt;&lt;/project&gt;\n聚合演示\n通过触发父工程构建命令、引发所有子模块构建！产生反应堆！\n\n5 Maven核心掌握总结\n\n\n\n核心点\n掌握目标\n\n\n\n\n安装\nmaven安装、环境变量、maven配置文件修改\n\n\n工程创建\ngavp属性理解、JavaSE/EE工程创建、项目结构\n\n\n依赖管理\n依赖添加、依赖传递、版本提取、导入依赖错误解决\n\n\n构建管理\n构建过程、构建场景、构建周期等\n\n\n继承和聚合\n理解继承和聚合作用、继承语法和实践、聚合语法和实践\n\n\n\n","categories":["Maven"],"tags":["Maven"]},{"title":"MyBatis-Plus 实践","url":"/2024/06/18/MyBatis-Plus-%E5%AE%9E%E8%B7%B5/","content":"MyBatis-Plus 使用实践指南，涵盖基于 Mapper 与 Service 的 CRUD\n操作、条件构造器详解、核心注解用法、分页与插件机制，以及 MyBatis-X\n逆向工程等高级功能，助力高效构建企业级持久层架构。\n\n一、MyBatis-Plus快速入门\n1.1 简介\n\n课程版本：3.5.3.1\n\nhttps://baomidou.com/\nMyBatis-Plus [ (opens new\nwindow)](https://github.com/baomidou/mybatis-plus ” (opens new\nwindow)“)（简称 MP）是一个 MyBatis [ (opens new\nwindow)](https://www.mybatis.org/mybatis-3/” (opens new window)“)\n的增强工具，在 MyBatis\n的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n特性：\n\n无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑\n损耗小：启动即会自动注入基本\nCURD，性能基本无损耗，直接面向对象操作\n强大的 CRUD 操作：内置通用 Mapper、通用\nService，仅仅通过少量配置即可实现单表大部分 CRUD\n操作，更有强大的条件构造器，满足各类使用需求\n支持 Lambda 形式调用：通过 Lambda\n表达式，方便的编写各类查询条件，无需再担心字段写错\n支持主键自动生成：支持多达 4\n种主键策略（内含分布式唯一 ID 生成器 -\nSequence），可自由配置，完美解决主键问题\n支持 ActiveRecord 模式：支持 ActiveRecord\n形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作\n支持自定义全局通用操作：支持全局通用方法注入（\nWrite once, use anywhere ）\n内置代码生成器：采用代码或者 Maven 插件可快速生成\nMapper 、 Model 、 Service 、 Controller\n层代码，支持模板引擎，更有超多自定义配置等您来使用\n内置分页插件：基于 MyBatis\n物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List\n查询\n分页插件支持多种数据库：支持\nMySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer\n等多种数据库\n内置性能分析插件：可输出 SQL\n语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询\n内置全局拦截插件：提供全表 delete 、 update\n操作智能分析阻断，也可自定义拦截规则，预防误操作\n\n支持数据库：\n\nMySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss\n，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift\n达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库\n\nmybatis-plus总结：\n自动生成单表的CRUD功能\n提供丰富的条件拼接方式\n全自动ORM类型持久层框架\n1.2 快速入门\n\n准备数据库脚本\n现有一张 User 表，其表结构如下：\n\n\n\n\n\n\n\n\n\nid\nname\nage\nemail\n\n\n\n\n1\nJone\n18\ntest1@baomidou.com\n\n\n2\nJack\n20\ntest2@baomidou.com\n\n\n3\nTom\n28\ntest3@baomidou.com\n\n\n4\nSandy\n21\ntest4@baomidou.com\n\n\n5\nBillie\n24\ntest5@baomidou.com\n\n\n\nDROP TABLE IF EXISTS user;CREATE TABLE user(    id BIGINT(20) NOT NULL COMMENT '主键ID',    name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',    age INT(11) NULL DEFAULT NULL COMMENT '年龄',    email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',    PRIMARY KEY (id));INSERT INTO user (id, name, age, email) VALUES(1, 'Jone', 18, 'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com');\n准备boot工程\n导入依赖\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.5&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.atguigu&lt;/groupId&gt;    &lt;artifactId&gt;springboot-starter-mybatis-plus-06&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;            &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;                &lt;!-- 测试环境 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;/dependency&gt;                &lt;!-- mybatis-plus  --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.5.3.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 数据库相关配置启动器 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- druid启动器的依赖  --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid-spring-boot-3-starter&lt;/artifactId&gt;            &lt;version&gt;1.2.18&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 驱动类--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.28&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;        &lt;!--    SpringBoot应用打包插件--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n配置文件和启动类\napplication.yaml\n# 连接池配置spring:  datasource:    type: com.alibaba.druid.pool.DruidDataSource    druid:      url: jdbc:mysql:///day01      username: root      password: root      driver-class-name: com.mysql.cj.jdbc.Driver\n启动类\n@MapperScan(\"com.atguigu.mapper\")@SpringBootApplicationpublic class MainApplication {    public static void main(String[] args) {        SpringApplication.run(MainApplication.class,args);    }    }\n功能编码\n编写实体类 User.java（此处使用了 Lombok [\n](https://www.projectlombok.org/ ” “)简化代码）\n@Datapublic class User {    private Long id;    private String name;    private Integer age;    private String email;}\n编写 Mapper 包下的 UserMapper接口\npublic interface UserMapper extends BaseMapper&lt;User&gt; {}\n继承mybatis-plus提供的基础Mapper接口，自带crud方法！\n测试和使用\n添加测试类，进行功能测试：\n@SpringBootTest //springboot下测试环境注解public class SampleTest {    @Autowired    private UserMapper userMapper;    @Test    public void testSelect() {        System.out.println((\"----- selectAll method test ------\"));        List&lt;User&gt; userList = userMapper.selectList(null);        userList.forEach(System.out::println);    }}\n小结\n通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML\n文件都不用编写！\n从以上步骤中，我们可以看到集成MyBatis-Plus非常的简单，只需要引入\nstarter 工程，并配置 mapper 扫描路径即可。\n\n二、MyBatis-Plus核心功能\n2.1 基于Mapper接口CRUD\n\n通用 CRUD 封装BaseMapper (opens new\nwindow)接口， Mybatis-Plus\n启动时自动解析实体表关系映射转换为 Mybatis\n内部对象注入容器! 内部包含常见的单表操作！\n\nInsert方法\n// 插入一条记录// T 就是要插入的实体对象// 默认主键生成策略为雪花算法（后面讲解）int insert(T entity);\n\n\n\n类型\n参数名\n描述\n\n\n\n\nT\nentity\n实体对象\n\n\n\nDelete方法\n// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);\n\n\n\n\n\n\n\n\n类型\n参数名\n描述\n\n\n\n\nWrapper&lt;T&gt;\nwrapper\n实体对象封装操作类（可以为 null）\n\n\nCollection&lt;? extends Serializable&gt;\nidList\n主键 ID 列表(不能为 null 以及 empty)\n\n\nSerializable\nid\n主键 ID\n\n\nMap&lt;String, Object&gt;\ncolumnMap\n表字段 map 对象\n\n\n\nUpdate方法\n// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity,             @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改  主键属性必须值int updateById(@Param(Constants.ENTITY) T entity);\n\n\n\n\n\n\n\n\n类型\n参数名\n描述\n\n\n\n\nT\nentity\n实体对象 (set 条件值,可为 null)\n\n\nWrapper&lt;T&gt;\nupdateWrapper\n实体对象封装操作类（可以为 null,里面的 entity 用于生成 where\n语句）\n\n\n\nSelect方法\n// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);\n参数说明\n\n\n\n\n\n\n\n\n类型\n参数名\n描述\n\n\n\n\nSerializable\nid\n主键 ID\n\n\nWrapper&lt;T&gt;\nqueryWrapper\n实体对象封装操作类（可以为 null）\n\n\nCollection&lt;? extends Serializable&gt;\nidList\n主键 ID 列表(不能为 null 以及 empty)\n\n\nMap&lt;String, Object&gt;\ncolumnMap\n表字段 map 对象\n\n\nIPage&lt;T&gt;\npage\n分页查询条件（可以为 RowBounds.DEFAULT）\n\n\n\n自定义和多表映射\nmybatis-plus的默认mapperxml位置\nmybatis-plus: # mybatis-plus的配置  # 默认位置 private String[] mapperLocations = new String[]{\"classpath*:/mapper/**/*.xml\"};      mapper-locations: classpath:/mapper/*.xml\n自定义mapper方法：\npublic interface UserMapper extends BaseMapper&lt;User&gt; {    //正常自定义方法！    //可以使用注解@Select或者mapper.xml实现    List&lt;User&gt; queryAll();}\n基于mapper.xml实现：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace = 接口的全限定符 --&gt;&lt;mapper namespace=\"com.atguigu.mapper.UserMapper\"&gt;   &lt;select id=\"queryAll\" resultType=\"user\" &gt;       select * from user   &lt;/select&gt;&lt;/mapper&gt;\n2.2 基于Service接口CRUD\n通用 Service CRUD 封装IService接口，进一步封装 CRUD\n采用 get 查询单行 remove 删除\nlist 查询集合 page 分页 前缀命名方式区分\nMapper 层避免混淆，\n对比Mapper接口CRUD区别：\n\nservice添加了批量方法\nservice层的方法自动添加事务\n\n使用Iservice接口方式\n接口继承IService接口\npublic interface UserService extends IService&lt;User&gt; {}\n类继承ServiceImpl实现类\n@Servicepublic class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService{}\nCRUD方法介绍\n保存：// 插入一条记录（选择字段，策略插入）boolean save(T entity);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList);// 插入（批量）boolean saveBatch(Collection&lt;T&gt; entityList, int batchSize);修改或者保存：// TableId 注解存在更新记录，否插入一条记录boolean saveOrUpdate(T entity);// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法boolean saveOrUpdate(T entity, Wrapper&lt;T&gt; updateWrapper);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList);// 批量修改插入boolean saveOrUpdateBatch(Collection&lt;T&gt; entityList, int batchSize);移除：// 根据 queryWrapper 设置的条件，删除记录boolean remove(Wrapper&lt;T&gt; queryWrapper);// 根据 ID 删除boolean removeById(Serializable id);// 根据 columnMap 条件，删除记录boolean removeByMap(Map&lt;String, Object&gt; columnMap);// 删除（根据ID 批量删除）boolean removeByIds(Collection&lt;? extends Serializable&gt; idList);更新：// 根据 UpdateWrapper 条件，更新记录 需要设置sqlsetboolean update(Wrapper&lt;T&gt; updateWrapper);// 根据 whereWrapper 条件，更新记录boolean update(T updateEntity, Wrapper&lt;T&gt; whereWrapper);// 根据 ID 选择修改boolean updateById(T entity);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList);// 根据ID 批量更新boolean updateBatchById(Collection&lt;T&gt; entityList, int batchSize);数量： // 查询总记录数int count();// 根据 Wrapper 条件，查询总记录数int count(Wrapper&lt;T&gt; queryWrapper);查询：// 根据 ID 查询T getById(Serializable id);// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(\"LIMIT 1\")T getOne(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录T getOne(Wrapper&lt;T&gt; queryWrapper, boolean throwEx);// 根据 Wrapper，查询一条记录Map&lt;String, Object&gt; getMap(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper，查询一条记录&lt;V&gt; V getObj(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);集合：// 查询所有List&lt;T&gt; list();// 查询列表List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）Collection&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList);// 查询（根据 columnMap 条件）Collection&lt;T&gt; listByMap(Map&lt;String, Object&gt; columnMap);// 查询所有列表List&lt;Map&lt;String, Object&gt;&gt; listMaps();// 查询列表List&lt;Map&lt;String, Object&gt;&gt; listMaps(Wrapper&lt;T&gt; queryWrapper);// 查询全部记录List&lt;Object&gt; listObjs();// 查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Function&lt;? super Object, V&gt; mapper);// 根据 Wrapper 条件，查询全部记录List&lt;Object&gt; listObjs(Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录&lt;V&gt; List&lt;V&gt; listObjs(Wrapper&lt;T&gt; queryWrapper, Function&lt;? super Object, V&gt; mapper);\n2.3 分页查询实现\n\n导入分页插件\n@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() {    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));    return interceptor;}\n使用分页查询\n@Testpublic void testPageQuery(){    //设置分页参数    Page&lt;User&gt; page = new Page&lt;&gt;(1, 5);    userMapper.selectPage(page, null);    //获取分页数据    List&lt;User&gt; list = page.getRecords();    list.forEach(System.out::println);    System.out.println(\"当前页：\"+page.getCurrent());    System.out.println(\"每页显示的条数：\"+page.getSize());    System.out.println(\"总记录数：\"+page.getTotal());    System.out.println(\"总页数：\"+page.getPages());    System.out.println(\"是否有上一页：\"+page.hasPrevious());    System.out.println(\"是否有下一页：\"+page.hasNext());}\n自定义的mapper方法使用分页\n//传入参数携带Ipage接口//返回结果为IPageIPage&lt;User&gt; selectPageVo(IPage&lt;?&gt; page, Integer id);\n&lt;select id=\"selectPageVo\" resultType=\"xxx.xxx.xxx.User\"&gt;    SELECT * FROM user WHERE id &gt; #{id}&lt;/select&gt;\n@Testpublic void testQuick(){    IPage page = new Page(1,2);    userMapper.selectPageVo(page,2);    long current = page.getCurrent();    System.out.println(\"current = \" + current);    long pages = page.getPages();    System.out.println(\"pages = \" + pages);    long total = page.getTotal();    System.out.println(\"total = \" + total);    List records = page.getRecords();    System.out.println(\"records = \" + records);}\n\n2.4 条件构造器使用\n2.4.1 条件构造器作用\n实例代码：\nQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(\"name\", \"John\"); // 添加等于条件queryWrapper.ne(\"age\", 30); // 添加不等于条件queryWrapper.like(\"email\", \"@gmail.com\"); // 添加模糊匹配条件等同于： delete from user where name = \"John\" and age != 30                                  and email like \"%@gmail.com%\"// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);\n使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的\nSQL\n语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。\n2.4.2 条件构造器继承结构\n条件构造器类结构：\n\nWrapper ： 条件构造抽象类，最顶端父类\n\nAbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件\n\nQueryWrapper ： 查询/删除条件封装\nUpdateWrapper ： 修改条件封装\nAbstractLambdaWrapper ： 使用Lambda 语法\n\nLambdaQueryWrapper\nLambdaUpdateWrapper\n\n\n\n2.4.3 基于QueryWrapper 组装条件\n\n组装查询条件：\n@Testpublic void test01(){    //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.like(\"username\", \"a\")            .between(\"age\", 20, 30)            .isNotNull(\"email\");    List&lt;User&gt; list = userMapper.selectList(queryWrapper);    list.forEach(System.out::println);}\n组装排序条件:\n@Testpublic void test02(){    //按年龄降序查询用户，如果年龄相同则按id升序排列    //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper            .orderByDesc(\"age\")            .orderByAsc(\"id\");    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);}\n组装删除条件:\n@Testpublic void test03(){    //删除email为空的用户    //DELETE FROM t_user WHERE (email IS NULL)    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.isNull(\"email\");    //条件构造器也可以构建删除语句的条件    int result = userMapper.delete(queryWrapper);    System.out.println(\"受影响的行数：\" + result);}\nand和or关键字使用(修改)：\n@Testpublic void test04() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改    //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)    queryWrapper            .like(\"username\", \"a\")            .gt(\"age\", 20)            .or()            .isNull(\"email\");    User user = new User();    user.setAge(18);    user.setEmail(\"user@atguigu.com\");    int result = userMapper.update(user, queryWrapper);    System.out.println(\"受影响的行数：\" + result);}\n指定列映射查询：\n@Testpublic void test05() {    //查询用户信息的username和age字段    //SELECT username,age FROM t_user    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select(\"username\", \"age\");    //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);    maps.forEach(System.out::println);}\ncondition判断组织条件:\n @Testpublic void testQuick3(){        String name = \"root\";    int    age = 18;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //判断条件拼接    //当name不为null拼接等于, age &gt; 1 拼接等于判断    //方案1: 手动判断    if (!StringUtils.isEmpty(name)){        queryWrapper.eq(\"name\",name);    }    if (age &gt; 1){        queryWrapper.eq(\"age\",age);    }        //方案2: 拼接condition判断    //每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!    //eq(condition,列名,值)    queryWrapper.eq(!StringUtils.isEmpty(name),\"name\",name)            .eq(age&gt;1,\"age\",age);   }\n2.3.4 基于\nUpdateWrapper组装条件\n使用queryWrapper:\n@Testpublic void test04() {    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改    //UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)    queryWrapper            .like(\"username\", \"a\")            .gt(\"age\", 20)            .or()            .isNull(\"email\");    User user = new User();    user.setAge(18);    user.setEmail(\"user@atguigu.com\");    int result = userMapper.update(user, queryWrapper);    System.out.println(\"受影响的行数：\" + result);}\n注意：使用queryWrapper +\n实体类形式可以实现修改，但是无法将列值修改为null值！\n使用updateWrapper:\n@Testpublic void testQuick2(){    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    //将id = 3 的email设置为null, age = 18    updateWrapper.eq(\"id\",3)            .set(\"email\",null)  // set 指定列和结果            .set(\"age\",18);    //如果使用updateWrapper 实体对象写null即可!    int result = userMapper.update(null, updateWrapper);    System.out.println(\"result = \" + result);}\n使用updateWrapper可以随意设置列的值！！\n2.3.5\n基于LambdaQueryWrapper组装条件\n1. LambdaQueryWrapper对比QueryWrapper优势\nQueryWrapper 示例代码：\nQueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();queryWrapper.eq(\"name\", \"John\")  .ge(\"age\", 18)  .orderByDesc(\"create_time\")  .last(\"limit 10\");List&lt;User&gt; userList = userMapper.selectList(queryWrapper);\nLambdaQueryWrapper 示例代码：\nLambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = new LambdaQueryWrapper&lt;&gt;();lambdaQueryWrapper.eq(User::getName, \"John\")  .ge(User::getAge, 18)  .orderByDesc(User::getCreateTime)  .last(\"limit 10\");List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);\n从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper\n使用了实体类的属性引用（例如\nUser::getName、User::getAge），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。\n2. lambda表达式回顾\nLambda 表达式是 Java 8\n引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda\n表达式可以用于简化代码，提高代码的可读性和可维护性。\nLambda 表达式的语法可以分为以下几个部分：\n\n参数列表： 参数列表用小括号 ()\n括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。\n示例：(a, b), x -&gt;,\n() -&gt;\n箭头符号： 箭头符号 -&gt;\n分割参数列表和 Lambda 表达式的主体部分。\n示例：-&gt;\nLambda 表达式的主体： Lambda\n表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略\nreturn 关键字；如果是多条语句的代码块，需要使用大括号 {}\n括起来，并且需要明确指定 return 关键字。\n示例：\n\n单个表达式：x -&gt; x * x\n代码块：(x, y) -&gt; { int sum = x + y; return sum; }\n\n\nLambda 表达式的语法可以更具体地描述如下：\n// 使用 Lambda 表达式实现一个接口的方法interface Greeting {    void sayHello();}public class LambdaExample {    public static void main(String[] args) {            //原始匿名内部类方式        Greeting greeting = new Greeting() {            @Override            public void sayHello(int a) {                System.out.println(\"Hello, world!\");            }        };                a-&gt;System.out.println(\"Hello, world!\")                // 使用 Lambda 表达式实现接口的方法        greeting = () -&gt; System.out.println(\"Hello, world!\");          System.out::println;           () -&gt;  类.XXX(); -&gt; 类：：方法名        // 调用接口的方法        greeting.sayHello();    }}\n3. 方法引用回顾:\n方法引用是 Java 8\n中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代\nLambda 表达式，使代码更简洁、更易读。\nJava 8 支持以下几种方法引用的形式：\n\n静态方法引用： 引用静态方法，语法为\n类名::静态方法名。\n实例方法引用： 引用实例方法，语法为\n实例对象::实例方法名。\n对象方法引用： 引用特定对象的实例方法，语法为\n类名::实例方法名。\n构造函数引用： 引用构造函数，语法为\n类名::new。\n\n演示代码:\nimport java.util.Arrays;import java.util.List;import java.util.function.Consumer;public class MethodReferenceExample {    public static void main(String[] args) {        List&lt;String&gt; names = Arrays.asList(\"John\", \"Tom\", \"Alice\");        // 使用 Lambda 表达式        names.forEach(name -&gt; System.out.println(name));        // 使用方法引用        names.forEach(System.out::println);    }}\n2.3.6\n基于LambdaUpdateWrapper组装条件\n使用案例:\n@Testpublic void testQuick2(){    UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;();    //将id = 3 的email设置为null, age = 18    updateWrapper.eq(\"id\",3)            .set(\"email\",null)  // set 指定列和结果            .set(\"age\",18);    //使用lambdaUpdateWrapper    LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = new LambdaUpdateWrapper&lt;&gt;();    updateWrapper1.eq(User::getId,3)            .set(User::getEmail,null)            .set(User::getAge,18);        //如果使用updateWrapper 实体对象写null即可!    int result = userMapper.update(null, updateWrapper);    System.out.println(\"result = \" + result);}\n2.5 核心注解使用\n\n理解和介绍\nMyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。\nMyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。\n理解：\npublic interface UserMapper extends BaseMapper&lt;User&gt; {}\n此接口对应的方法为什么会自动触发 user表的crud呢？\n默认情况下，\n根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！\n但是不是所有数据库的信息和实体类都完全映射！\n例如： 表名 t_user → 实体类 User 这时候就不对应了！\n自定义映射关系就可以使用mybatis-plus提供的注解即可！\n@TableName注解\n\n描述：表名注解，标识实体类对应的表\n使用位置：实体类\n\n@TableName(\"sys_user\") //对应数据库表名public class User {    private Long id;    private String name;    private Integer age;    private String email;}\n特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！\n其他解决方案：全局设置前缀 (https://www.baomidou.com/pages/56bac0/#基本配置)\nmybatis-plus: # mybatis-plus的配置  global-config:    db-config:      table-prefix: sys_ # 表名前缀字符串\n@TableId\n注解\n\n描述：主键注解\n使用位置：实体类主键字段\n\n@TableName(\"sys_user\")public class User {    @TableId(value=\"主键列名\",type=主键策略)    private Long id;    private String name;    private Integer age;    private String email;}\nmybatis-plus:  configuration:    # 配置MyBatis日志    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  global-config:    db-config:      # 配置MyBatis-Plus操作表的默认前缀      table-prefix: t_      # 配置MyBatis-Plus的主键策略      id-type: auto\n在以下场景下，添加@TableId注解是必要的：\n\n实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用@TableId注解来指定实体类中表示主键的字段。\n主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加@TableId注解，并通过value属性指定生成策略。\n\n雪花算法使用场景\n雪花算法（Snowflake\nAlgorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。\n在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。\n雪花算法生成的ID是一个64位的整数，由以下几个部分组成：\n\n时间戳：41位，精确到毫秒级，可以使用69年。\n节点ID：10位，用于标识分布式系统中的不同节点。\n序列号：12位，表示在同一毫秒内生成的不同ID的序号。\n通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。\n雪花算法的工作方式如下：\n当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。\n节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。\n序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。\n需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。\n雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。\n\n你需要记住的: 雪花算法生成的数字,需要使用Long 或者\nString类型主键!!\n@TableField\n描述：字段注解（非主键）\n@TableName(\"sys_user\")public class User {    @TableId    private Long id;    @TableField(\"nickname\")    private String name;    private Integer age;    private String email;}\nMyBatis-Plus会自动开启驼峰命名风格映射!!!\n\n三、MyBatis-Plus高级扩展\n3.1 逻辑删除实现\n概念:\n逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。\n\n物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据\n逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录\n\n逻辑删除实现:\n\n数据库和实体类添加逻辑删除字段\n\n表添加逻辑删除字段\n可以是一个布尔类型、整数类型或枚举类型。\nALTER TABLE USER ADD deleted INT DEFAULT 0 ;  # int 类型 1 逻辑删除 0 未逻辑删除\n实体类添加逻辑删除属性\n@Datapublic class User {   // @TableId    private Integer id;    private String name;    private Integer age;    private String email;    @TableLogic    //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除 0     private Integer deleted;}\n\n指定逻辑删除字段和属性值\n\n单一指定\n@Datapublic class User {   // @TableId    private Integer id;    private String name;    private Integer age;    private String email;     @TableLogic    //逻辑删除字段 int mybatis-plus下,默认 逻辑删除值为1 未逻辑删除0    private Integer deleted;}\n全局指定\nmybatis-plus:  global-config:    db-config:      logic-delete-field: deleted # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以不配置步骤2)      logic-delete-value: 1 # 逻辑已删除值(默认为 1)      logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n\n演示逻辑删除操作\n\n逻辑删除以后,没有真正的删除语句,删除改为修改语句!\n\n\n//逻辑删除@Testpublic void testQuick5(){    //逻辑删除    userMapper.deleteById(5);}\n执行效果:\nJDBC Connection\n[com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl@5871a482] will not be\nmanaged by Spring ==&gt; Preparing: UPDATE user SET deleted=1 WHERE id=?\nAND deleted=0 ==&gt; Parameters: 5(Integer) &lt;== Updates: 1\n\n测试查询数据\n@Testpublic void testQuick6(){    //正常查询.默认查询非逻辑删除数据    userMapper.selectList(null);}//SELECT id,name,age,email,deleted FROM user WHERE deleted=0\n\n3.2 乐观锁实现\n3.2.1 悲观锁和乐观锁场景和介绍\n并发问题场景演示:\n\n乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!!\n悲观锁：\n悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。\n乐观锁：\n乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。\n理解点:\n悲观锁和乐观锁是两种解决并发数据问题的思路,不是具体技术!!!\n具体技术和方案:\n\n乐观锁实现方案和技术：\n\n版本号/时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。\nCAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。\n无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。\n\n悲观锁实现方案和技术：\n\n锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write\nLock）来保证对共享资源的独占访问。\n数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。\n信号量（Semaphore）：使用信号量来限制对资源的并发访问。\n\n\n介绍版本号乐观锁技术的实现流程:\n\n每条数据添加一个版本号字段version\n取出记录时，获取当前 version\n更新时，检查获取版本号是不是数据库当前最新版本号\n如果是[证明没有人修改数据], 执行更新, set 数据更新 , version =\nversion+ 1 \n如果 version\n不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败\n\n3.2.2\n使用mybatis-plus数据使用乐观锁\n 1. 添加版本号更新插件\n@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() {    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());    return interceptor;}\n\n乐观锁字段添加@Version注解\n注意: 数据库也需要添加version字段\nALTER TABLE USER ADD VERSION INT DEFAULT 1 ;  # int 类型 乐观锁字段\n\n支持的类型:int,Integer,long,Long,Date,Timestamp,LocalDateTime\n仅支持 updateById(id) 与\nupdate(entity, wrapper) 方法\n\n@Versionprivate Integer version;\n正常更新使用即可\n//演示乐观锁生效场景@Testpublic void testQuick7(){    //步骤1: 先查询,在更新 获取version数据    //同时查询两条,但是version唯一,最后更新的失败    User user  = userMapper.selectById(5);    User user1  = userMapper.selectById(5);    user.setAge(20);    user1.setAge(30);    userMapper.updateById(user);    //乐观锁生效,失败!    userMapper.updateById(user1);}\n\n3.3 防全表更新和删除实现\n针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除\n添加防止全表更新和删除拦截器\n@Beanpublic MybatisPlusInterceptor mybatisPlusInterceptor() {    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();    interceptor.addInnerInterceptor(new BlockAttackInnerInterceptor());    return interceptor;}\n测试全部更新或者删除\n@Testpublic void testQuick8(){    User user = new User();    user.setName(\"custom_name\");    user.setEmail(\"xxx@mail.com\");    //Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation    //全局更新,报错    userService.saveOrUpdate(user,null);}\n四、MyBatis-Plus代码生成器(MyBatisX插件)\n4.1 Mybatisx插件逆向工程\nMyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率\n但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件\nMyBatisX一款基于 IDEA 的快速开发插件，为效率而生。\n\n\n\n4.2 MyBatisX快速代码生成\n使用mybatisX插件,自动生成sql语句实现\nhttps://baomidou.com/pages/ba5b24/#功能\n","categories":["后端","Spring"],"tags":["Persistence Layer","MyBatis"]},{"title":"SQL DDL语句","url":"/2024/02/21/SQL-DDL%E8%AF%AD%E5%8F%A5/","content":"详解 SQL\n数据定义语言（DDL）的核心操作，涵盖数据库创建与切换、表结构设计（字段类型、约束、别名）、ALTER\n语句动态修改列属性与表名，以及 DROP 与 TRUNCATE 的差异对比。结合 MySQL\n8.0 原子性 DDL\n特性，解析表结构变更的事务安全保障，并融入阿里开发规范，强化字段命名规则与表设计最佳实践。\n\n1. 基础知识\n1.1 一条数据存储的过程\n存储数据是处理数据的第一步。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。\n那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？\n在 MySQL 中，一个完整的数据存储过程总共有 4\n步，分别是创建数据库、确认字段、创建数据表、插入数据。\n\n\nimage-20211007155810920\n\n我们要先创建一个数据库，而不是直接创建数据表呢？\n因为从系统架构的层次上看，MySQL\n数据库系统从大到小依次是数据库服务器、数据库、数据表、数据表的行与列。\nMySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。\n1.2 标识符命名规则\n\n数据库名、表名不得超过30个字符，变量名限制为29个\n必须只能包含 A–Z, a–z, 0–9, _共63个字符\n数据库名、表名、字段名等对象名中间不要包含空格\n同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名\n必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来\n保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了\n\n1.3 MySQL中的数据类型\n\n\n\n\n\n\n\n类型\n类型举例\n\n\n\n\n整数类型\nTINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT\n\n\n浮点类型\nFLOAT、DOUBLE\n\n\n定点数类型\nDECIMAL\n\n\n位类型\nBIT\n\n\n日期时间类型\nYEAR、TIME、DATE、DATETIME、TIMESTAMP\n\n\n文本字符串类型\nCHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT\n\n\n枚举类型\nENUM\n\n\n集合类型\nSET\n\n\n二进制字符串类型\nBINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB\n\n\nJSON类型\nJSON对象、JSON数组\n\n\n空间数据类型\n单值：GEOMETRY、POINT、LINESTRING、POLYGON；集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION\n\n\n\n其中，常用的几类类型介绍如下：\n\n\n\n\n\n\n\n数据类型\n描述\n\n\n\n\nINT\n从-231到231-1的整型数据。存储大小为 4个字节\n\n\nCHAR(size)\n定长字符数据。若未指定，默认为1个字符，最大长度255\n\n\nVARCHAR(size)\n可变长字符数据，根据字符串实际长度保存，必须指定长度\n\n\nFLOAT(M,D)\n单精度，占用4个字节，M=整数位+小数位，D=小数位。\nD&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=6\n\n\nDOUBLE(M,D)\n双精度，占用8个字节，D&lt;=M&lt;=255,0&lt;=D&lt;=30，默认M+D&lt;=15\n\n\nDECIMAL(M,D)\n高精度小数，占用M+2个字节，D&lt;=M&lt;=65，0&lt;=D&lt;=30，最大取值范围与DOUBLE相同。\n\n\nDATE\n日期型数据，格式’YYYY-MM-DD’\n\n\nBLOB\n二进制形式的长文本数据，最大可达4G\n\n\nTEXT\n长文本数据，最大可达4G\n\n\n\n2. 创建和管理数据库\n2.1 创建数据库\n\n方式1：创建数据库\n\nCREATE DATABASE 数据库名; \n\n方式2：创建数据库并指定字符集\n\nCREATE DATABASE 数据库名 CHARACTER SET 字符集;\n\n方式3：判断数据库是否已经存在，不存在则创建数据库（推荐）\n\nCREATE DATABASE IF NOT EXISTS 数据库名; \n如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。\n\n注意：DATABASE\n不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。\n\n2.2 使用数据库\n\n查看当前所有的数据库\n\nSHOW DATABASES; #有一个S，代表多个数据库\n\n查看当前正在使用的数据库\n\nSELECT DATABASE();  #使用的一个 mysql 中的全局函数\n\n查看指定库下所有的表\n\nSHOW TABLES FROM 数据库名;\n\n查看数据库的创建信息\n\nSHOW CREATE DATABASE 数据库名;或者：SHOW CREATE DATABASE 数据库名\\G\n\n使用/切换数据库\n\nUSE 数据库名;\n\n注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。\n\n2.3 修改数据库\n\n更改数据库字符集\n\nALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等\n2.4 删除数据库\n\n方式1：删除指定的数据库\n\nDROP DATABASE 数据库名;\n\n方式2：删除指定的数据库（推荐）\n\nDROP DATABASE IF EXISTS 数据库名;\n3. 创建表\n3.1 创建方式1\n\n必须具备：\n\nCREATE TABLE权限\n存储空间\n\n语法格式：\n\nCREATE TABLE [IF NOT EXISTS] 表名(\t字段1, 数据类型 [约束条件] [默认值],\t字段2, 数据类型 [约束条件] [默认值],\t字段3, 数据类型 [约束条件] [默认值],\t……\t[表约束条件]);\n\n加上了IF NOT\nEXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。\n\n\n必须指定：\n\n表名\n列名(或字段名)，数据类型，长度\n\n可选指定：\n\n约束条件\n默认值\n\n创建表举例1：\n\n-- 创建表CREATE TABLE emp (  -- int类型  emp_id INT,  -- 最多保存20个中英文字符  emp_name VARCHAR(20),  -- 总位数不超过15位  salary DOUBLE,  -- 日期类型  birthday DATE);\nMySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。\n\n创建表举例2：\n\nCREATE TABLE dept(    -- int类型，自增\tdeptno INT(2) AUTO_INCREMENT,\tdname VARCHAR(14),\tloc VARCHAR(13),    -- 主键    PRIMARY KEY (deptno));\n\n在MySQL\n8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。\n\n3.2 创建方式2\n\n使用 AS subquery\n选项，将创建表和插入数据结合起来\n\n\n1554997882872\n\n指定的列和子查询中的列要一一对应\n通过列名和默认值定义列\n\nCREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表\nCREATE TABLE dept80AS SELECT  employee_id, last_name, salary*12 ANNSAL, hire_dateFROM    employeesWHERE   department_id = 80;\n3.3 查看数据表结构\n在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用DESCRIBE/DESC语句查看数据表结构，也支持使用SHOW CREATE TABLE语句查看数据表结构。\n4. 修改表\n修改表指的是修改数据库中已经存在的数据表的结构。\n使用 ALTER TABLE 语句可以实现：\n\n向已有的表中添加列\n修改现有表中的列\n删除现有表中的列\n重命名现有表中的列\n\n4.1 追加一个列\n语法格式如下：\nALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;\n举例：\nALTER TABLE dept80 ADD job_id varchar(15);\n4.2 修改一个列\n\n可以修改列的数据类型，长度、默认值和位置\n修改字段数据类型、长度、默认值、位置的语法格式如下：\n\nALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;\n\n举例：\n\nALTER TABLE\tdept80MODIFY last_name VARCHAR(30);\nALTER TABLE\tdept80MODIFY salary double(9,2) default 1000;\n\n对默认值的修改只影响今后对表的修改\n此外，还可以通过此种方式修改列的约束。这里暂先不讲。\n\n4.3 重命名一个列\n使用 CHANGE old_column new_column\ndataType子句重命名列。语法格式如下：\nALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;\n举例：\nALTER TABLE  dept80CHANGE department_name dept_name varchar(15); \n4.4 删除一个列\n删除表中某个字段的语法格式如下：\nALTER TABLE 表名 DROP 【COLUMN】字段名\n举例：\nALTER TABLE  dept80DROP COLUMN  job_id; \n5. 重命名表\n\n方式一：使用RENAME\n\nRENAME TABLE empTO myemp;\n\n方式二：\n\nALTER table deptRENAME [TO] detail_dept;  -- [TO]可以省略\n\n必须是对象的拥有者\n\n6. 删除表\n\n在MySQL中，当一张数据表没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。\n数据和结构都被删除\n所有正在运行的相关事务被提交\n所有相关索引被删除\n语法格式：\n\nDROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];\nIF EXISTS的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。\n\nDROP TABLE 语句不能回滚\n\n7. 清空表\n\nTRUNCATE TABLE语句：\n\n删除表中所有的数据\n释放表的存储空间\n\n举例：\n\nTRUNCATE TABLE detail_dept;\n\nTRUNCATE语句不能回滚，而使用 DELETE\n语句删除数据，可以回滚\n对比：\n\nSET autocommit = FALSE;  DELETE FROM emp2; #TRUNCATE TABLE emp2;  SELECT * FROM emp2;  ROLLBACK;  SELECT * FROM emp2;\n\n阿里开发规范：\n【参考】TRUNCATE TABLE 比 DELETE\n速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发\nTRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。\n说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE\n语句相同。\n\n8. 内容拓展\n拓展1：阿里巴巴《Java开发手册》之MySQL字段命名\n\n【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n\n正例：aliyun_admin，rdc_config，level3_name\n反例：AliyunAdmin，rdcConfig，level_3_name\n\n【强制】禁用保留字，如 desc、range、match、delayed\n等，请参考 MySQL 官方保留字。\n【强制】表必备三字段：id, gmt_create,\ngmt_modified。\n\n说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为\n1。gmt_create, gmt_modified 的类型均为 DATETIME\n类型，前者现在时表示主动式创建，后者过去分词表示被动式更新\n\n【推荐】表的命名最好是遵循 “业务名称_表的作用”。\n\n正例：alipay_task 、 force_project、 trade_config\n\n【推荐】库名与应用名称尽量一致。\n【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n\n正例：无符号值可以避免误存负数，且扩大了表示范围。\n\n\n\nimage-20211024012735469\n\n\n拓展2：如何理解清空表、删除表等操作需谨慎？！\n表删除操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行备份，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。\n同样的，在使用 ALTER TABLE\n进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的备份，因为数据库的改变是无法撤销的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。\n拓展3：MySQL8新特性—DDL的原子化\n在MySQL\n8.0版本中，InnoDB表的DDL支持事务完整性，即DDL操作要么成功要么回滚。DDL操作回滚日志写入到data\ndictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show\ntables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。\n分别在MySQL 5.7版本和MySQL\n8.0版本中创建数据库和数据表，结果如下：\nCREATE DATABASE mytest;USE mytest;CREATE TABLE book1(book_id INT ,book_name VARCHAR(255));SHOW TABLES;\n（1）在MySQL 5.7版本中，测试步骤如下：\n删除数据表book1和数据表book2，结果如下：\nmysql&gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table 'mytest.book2'\n再次查询数据库中的数据表名称，结果如下：\nmysql&gt; SHOW TABLES;Empty set (0.00 sec)\n从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。\n（2）在MySQL 8.0版本中，测试步骤如下：\n删除数据表book1和数据表book2，结果如下：\nmysql&gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table 'mytest.book2'\n再次查询数据库中的数据表名称，结果如下：\nmysql&gt; show tables;+------------------+| Tables_in_mytest |+------------------+| book1            |+------------------+1 row in set (0.00 sec)\n从结果可以看出，数据表book1并没有被删除。\n","categories":["Database","SQL"],"tags":["SQL,DDL"]},{"title":"SQL DML语句","url":"/2024/02/21/SQL-DML%E8%AF%AD%E5%8F%A5/","content":"SQL 中常用的数据操作语句（DML）详细解析，涵盖 INSERT、UPDATE、DELETE\n的完整语法与多种使用方式，结合 MySQL 8.0\n新增的计算列（虚拟列与存储列）特性，并通过图示与完整案例深入讲解 DML\n在实际项目中的应用场景与注意事项。\n\n1. 插入数据\n1.1 实际问题\n1.2 方式1：VALUES的方式添加\n使用这种语法一次只能向表中插入一条数据。\n情况1：为表的所有字段按默认顺序插入数据\nINSERT INTO 表名VALUES (value1,value2,....);\n值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。\nINSERT INTO departmentsVALUES (70, 'Pub', 100, 1700);\nINSERT INTO\tdepartmentsVALUES\t\t(100, 'Finance', NULL, NULL);\n情况2：为表的指定字段插入数据\nINSERT INTO 表名(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]);\n为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。\n在 INSERT\n子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。\n举例：\nINSERT INTO departments(department_id, department_name)VALUES (80, 'IT');\n情况3：同时插入多条记录\nINSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：\nINSERT INTO table_name VALUES (value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]);\n或者\nINSERT INTO table_name(column1 [, column2, …, columnn]) VALUES (value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]);\n举例：\nmysql&gt; INSERT INTO emp(emp_id,emp_name)    -&gt; VALUES (1001,'shkstart'),    -&gt; (1002,'atguigu'),    -&gt; (1003,'Tom');Query OK, 3 rows affected (0.00 sec)Records: 3  Duplicates: 0  Warnings: 0\n使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：\n●　Records：表明插入的记录条数。\n●　Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。\n●　Warnings：表明有问题的数据值，例如发生数据类型转换。\n\n一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中效率更高。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。\n\n小结：\n\nVALUES也可以写成VALUE，但是VALUES是标准写法。\n字符和日期型数据应包含在单引号中。\n\n1.3 方式2：将查询结果插入到表中\nINSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。\n基本语法格式如下：\nINSERT INTO 目标表名(tar_column1 [, tar_column2, …, tar_columnn])SELECT(src_column1 [, src_column2, …, src_columnn])FROM 源表名[WHERE condition]\n\n在 INSERT 语句中加入子查询。\n不必书写 VALUES\n子句。\n子查询中的值列表应与 INSERT 子句中的列名对应。\n\n举例：\nINSERT INTO emp2 SELECT * FROM employeesWHERE department_id = 90;\nINSERT INTO sales_reps(id, name, salary, commission_pct)SELECT employee_id, last_name, salary, commission_pctFROM   employeesWHERE  job_id LIKE '%REP%';\n2. 更新数据\n\n使用 UPDATE 语句更新数据。语法如下：\n\nUPDATE table_nameSET column1=value1, column2=value2, … , column=valuen[WHERE condition]\n\n可以一次更新多条数据。\n如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT\n= FALSE;使用 WHERE\n子句指定需要更新的数据。\n\nUPDATE employeesSET    department_id = 70WHERE  employee_id = 113;\n\n如果省略 WHERE 子句，则表中的所有数据都将被更新。\n\nUPDATE \tcopy_empSET    \tdepartment_id = 110;\n\n更新中的数据完整性错误\n\nUPDATE employeesSET    department_id = 55WHERE  department_id = 110;\n\n\n1555426069578\n\n\n说明：不存在 55 号部门\n\n3. 删除数据\n\n使用 DELETE 语句从表中删除数据\n\nDELETE FROM table_name [WHERE &lt;condition&gt;];\ntable_name指定要执行删除操作的表；“[WHERE\n]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。\n\n使用 WHERE 子句删除指定的记录。\n\nDELETE FROM departmentsWHERE  department_name = 'Finance';\n\n如果省略 WHERE 子句，则表中的全部数据将被删除\n\nDELETE FROM  copy_emp;\n\n删除中的数据完整性错误\n\nDELETE FROM departmentsWHERE       department_id = 60;\n\n\n1555426258516\n\n\n说明：You cannot delete a row that contains a primary key that is\nused as a foreign key in another table.\n\n4. MySQL8新特性：计算列\n什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。\n在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE\n中都支持增加计算列。下面以CREATE TABLE为例进行讲解。\n举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。\n首先创建测试表tb1，语句如下：\nCREATE TABLE tb1(id INT,a INT,b INT,c INT GENERATED ALWAYS AS (a + b) VIRTUAL);\n插入演示数据，语句如下：\nINSERT INTO tb1(a,b) VALUES (100,200);\n查询数据表tb1中的数据，结果如下：\nmysql&gt; SELECT * FROM tb1;+------+------+------+------+| id   | a    | b    | c    |+------+------+------+------+| NULL |  100 |  200 |  300 |+------+------+------+------+1 row in set (0.00 sec)\n更新数据中的数据，语句如下：\nmysql&gt; UPDATE tb1 SET a = 500;Query OK, 0 rows affected (0.00 sec)Rows matched: 1  Changed: 0  Warnings: 0\n5. 综合案例\n# 1、创建数据库test01_library# 2、创建表 books，表结构如下：\n\n\n\n字段名\n字段说明\n数据类型\n\n\n\n\nid\n书编号\nINT\n\n\nname\n书名\nVARCHAR(50)\n\n\nauthors\n作者\nVARCHAR(100)\n\n\nprice\n价格\nFLOAT\n\n\npubdate\n出版日期\nYEAR\n\n\nnote\n说明\nVARCHAR(100)\n\n\nnum\n库存\nINT\n\n\n\n# 3、向books表中插入记录# 1）不指定字段名称，插入第一条记录# 2）指定所有字段名称，插入第二记录# 3）同时插入多条记录（剩下的所有记录）\n\n\n\n\n\n\n\n\n\n\n\n\nid\nname\nauthors\nprice\npubdate\nnote\nnum\n\n\n\n\n1\nTal of AAA\nDickes\n23\n1995\nnovel\n11\n\n\n2\nEmmaT\nJane lura\n35\n1993\njoke\n22\n\n\n3\nStory of Jane\nJane Tim\n40\n2001\nnovel\n0\n\n\n4\nLovey Day\nGeorge Byron\n20\n2005\nnovel\n30\n\n\n5\nOld land\nHonore Blade\n30\n2010\nlaw\n0\n\n\n6\nThe Battle\nUpton Sara\n30\n1999\nmedicine\n40\n\n\n7\nRose Hood\nRichard haggard\n28\n2008\ncartoon\n28\n\n\n\n# 4、将小说类型(novel)的书的价格都增加5。# 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。# 6、删除库存为0的记录。\n# 7、统计书名中包含a字母的书# 8、统计书名中包含a字母的书的数量和库存总量# 9、找出“novel”类型的书，按照价格降序排列# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列# 11、按照note分类统计书的数量# 12、按照note分类统计书的库存量，显示库存量超过30本的# 13、查询所有图书，每页显示5本，显示第二页# 14、按照note分类统计书的库存量，显示库存量最多的# 15、查询书名达到10个字符的书，不包括里面的空格# 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话# 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货# 18、统计每一种note的库存量，并合计总量# 19、统计每一种note的数量，并合计总量# 20、统计库存量前三名的图书# 21、找出最早出版的一本书# 22、找出novel中价格最高的一本书# 23、找出书名中字数最多的一本书，不含空格\n答案：\n#1、创建数据库test01_libraryCREATE DATABASE IF NOT EXISTS test01_library CHARACTER SET 'utf8';#指定使用哪个数据库USE test01_library;#2、创建表 booksCREATE TABLE books(\tid INT,\tname VARCHAR(50),\t`authors` VARCHAR(100) ,\tprice FLOAT,\tpubdate YEAR ,\tnote VARCHAR(100),\tnum INT);#3、向books表中插入记录# 1）不指定字段名称，插入第一条记录INSERT INTO books VALUES(1,'Tal of AAA','Dickes',23,1995,'novel',11);# 2）指定所有字段名称，插入第二记录INSERT INTO books (id,name,`authors`,price,pubdate,note,num)VALUES(2,'EmmaT','Jane lura',35,1993,'Joke',22);# 3）同时插入多条记录（剩下的所有记录）INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES(3,'Story of Jane','Jane Tim',40,2001,'novel',0),(4,'Lovey Day','George Byron',20,2005,'novel',30),(5,'Old land','Honore Blade',30,2010,'Law',0),(6,'The Battle','Upton Sara',30,1999,'medicine',40),(7,'Rose Hood','Richard haggard',28,2008,'cartoon',28);# 4、将小说类型(novel)的书的价格都增加5。UPDATE books SET price=price+5 WHERE note = 'novel';# 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。UPDATE books SET price=40,note='drama' WHERE name='EmmaT';# 6、删除库存为0的记录。DELETE FROM books WHERE num=0;\n# 7、统计书名中包含a字母的书SELECT * FROM books WHERE name LIKE '%a%';# 8、统计书名中包含a字母的书的数量和库存总量SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE '%a%';# 9、找出“novel”类型的书，按照价格降序排列SELECT * FROM books WHERE note = 'novel' ORDER BY price DESC;# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列SELECT * FROM books ORDER BY num DESC,note ASC;# 11、按照note分类统计书的数量SELECT note,COUNT(*) FROM books GROUP BY note;# 12、按照note分类统计书的库存量，显示库存量超过30本的SELECT note,SUM(num) FROM books GROUP BY note HAVING SUM(num)&gt;30;# 13、查询所有图书，每页显示5本，显示第二页SELECT * FROM books LIMIT 5,5;# 14、按照note分类统计书的库存量，显示库存量最多的SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;# 15、查询书名达到10个字符的书，不包括里面的空格SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,' ',''))&gt;=10;/*16、查询书名和类型， 其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话*/SELECT name AS \"书名\" ,note, CASE note  WHEN 'novel' THEN '小说' WHEN 'law' THEN '法律' WHEN 'medicine' THEN '医药' WHEN 'cartoon' THEN '卡通' WHEN 'joke' THEN '笑话' END AS \"类型\"FROM books;# 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货SELECT name,num,CASE   WHEN num&gt;30 THEN '滞销'  WHEN num&gt;0 AND num&lt;10 THEN '畅销'  WHEN num=0 THEN '无货'  ELSE '正常'  END AS \"库存状态\"FROM books;# 18、统计每一种note的库存量，并合计总量SELECT IFNULL(note,'合计总库存量') AS note,SUM(num) FROM books GROUP BY note WITH ROLLUP;# 19、统计每一种note的数量，并合计总量SELECT IFNULL(note,'合计总数') AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;# 20、统计库存量前三名的图书SELECT * FROM books ORDER BY num DESC LIMIT 0,3;# 21、找出最早出版的一本书SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;# 22、找出novel中价格最高的一本书SELECT * FROM books WHERE note = 'novel' ORDER BY price DESC LIMIT 0,1;# 23、找出书名中字数最多的一本书，不含空格SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,' ','')) DESC LIMIT 0,1;\n","categories":["Database","SQL"],"tags":["SQL,DML"]},{"title":"MyBatis 实践","url":"/2024/06/13/MyBatis-%E5%AE%9E%E8%B7%B5/","content":"MyBatis 核心功能与进阶用法全解析，涵盖配置文件结构、基本 CRUD\n操作、多表关联映射、动态 SQL\n编写技巧，以及插件机制等高级扩展能力，助力高效构建持久层数据访问逻辑。\n\n一、Mybatis简介\n1.1 简介\nhttps://mybatis.org/mybatis-3/zh/index.html\nMyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache\nSoftware Foundation迁移到了Google Code。随着开发团队转投Google\nCode旗下，\niBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。\nMyBatis 是一款优秀的持久层框架，它支持自定义\nSQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC\n代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML\n或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java\nObjects，普通老式 Java 对象）为数据库中的记录。\n\n社区会持续更新开源项目，版本会不断变化，我们不必每个小版本都追，关注重大更新的大版本升级即可。\n\n本课程使用：3.5.11版本\n1.2 持久层框架对比\n\nJDBC\n\nSQL 夹杂在Java代码中耦合度高，导致硬编码内伤\n维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见\n代码冗长，开发效率低\n\nHibernate 和 JPA\n\n操作简便，开发效率高\n程序中的长难复杂 SQL 需要绕过框架\n内部自动生成的 SQL，不容易做特殊优化\n基于全映射的全自动框架，大量字段的 POJO\n进行部分映射时比较困难。\n反射操作太多，导致数据库性能下降\n\nMyBatis\n\n轻量级，性能出色\nSQL 和 Java\n编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据\n开发效率稍逊于 Hibernate，但是完全能够接收\n\n\n开发效率：Hibernate&gt;Mybatis&gt;JDBC\n运行效率：JDBC&gt;Mybatis&gt;Hibernate\n1.3 快速入门（基于Mybatis3方式）\n\n准备数据模型\nCREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`(  emp_id INT AUTO_INCREMENT,  emp_name CHAR(100),  emp_salary DOUBLE(10,5),  PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"tom\",200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"jerry\",666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"andy\",777.77);\n项目搭建和准备\n\n项目搭建\n依赖导入\npom.xml\n&lt;dependencies&gt;  &lt;!-- mybatis依赖 --&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;3.5.11&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;  &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;8.0.25&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--junit5测试--&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;      &lt;version&gt;5.3.1&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n实体类准备\npublic class Employee {    private Integer empId;    private String empName;    private Double empSalary;        //getter | setter}\n\n准备Mapper接口和MapperXML文件\nMyBatis\n框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义！\n推荐在XML文件中编写SQL语句，让用户能更专注于 SQL\n代码，不用关注其他的JDBC代码。(如果拿它跟具有相同功能的 JDBC\n代码进行对比，你会立即发现省掉了将近 95% 的代码！！)\n一般编写SQL语句的文件命名：XxxMapper.xml Xxx一般取表名！！\nMybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper\n仅仅只是建接口即可，我们不需要提供实现类，具体的SQL写到对应的Mapper文件，该用法的思路如下图所示：\n\n\n定义mapper接口\n包：com.atguigu.mapper\npackage com.atguigu.mapper;import com.atguigu.pojo.Employee;/** * t_emp表对应数据库SQL语句映射接口! *    接口只规定方法,参数和返回值! *    mapper.xml中编写具体SQL语句! */public interface EmployeeMapper {    /**     * 根据员工id查询员工数据方法     * @param empId  员工id     * @return 员工实体对象     */    Employee selectEmployee(Integer empId);    }\n定义mapper xml\n位置： resources/mappers/EmployeeMapper.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=\"com.atguigu.mapper.EmployeeMapper\"&gt;        &lt;!-- 查询使用 select标签            id = 方法名            resultType = 返回值类型            标签内编写SQL语句     --&gt;    &lt;select id=\"selectEmployee\" resultType=\"com.atguigu.pojo.Employee\"&gt;        &lt;!-- #{empId}代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;        select emp_id empId,emp_name empName, emp_salary empSalary from            t_emp where emp_id = #{empId}    &lt;/select&gt;&lt;/mapper&gt;\n注意：\n\n方法名和SQL的id一致(方法不能进行重载，否则XML文件识别不了)\n方法返回值和resultType一致\n方法的参数和SQL的参数一致\n接口的全类名和映射配置文件的名称空间一致\n\n\n准备MyBatis配置文件\nmybatis框架配置文件：\n数据库连接信息，性能配置，mapper.xml配置等！\n习惯上命名为\nmybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合\nSpring\n之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"  \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;  &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;  &lt;environments default=\"development\"&gt;    &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;    &lt;environment id=\"development\"&gt;      &lt;!-- Mybatis的内置的事务管理器 --&gt;      &lt;transactionManager type=\"JDBC\"/&gt;      &lt;!-- 配置数据源 --&gt;      &lt;dataSource type=\"POOLED\"&gt;        &lt;!-- 建立数据库连接的具体信息 --&gt;        &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;        &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis-example\"/&gt;        &lt;property name=\"username\" value=\"root\"/&gt;        &lt;property name=\"password\" value=\"root\"/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;    &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;    &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;    &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;    &lt;mapper resource=\"mappers/EmployeeMapper.xml\"/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;\n运行和测试\n/** * projectName: com.atguigu.test * * description: 测试类 */public class MyBatisTest {    @Test    public void testSelectEmployee() throws IOException {        // 1.创建SqlSessionFactory对象        // ①声明Mybatis全局配置文件的路径        String mybatisConfigFilePath = \"mybatis-config.xml\";        // ②以输入流的形式加载Mybatis配置文件        InputStream inputStream = Resources.getResourceAsStream(mybatisConfigFilePath);        // ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        // 2.使用SqlSessionFactory对象开启一个会话        SqlSession session = sessionFactory.openSession();        // 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术)        EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);        // 4. 调用代理类方法既可以触发对应的SQL语句        Employee employee = employeeMapper.selectEmployee(1);        System.out.println(\"employee = \" + employee);        // 4.关闭SqlSession        session.commit(); //提交事务 [DQL不需要,其他需要]        session.close(); //关闭会话    }}\n说明：\n\nSqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）\nSqlSessionFactory：是“生产”SqlSession的“工厂”。\n工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。\n\nSqlSession和HttpSession区别\n\nHttpSession：工作在Web服务器上，属于表述层。\n\n代表浏览器和Web服务器之间的会话。\n\nSqlSession：不依赖Web服务器，属于持久化层。\n\n代表Java程序和数据库之间的会话。 \n\n\n\n二、MyBatis基本使用\n2.1 向SQL语句传参\n2.1.1 mybatis日志输出配置\nmybatis配置文件设计标签和顶层结构如下：\n\nconfiguration（配置）\n\nproperties（属性）\nsettings（设置）\ntypeAliases（类型别名）\ntypeHandlers（类型处理器）\nobjectFactory（对象工厂）\nplugins（插件）\nenvironments（环境配置）\n\nenvironment（环境变量）\n\ntransactionManager（事务管理器）\ndataSource（数据源）\n\n\ndatabaseIdProvider（数据库厂商标识）\nmappers（映射器）\n\n\n我们可以在mybatis的配置文件使用settings标签设置，输出运过程SQL日志！\n通过查看日志，我们可以判定#{} 和 ${}的输出效果！\n日志配置：\n&lt;settings&gt;  &lt;!-- SLF4J 选择slf4j输出！ --&gt;  &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/&gt;&lt;/settings&gt;\n2.1.2 #{}形式\nMybatis会将SQL语句中的#{}转换为问号占位符。\n\n2.1.3 ${}形式\n${}形式传参，底层Mybatis做的是字符串拼接操作。\n\n通常不会采用${}的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用\n结论：实际开发中，能用#{}实现的，肯定不用${}。\n特殊情况： 动态的不是值，是列名或者关键字，需要使用${}拼接\n//注解方式传入参数！！@Select(\"select * from user where ${column} = #{value}\")User findByColumn(@Param(\"column\") String column,                                 @Param(\"value\") String value);\n2.2 数据输入\n2.2.1 Mybatis总体机制概括\n2.2.2 概念说明\n这里数据输入具体是指上层方法（例如Service方法）调用Mapper接口时，数据传入的形式。\n\n简单类型：只包含一个值的数据类型\n\n基本数据类型：int、byte、short、double、……\n基本数据类型的包装类型：Integer、Character、Double、……\n字符串类型：String\n\n复杂类型：包含多个值的数据类型\n\n实体类类型：Employee、Department、……\n集合类型：List、Set、Map、……\n数组类型：int[]、String[]、……\n复合类型：List&lt;Employee&gt;、实体类中包含集合……\n\n\n2.2.3 单个简单类型参数\nMapper接口中抽象方法的声明\nEmployee selectEmployee(Integer empId);\nSQL语句\n&lt;select id=\"selectEmployee\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#{empId}&lt;/select&gt;\n\n单个简单类型参数，在#{}中可以随意命名，但通常还是使用对应接口方法参数名。\n\n2.2.4 实体类类型参数\nMapper接口中抽象方法的声明\nint insertEmployee(Employee employee);\nSQL语句\n&lt;insert id=\"insertEmployee\"&gt;  insert into t_emp(emp_name,emp_salary) values(#{empName},#{empSalary})&lt;/insert&gt;\n对应关系\nMybatis会根据#{}中传入的数据，加工成getXxx()方法。\n通过反射在实体类对象中调用这个方法，从而获取到对应的数据。\n填充到#{}解析后的问号占位符这个位置。\n2.2.5 零散的简单类型数据\n零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称：\n\nMapper接口中抽象方法的声明\nint updateEmployee(@Param(\"empId\") Integer empId,@Param(\"empSalary\") Double empSalary);\nSQL语句\n&lt;update id=\"updateEmployee\"&gt;  update t_emp set emp_salary=#{empSalary} where emp_id=#{empId}&lt;/update&gt;\n对应关系\n2.2.6 Map类型参数\nMapper接口中抽象方法的声明\nint updateEmployeeByMap(Map&lt;String, Object&gt; paramMap);\nSQL语句\n&lt;update id=\"updateEmployeeByMap\"&gt;  update t_emp set emp_salary=#{empSalaryKey} where emp_id=#{empIdKey}&lt;/update&gt;\njunit测试\nprivate SqlSession session;//junit5会在每一个@Test方法前执行@BeforeEach方法@BeforeEachpublic void init() throws IOException {    session = new SqlSessionFactoryBuilder()            .build(                    Resources.getResourceAsStream(\"mybatis-config.xml\"))            .openSession();}@Testpublic void testUpdateEmpNameByMap() {  EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);  Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();  paramMap.put(\"empSalaryKey\", 999.99);  paramMap.put(\"empIdKey\", 5);  int result = mapper.updateEmployeeByMap(paramMap);  log.info(\"result = \" + result);}//junit5会在每一个@Test方法后执行@@AfterEach方法@AfterEachpublic void clear() {    session.commit();    session.close();}\n对应关系\n#{}中写Map中的key\n使用场景\n有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。\n2.3数据输出\n2.3.1 输出概述\n数据输出总体上有两种形式：\n\n增删改操作（DML）返回的受影响行数：直接使用 int 或 long\n类型接收即可\n查询操作（DQL）的查询结果\n\n我们需要做的是，指定查询的输出数据类型即可！\n并且插入场景下，实现主键数据回显示！\n2.3.2 单个简单类型\nMapper接口中的抽象方法\nint selectEmpCount();\nSQL语句\n&lt;select id=\"selectEmpCount\" resultType=\"int\"&gt;  select count(*) from t_emp&lt;/select&gt;\n\nMybatis 内部给常用的数据类型设定了很多别名。 以 int\n类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER\n等等。\n\njunit测试\n@Testpublic void testEmpCount() {  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);  int count = employeeMapper.selectEmpCount();  log.info(\"count = \" + count);}\n细节解释：\nselect标签，通过resultType指定查询返回值类型！\nresultType = “全限定符 ｜ 别名 ｜\n如果是返回集合类型，写范型类型即可”\n别名问题：\nhttps://mybatis.org/mybatis-3/zh/configuration.html#typeAliases\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML\n配置，意在降低冗余的全限定类名书写。例如：\n&lt;typeAliases&gt;  &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt;  &lt;typeAlias alias=\"Blog\" type=\"domain.blog.Blog\"/&gt;&lt;/typeAliases&gt;\n当这样配置时，Blog 可以用在任何使用\ndomain.blog.Blog 的地方。\n也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java\nBean，比如：\n&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt; &lt;/typeAliases&gt;\n每一个在包 domain.blog 中的 Java\nBean，在没有注解的情况下，会使用 Bean\n的首字母小写的非限定类名来作为它的别名。 比如\ndomain.blog.Author 的别名为\nauthor；若有注解，则别名为其注解值。见下面的例子：\n@Alias(\"author\")public class Author {    ...}\n下面是Mybatis为常见的 Java\n类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。\n\n\n\n别名\n映射的类型\n\n\n\n\n_byte\nbyte\n\n\n_char (since 3.5.10)\nchar\n\n\n_character (since 3.5.10)\nchar\n\n\n_long\nlong\n\n\n_short\nshort\n\n\n_int\nint\n\n\n_integer\nint\n\n\n_double\ndouble\n\n\n_float\nfloat\n\n\n_boolean\nboolean\n\n\nstring\nString\n\n\nbyte\nByte\n\n\nchar (since 3.5.10)\nCharacter\n\n\ncharacter (since 3.5.10)\nCharacter\n\n\nlong\nLong\n\n\nshort\nShort\n\n\nint\nInteger\n\n\ninteger\nInteger\n\n\ndouble\nDouble\n\n\nfloat\nFloat\n\n\nboolean\nBoolean\n\n\ndate\nDate\n\n\ndecimal\nBigDecimal\n\n\nbigdecimal\nBigDecimal\n\n\nbiginteger\nBigInteger\n\n\nobject\nObject\n\n\nobject[]\nObject[]\n\n\nmap\nMap\n\n\nhashmap\nHashMap\n\n\nlist\nList\n\n\narraylist\nArrayList\n\n\ncollection\nCollection\n\n\n\n2.3.3 返回实体类对象\nMapper接口的抽象方法\nEmployee selectEmployee(Integer empId);\nSQL语句\n&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=\"selectEmployee\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;  &lt;!-- Mybatis负责把SQL语句中的#{}部分替换成“?”占位符 --&gt;  &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#{maomi}&lt;/select&gt;\n通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来。\n增加全局配置自动识别对应关系\n在 Mybatis\n全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名\n&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;&lt;settings&gt;  &lt;!-- 具体配置 --&gt;  &lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;  &lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;  &lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;  &lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;  &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;&lt;/settings&gt;\n2.3.4 返回Map类型\n适用于SQL查询返回的各个字段综合起来并不和任何一个现有的实体类对应，没法封装到实体类对象中。能够封装成实体类类型的，就不使用Map类型。\nMapper接口的抽象方法\nMap&lt;String,Object&gt; selectEmpNameAndMaxSalary();\nSQL语句\n&lt;!-- Map&lt;String,Object&gt; selectEmpNameAndMaxSalary(); --&gt;&lt;!-- 返回工资最高的员工的姓名和他的工资 --&gt;&lt;select id=\"selectEmpNameAndMaxSalary\" resultType=\"map\"&gt;  SELECT    emp_name 员工姓名,    emp_salary 员工工资,    (SELECT AVG(emp_salary) FROM t_emp) 部门平均工资  FROM t_emp WHERE emp_salary=(    SELECT MAX(emp_salary) FROM t_emp  )&lt;/select&gt;\njunit测试\n@Testpublic void testQueryEmpNameAndSalary() {  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);  Map&lt;String, Object&gt; resultMap = employeeMapper.selectEmpNameAndMaxSalary();  Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = resultMap.entrySet();  for (Map.Entry&lt;String, Object&gt; entry : entrySet) {    String key = entry.getKey();    Object value = entry.getValue();    log.info(key + \"=\" + value);  }}\n2.3.5 返回List类型\n查询结果返回多个实体类对象，希望把多个实体类对象放在List集合中返回。\n此时不需要任何特殊处理，在resultType属性中还是设置List中存放的实体类类型即可。\nMapper接口中抽象方法\nList&lt;Employee&gt; selectAll();\nSQL语句\n&lt;!-- List&lt;Employee&gt; selectAll(); --&gt;&lt;select id=\"selectAll\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;  select emp_id empId,emp_name empName,emp_salary empSalary  from t_emp&lt;/select&gt;\njunit测试\n@Testpublic void testSelectAll() {  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);  List&lt;Employee&gt; employeeList = employeeMapper.selectAll();  for (Employee employee : employeeList) {    log.info(\"employee = \" + employee);  }}\n2.3.6 返回主键值\n\n自增长类型主键\nMapper接口中的抽象方法\nint insertEmployee(Employee employee);\nSQL语句\n&lt;!-- int insertEmployee(Employee employee); --&gt;&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;&lt;insert id=\"insertEmployee\" useGeneratedKeys=\"true\" keyProperty=\"empId\"&gt;  insert into t_emp(emp_name,emp_salary)  values(#{empName},#{empSalary})&lt;/insert&gt;\njunit测试\n@Testpublic void testSaveEmp() {  EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);  Employee employee = new Employee();  employee.setEmpName(\"john\");  employee.setEmpSalary(666.66);  employeeMapper.insertEmployee(employee);  log.info(\"employee.getEmpId() = \" + employee.getEmpId());}\nMybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。\n非自增长类型主键\n而对于不支持自增型主键的数据库（例如\nOracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey\n元素将会首先运行，id 会被设置，然后插入语句会被调用！\n使用 selectKey 帮助插入UUID作为字符串类型主键示例：\n&lt;insert id=\"insertUser\" parameterType=\"User\"&gt;    &lt;selectKey keyProperty=\"id\" resultType=\"java.lang.String\"        order=\"BEFORE\"&gt;        SELECT UUID() as id    &lt;/selectKey&gt;    INSERT INTO user (id, username, password)     VALUES (        #{id},        #{username},        #{password}    )&lt;/insert&gt;\n在上例中，我们定义了一个 insertUser 的插入语句来将\nUser 对象插入到 user 表中。我们使用\nselectKey 来查询 UUID 并设置到 id 字段中。\n通过 keyProperty 属性来指定查询到的 UUID 赋值给对象中的\nid 属性，而 resultType 属性指定了 UUID\n的类型为 java.lang.String。\n需要注意的是，我们将 selectKey\n放在了插入语句的前面，这是因为 MySQL 在 insert\n语句中只支持一个 select 子句，而 selectKey\n中查询 UUID 的语句就是一个 select\n子句，因此我们需要将其放在前面。\n最后，在将 User 对象插入到 user\n表中时，我们直接使用对象中的 id 属性来插入主键值。\n使用这种方式，我们可以方便地插入 UUID\n作为字符串类型主键。当然，还有其他插入方式可以使用，如使用Java代码生成UUID并在类中显式设置值等。需要根据具体应用场景和需求选择合适的插入方式。\n\n2.3.7\n实体类属性和数据库字段对应关系\n\n别名对应\n将字段的别名设置成和实体类属性一致。\n&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;&lt;select id=\"selectEmployee\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;  &lt;!-- Mybatis负责把SQL语句中的#{}部分替换成“?”占位符 --&gt;  &lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;  select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#{maomi}&lt;/select&gt;\n\n关于实体类属性的约定：\ngetXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。\n\n全局配置自动识别驼峰式命名规则\n在Mybatis全局配置文件加入如下配置：\n&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;&lt;settings&gt;  &lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;  &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;&lt;/settings&gt;\nSQL语句中可以不使用别名\n&lt;!-- Employee selectEmployee(Integer empId); --&gt;&lt;select id=\"selectEmployee\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;  select emp_id,emp_name,emp_salary from t_emp where emp_id=#{empId}&lt;/select&gt;\n使用resultMap\n使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系\n&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;&lt;resultMap id=\"selectEmployeeByRMResultMap\" type=\"com.atguigu.mybatis.entity.Employee\"&gt;  &lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;  &lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;  &lt;id column=\"emp_id\" property=\"empId\"/&gt;  &lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;  &lt;result column=\"emp_name\" property=\"empName\"/&gt;  &lt;result column=\"emp_salary\" property=\"empSalary\"/&gt;&lt;/resultMap&gt;&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;&lt;select id=\"selectEmployeeByRM\" resultMap=\"selectEmployeeByRMResultMap\"&gt;  select emp_id,emp_name,emp_salary from t_emp where emp_id=#{empId}&lt;/select&gt;\n\n2.4 CRUD强化练习\n\n准备数据库数据\n首先，我们需要准备一张名为 user 的表。该表包含字段\nid（主键）、username、password。创建SQL如下：\nCREATE TABLE `user` (  `id` INT(11) NOT NULL AUTO_INCREMENT,  `username` VARCHAR(50) NOT NULL,  `password` VARCHAR(50) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n实体类准备\n接下来，我们需要定义一个实体类 User，来对应 user\n表的一行数据。\n@Data //lombokpublic class User {  private Integer id;  private String username;  private String password;}\nMapper接口定义\n定义一个 Mapper 接口 UserMapper，并在其中添加 user\n表的增、删、改、查方法。\npublic interface UserMapper {    int insert(User user);  int update(User user);  int delete(Integer id);  User selectById(Integer id);  List&lt;User&gt; selectAll();}\nMapperXML编写\n在 resources /mappers目录下创建一个名为 UserMapper.xml\n的 XML 文件，包含与 Mapper 接口中相同的五个 SQL\n语句，并在其中，将查询结果映射到 User 实体中。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=\"com.atguigu.mapper.UserMapper\"&gt;  &lt;!-- 定义一个插入语句，并获取主键值 --&gt;  &lt;insert id=\"insert\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt;    INSERT INTO user(username, password)                VALUES(#{username}, #{password})  &lt;/insert&gt;    &lt;update id=\"update\"&gt;    UPDATE user SET username=#{username}, password=#{password}    WHERE id=#{id}  &lt;/update&gt;    &lt;delete id=\"delete\"&gt;    DELETE FROM user WHERE id=#{id}  &lt;/delete&gt;  &lt;!-- resultType使用user别名，稍后需要配置！--&gt;  &lt;select id=\"selectById\" resultType=\"user\"&gt;    SELECT id, username, password FROM user WHERE id=#{id}  &lt;/select&gt;    &lt;!-- resultType返回值类型为集合，所以只写范型即可！ --&gt;  &lt;select id=\"selectAll\" resultType=\"user\"&gt;    SELECT id, username, password FROM user  &lt;/select&gt;  &lt;/mapper&gt;\nMyBatis配置文件\n位置：resources: mybatis-config.xml \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt;    &lt;settings&gt;        &lt;!-- 开启驼峰式映射--&gt;        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;        &lt;!-- 开启logback日志输出--&gt;        &lt;setting name=\"logImpl\" value=\"SLF4J\"/&gt;    &lt;/settings&gt;    &lt;typeAliases&gt;        &lt;!-- 给实体类起别名 --&gt;        &lt;package name=\"com.atguigu.pojo\"/&gt;    &lt;/typeAliases&gt;    &lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的id属性的值。 --&gt;    &lt;environments default=\"development\"&gt;        &lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;        &lt;environment id=\"development\"&gt;            &lt;!-- Mybatis的内置的事务管理器 --&gt;            &lt;transactionManager type=\"JDBC\"/&gt;            &lt;!-- 配置数据源 --&gt;            &lt;dataSource type=\"POOLED\"&gt;                &lt;!-- 建立数据库连接的具体信息 --&gt;                &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt;                &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis-example\"/&gt;                &lt;property name=\"username\" value=\"root\"/&gt;                &lt;property name=\"password\" value=\"root\"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;        &lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;        &lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径根目录为基准的相对路径 --&gt;        &lt;!--    对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所以这里我们可以以resources目录为基准 --&gt;        &lt;mapper resource=\"mappers/UserMapper.xml\"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;\n效果测试\npackage com.atguigu.test;import com.atguigu.mapper.UserMapper;import com.atguigu.pojo.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import java.io.IOException;import java.util.List;/** * projectName: com.atguigu.test */public class MyBatisTest {    private SqlSession session;    // junit会在每一个@Test方法前执行@BeforeEach方法    @BeforeEach    public void init() throws IOException {        session = new SqlSessionFactoryBuilder()                .build(                        Resources.getResourceAsStream(\"mybatis-config.xml\"))                .openSession();    }    @Test    public void createTest() {        User user = new User();        user.setUsername(\"admin\");        user.setPassword(\"123456\");        UserMapper userMapper = session.getMapper(UserMapper.class);        userMapper.insert(user);        System.out.println(user);    }    @Test    public void updateTest() {        UserMapper userMapper = session.getMapper(UserMapper.class);        User user = userMapper.selectById(1);        user.setUsername(\"root\");        user.setPassword(\"111111\");        userMapper.update(user);        user = userMapper.selectById(1);        System.out.println(user);    }    @Test    public void deleteTest() {        UserMapper userMapper = session.getMapper(UserMapper.class);        userMapper.delete(1);        User user = userMapper.selectById(1);        System.out.println(\"user = \" + user);    }    @Test    public void selectByIdTest() {        UserMapper userMapper = session.getMapper(UserMapper.class);        User user = userMapper.selectById(1);        System.out.println(\"user = \" + user);    }    @Test    public void selectAllTest() {        UserMapper userMapper = session.getMapper(UserMapper.class);        List&lt;User&gt; userList = userMapper.selectAll();        System.out.println(\"userList = \" + userList);    }    // junit会在每一个@Test方法后执行@@AfterEach方法    @AfterEach    public void clear() {        session.commit();        session.close();    }}\n\n2.5 mapperXML标签总结\nMyBatis\n的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的\nXML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC\n代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis\n致力于减少使用成本，让用户能更专注于 SQL 代码。\nSQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：\n\ninsert – 映射插入语句。\nupdate – 映射更新语句。\ndelete – 映射删除语句。\nselect – 映射查询语句。\n\nselect标签：\nMyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select\n元素是非常简单：\n&lt;select id=\"selectPerson\" resultType=\"hashmap\" resultMap=\"自定义结构\"&gt; SELECT * FROM PERSON WHERE ID = #{id} &lt;/select&gt;\n这个语句名为 selectPerson，接受一个 int（或\nInteger）类型的参数，并返回一个 HashMap\n类型的对象，其中的键是列名，值便是结果行中的对应值。\n注意参数符号：#{id} ${key}\nMyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC\n中，这样的一个参数在 SQL\n中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：\n// 近似的 JDBC 代码，非 MyBatis 代码...String selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";PreparedStatement ps = conn.prepareStatement(selectPerson);ps.setInt(1,id);\nselect 元素允许你配置很多属性来配置每条语句的行为细节：\n\n\n\n\n\n\n\n属性\n描述\n\n\n\n\nid\n在命名空间中唯一的标识符，可以被用来引用这条语句。\n\n\nresultType\n期望从这条语句中返回结果的类全限定名或别名。\n注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。\nresultType 和 resultMap 之间只能同时使用一个。\n\n\nresultMap\n对外部 resultMap 的命名引用。结果映射是 MyBatis\n最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。\nresultType 和 resultMap 之间只能同时使用一个。\n\n\ntimeout\n这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。\n\n\nstatementType\n可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用\nStatement，PreparedStatement 或\nCallableStatement，默认值：PREPARED。\n\n\n\ninsert, update 和 delete标签：\n数据变更语句 insert，update 和 delete 的实现非常接近：\n&lt;insert  id=\"insertAuthor\"  statementType=\"PREPARED\"  keyProperty=\"\"  keyColumn=\"\"  useGeneratedKeys=\"\"  timeout=\"20\"&gt;&lt;update  id=\"updateAuthor\"  statementType=\"PREPARED\"  timeout=\"20\"&gt;&lt;delete  id=\"deleteAuthor\"  statementType=\"PREPARED\"  timeout=\"20\"&gt;\n\n\n\n\n\n\n\n属性\n描述\n\n\n\n\nid\n在命名空间中唯一的标识符，可以被用来引用这条语句。\n\n\ntimeout\n这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。\n\n\nstatementType\n可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用\nStatement，PreparedStatement 或\nCallableStatement，默认值：PREPARED。\n\n\nuseGeneratedKeys\n（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的\ngetGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL\nServer 这样的关系型数据库管理系统的自动递增字段），默认值：false。\n\n\nkeyProperty\n（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis\n会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey\n子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。\n\n\nkeyColumn\n（仅适用于 insert 和\nupdate）设置生成键值在表中的列名，在某些数据库（像\nPostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。\n\n\n\n三、MyBatis多表映射\n3.1 多表映射概念\n\n多表查询结果映射思路\n上面课程中，我全面讲解了单表的mybatis操作！但是开发中更多的是多表查询需求，这种情况我们如何让进行处理？\nMyBatis 思想是：数据库不可能永远是你所想或所需的那个样子。\n我们希望每个数据库都具备良好的第三范式或 BCNF\n范式，可惜它们并不都是那样。\n如果能有一种数据库映射模式，完美适配所有的应用程序查询需求，那就太好了，而\nResultMap 就是 MyBatis 就是完美答案。 \n官方例子：我们如何映射下面这个语句\n&lt;!-- 非常复杂的语句 --&gt;&lt;select id=\"selectBlogDetails\" resultMap=\"detailedBlogResultMap\"&gt;  select       B.id as blog_id,       B.title as blog_title,       B.author_id as blog_author_id,       A.id as author_id,       A.username as author_username,       A.password as author_password,       A.email as author_email,       A.bio as author_bio,       A.favourite_section as author_favourite_section,       P.id as post_id,       P.blog_id as post_blog_id,       P.author_id as post_author_id,       P.created_on as post_created_on,       P.section as post_section,       P.subject as post_subject,       P.draft as draft,       P.body as post_body,       C.id as comment_id,       C.post_id as comment_post_id,       C.name as comment_name,       C.comment as comment_text,       T.id as tag_id,       T.name as tag_name  from Blog B       left outer join Author A on B.author_id = A.id       left outer join Post P on B.id = P.blog_id       left outer join Comment C on P.id = C.post_id       left outer join Post_Tag PT on PT.post_id = P.id       left outer join Tag T on PT.tag_id = T.id  where B.id = #{id}&lt;/select&gt;\n你可能想把它映射到一个智能的对象模型，这个对象表示了一篇博客，它由某位作者所写，有很多的博文，每篇博文有零或多条的评论和标签。\n我们先来看看下面这个完整的例子，它是一个非常复杂的结果映射（假设作者，博客，博文，评论和标签都是类型别名）。\n虽然它看起来令人望而生畏，但其实非常简单。 \n&lt;!-- 非常复杂的结果映射 --&gt;&lt;resultMap id=\"detailedBlogResultMap\" type=\"Blog\"&gt;  &lt;constructor&gt;    &lt;idArg column=\"blog_id\" javaType=\"int\"/&gt;  &lt;/constructor&gt;  &lt;result property=\"title\" column=\"blog_title\"/&gt;  &lt;association property=\"author\" javaType=\"Author\"&gt;    &lt;id property=\"id\" column=\"author_id\"/&gt;    &lt;result property=\"username\" column=\"author_username\"/&gt;    &lt;result property=\"password\" column=\"author_password\"/&gt;    &lt;result property=\"email\" column=\"author_email\"/&gt;    &lt;result property=\"bio\" column=\"author_bio\"/&gt;    &lt;result property=\"favouriteSection\" column=\"author_favourite_section\"/&gt;  &lt;/association&gt;  &lt;collection property=\"posts\" ofType=\"Post\"&gt;    &lt;id property=\"id\" column=\"post_id\"/&gt;    &lt;result property=\"subject\" column=\"post_subject\"/&gt;    &lt;association property=\"author\" javaType=\"Author\"/&gt;    &lt;collection property=\"comments\" ofType=\"Comment\"&gt;      &lt;id property=\"id\" column=\"comment_id\"/&gt;    &lt;/collection&gt;    &lt;collection property=\"tags\" ofType=\"Tag\" &gt;      &lt;id property=\"id\" column=\"tag_id\"/&gt;    &lt;/collection&gt;  &lt;/collection&gt;&lt;/resultMap&gt;\n你现在可能看不懂，接下来我们要学习将多表查询结果使用ResultMap标签映射到实体类对象上！\n我们的学习目标：\n多表查询语句使用\n多表结果承接实体类设计\n使用ResultMap完成多表结果映射\n实体类设计方案\n多表关系回顾：（双向查看）\n\n一对一\n夫妻关系，人和身份证号\n一对多 | 多对一\n用户和用户的订单，锁和钥匙\n多对多\n老师和学生，部门和员工\n\n实体类设计关系(查询)：（单向查看）\n\n对一 ： 夫妻一方对应另一方，订单对应用户都是对一关系\n实体类设计：对一关系下，类中只要包含单个对方对象类型属性即可！\npublic class Customer {  private Integer customerId;  private String customerName;}public class Order {  private Integer orderId;  private String orderName;  private Customer customer;// 体现的是对一的关系}  \n对多:\n用户对应的订单，讲师对应的学生或者学生对应的讲师都是对多关系：\n实体类设计：对多关系下，类中只要包含对方类型集合属性即可！\npublic class Customer {  private Integer customerId;  private String customerName;  private List&lt;Order&gt; orderList;// 体现的是对多的关系}public class Order {  private Integer orderId;  private String orderName;  private Customer customer;// 体现的是对一的关系  }//查询客户和客户对应的订单集合  不要管!\n\n多表结果实体类设计小技巧：\n\n对一，属性中包含对方对象\n对多，属性中包含对方对象集合\n\n只有真实发生多表查询时，才需要设计和修改实体类，否则不提前设计和修改实体类！\n无论多少张表联查，实体类设计都是两两考虑!\n在查询映射的时候，只需要关注本次查询相关的属性！\n例如：查询订单和对应的客户，就不要关注客户中的订单集合！\n多表映射案例准备\n数据库：\nCREATE TABLE `t_customer` (`customer_id` INT NOT NULL AUTO_INCREMENT, `customer_name` CHAR(100), PRIMARY KEY (`customer_id`) );CREATE TABLE `t_order` ( `order_id` INT NOT NULL AUTO_INCREMENT, `order_name` CHAR(100), `customer_id` INT, PRIMARY KEY (`order_id`) ); INSERT INTO `t_customer` (`customer_name`) VALUES ('c01');INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES ('o1', '1');INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES ('o2', '1');INSERT INTO `t_order` (`order_name`, `customer_id`) VALUES ('o3', '1'); \n实际开发时，一般在开发过程中，不给数据库表设置外键约束。\n原因是避免调试不方便。\n一般是功能开发完成，再加外键约束检查是否有bug。\n实体类设计：\n稍后会进行订单关联客户查询，也会进行客户关联订单查询，所以在这先练习设计\n@Datapublic class Customer {  private Integer customerId;  private String customerName;  private List&lt;Order&gt; orderList;// 体现的是对多的关系  }  @Datapublic class Order {  private Integer orderId;  private String orderName;  private Customer customer;// 体现的是对一的关系  }  \n\n3.2 对一映射\n\n需求说明\n根据ID查询订单，以及订单关联的用户的信息！\nOrderMapper接口\npublic interface OrderMapper {  Order selectOrderWithCustomer(Integer orderId);}\nOrderMapper.xml配置文件\n&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;&lt;resultMap id=\"selectOrderWithCustomerResultMap\" type=\"order\"&gt;  &lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;  &lt;id column=\"order_id\" property=\"orderId\"/&gt;  &lt;result column=\"order_name\" property=\"orderName\"/&gt;  &lt;!-- 使用association标签配置“对一”关联关系 --&gt;  &lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;  &lt;!-- javaType属性：一的一端类的全类名 --&gt;  &lt;association property=\"customer\" javaType=\"customer\"&gt;    &lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;    &lt;id column=\"customer_id\" property=\"customerId\"/&gt;    &lt;result column=\"customer_name\" property=\"customerName\"/&gt;  &lt;/association&gt;&lt;/resultMap&gt;&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;&lt;select id=\"selectOrderWithCustomer\" resultMap=\"selectOrderWithCustomerResultMap\"&gt;  SELECT order_id,order_name,c.customer_id,customer_name  FROM t_order o  LEFT JOIN t_customer c  ON o.customer_id=c.customer_id  WHERE o.order_id=#{orderId}&lt;/select&gt;\nMybatis全局注册Mapper文件\n&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt;  &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;  &lt;mapper resource=\"mappers/OrderMapper.xml\"/&gt;&lt;/mappers&gt;\njunit测试程序\n@Slf4jpublic class MyBatisTest {    private SqlSession session;    // junit会在每一个@Test方法前执行@BeforeEach方法    @BeforeEach    public void init() throws IOException {        session = new SqlSessionFactoryBuilder()                .build(                        Resources.getResourceAsStream(\"mybatis-config.xml\"))                .openSession();    }    @Test    public void testRelationshipToOne() {          OrderMapper orderMapper = session.getMapper(OrderMapper.class);      // 查询Order对象，检查是否同时查询了关联的Customer对象      Order order = orderMapper.selectOrderWithCustomer(2);      log.info(\"order = \" + order);        }    // junit会在每一个@Test方法后执行@@AfterEach方法    @AfterEach    public void clear() {        session.commit();        session.close();    }}\n关键词\n在“对一”关联关系中，我们的配置比较多，但是关键词就只有：association和javaType\n\n3.3 对多映射\n\n需求说明\n查询客户和客户关联的订单信息！\nCustomerMapper接口\npublic interface CustomerMapper {  Customer selectCustomerWithOrderList(Integer customerId);}\nCustomerMapper.xml文件\n&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;&lt;resultMap id=\"selectCustomerWithOrderListResultMap\"  type=\"customer\"&gt;  &lt;!-- 映射Customer本身的属性 --&gt;  &lt;id column=\"customer_id\" property=\"customerId\"/&gt;  &lt;result column=\"customer_name\" property=\"customerName\"/&gt;  &lt;!-- collection标签：映射“对多”的关联关系 --&gt;  &lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;  &lt;!-- ofType属性：集合属性中元素的类型 --&gt;  &lt;collection property=\"orderList\" ofType=\"order\"&gt;    &lt;!-- 映射Order的属性 --&gt;    &lt;id column=\"order_id\" property=\"orderId\"/&gt;    &lt;result column=\"order_name\" property=\"orderName\"/&gt;  &lt;/collection&gt;&lt;/resultMap&gt;&lt;!-- Customer selectCustomerWithOrderList(Integer customerId); --&gt;&lt;select id=\"selectCustomerWithOrderList\" resultMap=\"selectCustomerWithOrderListResultMap\"&gt;  SELECT c.customer_id,c.customer_name,o.order_id,o.order_name  FROM t_customer c  LEFT JOIN t_order o  ON c.customer_id=o.customer_id  WHERE c.customer_id=#{customerId}&lt;/select&gt;\nMybatis全局注册Mapper文件\n&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;&lt;mappers&gt;  &lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;  &lt;mapper resource=\"mappers/OrderMapper.xml\"/&gt;  &lt;mapper resource=\"mappers/CustomerMapper.xml\"/&gt;&lt;/mappers&gt;\njunit测试程序\n@Testpublic void testRelationshipToMulti() {  CustomerMapper customerMapper = session.getMapper(CustomerMapper.class);  // 查询Customer对象同时将关联的Order集合查询出来  Customer customer = customerMapper.selectCustomerWithOrderList(1);  log.info(\"customer.getCustomerId() = \" + customer.getCustomerId());  log.info(\"customer.getCustomerName() = \" + customer.getCustomerName());  List&lt;Order&gt; orderList = customer.getOrderList();  for (Order order : orderList) {    log.info(\"order = \" + order);  }}\n关键词\n在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType”\n\n3.4 多表映射总结\n3.4.1 多表映射优化\n\n\n\n\n\n\n\n\n\nsetting属性\n属性含义\n可选值\n默认值\n\n\n\n\nautoMappingBehavior\n指定 MyBatis 应如何自动映射列到字段或属性。 NONE\n表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL\n会自动映射任何复杂的结果集（无论是否嵌套）。\nNONE, PARTIAL, FULL\nPARTIAL\n\n\n\n我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名=属性名，或者开启驼峰映射也可以自定映射）的result标签！\n修改mybati-sconfig.xml:\n&lt;!--开启resultMap自动映射 --&gt;&lt;setting name=\"autoMappingBehavior\" value=\"FULL\"/&gt;\n修改teacherMapper.xml\n&lt;resultMap id=\"teacherMap\" type=\"teacher\"&gt;    &lt;id property=\"tId\" column=\"t_id\" /&gt;    &lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;&lt;!--        &lt;result property=\"tName\" column=\"t_name\" /&gt;--&gt;    &lt;collection property=\"students\" ofType=\"student\" &gt;        &lt;id property=\"sId\" column=\"s_id\" /&gt;&lt;!--            &lt;result property=\"sName\" column=\"s_name\" /&gt;--&gt;    &lt;/collection&gt;&lt;/resultMap&gt;\n3.4.2 多表映射总结\n\n\n\n\n\n\n\n\n关联关系\n配置项关键词\n所在配置文件和具体位置\n\n\n\n\n对一\nassociation标签/javaType属性/property属性\nMapper配置文件中的resultMap标签内\n\n\n对多\ncollection标签/ofType属性/property属性\nMapper配置文件中的resultMap标签内\n\n\n\n四、MyBatis动态语句\n4.1 动态语句需求和简介\n经常遇到很多按照很多查询条件进行查询的情况，比如智联招聘的职位搜索等。其中经常出现很多条件不取值的情况，在后台应该如何完成最终的SQL语句呢？\n动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC\n或其它类似的框架，你应该能理解根据不同条件拼接 SQL\n语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态\nSQL，可以彻底摆脱这种痛苦。\n使用动态 SQL 并非一件易事，但借助可用于任何 SQL\n映射语句中的强大的动态 SQL 语言，MyBatis\n显著地提升了这一特性的易用性。\n如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL\n元素可能会感觉似曾相识。在 MyBatis\n之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL\n的表达式，MyBatis 3\n替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。\n4.2 if和where标签\n使用动态 SQL 最常见情景是根据条件包含 where / if\n子句的一部分。比如：\n&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;&lt;select id=\"selectEmployeeByCondition\" resultType=\"employee\"&gt;    select emp_id,emp_name,emp_salary from t_emp    &lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;    &lt;where&gt;        &lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;        &lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;        &lt;if test=\"empName != null\"&gt;            &lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#{} --&gt;            or emp_name=#{empName}        &lt;/if&gt;        &lt;if test=\"empSalary &amp;gt; 2000\"&gt;            or emp_salary&gt;#{empSalary}        &lt;/if&gt;        &lt;!--         第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?         第二种情况：部分条件满足 WHERE emp_salary&gt;?         第三种情况：所有条件都不满足 没有where子句         --&gt;    &lt;/where&gt;&lt;/select&gt;\n4.3 set标签\n&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;&lt;update id=\"updateEmployeeDynamic\"&gt;    update t_emp    &lt;!-- set emp_name=#{empName},emp_salary=#{empSalary} --&gt;    &lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;    &lt;set&gt;        &lt;if test=\"empName != null\"&gt;            emp_name=#{empName},        &lt;/if&gt;        &lt;if test=\"empSalary &amp;lt; 3000\"&gt;            emp_salary=#{empSalary},        &lt;/if&gt;    &lt;/set&gt;    where emp_id=#{empId}    &lt;!--         第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?         第二种情况：部分条件满足 SET emp_salary=?         第三种情况：所有条件都不满足 update t_emp where emp_id=?            没有set子句的update语句会导致SQL语法错误     --&gt;&lt;/update&gt;\n4.4 trim标签(了解)\n使用trim标签控制条件部分两端是否包含某些字符\n\nprefix属性：指定要动态添加的前缀\nsuffix属性：指定要动态添加的后缀\nprefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值\nsuffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值\n\n&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByTrim(Employee employee) --&gt;&lt;select id=\"selectEmployeeByConditionByTrim\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;    select emp_id,emp_name,emp_age,emp_salary,emp_gender    from t_emp    &lt;!-- prefix属性指定要动态添加的前缀 --&gt;    &lt;!-- suffix属性指定要动态添加的后缀 --&gt;    &lt;!-- prefixOverrides属性指定要动态去掉的前缀，使用“|”分隔有可能的多个值 --&gt;    &lt;!-- suffixOverrides属性指定要动态去掉的后缀，使用“|”分隔有可能的多个值 --&gt;    &lt;!-- 当前例子用where标签实现更简洁，但是trim标签更灵活，可以用在任何有需要的地方 --&gt;    &lt;trim prefix=\"where\" suffixOverrides=\"and|or\"&gt;        &lt;if test=\"empName != null\"&gt;            emp_name=#{empName} and        &lt;/if&gt;        &lt;if test=\"empSalary &amp;gt; 3000\"&gt;            emp_salary&gt;#{empSalary} and        &lt;/if&gt;        &lt;if test=\"empAge &amp;lt;= 20\"&gt;            emp_age=#{empAge} or        &lt;/if&gt;        &lt;if test=\"empGender=='male'\"&gt;            emp_gender=#{empGender}        &lt;/if&gt;    &lt;/trim&gt;&lt;/select&gt;\n4.5 choose/when/otherwise标签\n在多个分支条件中，仅执行一个。\n\n从上到下依次执行条件判断\n遇到的第一个满足条件的分支会被采纳\n被采纳分支后面的分支都将不被考虑\n如果所有的when分支都不满足，那么就执行otherwise分支\n\n&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;&lt;select id=\"selectEmployeeByConditionByChoose\" resultType=\"com.atguigu.mybatis.entity.Employee\"&gt;    select emp_id,emp_name,emp_salary from t_emp    where    &lt;choose&gt;        &lt;when test=\"empName != null\"&gt;emp_name=#{empName}&lt;/when&gt;        &lt;when test=\"empSalary &amp;lt; 3000\"&gt;emp_salary &amp;lt; 3000&lt;/when&gt;        &lt;otherwise&gt;1=1&lt;/otherwise&gt;    &lt;/choose&gt;        &lt;!--     第一种情况：第一个when满足条件 where emp_name=?     第二种情况：第二个when满足条件 where emp_salary &lt; 3000     第三种情况：两个when都不满足 where 1=1 执行了otherwise     --&gt;&lt;/select&gt;\n4.6 foreach标签\n基本用法\n用批量插入举例\n&lt;!--    collection属性：要遍历的集合    item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象    separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符    open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串    close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串    index属性：这里起一个名字，便于后面引用        遍历List集合，这里能够得到List集合的索引值        遍历Map集合，这里能够得到Map集合的key --&gt;&lt;foreach collection=\"empList\" item=\"emp\" separator=\",\" open=\"values\" index=\"myIndex\"&gt;    &lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;    (#{emp.empName},#{myIndex},#{emp.empSalary},#{emp.empGender})&lt;/foreach&gt;\n批量更新时需要注意\n上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：\natguigu.dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true\n对应的foreach标签如下：\n&lt;!-- int updateEmployeeBatch(@Param(\"empList\") List&lt;Employee&gt; empList) --&gt;&lt;update id=\"updateEmployeeBatch\"&gt;    &lt;foreach collection=\"empList\" item=\"emp\" separator=\";\"&gt;        update t_emp set emp_name=#{emp.empName} where emp_id=#{emp.empId}    &lt;/foreach&gt;&lt;/update&gt;\n关于foreach标签的collection属性\n如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。\n这一点可以通过异常信息看出来：\nParameter 'empList' not found. Available parameters are [arg0, collection, list]\n在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。\n4.7 sql片段\n抽取重复的SQL片段\n&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;&lt;sql id=\"mySelectSql\"&gt;    select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp&lt;/sql&gt;\n引用已抽取的SQL片段\n&lt;!-- 使用include标签引用声明的SQL片段 --&gt;&lt;include refid=\"mySelectSql\"/&gt;\n五、MyBatis高级扩展\n5.1 Mapper批量映射优化\n\n需求\nMapper\n配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。\n配置方式\nMybatis 允许在指定 Mapper 映射文件时，只指定其所在的包：\n&lt;mappers&gt;    &lt;package name=\"com.atguigu.mapper\"/&gt;&lt;/mappers&gt;\n此时这个包下的所有 Mapper\n配置文件将被自动加载、注册，比较方便。\n资源创建要求\n\nresources下创建多个连续文件夹需要用“/”分割（org/example）。\n\n\n\nMapper 接口和 Mapper 配置文件名称一致\n\nMapper 接口：EmployeeMapper.java\nMapper 配置文件：EmployeeMapper.xml\n\nMapper 配置文件放在 Mapper 接口所在的包内\n\n可以将mapperxml文件放在mapper接口所在的包！\n可以在sources下创建mapper接口包一致的文件夹结构存放mapperxml文件（推荐）\n\n\n\n\n5.2 插件和分页插件PageHelper\n5.2.1\n插件机制和PageHelper插件介绍\nMyBatis\n对插件进行了标准化的设计，并提供了一套可扩展的插件机制。插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改\nSQL 语句、映射语句的结果等。\n具体来说，MyBatis 的插件机制包括以下三个组件：\n\nInterceptor（拦截器）：定义一个拦截方法\nintercept，该方法在执行 SQL\n语句、执行查询、查询结果的映射时会被调用。\nInvocation（调用）：实际上是对被拦截的方法的封装，封装了\nObject target、Method method 和\nObject[] args 这三个字段。\nInterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的\nInterceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。\n\n插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解\n@Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis\n的配置文件中添加插件即可。\nPageHelper 是 MyBatis\n中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle\n分页方式），支持多种数据库，并且使用非常简单。下面就介绍一下 PageHelper\n的使用方式。\nhttps://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md#如何配置数据库方言\n5.2.2 PageHelper插件使用\n\npom.xml引入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.1.11&lt;/version&gt;&lt;/dependency&gt;\nmybatis-config.xml配置分页插件\n在 MyBatis 的配置文件中添加 PageHelper 的插件：\n&lt;plugins&gt;    &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt;        &lt;property name=\"helperDialect\" value=\"mysql\"/&gt;    &lt;/plugin&gt;&lt;/plugins&gt;\n\n其中，com.github.pagehelper.PageInterceptor 是\nPageHelper 插件的名称，dialect\n属性用于指定数据库类型（支持多种数据库）\n\n页插件使用\n在查询方法中使用分页：\n@Testpublic void testTeacherRelationshipToMulti() {    TeacherMapper teacherMapper = session.getMapper(TeacherMapper.class);    PageHelper.startPage(1,2);    // 查询Customer对象同时将关联的Order集合查询出来    List&lt;Teacher&gt; allTeachers = teacherMapper.findAllTeachers();    PageInfo&lt;Teacher&gt; pageInfo = new PageInfo&lt;&gt;(allTeachers);    System.out.println(\"pageInfo = \" + pageInfo);    long total = pageInfo.getTotal(); // 获取总记录数    System.out.println(\"total = \" + total);    int pages = pageInfo.getPages();  // 获取总页数    System.out.println(\"pages = \" + pages);    int pageNum = pageInfo.getPageNum(); // 获取当前页码    System.out.println(\"pageNum = \" + pageNum);    int pageSize = pageInfo.getPageSize(); // 获取每页显示记录数    System.out.println(\"pageSize = \" + pageSize);    List&lt;Teacher&gt; teachers = pageInfo.getList(); //获取查询页的数据集合    System.out.println(\"teachers = \" + teachers);    teachers.forEach(System.out::println);}\n\n5.3 逆向工程和MybatisX插件\n5.3.1 ORM思维介绍\nORM（Object-Relational\nMapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!\n最终:\n让我们可以使用面向对象思维进行数据库操作！！！\nORM 框架通常有半自动和全自动两种方式。\n\n半自动 ORM 通常需要程序员手动编写 SQL\n语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。\n全自动 ORM 则是将实体类和数据表进行自动映射，使用 API\n进行数据库操作时，ORM 框架会自动执行 SQL\n语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL\n语句和转换代码。\n\n下面是半自动和全自动 ORM 框架的区别：\n\n映射方式：半自动 ORM\n框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML\n文件或注解方式来指定；全自动 ORM\n框架则可以自动进行实体类和数据表的映射，无需手动干预。\n查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL\n语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL\n语句、执行查询操作，并将查询结果转换成实体对象。\n性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL\n语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动\nORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。\n学习成本：半自动 ORM 框架需要程序员手动编写 SQL\n语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM\n框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL\n知识。\n\n常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括\nHibernate、Spring Data JPA、MyBatis-Plus 等。\n5.3.2 逆向工程\n MyBatis\n的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml\n文件、Mapper\n接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起\nDAO 层，并快速上手进行业务开发。 MyBatis 的逆向工程有两种方式：通过\nMyBatis Generator 插件实现和通过 Maven\n插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接\nURL、用户名、密码、要生成的表名、生成的文件路径等等。 总的来说，MyBatis\n的逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动\nORM 思维像全自动发展的过程，提高程序员的开发效率。\n注意：逆向工程只能生成单表crud的操作，多表查询依然需要我们自己编写！\n5.3.3 逆向工程插件MyBatisX使用\n MyBatisX 是一个 MyBatis\n的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo\n类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：\n\n安装插件：\n在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。\n使用 IntelliJ IDEA连接数据库\n\n连接数据库\n\n填写信息\n\n展示库表\n\n逆向工程使用\n\n\n\n\n查看生成结果\n\n逆向工程案例使用\n正常使用即可，自动生成单表的crud方法！\npackage com.atguigu.mapper;import com.atguigu.pojo.User;/*** @author Jackiechan* @description 针对表【user】的数据库操作Mapper* @createDate 2023-06-02 16:55:32* @Entity com.atguigu.pojo.User*/public interface UserMapper {    int deleteByPrimaryKey(Long id);    int insert(User record);    int insertSelective(User record);    User selectByPrimaryKey(Long id);    int updateByPrimaryKeySelective(User record);    int updateByPrimaryKey(User record);}\n\n六、MyBatis总结\n\n\n\n核心点\n掌握目标\n\n\n\n\nmybatis基础\n使用流程, 参数输入,#{} ${},参数输出\n\n\nmybatis多表\n实体类设计,resultMap多表结果映射\n\n\nmybatis动态语句\nMybatis动态语句概念, where , if , foreach标签\n\n\nmybatis扩展\nMapper批量处理,分页插件,逆向工程\n\n\n\n","categories":["后端","Spring"],"tags":["Persistence Layer","MyBatis"]},{"title":"MySql 数据类型详解","url":"/2024/02/22/MySql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/","content":"Mysql中常用数据类型详解以及大厂数据类型使用准则\n\n1. MySQL中的数据类型\n\n\n\n\n\n\n\n类型\n类型举例\n\n\n\n\n整数类型\nTINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT\n\n\n浮点类型\nFLOAT、DOUBLE\n\n\n定点数类型\nDECIMAL\n\n\n位类型\nBIT\n\n\n日期时间类型\nYEAR、TIME、DATE、DATETIME、TIMESTAMP\n\n\n文本字符串类型\nCHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT\n\n\n枚举类型\nENUM\n\n\n集合类型\nSET\n\n\n二进制字符串类型\nBINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB\n\n\nJSON类型\nJSON对象、JSON数组\n\n\n空间数据类型\n单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION\n\n\n\n常见数据类型的属性，如下：\n\n\n\nMySQL关键字\n含义\n\n\n\n\nNULL\n数据列可包含NULL值\n\n\nNOT NULL\n数据列不允许包含NULL值\n\n\nDEFAULT\n默认值\n\n\nPRIMARY KEY\n主键\n\n\nAUTO_INCREMENT\n自动递增，适用于整数类型\n\n\nUNSIGNED\n无符号\n\n\nCHARACTER SET name\n指定一个字符集\n\n\n\n2. 整数类型\n2.1 类型介绍\n整数类型一共有 5 种，包括\nTINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。\n它们的区别如下表所示：\n\n\n\n\n\n\n\n\n\n整数类型\n字节\n有符号数取值范围\n无符号数取值范围\n\n\n\n\nTINYINT\n1\n-128~127\n0~255\n\n\nSMALLINT\n2\n-32768~32767\n0~65535\n\n\nMEDIUMINT\n3\n-8388608~8388607\n0~16777215\n\n\nINT、INTEGER\n4\n-2147483648~2147483647\n0~4294967295\n\n\nBIGINT\n8\n-9223372036854775808~9223372036854775807\n0~18446744073709551615\n\n\n\n2.2 可选属性\n整数类型的可选属性有三个：\n2.2.1 M\nM: 表示显示宽度，M的取值范围是(0,\n255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ZEROFILL”使用，表示用“0”填满宽度，否则指定显示宽度无效。\n如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？\n答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即显示宽度与类型可以存储的值范围无关。从MySQL\n8.0.17开始，整数数据类型不推荐使用显示宽度属性。\n整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。\n举例：\nCREATE TABLE test_int1 ( x TINYINT,　y SMALLINT,　z MEDIUMINT,　m INT,　n BIGINT );\n查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）\nmysql&gt; desc test_int1;+-------+--------------+------+-----+---------+-------+| Field | Type         | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+|   x   | tinyint(4)   | YES  |     | NULL    |       || 　y   | smallint(6)  | YES  |     | NULL    |       || 　z   | mediumint(9) | YES  |     | NULL    |       || 　m   | int(11)      | YES  |     | NULL    |       || 　n   | bigint(20)   | YES  |     | NULL    |       |+-------+--------------+------+-----+---------+-------+5 rows in set (0.00 sec)\nTINYINT有符号数和无符号数的取值范围分别为-128127和0255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。\n举例：\nCREATE TABLE test_int2(f1 INT,f2 INT(5),f3 INT(5) ZEROFILL)DESC test_int2;INSERT INTO test_int2(f1,f2,f3)VALUES(1,123,123);INSERT INTO test_int2(f1,f2)VALUES(123456,123456);INSERT INTO test_int2(f1,f2,f3)VALUES(123456,123456,123456);\nmysql&gt; SELECT * FROM test_int2;+--------+--------+--------+| f1     | f2     | f3     |+--------+--------+--------+|      1 |    123 |  00123 || 123456 | 123456 |   NULL || 123456 | 123456 | 123456 |+--------+--------+--------+3 rows in set (0.00 sec)\n2.2.2 UNSIGNED\nUNSIGNED:\n无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。\nint类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。\nCREATE TABLE test_int3(f1 INT UNSIGNED);mysql&gt; desc test_int3;+-------+------------------+------+-----+---------+-------+| Field | Type             | Null | Key | Default | Extra |+-------+------------------+------+-----+---------+-------+| f1    | int(10) unsigned | YES  |     | NULL    |       |+-------+------------------+------+-----+---------+-------+1 row in set (0.00 sec)\n2.2.3 ZEROFILL\nZEROFILL:\n0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。\n原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。\nint(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes\n的存储空间。也就是说，int(M)，必须和UNSIGNED\nZEROFILL一起使用才有意义。如果整数值超过M位，就按照实际位数存储。只是无须再用字符\n0 进行填充。\n2.3 适用场景\nTINYINT：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。\nSMALLINT：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。\nMEDIUMINT：用于较大整数的计算，比如车站每日的客流量等。\nINT、INTEGER：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。\nBIGINT：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。\n2.4 如何选择？\n在评估用哪种整数类型的时候，你需要考虑存储空间和可靠性的平衡问题：一方\n面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，\n使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起系统错误，影响可靠性。\n举个例子，商品编号采用的数据类型是\nINT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。\n如果使用 SMALLINT 类型，虽然占用字节数比 INT\n类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用\nINT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。\n你要注意的是，在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。\n3. 浮点类型\n3.1 类型介绍\n浮点数和定点数类型的特点是可以处理小数，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。\nMySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。\n\nFLOAT 表示单精度浮点数；\nDOUBLE 表示双精度浮点数；\n\n\n\nimage-20211007173312237\n\n\nREAL默认就是 DOUBLE。如果你把 SQL\n模式设定为启用“REAL_AS_FLOAT”，那 么，MySQL 就认为 REAL 是\nFLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：\nSET sql_mode = “REAL_AS_FLOAT”;\n\n问题1：FLOAT 和 DOUBLE\n这两种数据类型的区别是啥呢？\nFLOAT 占用字节数少，取值范围小；DOUBLE\n占用字节数多，取值范围也大。\n问题2：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？\nMySQL\n存储浮点数的格式为：符号(S)、尾数(M)和\n阶码(E)。因此，无论有没有符号，MySQL\n的浮点数都会存储表示符号的部分。因此，\n所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。\n3.2 数据精度说明\n对于浮点类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节。\n\nMySQL允许使用非标准语法（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：FLOAT(M,D)或DOUBLE(M,D)。这里，M称为精度，D称为标度。(M,D)中\nM=整数位+小数位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。\n例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。\nFLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。\n说明：浮点类型，也可以加UNSIGNED，但是不会改变数据范围，例如：FLOAT(3,2)\nUNSIGNED仍然只能表示0-9.99的范围。\n不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：\n\n如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值\n如果存储时，小数点部分若超出范围，就分以下情况：\n\n若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。\n若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。\n\n\n从MySQL 8.0.17开始，FLOAT(M,D)\n和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。\n举例\nCREATE TABLE test_double1(f1 FLOAT,f2 FLOAT(5,2),f3 DOUBLE,f4 DOUBLE(5,2));DESC test_double1;INSERT INTO test_double1VALUES(123.456,123.456,123.4567,123.45);#Out of range value for column 'f2' at row 1INSERT INTO test_double1VALUES(123.456,1234.456,123.4567,123.45); SELECT * FROM test_double1;\n\n3.3 精度误差说明\n浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL\n的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47\n+ 0.44 + 0.19 = 1.1。而使用sum之后查询：\nCREATE TABLE test_double2(f1 DOUBLE);INSERT INTO test_double2VALUES(0.47),(0.44),(0.19);\nmysql&gt; SELECT SUM(f1)    -&gt; FROM test_double2;+--------------------+| SUM(f1)            |+--------------------+| 1.0999999999999999 |+--------------------+1 row in set (0.00 sec)\nmysql&gt; SELECT SUM(f1) = 1.1,1.1 = 1.1    -&gt; FROM test_double2;+---------------+-----------+| SUM(f1) = 1.1 | 1.1 = 1.1 |+---------------+-----------+|             0 |         1 |+---------------+-----------+1 row in set (0.00 sec)\n查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。\n你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是，\n1.0999999940395355。显然，误差更大了。\n那么，为什么会存在这样的误差呢？问题还是出在 MySQL\n对浮点类型数据的存储方式上。\nMySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE\n类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如\n9.625，用二进制来表达，就是 1001.101，或者表达成\n1.001101×2^3。如果尾数不是 0 或 5（比如\n9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。\n在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL\n有没有精准的数据类型呢？当然有，这就是定点数类型：DECIMAL。\n4. 定点数类型\n4.1 类型介绍\n\nMySQL中的定点数类型只有 DECIMAL 一种类型。\n\n\n\n数据类型\n字节数\n含义\n\n\n\n\nDECIMAL(M,D),DEC,NUMERIC\nM+2字节\n有效范围由M和D决定\n\n\n\n使用 DECIMAL(M,D)\n的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。\nDECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。DECIMAL\n的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。\n定点数在MySQL内部是以字符串的形式进行存储，这就决定了它一定是精准的。\n当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。\n浮点数 vs 定点数\n\n浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）\n定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景\n（比如涉及金额计算的场景）\n\n举例\nCREATE TABLE test_decimal1(f1 DECIMAL,f2 DECIMAL(5,2));DESC test_decimal1;INSERT INTO test_decimal1(f1,f2)VALUES(123.123,123.456);#Out of range value for column 'f2' at row 1INSERT INTO test_decimal1(f2)VALUES(1234.34);\nmysql&gt; SELECT * FROM test_decimal1;+------+--------+| f1   | f2     |+------+--------+|  123 | 123.46 |+------+--------+1 row in set (0.00 sec)\n举例\n我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为\nDECIMAL(5,2)：\nALTER TABLE test_double2MODIFY f1 DECIMAL(5,2);\n然后，我们再一次运行求和语句：\nmysql&gt; SELECT SUM(f1)    -&gt; FROM test_double2;+---------+| SUM(f1) |+---------+|    1.10 |+---------+1 row in set (0.00 sec)\nmysql&gt; SELECT SUM(f1) = 1.1    -&gt; FROM test_double2;+---------------+| SUM(f1) = 1.1 |+---------------+|             1 |+---------------+1 row in set (0.00 sec)\n\n4.2 开发中经验\n\n“由于 DECIMAL\n数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是\nDECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ”\n——来自某项目经理\n\n5. 位类型：BIT\nBIT类型中存储的是二进制值，类似010110。\n\n\n\n二进制字符串类型\n长度\n长度范围\n占用空间\n\n\n\n\nBIT(M)\nM\n1 &lt;= M &lt;= 64\n约为(M + 7)/8个字节\n\n\n\nBIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。\nCREATE TABLE test_bit1(f1 BIT,f2 BIT(5),f3 BIT(64));INSERT INTO test_bit1(f1)VALUES(1);#Data too long for column 'f1' at row 1INSERT INTO test_bit1(f1)VALUES(2);INSERT INTO test_bit1(f2)VALUES(23);\n注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。\n使用SELECT命令查询位字段时，可以用BIN()或HEX()函数进行读取。\nmysql&gt; SELECT * FROM test_bit1;+------------+------------+------------+| f1         | f2         | f3         |+------------+------------+------------+| 0x01       | NULL       | NULL       || NULL       | 0x17       | NULL       |+------------+------------+------------+2 rows in set (0.00 sec)\nmysql&gt; SELECT BIN(f2),HEX(f2)    -&gt; FROM test_bit1;+---------+---------+| BIN(f2) | HEX(f2) |+---------+---------+| NULL    | NULL    || 10111   | 17      |+---------+---------+2 rows in set (0.00 sec)\nmysql&gt; SELECT f2 + 0    -&gt; FROM test_bit1;+--------+| f2 + 0 |+--------+|   NULL ||     23 |+--------+2 rows in set (0.00 sec)\n可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。\n6. 日期与时间类型\n日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。\nMySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。\n\nYEAR类型通常用来表示年\nDATE类型通常用来表示年、月、日\nTIME类型通常用来表示时、分、秒\nDATETIME类型通常用来表示年、月、日、时、分、秒\nTIMESTAMP类型通常用来表示带时区的年、月、日、时、分、秒\n\n\n\n\n\n\n\n\n\n\n\n\n类型\n名称\n字节\n日期格式\n最小值\n最大值\n\n\n\n\nYEAR\n年\n1\nYYYY或YY\n1901\n2155\n\n\nTIME\n时间\n3\nHH:MM:SS\n-838:59:59\n838:59:59\n\n\nDATE\n日期\n3\nYYYY-MM-DD\n1000-01-01\n9999-12-03\n\n\nDATETIME\n日期时间\n8\nYYYY-MM-DD HH:MM:SS\n1000-01-01 00:00:00\n9999-12-31 23:59:59\n\n\nTIMESTAMP\n日期时间\n4\nYYYY-MM-DD HH:MM:SS\n1970-01-01 00:00:00 UTC\n2038-01-19 03:14:07UTC\n\n\n\n可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。\n为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是\nMySQL 设计的 TIME\n类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过\n24 小时。\n6.1 YEAR类型\nYEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要1个字节的存储空间。\n在MySQL中，YEAR有以下几种存储格式：\n\n以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。\n以2位字符串格式表示YEAR类型，最小值为00，最大值为99。\n\n当取值为01到69时，表示2001到2069；\n当取值为70到99时，表示1970到1999；\n当取值整数的0或00添加的话，那么是0000年；\n当取值是日期/字符串的’0’添加的话，是2000年。\n\n\n从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL\n8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。\nCREATE TABLE test_year(f1 YEAR,f2 YEAR(4));\nmysql&gt; DESC test_year;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| f1    | year(4) | YES  |     | NULL    |       || f2    | year(4) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)\nINSERT INTO test_yearVALUES('2020','2021');mysql&gt; SELECT * FROM test_year;+------+------+| f1   | f2   |+------+------+| 2020 | 2021 |+------+------+1 rows in set (0.00 sec)\nINSERT INTO test_yearVALUES('45','71');INSERT INTO test_yearVALUES(0,'0');mysql&gt; SELECT * FROM test_year;+------+------+| f1   | f2   |+------+------+| 2020 | 2021 || 2045 | 1971 || 0000 | 2000 |+------+------+3 rows in set (0.00 sec)\n6.2 DATE类型\nDATE类型表示日期，没有时间部分，格式为YYYY-MM-DD，其中，YYYY表示年份，MM表示月份，DD表示日期。需要3个字节的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。\n\n以YYYY-MM-DD格式或者YYYYMMDD格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。\n以YY-MM-DD格式或者YYMMDD格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。\n使用CURRENT_DATE()或者NOW()函数，会插入当前系统的日期。\n\n举例：\n创建数据表，表中只包含一个DATE类型的字段f1。\nCREATE TABLE test_date1(f1 DATE);Query OK, 0 rows affected (0.13 sec)\n插入数据：\nINSERT INTO test_date1VALUES ('2020-10-01'), ('20201001'),(20201001);INSERT INTO test_date1VALUES ('00-01-01'), ('000101'), ('69-10-01'), ('691001'), ('70-01-01'), ('700101'), ('99-01-01'), ('990101');INSERT INTO test_date1VALUES (000301), (690301), (700301), (990301); INSERT INTO test_date1VALUES (CURRENT_DATE()), (NOW());SELECT *FROM test_date1;\n6.3 TIME类型\nTIME类型用来表示时间，不包含日期部分。在MySQL中，需要3个字节的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。\n在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。\n（1）可以使用带有冒号的字符串，比如’D HH:MM:SS'、‘HH:MM:SS’、‘HH:MM’、‘D HH:MM’、‘D HH’或’SS’格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。\n（2）可以使用不带有冒号的字符串或者数字，格式为’HHMMSS’或者HHMMSS。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。\n（3）使用CURRENT_TIME()或者NOW()，会插入当前系统的时间。\n举例：\n创建数据表，表中包含一个TIME类型的字段f1。\nCREATE TABLE test_time1(f1 TIME);Query OK, 0 rows affected (0.02 sec)\nINSERT INTO test_time1VALUES('2 12:30:29'), ('12:35:29'), ('12:40'), ('2 12:40'),('1 05'), ('45');INSERT INTO test_time1VALUES ('123520'), (124011),(1210);INSERT INTO test_time1VALUES (NOW()), (CURRENT_TIME());SELECT * FROM test_time1;\n6.4 DATETIME类型\nDATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要8个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为YYYY-MM-DD HH:MM:SS，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。\n在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。\n\n以YYYY-MM-DD HH:MM:SS格式或者YYYYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01\n00:00:00，最大值为9999-12-03 23:59:59。\n\n以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD\nHH:MM:SS格式。\n\n以YY-MM-DD HH:MM:SS格式或者YYMMDDHHMMSS格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。\n使用函数CURRENT_TIMESTAMP()和NOW()，可以向DATETIME类型的字段插入系统的当前日期和时间。\n\n举例：\n创建数据表，表中包含一个DATETIME类型的字段dt。\nCREATE TABLE test_datetime1(dt DATETIME);Query OK, 0 rows affected (0.02 sec)\n插入数据：\nINSERT INTO test_datetime1VALUES ('2021-01-01 06:50:30'), ('20210101065030');INSERT INTO test_datetime1VALUES ('99-01-01 00:00:00'), ('990101000000'), ('20-01-01 00:00:00'), ('200101000000');INSERT INTO test_datetime1VALUES (20200101000000), (200101000000), (19990101000000), (990101000000); INSERT INTO test_datetime1VALUES (CURRENT_TIMESTAMP()), (NOW());\n6.5 TIMESTAMP类型\nTIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是YYYY-MM-DD HH:MM:SS，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01\n00:00:01 UTC”到“2038-01-19 03:14:07\nUTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。\n\n存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。\n\n向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD\nHH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。\n如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。\n举例：\n创建数据表，表中包含一个TIMESTAMP类型的字段ts。\nCREATE TABLE test_timestamp1(ts TIMESTAMP);\n插入数据：\nINSERT INTO test_timestamp1VALUES ('1999-01-01 03:04:50'), ('19990101030405'), ('99-01-01 03:04:05'), ('990101030405');INSERT INTO test_timestamp1VALUES ('2020@01@01@00@00@00'), ('20@01@01@00@00@00');INSERT INTO test_timestamp1VALUES (CURRENT_TIMESTAMP()), (NOW());#Incorrect datetime valueINSERT INTO test_timestamp1VALUES ('2038-01-20 03:14:07');\nTIMESTAMP和DATETIME的区别：\n\nTIMESTAMP存储空间比较小，表示的日期时间范围也比较小\n底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0\n0毫秒的毫秒值。\n两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。\nTIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。\nCREATE TABLE temp_time(d1 DATETIME,d2 TIMESTAMP);\nINSERT INTO temp_time VALUES('2021-9-2 14:45:52','2021-9-2 14:45:52');INSERT INTO temp_time VALUES(NOW(),NOW());\nmysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1                  | d2                  |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 || 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec)\n#修改当前的时区SET time_zone = '+9:00';\nmysql&gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1                  | d2                  |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 || 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec)\n\n6.6 开发中经验\n用得最多的日期时间类型，就是 DATETIME。虽然 MySQL 也支持\nYEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP\n类型，但是在实际项目中，尽量用 DATETIME\n类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL\n语句也会更加复杂。\n此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用时间戳，因为DATETIME虽然直观，但不便于计算。\nmysql&gt; SELECT UNIX_TIMESTAMP();+------------------+| UNIX_TIMESTAMP() |+------------------+|       1635932762 |+------------------+1 row in set (0.00 sec)\n7. 文本字符串类型\n在实际的项目中，我们还经常遇到一种数据，就是字符串数据。\nMySQL中，文本字符串总体上分为CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET等类型。\n7.1 CHAR与VARCHAR类型\nCHAR和VARCHAR类型都可以存储比较短的字符串。\n\n\n\n\n\n\n\n\n\n\n字符串(文本)类型\n特点\n长度\n长度范围\n占用的存储空间\n\n\n\n\nCHAR(M)\n固定长度\nM\n0 &lt;= M &lt;= 255\nM个字节\n\n\nVARCHAR(M)\n可变长度\nM\n0 &lt;= M &lt;= 65535\n(实际长度 + 1) 个字节\n\n\n\nCHAR类型：\n\nCHAR(M)\n类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。\n如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。\n定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。\n\nCREATE TABLE test_char1(c1 CHAR,c2 CHAR(5));DESC test_char1;\nINSERT INTO test_char1VALUES('a','Tom');SELECT c1,CONCAT(c2,'***') FROM test_char1;\nINSERT INTO test_char1(c2)VALUES('a  ');SELECT CHAR_LENGTH(c2)FROM test_char1;\nVARCHAR类型：\n\nVARCHAR(M) 定义时，必须指定长度M，否则报错。\nMySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）\n；MySQL5.0版本以上，varchar(20)：指的是20字符。\n检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。\n\nCREATE TABLE test_varchar1(NAME VARCHAR  #错误);\n#Column length too big for column 'NAME' (max = 21845);CREATE TABLE test_varchar2(NAME VARCHAR(65535)  #错误);\nCREATE TABLE test_varchar3(NAME VARCHAR(5));INSERT INTO test_varchar3VALUES('尚硅谷'),('尚硅谷教育');#Data too long for column 'NAME' at row 1INSERT INTO test_varchar3VALUES('尚硅谷IT教育');\n哪些情况使用 CHAR 或 VARCHAR 更好\n\n\n\n类型\n特点\n空间上\n时间上\n适用场景\n\n\n\n\nCHAR(M)\n固定长度\n浪费存储空间\n效率高\n存储不大，速度要求高\n\n\nVARCHAR(M)\n可变长度\n节省存储空间\n效率低\n非CHAR的情况\n\n\n\n情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。\n情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。\n情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。\n情况4：具体存储引擎中的情况：\n\nMyISAM\n数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使数据检索更快，用空间换时间。\nMEMORY\n存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。\nInnoDB存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。\n\n7.2 TEXT类型\n在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT\n和 LONGTEXT 类型。\n在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和\nVARCHAR类型相同。\n每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：\n\n\n\n\n\n\n\n\n\n\n文本字符串类型\n特点\n长度\n长度范围\n占用的存储空间\n\n\n\n\nTINYTEXT\n小文本、可变长度\nL\n0 &lt;= L &lt;= 255\nL + 2 个字节\n\n\nTEXT\n文本、可变长度\nL\n0 &lt;= L &lt;= 65535\nL + 2 个字节\n\n\nMEDIUMTEXT\n中等文本、可变长度\nL\n0 &lt;= L &lt;= 16777215\nL + 3 个字节\n\n\nLONGTEXT\n大文本、可变长度\nL\n0 &lt;= L&lt;= 4294967295（相当于4GB）\nL + 4 个字节\n\n\n\n由于实际存储的长度不确定，MySQL 不允许 TEXT\n类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者\nVARCHAR(M)。\n举例：\n创建数据表：\nCREATE TABLE test_text(tx TEXT);\nINSERT INTO test_textVALUES('atguigu   ');SELECT CHAR_LENGTH(tx)FROM test_text; #10\n说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。\n开发中经验：\nTEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。\n8. ENUM类型\nENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。\n其所需要的存储空间由定义ENUM类型时指定的成员个数决定。\n\n\n\n文本字符串类型\n长度\n长度范围\n占用的存储空间\n\n\n\n\nENUM\nL\n1 &lt;= L &lt;= 65535\n1或2个字节\n\n\n\n\n当ENUM类型包含1～255个成员时，需要1个字节的存储空间；\n当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。\nENUM类型的成员个数的上限为65535个。\n\n举例：\n创建表如下：\nCREATE TABLE test_enum(season ENUM('春','夏','秋','冬','unknow'));\n添加数据：\nINSERT INTO test_enumVALUES('春'),('秋');# 忽略大小写INSERT INTO test_enumVALUES('UNKNOW');# 允许按照角标的方式获取指定索引位置的枚举值INSERT INTO test_enumVALUES('1'),(3);# Data truncated for column 'season' at row 1INSERT INTO test_enumVALUES('ab');# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的INSERT INTO test_enumVALUES(NULL);\n9. SET类型\nSET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为64。设置字段值时，可以取取值范围内的\n0 个或多个值。\n当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：\n\n\n\n成员个数范围（L表示实际成员个数）\n占用的存储空间\n\n\n\n\n1 &lt;= L &lt;= 8\n1个字节\n\n\n9 &lt;= L &lt;= 16\n2个字节\n\n\n17 &lt;= L &lt;= 24\n3个字节\n\n\n25 &lt;= L &lt;= 32\n4个字节\n\n\n33 &lt;= L &lt;= 64\n8个字节\n\n\n\nSET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。\n举例：\n创建表：\nCREATE TABLE test_set(s SET ('A', 'B', 'C'));\n向表中插入数据：\nINSERT INTO test_set (s) VALUES ('A'), ('A,B');#插入重复的SET类型成员时，MySQL会自动删除重复的成员INSERT INTO test_set (s) VALUES ('A,B,C,A');#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。INSERT INTO test_set (s) VALUES ('A,B,C,D');SELECT *FROM test_set;\n举例：\nCREATE TABLE temp_mul(gender ENUM('男','女'),hobby SET('吃饭','睡觉','打豆豆','写代码'));\nINSERT INTO temp_mul VALUES('男','睡觉,打豆豆'); #成功# Data truncated for column 'gender' at row 1INSERT INTO temp_mul VALUES('男,女','睡觉,写代码'); #失败# Data truncated for column 'gender' at row 1INSERT INTO temp_mul VALUES('妖','睡觉,写代码');#失败INSERT INTO temp_mul VALUES('男','睡觉,写代码,吃饭'); #成功\n10. 二进制字符串类型\nMySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。\nMySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB\n和 LONGBLOB类型。\nBINARY与VARBINARY类型\nBINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。\nBINARY\n(M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储1个字节。例如BINARY\n(8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\\0’以补齐指定长度。\nVARBINARY\n(M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型必须指定(M)，否则报错。\n\n\n\n二进制字符串类型\n特点\n值的长度\n占用空间\n\n\n\n\nBINARY(M)\n固定长度\nM （0 &lt;= M &lt;= 255）\nM个字节\n\n\nVARBINARY(M)\n可变长度\nM（0 &lt;= M &lt;= 65535）\nM+1个字节\n\n\n\n举例：\n创建表：\nCREATE TABLE test_binary1(f1 BINARY,f2 BINARY(3),# f3 VARBINARY,f4 VARBINARY(10));\n添加数据：\nINSERT INTO test_binary1(f1,f2)VALUES('a','a');INSERT INTO test_binary1(f1,f2)VALUES('尚','尚');#失败\nINSERT INTO test_binary1(f2,f4)VALUES('ab','ab');mysql&gt; SELECT LENGTH(f2),LENGTH(f4)    -&gt; FROM test_binary1;+------------+------------+| LENGTH(f2) | LENGTH(f4) |+------------+------------+|          3 |       NULL ||          3 |          2 |+------------+------------+2 rows in set (0.00 sec)\nBLOB类型\nBLOB是一个二进制大对象，可以容纳可变数量的数据。\nMySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB\n4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。\n需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到服务器的磁盘上，并将图片、音频和视频的访问路径存储到MySQL中。\n\n\n\n\n\n\n\n\n\n二进制字符串类型\n值的长度\n长度范围\n占用空间\n\n\n\n\nTINYBLOB\nL\n0 &lt;= L &lt;= 255\nL + 1 个字节\n\n\nBLOB\nL\n0 &lt;= L &lt;= 65535（相当于64KB）\nL + 2 个字节\n\n\nMEDIUMBLOB\nL\n0 &lt;= L &lt;= 16777215 （相当于16MB）\nL + 3 个字节\n\n\nLONGBLOB\nL\n0 &lt;= L &lt;= 4294967295（相当于4GB）\nL + 4 个字节\n\n\n\n举例：\nCREATE TABLE test_blob1(id INT,img MEDIUMBLOB);\nTEXT和BLOB的使用注意事项：\n在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。\n①\nBLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用\nOPTIMIZE TABLE 功能对这类表进行碎片整理。\n② 如果需要对大文本字段进行模糊查询，MySQL\n提供了前缀索引。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT\n*\n查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。\n③\n把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行\nSELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。\n11. JSON 类型\nJSON（JavaScript Object\nNotation）是一种轻量级的数据交换格式。简洁和清晰的层次结构使得\nJSON\n成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON\n可以将 JavaScript\n对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。\n在MySQL 5.7中，就已经支持JSON数据类型。在MySQL\n8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。\n创建数据表，表中包含一个JSON类型的字段 js 。\nCREATE TABLE test_json(js json);\n向表中插入JSON数据。\nINSERT INTO test_json (js) VALUES ('{\"name\":\"songhk\", \"age\":18, \"address\":{\"province\":\"beijing\", \"city\":\"beijing\"}}');\n查询t19表中的数据。\nmysql&gt; SELECT *    -&gt; FROM test_json;\n当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。\nmysql&gt; SELECT js -&gt; '$.name' AS NAME,js -&gt; '$.age' AS age ,js -&gt; '$.address.province' AS province, js -&gt; '$.address.city' AS city    -&gt; FROM test_json;+----------+------+-----------+-----------+| NAME     | age  | province  | city      |+----------+------+-----------+-----------+| \"songhk\" | 18   | \"beijing\" | \"beijing\" |+----------+------+-----------+-----------+1 row in set (0.00 sec)\n通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。\n12. 空间类型\nMySQL\n空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用Geometry（几何）来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。\nMySQL的空间数据类型（Spatial Data\nType）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION\n。\n\nGeometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。\n\nPoint，顾名思义就是点，有一个坐标值。例如POINT(121.213342\n31.234532)，POINT(30\n10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。\nLineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30\n10,10 30,40\n40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。\nPolygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0\n0,10 0,10 10, 0 10))。\n\n\n下面展示几种常见的几何图形元素：\n\n\nimage-20211104192912988\n\n\nMultiPoint、MultiLineString、MultiPolygon、GeometryCollection\n这4种类型都是集合类，是多个Point、LineString或Polygon组合而成。\n\n下面展示的是多个同类或异类几何图形元素的组合：\n\n\nimage-20211104193330204\n\n13. 小结及选择建议\n在定义数据类型时，如果确定是整数，就用INT；\n如果是小数，一定用定点数类型 DECIMAL(M,D)；\n如果是日期与时间，就用 DATETIME。\n这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT\n虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。\n关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：\n阿里巴巴《Java开发手册》之MySQL数据库：\n\n任何字段如果为非负数，必须是 UNSIGNED\n【强制】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。\n\n说明：在存储的时候，FLOAT 和 DOUBLE\n都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过\nDECIMAL 的范围，建议将数据拆成整数和小数并分开存储。\n\n【强制】如果存储的字符串长度几乎相等，使用 CHAR\n定长字符串类型。\n【强制】VARCHAR\n是可变长字符串，不预先分配存储空间，长度不要超过\n5000。如果存储长度大于此值，定义字段类型为\nTEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。\n\n","categories":["Database","SQL"],"tags":["MySQL,DataType"]},{"title":"MySql 库表管理","url":"/2024/02/23/MySql-%E5%BA%93%E8%A1%A8%E7%AE%A1%E7%90%86/","content":"MySQL\n库表用户与权限管理：用户的创建、修改、删除与密码设置，权限的授予与回收，以及角色的创建、赋权、激活与强制绑定等完整操作流程。\n\n1. 用户管理\n1.1 登录MySQL服务器\n启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下：\nmysql –h hostname|hostIP –P port –u username –p DatabaseName –e \"SQL语句\"\n\n-h参数后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。\n-P参数后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306，不使用该参数时自动连接到3306端口，port为连接的端口号。\n-u参数后面接用户名，username为用户名。\n-p参数会提示输入密码。\nDatabaseName参数指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库中，然后可以使用USE命令来选择数据库。\n-e参数后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL服务器。\n\nmysql -uroot -p -hlocalhost -P3306 mysql -e \"select host,user from user\"\n1.2 创建用户\nCREATE USER 用户名 [IDENTIFIED BY '密码'][,用户名 [IDENTIFIED BY '密码']];\n举例：\nCREATE USER zhang3 IDENTIFIED BY '123123'; # 默认host是 %CREATE USER 'kangshifu'@'localhost' IDENTIFIED BY '123456';\n1.3 修改用户\nUPDATE mysql.user SET USER='li4' WHERE USER='wang5'; FLUSH PRIVILEGES;\n1.4 删除用户\n方式1：使用DROP方式删除（推荐）\nDROP USER user[,user]…;\n举例：\nDROP USER li4 ; # 默认删除host为%的用户DROP USER 'kangshifu'@'localhost';\n方式2：使用DELETE方式删除（不推荐，有残留信息）\nDELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;FLUSH PRIVILEGES;\n1.5 设置当前用户密码\n1. 使用ALTER\nUSER命令来修改当前用户密码\nALTER USER USER() IDENTIFIED BY 'new_password';\n2.\n使用SET语句来修改当前用户密码\nSET PASSWORD='new_password';\n1.6 修改其它用户密码\n1.\n使用ALTER语句来修改普通用户的密码\nALTER USER user [IDENTIFIED BY '新密码'] [,user[IDENTIFIED BY '新密码']]…;\n2.\n使用SET命令来修改普通用户的密码\nSET PASSWORD FOR 'username'@'hostname'='new_password';\n2. 权限管理\n2.1 权限列表\nshow privileges;\n\nCREATE和DROP权限，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。\nSELECT、INSERT、UPDATE和DELETE权限允许在一个数据库现有的表上实施操作。\nSELECT权限只有在它们真正从一个表中检索行时才被用到。\nINDEX权限允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE\nTABLE语句中包括索引定义。\nALTER权限可以使用ALTER\nTABLE来更改表的结构和重新命名表。\nCREATE ROUTINE权限用来创建保存的程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序，EXECUTE权限用来执行保存的程序。\nGRANT权限允许授权给其他用户，可用于数据库、表和保存的程序。\nFILE权限使用户可以使用LOAD DATA INFILE和SELECT … INTO\nOUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。\n\n2.2 授予权限的原则\n权限控制主要是出于安全因素，因此需要遵循以下几个经验原则：\n1、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。\n2、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。\n3、为每个用户设置满足密码复杂度的密码。\n4、定期清理不需要的用户，回收权限或者删除用户。\n2.3 授予权限\nGRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];\n\n该权限如果发现没有该用户，则会直接新建一个用户。\n给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost;\n\n授予通过网络方式登录的joe用户，对所有库所有表的全部权限，密码设为123。\n注意这里唯独不包括grant的权限\n\nGRANT ALL PRIVILEGES ON *.* TO joe@'%' IDENTIFIED BY '123';\n2.4 查看权限\n\n查看当前用户权限\n\nSHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();\n\n查看某用户的全局权限\n\nSHOW GRANTS FOR 'user'@'主机地址';\n2.5 收回权限\n注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。\n\n收回权限命令\n\nREVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;\n\n举例\n\n回全库全表的所有权限 REVOKE ALL PRIVILEGES ON *.* FROM joe@'%'; 回mysql库下的所有表的插删改查权限 REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;\n\n注意：须用户重新登录后才能生效\n\n3. 角色管理\n3.1 创建角色\nCREATE ROLE 'role_name'[@'host_name'] [,'role_name'[@'host_name']]...\n角色名称的命名规则和用户名类似。如果host_name省略，默认为%，role_name不可省略，不可为空。\n3.2 给角色赋予权限\nGRANT privileges ON table_name TO 'role_name'[@'host_name'];\n上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称\nSHOW PRIVILEGES\\G\n3.3 查看角色的权限\nSHOW GRANTS FOR 'role_name';\n只要你创建了一个角色，系统就会自动给你一个“USAGE”权限，意思是连接登录数据库的权限。\n3.4 回收角色的权限\nREVOKE privileges ON tablename FROM 'rolename';\n3.5 删除角色\nDROP ROLE role [,role2]...\n注意，如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限。\n3.6 给用户赋予角色\n角色创建并授权后，要赋给用户并处于激活状态才能发挥作用。\nGRANT role [,role2,...] TO user [,user2,...];\n查询当前已激活的角色\nSELECT CURRENT_ROLE();\n3.7 激活角色\n方式1：使用set default role 命令激活角色\nSET DEFAULT ROLE ALL TO 'kangshifu'@'localhost';\n方式2：将activate_all_roles_on_login设置为ON\nSET GLOBAL activate_all_roles_on_login=ON;\n这条 SQL 语句的意思是，对所有角色永久激活。\n3.8 撤销用户的角色\nREVOKE role FROM user;\n3.9 设置强制角色(mandatory\nrole)\n方式1：服务启动前设置\n[mysqld] mandatory_roles='role1,role2@localhost,r3@%.atguigu.com'\n方式2：运行时设置\nSET PERSIST mandatory_roles = 'role1,role2@localhost,r3@%.example.com'; #系统重启后仍然有效SET GLOBAL mandatory_roles = 'role1,role2@localhost,r3@%.example.com'; #系统重启后失效\n","categories":["Database","SQL"],"tags":["MySQL,DCL"]},{"title":"SQL DQL语句","url":"/2024/02/21/SQL-DQL%E8%AF%AD%E5%8F%A5/","content":"常见的 SQL 查询语言（DQL）使用方法与语法规则，涵盖基本 SELECT\n查询、常数与去重查询、字段别名、空值处理、保留字使用技巧，以及表结构查看等操作示例。\n\n1. SQL概述\n1.1 SQL背景知识\n\n1946\n年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是\nSQL。\n\n45 年前，也就是 1974 年，IBM\n研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。\n\n不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。\nSQL（Structured Query\nLanguage，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道，由IBM上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有SQL-86，SQL-89，SQL-92，SQL-99等标准。\n\nSQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和\n99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。\n\n不同的数据库生产厂商都支持SQL语句，但都有特有内容。\n\n1.2 SQL语言排行榜\n自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。\n1.3 SQL 分类\nSQL语言在功能上主要分为如下3大类：\n\nDDL（Data Definition\nLanguages、数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\n\n主要的语句关键字包括CREATE、DROP、ALTER等。\n\nDML（Data Manipulation\nLanguage、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。\n\n主要的语句关键字包括INSERT、DELETE、UPDATE、SELECT等。\nSELECT是SQL语言的基础，最为重要。\n\nDCL（Data Control\nLanguage、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。\n\n主要的语句关键字包括GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等。\n\n\n\n因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。\n还有单独将COMMIT、ROLLBACK 取出来称为TCL\n（Transaction Control Language，事务控制语言）。\n\n2. SQL语言的规则与规范\n2.1 基本规则\n\nSQL\n可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进\n每条命令以 ; 或 或 束\n关键字不能被缩写也不能分行\n关于标点符号\n\n必须保证所有的()、单引号、双引号是成对结束的\n必须使用英文状态下的半角输入方式\n字符串型和日期时间类型的数据可以使用单引号（’ ’）表示\n列的别名，尽量使用双引号（” “），而且不建议省略as\n\n\n2.2 SQL大小写规范 （建议遵守）\n\nMySQL 在 Windows 环境下是大小写不敏感的\nMySQL 在 Linux 环境下是大小写敏感的\n\n数据库名、表名、表的别名、变量名是严格区分大小写的\n关键字、函数名、列名(或字段名)、列的别名(字段的别名)\n是忽略大小写的。\n\n推荐采用统一的书写规范：\n\n数据库名、表名、表别名、字段名、字段别名等都小写\nSQL 关键字、函数名、绑定变量等都大写\n\n\n2.3 注 释\n可以使用如下格式的注释结构\n单行注释：#注释文字(MySQL特有的方式)单行注释：-- 注释文字(--后面必须包含一个空格。)多行注释：/* 注释文字  */\n2.4 命名规则（暂时了解）\n\n数据库、表名不得超过30个字符，变量名限制为29个\n必须只能包含 A–Z, a–z, 0–9, _共63个字符\n数据库名、表名、字段名等对象名中间不要包含空格\n同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名\n必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来\n保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了\n\n举例：\n#以下两句是一样的，不区分大小写show databases;SHOW DATABASES;#创建表格#create table student info(...); #表名错误，因为表名有空格create table student_info(...); #其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了CREATE TABLE `order`(    id INT,    lname VARCHAR(20));select id as \"编号\", `name` as \"姓名\" from t_stu; #起别名时，as都可以省略select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略\"\"select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略\"\"\n2.5 数据导入指令\n在命令行客户端登录mysql，使用source指令导入\nmysql&gt; source d:\\mysqldb.sql\nmysql&gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field          | Type        | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id    | int(6)      | NO   | PRI | 0       |       || first_name     | varchar(20) | YES  |     | NULL    |       || last_name      | varchar(25) | NO   |     | NULL    |       || email          | varchar(25) | NO   | UNI | NULL    |       || phone_number   | varchar(20) | YES  |     | NULL    |       || hire_date      | date        | NO   |     | NULL    |       || job_id         | varchar(10) | NO   | MUL | NULL    |       || salary         | double(8,2) | YES  |     | NULL    |       || commission_pct | double(2,2) | YES  |     | NULL    |       || manager_id     | int(6)      | YES  | MUL | NULL    |       || department_id  | int(4)      | YES  | MUL | NULL    |       |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec)\n3. 基本的SELECT语句\n3.0 SELECT…\nSELECT 1; #没有任何子句SELECT 9/2; #没有任何子句\n3.1 SELECT … FROM\n\n语法：\n\nSELECT   标识选择哪些列FROM     标识从哪个表中选择\n\n选择全部列：\n\nSELECT *FROM   departments;\n\n一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。\n在生产环境下，不推荐你直接使用SELECT *进行查询。\n\n\n选择特定的列：\n\nSELECT department_id, location_idFROM   departments;\n\nMySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。\n\n3.2 列的别名\n\n重命名一个列\n便于计算\n紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特殊的字符并区分大小写。\nAS 可以省略\n建议别名简短，见名知意\n举例\nSELECT last_name AS name, commission_pct commFROM   employees;\nSELECT last_name \"Name\", salary*12 \"Annual Salary\"FROM   employees;\n\n3.3 去除重复行\n默认情况下，查询会返回全部行，包括重复行。\nSELECT department_idFROM   employees;\n在SELECT语句中使用关键字DISTINCT去除重复行\nSELECT DISTINCT department_idFROM   employees;\n针对于：\nSELECT DISTINCT department_id,salary FROM employees;\n这里有两点需要注意：\n\nDISTINCT\n需要放到所有列名的前面，如果写成SELECT salary, DISTINCT department_id FROM employees会报错。\nDISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74\n条，因为这 74 个部门id不同，都有 salary\n这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写DISTINCT department_id即可，后面不需要再加其他的列名了。\n\n3.4 空值参与运算\n\n所有运算符或列值遇到null值，运算的结果都为null\n\nSELECT employee_id,salary,commission_pct,12 * salary * (1 + commission_pct) \"annual_sal\"FROM employees;\n这里你一定要注意，在 MySQL 里面，\n空值不等于空字符串。一个空字符串的长度是\n0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。\n3.5 着重号\n\n错误的\n\nmysql&gt; SELECT * FROM ORDER;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'ORDER' at line 1\n\n正确的\n\nmysql&gt; SELECT * FROM `ORDER`;+----------+------------+| order_id | order_name |+----------+------------+|        1 | shkstart   ||        2 | tomcat     ||        3 | dubbo      |+----------+------------+3 rows in set (0.00 sec)mysql&gt; SELECT * FROM `order`;+----------+------------+| order_id | order_name |+----------+------------+|        1 | shkstart   ||        2 | tomcat     ||        3 | dubbo      |+----------+------------+3 rows in set (0.00 sec)\n\n结论\n\n我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对``（着重号）引起来。\n3.6 5、查询常数\nSELECT 查询还可以对常数进行查询。对的，就是在 SELECT\n查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。\n你可能会问为什么我们还要对常数进行查询呢？\nSQL 中的 SELECT\n语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。\n比如说，我们想对 employees\n数据表中的员工姓名进行查询，同时增加一列字段corporation，这个字段固定值为“尚硅谷”，可以这样写：\nSELECT '尚硅谷' as corporation, last_name FROM employees;\n4. 显示表结构\n使用DESCRIBE 或 DESC 命令，表示表结构。\nDESCRIBE employees;或DESC employees;\nmysql&gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field          | Type        | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id    | int(6)      | NO   | PRI | 0       |       || first_name     | varchar(20) | YES  |     | NULL    |       || last_name      | varchar(25) | NO   |     | NULL    |       || email          | varchar(25) | NO   | UNI | NULL    |       || phone_number   | varchar(20) | YES  |     | NULL    |       || hire_date      | date        | NO   |     | NULL    |       || job_id         | varchar(10) | NO   | MUL | NULL    |       || salary         | double(8,2) | YES  |     | NULL    |       || commission_pct | double(2,2) | YES  |     | NULL    |       || manager_id     | int(6)      | YES  | MUL | NULL    |       || department_id  | int(4)      | YES  | MUL | NULL    |       |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec)\n其中，各个字段的含义分别解释如下：\n\nField：表示字段名称。\nType：表示字段类型，这里 barcode、goodsname 是文本型的，price\n是整数类型的。\nNull：表示该列是否可以存储NULL值。\nKey：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。\nDefault：表示该列是否有默认值，如果有，那么值是多少。\nExtra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。\n\n5. 过滤数据\n\n语法：\nSELECT 字段1,字段2FROM 表名WHERE 过滤条件\n\n使用WHERE 子句，将不满足条件的行过滤掉\nWHERE子句紧随 FROM子句\n\n举例\n\nSELECT employee_id, last_name, job_id, department_idFROM   employeesWHERE  department_id = 90 ;\n","categories":["Database","SQL"],"tags":["SQL,DQL"]},{"title":"SQL 函数基础","url":"/2024/02/21/SQL-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/","content":"SQL函数基础知识,\n包括函数的定义、分类、内置函数的使用方法和示例等。\n\n1. 函数的理解\n1.1 什么是函数\n函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既提高了代码效率，又提高了可维护性。在\nSQL\n中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地提高用户对数据库的管理效率。\n从函数定义的角度出发，我们可以将函数分成内置函数和自定义函数。在\nSQL\n语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是\nSQL 的内置函数。\n1.2 不同DBMS函数的差异\n我们在使用 SQL\n语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即\nDBMS。DBMS\n之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是被\nDBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在\nMySQL 中的字符串拼接函数为concat()。大部分 DBMS\n会有自己特定的函数，这就意味着采用 SQL\n函数的代码可移植性是很差的，因此在使用函数的时候需要特别注意。\n1.3 MySQL的内置函数及分类\nMySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。\nMySQL提供的内置函数从实现的功能角度可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：单行函数、聚合函数（或分组函数）。\n单行函数\n\n操作数据对象\n接受参数返回一个结果\n只对一行进行变换\n每行返回一个结果\n可以嵌套\n参数可以是一列或一个值\n\n2. 数值函数\n2.1 基本函数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nABS(x)\n返回x的绝对值\n\n\nSIGN(X)\n返回X的符号。正数返回1，负数返回-1，0返回0\n\n\nPI()\n返回圆周率的值\n\n\nCEIL(x)，CEILING(x)\n返回大于或等于某个值的最小整数\n\n\nFLOOR(x)\n返回小于或等于某个值的最大整数\n\n\nLEAST(e1,e2,e3…)\n返回列表中的最小值\n\n\nGREATEST(e1,e2,e3…)\n返回列表中的最大值\n\n\nMOD(x,y)\n返回X除以Y后的余数\n\n\nRAND()\n返回0~1的随机值\n\n\nRAND(x)\n返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数\n\n\nROUND(x)\n返回一个对x的值进行四舍五入后，最接近于X的整数\n\n\nROUND(x,y)\n返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位\n\n\nTRUNCATE(x,y)\n返回数字x截断为y位小数的结果\n\n\nSQRT(x)\n返回x的平方根。当X的值为负数时，返回NULL\n\n\n\n2.2 角度与弧度互换函数\n\n\n\n函数\n用法\n\n\n\n\nRADIANS(x)\n将角度转化为弧度，其中，参数x为角度值\n\n\nDEGREES(x)\n将弧度转化为角度，其中，参数x为弧度值\n\n\n\n2.3 三角函数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nSIN(x)\n返回x的正弦值，其中，参数x为弧度值\n\n\nASIN(x)\n返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL\n\n\nCOS(x)\n返回x的余弦值，其中，参数x为弧度值\n\n\nACOS(x)\n返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL\n\n\nTAN(x)\n返回x的正切值，其中，参数x为弧度值\n\n\nATAN(x)\n返回x的反正切值，即返回正切值为x的值\n\n\nATAN2(m,n)\n返回两个参数的反正切值\n\n\nCOT(x)\n返回x的余切值，其中，X为弧度值\n\n\n\n2.4 指数与对数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nPOW(x,y)，POWER(X,Y)\n返回x的y次方\n\n\nEXP(X)\n返回e的X次方，其中e是一个常数，2.718281828459045\n\n\nLN(X)，LOG(X)\n返回以e为底的X的对数，当X &lt;= 0 时，返回的结果为NULL\n\n\nLOG10(X)\n返回以10为底的X的对数，当X &lt;= 0 时，返回的结果为NULL\n\n\nLOG2(X)\n返回以2为底的X的对数，当X &lt;= 0 时，返回NULL\n\n\n\n2.5 进制间的转换\n\n\n\n函数\n用法\n\n\n\n\nBIN(x)\n返回x的二进制编码\n\n\nHEX(x)\n返回x的十六进制编码\n\n\nOCT(x)\n返回x的八进制编码\n\n\nCONV(x,f1,f2)\n返回f1进制数变成f2进制数\n\n\n\n3. 字符串函数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nASCII(S)\n返回字符串S中的第一个字符的ASCII码值\n\n\nCHAR_LENGTH(s)\n返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同\n\n\nLENGTH(s)\n返回字符串s的字节数，和字符集有关\n\n\nCONCAT(s1,s2,……,sn)\n连接s1,s2,……,sn为一个字符串\n\n\nCONCAT_WS(x, s1,s2,……,sn)\n同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x\n\n\nINSERT(str, idx, len, replacestr)\n将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr\n\n\nREPLACE(str, a, b)\n用字符串b替换字符串str中所有出现的字符串a\n\n\nUPPER(s) 或 UCASE(s)\n将字符串s的所有字母转成大写字母\n\n\nLOWER(s) 或LCASE(s)\n将字符串s的所有字母转成小写字母\n\n\nLEFT(str,n)\n返回字符串str最左边的n个字符\n\n\nRIGHT(str,n)\n返回字符串str最右边的n个字符\n\n\nLPAD(str, len, pad)\n用字符串pad对str最左边进行填充，直到str的长度为len个字符\n\n\nRPAD(str ,len, pad)\n用字符串pad对str最右边进行填充，直到str的长度为len个字符\n\n\nLTRIM(s)\n去掉字符串s左侧的空格\n\n\nRTRIM(s)\n去掉字符串s右侧的空格\n\n\nTRIM(s)\n去掉字符串s开始与结尾的空格\n\n\nTRIM(s1 FROM s)\n去掉字符串s开始与结尾的s1\n\n\nTRIM(LEADING s1 FROM s)\n去掉字符串s开始处的s1\n\n\nTRIM(TRAILING s1 FROM s)\n去掉字符串s结尾处的s1\n\n\nREPEAT(str, n)\n返回str重复n次的结果\n\n\nSPACE(n)\n返回n个空格\n\n\nSTRCMP(s1,s2)\n比较字符串s1,s2的ASCII码值的大小\n\n\nSUBSTR(s,index,len)\n返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同\n\n\nLOCATE(substr,str)\n返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr\nIN str)、INSTR(str,substr)相同。未找到，返回0\n\n\nELT(m,s1,s2,…,sn)\n返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如果m=n，则返回sn\n\n\nFIELD(s,s1,s2,…,sn)\n返回字符串s在字符串列表中第一次出现的位置\n\n\nFIND_IN_SET(s1,s2)\n返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串\n\n\nREVERSE(s)\n返回s反转后的字符串\n\n\nNULLIF(value1,value2)\n比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1\n\n\n\n\n注意：MySQL中，字符串的位置是从1开始的。\n\n4. 日期和时间函数\n4.1 获取日期、时间\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nCURDATE() ，CURRENT_DATE()\n返回当前日期，只包含年、月、日\n\n\nCURTIME() ， CURRENT_TIME()\n返回当前时间，只包含时、分、秒\n\n\nNOW() / SYSDATE() / CURRENT_TIMESTAMP() /\nLOCALTIME() / LOCALTIMESTAMP()\n返回当前系统日期和时间\n\n\nUTC_DATE()\n返回UTC（世界标准时间）日期\n\n\nUTC_TIME()\n返回UTC（世界标准时间）时间\n\n\n\n4.2 日期与时间戳的转换\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nUNIX_TIMESTAMP()\n以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP()\n-&gt;1634348884\n\n\nUNIX_TIMESTAMP(date)\n将时间date以UNIX时间戳的形式返回。\n\n\nFROM_UNIXTIME(timestamp)\n将UNIX时间戳的时间转换为普通格式的时间\n\n\n\n4.3\n获取月份、星期、星期数、天数等函数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nYEAR(date) / MONTH(date) / DAY(date)\n返回具体的日期值\n\n\nHOUR(time) / MINUTE(time) / SECOND(time)\n返回具体的时间值\n\n\nMONTHNAME(date)\n返回月份：January，…\n\n\nDAYNAME(date)\n返回星期几：MONDAY，TUESDAY…..SUNDAY\n\n\nWEEKDAY(date)\n返回周几，注意，周1是0，周2是1，。。。周日是6\n\n\nQUARTER(date)\n返回日期对应的季度，范围为1～4\n\n\nWEEK(date) ， WEEKOFYEAR(date)\n返回一年中的第几周\n\n\nDAYOFYEAR(date)\n返回日期是一年中的第几天\n\n\nDAYOFMONTH(date)\n返回日期位于所在月份的第几天\n\n\nDAYOFWEEK(date)\n返回周几，注意：周日是1，周一是2，。。。周六是7\n\n\n\n4.4 日期的操作函数\n\n\n\n函数\n用法\n\n\n\n\nEXTRACT(type FROM date)\n返回指定日期中特定的部分，type指定返回的值\n\n\n\nEXTRACT(type FROM date)函数中type的取值与含义：\n\n\nimage-20211012142639469\n\nSELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())FROM DUAL;\n4.5 时间和秒钟转换的函数\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nTIME_TO_SEC(time)\n将 time\n转化为秒并返回结果值。转化的公式为：小时*3600+分钟*60+秒\n\n\nSEC_TO_TIME(seconds)\n将 seconds 描述转化为包含小时、分钟和秒的时间\n\n\n\n4.6 计算日期和时间的函数\n第1组：\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nDATE_ADD(datetime, INTERVAL expr type)，ADDDATE(date,INTERVAL expr\ntype)\n返回与给定日期时间相差INTERVAL时间段的日期时间\n\n\nDATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr\ntype)\n返回与date相差INTERVAL时间间隔的日期\n\n\n\n上述函数中type的取值：\n\n\nimage-20211012143203355\n\n举例：\nSELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col2,ADDDATE('2021-10-21 23:32:12',INTERVAL 1 SECOND) AS col3,DATE_ADD('2021-10-21 23:32:12',INTERVAL '1_1' MINUTE_SECOND) AS col4,DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数DATE_ADD(NOW(), INTERVAL '1_1' YEAR_MONTH) AS col6 #需要单引号FROM DUAL;\nSELECT DATE_SUB('2021-01-21',INTERVAL 31 DAY) AS col1,SUBDATE('2021-01-21',INTERVAL 31 DAY) AS col2,DATE_SUB('2021-01-21 02:01:01',INTERVAL '1 1' DAY_HOUR) AS col3FROM DUAL;\n第2组：\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nADDTIME(time1,time2)\n返回time1加上time2的时间。当time2为一个数字时，代表的是秒，可以为负数\n\n\nSUBTIME(time1,time2)\n返回time1减去time2后的时间。当time2为一个数字时，代表的是秒，可以为负数\n\n\nDATEDIFF(date1,date2)\n返回date1 - date2的日期间隔天数\n\n\nTIMEDIFF(time1, time2)\n返回time1 - time2的时间间隔\n\n\nFROM_DAYS(N)\n返回从0000年1月1日起，N天以后的日期\n\n\nTO_DAYS(date)\n返回日期date距离0000年1月1日的天数\n\n\nLAST_DAY(date)\n返回date所在月份的最后一天的日期\n\n\nMAKEDATE(year,n)\n针对给定年份与所在年份中的天数返回一个日期\n\n\nMAKETIME(hour,minute,second)\n将给定的小时、分钟和秒组合成时间并返回\n\n\nPERIOD_ADD(time,n)\n返回time加上n后的时间\n\n\n\n举例：查询 7 天内的新增用户数有多少？\nSELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)&lt;=7\n4.7 日期的格式化与解析\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nDATE_FORMAT(date,fmt)\n按照字符串fmt格式化日期date值\n\n\nTIME_FORMAT(time,fmt)\n按照字符串fmt格式化时间time值\n\n\nGET_FORMAT(date_type,format_type)\n返回日期字符串的显示格式\n\n\nSTR_TO_DATE(str, fmt)\n按照字符串fmt对str进行解析，解析为一个日期\n\n\n\n上述非GET_FORMAT函数中fmt参数常用的格式符：\n\n\n\n\n\n\n\n\n\n格式符\n说明\n格式符\n说明\n\n\n\n\n%Y\n4位数字表示年份\n%y\n表示两位数字表示年份\n\n\n%M\n月名表示月份（January,….）\n%m\n两位数字表示月份（01,02,03。。。）\n\n\n%b\n缩写的月名（Jan.，Feb.，….）\n%c\n数字表示月份（1,2,3,…）\n\n\n%D\n英文后缀表示月中的天数（1st,2nd,3rd,…）\n%d\n两位数字表示月中的天数(01,02…)\n\n\n%e\n数字形式表示月中的天数（1,2,3,4,5…..）\n\n\n\n\n%H\n两位数字表示小数，24小时制（01,02..）\n%h和%I\n两位数字表示小时，12小时制（01,02..）\n\n\n%k\n数字形式的小时，24小时制(1,2,3)\n%l\n数字形式表示小时，12小时制（1,2,3,4….）\n\n\n%i\n两位数字表示分钟（00,01,02）\n%S和%s\n两位数字表示秒(00,01,02…)\n\n\n%W\n一周中的星期名称（Sunday…）\n%a\n一周中的星期缩写（Sun.，Mon.,Tues.，..）\n\n\n%w\n以数字表示周中的天数(0=Sunday,1=Monday….)\n\n\n\n\n%j\n以3位数字表示年中的天数(001,002…)\n%U\n以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天\n\n\n%u\n以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天\n\n\n\n\n%T\n24小时制\n%r\n12小时制\n\n\n%p\nAM或PM\n%%\n表示%\n\n\n\nGET_FORMAT函数中date_type和format_type参数取值如下：\n\n\nimage-20211012145231321\n\n5. 流程控制函数\n流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nIF(value,value1,value2)\n如果value的值为TRUE，返回value1，否则返回value2\n\n\nIFNULL(value1, value2)\n如果value1不为NULL，返回value1，否则返回value2\n\n\nCASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn]\nEND\n相当于Java的if…else if…else…\n\n\nCASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n]\nEND\n相当于Java的switch…case…\n\n\n\nSELECT last_name, job_id, salary,       CASE job_id WHEN 'IT_PROG'  THEN  1.10*salary                   WHEN 'ST_CLERK' THEN  1.15*salary                   WHEN 'SA_REP'   THEN  1.20*salary       \t\t\t   ELSE      salary END     \"REVISED_SALARY\"FROM   employees;\n6. 加密与解密函数\n加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nPASSWORD(str)\n返回字符串str的加密版本，41位长的字符串。加密结果不可逆，常用于用户的密码加密\n\n\nMD5(str)\n返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL\n\n\nSHA(str)\n从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。SHA加密算法比MD5更加安全。\n\n\nENCODE(value,password_seed)\n返回使用password_seed作为加密密码加密value\n\n\nDECODE(value,password_seed)\n返回使用password_seed作为加密密码解密value\n\n\n\n可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。\n7. MySQL信息函数\nMySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nVERSION()\n返回当前MySQL的版本号\n\n\nCONNECTION_ID()\n返回当前MySQL服务器的连接数\n\n\nDATABASE()，SCHEMA()\n返回MySQL命令行当前所在的数据库\n\n\nUSER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()\n返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”\n\n\nCHARSET(value)\n返回字符串value自变量的字符集\n\n\nCOLLATION(value)\n返回字符串value的比较规则\n\n\n\n举例：\nmysql&gt; SELECT CHARSET('ABC');+----------------+| CHARSET('ABC') |+----------------+| utf8mb4        |+----------------+1 row in set (0.00 sec)\n8. 其他函数\nMySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。\n\n\n\n\n\n\n\n函数\n用法\n\n\n\n\nFORMAT(value,n)\n返回对数字value进行格式化后的结果数据。n表示四舍五入后保留到小数点后n位\n\n\nCONV(value,from,to)\n将value的值进行不同进制之间的转换\n\n\nINET_ATON(ipvalue)\n将以点分隔的IP地址转化为一个数字\n\n\nINET_NTOA(value)\n将数字形式的IP地址转化为以点分隔的IP地址\n\n\nBENCHMARK(n,expr)\n将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间\n\n\nCONVERT(value USING char_code)\n将value所使用的字符编码修改为char_code\n\n\n\n举例：\n# 如果n的值小于或者等于0，则只保留整数部分mysql&gt; SELECT FORMAT(123.123, 2), FORMAT(123.523, 0), FORMAT(123.123, -2); +--------------------+--------------------+---------------------+| FORMAT(123.123, 2) | FORMAT(123.523, 0) | FORMAT(123.123, -2) |+--------------------+--------------------+---------------------+| 123.12             | 124                | 123                 |+--------------------+--------------------+---------------------+1 row in set (0.00 sec)\nmysql&gt; SELECT INET_ATON('192.168.1.100');+----------------------------+| INET_ATON('192.168.1.100') |+----------------------------+|                 3232235876 |+----------------------------+1 row in set (0.00 sec)# 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上100。\nmysql&gt; SELECT INET_NTOA(3232235876);+-----------------------+| INET_NTOA(3232235876) |+-----------------------+| 192.168.1.100         |+-----------------------+1 row in set (0.00 sec)\nmysql&gt; SELECT BENCHMARK(1000000, MD5('mysql')); +----------------------------------+| BENCHMARK(1000000, MD5('mysql')) |+----------------------------------+|                                0 |+----------------------------------+1 row in set (0.20 sec)\nmysql&gt; SELECT CHARSET('mysql'), CHARSET(CONVERT('mysql' USING 'utf8'));+------------------+----------------------------------------+| CHARSET('mysql') | CHARSET(CONVERT('mysql' USING 'utf8')) |+------------------+----------------------------------------+| utf8mb4          | utf8                                   |+------------------+----------------------------------------+1 row in set, 1 warning (0.00 sec)​```xxxxxxxxxx mysql&gt; SELECT CHARSET('mysql'), CHARSET(CONVERT('mysql' USING 'utf8'));+------------------+----------------------------------------+| CHARSET('mysql') | CHARSET(CONVERT('mysql' USING 'utf8')) |+------------------+----------------------------------------+| utf8mb4          | utf8                                   |+------------------+----------------------------------------+1 row in set, 1 warning (0.00 sec)mysql\n","categories":["Database","SQL"],"tags":["SQL,Function"]},{"title":"SQL 子查询","url":"/2024/02/21/SQL-%E5%AD%90%E6%9F%A5%E8%AF%A2/","content":"常见的 SQL\n子查询使用方法及场景示例，涵盖单行子查询、多行子查询、相关与非相关子查询，以及\nHAVING、CASE、更新与删除中的子查询技巧。\n\n1. 需求分析与问题解决\n1.1 实际问题\n求比Bob工资高的人 =&gt; Bob工资是多少？\n#方式一：SELECT salaryFROM employeesWHERE last_name = 'Abel';SELECT last_name,salaryFROM employeesWHERE salary &gt; 11000;#方式二：自连接SELECT e2.last_name,e2.salaryFROM employees e1,employees e2WHERE e1.last_name = 'Abel'AND e1.`salary` &lt; e2.`salary`\n#方式三：子查询SELECT last_name,salaryFROM employeesWHERE salary &gt; (\t\tSELECT salary\t\tFROM employees\t\tWHERE last_name = 'Abel');\n1.2 子查询的基本使用\n\n子查询（内查询）在主查询之前一次执行完成。\n子查询的结果被主查询（外查询）使用 。\n注意事项\n\n子查询要包含在括号内\n将子查询放在比较条件的右侧\n单行操作符对应单行子查询，多行操作符对应多行子查询\n\n\n1.3 子查询的分类\n分类方式1：\n我们按内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询。\n\n单行子查询\n多行子查询\n\n分类方式2：\n我们按内查询是否被执行多次，将子查询划分为相关(或关联)子查询和不相关(或非关联)子查询。\n子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。\n同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。\n2. 单行子查询\n2.1 单行比较操作符\n\n\n\n操作符\n含义\n\n\n\n\n=\nequal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&lt;&gt;\nnot equal to\n\n\n\n2.2 代码示例\n题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资\nSELECT last_name, job_id, salaryFROM   employeesWHERE  job_id =                  (SELECT job_id                 FROM   employees                 WHERE  employee_id = 141)AND    salary &gt;                (SELECT salary                 FROM   employees                 WHERE  employee_id = 143);\n题目：返回公司工资最少的员工的last_name,job_id和salary\nSELECT last_name, job_id, salaryFROM   employeesWHERE  salary =                 (SELECT MIN(salary)                 FROM   employees);\n题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id\n实现方式1：不成对比较\nSELECT  employee_id, manager_id, department_idFROM    employeesWHERE   manager_id IN\t\t  (SELECT  manager_id                   FROM    employees                   WHERE   employee_id IN (174,141))AND     department_id IN \t\t  (SELECT  department_id                   FROM    employees                   WHERE   employee_id IN (174,141))AND\temployee_id NOT IN(174,141);\n实现方式2：成对比较\nSELECT\temployee_id, manager_id, department_idFROM\temployeesWHERE  (manager_id, department_id) IN                      (SELECT manager_id, department_id                       FROM   employees                       WHERE  employee_id IN (141,174))AND\temployee_id NOT IN (141,174);\n2.3 HAVING 中的子查询\n\n首先执行子查询。\n向主查询中的HAVING子句返回结果。\n\n题目：查询最低工资大于50号部门最低工资的部门id和其最低工资\nSELECT   department_id, MIN(salary)FROM     employeesGROUP BY department_idHAVING   MIN(salary) &gt;                       (SELECT MIN(salary)                        FROM   employees                        WHERE  department_id = 50);\n2.4 CASE中的子查询\n在CASE表达式中使用单列子查询：\n题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。\nSELECT employee_id, last_name,       (CASE department_id        WHEN             (SELECT department_id FROM departments\t      WHERE location_id = 1800)                   THEN 'Canada' ELSE 'USA' END) locationFROM   employees;\n2.5 子查询中的空值问题\nSELECT last_name, job_idFROM   employeesWHERE  job_id =                (SELECT job_id                 FROM   employees                 WHERE  last_name = 'Haas');\n\n子查询不返回任何行\n\n2.5 非法使用子查询\nSELECT employee_id, last_nameFROM   employeesWHERE  salary =                (SELECT   MIN(salary)                 FROM     employees                 GROUP BY department_id);\n\n多行子查询不能使用单行比较符\n\n3. 多行子查询\n\n也称为集合比较子查询\n内查询返回多行\n使用多行比较操作符\n\n3.1 多行比较操作符\n\n\n\n\n\n\n\n操作符\n含义\n\n\n\n\nIN\n等于列表中的任意一个\n\n\nANY\n需要和单行比较操作符一起使用，和子查询返回的某一个值比较\n\n\nALL\n需要和单行比较操作符一起使用，和子查询返回的所有值比较\n\n\nSOME\n实际上是ANY的别名，作用相同，一般常使用ANY\n\n\n\n\n体会 ANY 和 ALL 的区别\n\n3.2 代码示例\n题目：查询平均工资最低的部门id\n#方式1：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) = (\t\t\tSELECT MIN(avg_sal)\t\t\tFROM (\t\t\t\tSELECT AVG(salary) avg_sal\t\t\t\tFROM employees\t\t\t\tGROUP BY department_id\t\t\t\t) dept_avg_sal\t\t\t)\n#方式2：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &lt;= ALL (\t\t\t\tSELECT AVG(salary) avg_sal\t\t\t\tFROM employees\t\t\t\tGROUP BY department_id)\n3.3 空值问题\nSELECT last_nameFROM employeesWHERE employee_id NOT IN (\t\t\tSELECT manager_id\t\t\tFROM employees\t\t\t);\n4. 相关子查询\n4.1 相关子查询执行流程\n如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为关联子查询。\n相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。\n说明：子查询中使用主查询中的列\n4.2 代码示例\n题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id\n方式一：相关子查询\n\n\n1554992986225\n\n方式二：在 FROM 中使用子查询\nSELECT last_name,salary,e1.department_idFROM employees e1,(SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP BY department_id) e2WHERE e1.`department_id` = e2.department_idAND e2.dept_avg_sal &lt; e1.`salary`;\n\nfrom型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名，\n把它当成一张“临时的虚拟的表”来使用。\n\n在ORDER BY 中使用子查询：\n题目：查询员工的id,salary,按照department_name\n排序\nSELECT employee_id,salaryFROM employees eORDER BY (\t  SELECT department_name\t  FROM departments d\t  WHERE e.`department_id` = d.`department_id`\t);\n题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id\nSELECT e.employee_id, last_name,e.job_idFROM   employees e WHERE  2 &lt;= (SELECT COUNT(*)             FROM   job_history              WHERE  employee_id = e.employee_id);\n4.3 EXISTS 与 NOT EXISTS关键字\n\n关联子查询通常也会和\nEXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。\n如果在子查询中不存在满足条件的行：\n\n条件返回 FALSE\n继续在子查询中查找\n\n如果在子查询中存在满足条件的行：\n\n不在子查询中继续查找\n条件返回 TRUE\n\nNOT\nEXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。\n\n题目：查询公司管理者的employee_id，last_name，job_id，department_id信息\n方式一：\nSELECT employee_id, last_name, job_id, department_idFROM   employees e1WHERE  EXISTS ( SELECT *                 FROM   employees e2                 WHERE  e2.manager_id =                         e1.employee_id);\n方式二：自连接\nSELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_idFROM   employees e1 JOIN employees e2WHERE e1.employee_id = e2.manager_id;\n方式三：\nSELECT employee_id,last_name,job_id,department_idFROM employeesWHERE employee_id IN (\t\t     SELECT DISTINCT manager_id\t\t     FROM employees);\n题目：查询departments表中，不存在于employees表中的部门的department_id和department_name\nSELECT department_id, department_nameFROM departments dWHERE NOT EXISTS (SELECT 'X'                  FROM   employees                  WHERE  department_id = d.department_id);\n4.4 相关更新\nUPDATE table1 alias1SET    column = (SELECT expression                 FROM   table2 alias2                 WHERE  alias1.column = alias2.column);\n使用相关子查询依据一个表中的数据更新另一个表的数据。\n题目：在employees中增加一个department_name字段，数据为员工对应的部门名称\n# 1）ALTER TABLE employeesADD(department_name VARCHAR2(14));# 2）UPDATE employees eSET department_name =  (SELECT department_name \t                       FROM   departments d\t                       WHERE  e.department_id = d.department_id);\n4.4 相关删除\nDELETE FROM table1 alias1WHERE column operator (SELECT expression                       FROM   table2 alias2                       WHERE  alias1.column = alias2.column);\n使用相关子查询依据一个表中的数据删除另一个表的数据。\n题目：删除表employees中，其与emp_history表皆有的数据\nDELETE FROM employees eWHERE employee_id in             (SELECT employee_id            FROM   emp_history             WHERE  employee_id = e.employee_id);\n5. 抛一个思考题\n问题：谁的工资比Abel的高？\n解答：\n#方式1：自连接SELECT e2.last_name,e2.salaryFROM employees e1,employees e2WHERE e1.last_name = 'Abel'AND e1.`salary` &lt; e2.`salary`\n#方式2：子查询SELECT last_name,salaryFROM employeesWHERE salary &gt; (\t\tSELECT salary\t\tFROM employees\t\tWHERE last_name = 'Abel'\t\t);\n问题： 以上两种方式有好坏之分吗？\n解答： 自连接方式好！\n题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多\nDBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。\n可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分\nDBMS 中都对自连接处理进行了优化。\n","categories":["Database","SQL"],"tags":["SQL,Sub-Query"]},{"title":"SQL 排序与分页","url":"/2024/02/21/SQL-%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%A1%B5/","content":"常见的 SQL\n排序与分页方法详解，涵盖单列与多列排序、排序规则与执行顺序，MySQL 中使用\nLIMIT\n实现分页的原理与语法，并扩展介绍不同数据库系统中分页写法的差异与注意事项。\n\n1. 排序数据\n1.1 排序规则\n\n使用 ORDER BY 子句排序\n\nASC（ascend）: 升序\nDESC（descend）:降序\n\nORDER BY 子句在SELECT语句的结尾。\n\n1.2 单列排序\nSELECT   last_name, job_id, department_id, hire_dateFROM     employeesORDER BY hire_date ;\nSELECT   last_name, job_id, department_id, hire_dateFROM     employeesORDER BY hire_date DESC ;\nSELECT employee_id, last_name, salary*12 annsalFROM   employeesORDER BY annsal;\n1.3 多列排序\nSELECT last_name, department_id, salaryFROM   employeesORDER BY department_id, salary DESC;\n\n可以使用不在SELECT列表中的列排序。\n在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。\n\n2. 分页\n2.1 背景\n背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？\n背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？\n2.2 实现规则\n\n分页原理\n所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。\nMySQL中使用 LIMIT 实现分页\n格式：\nLIMIT [位置偏移量,] 行数\n第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。\n举例\n\n--前10条记录：SELECT * FROM 表名 LIMIT 0,10;或者SELECT * FROM 表名 LIMIT 10;--第11至20条记录：SELECT * FROM 表名 LIMIT 10,10;--第21至30条记录： SELECT * FROM 表名 LIMIT 20,10;\n\nMySQL 8.0中可以使用“LIMIT 3 OFFSET\n4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT\n4,3;”返回的结果相同。\n\n\n分页显式公式**：（当前页数-1）*每页条数，每页条数**\n\nSELECT * FROM table LIMIT(PageNo - 1)*PageSize,PageSize;\n\n注意：LIMIT 子句必须放在整个SELECT语句的最后！\n使用 LIMIT 的好处\n\n约束返回结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有\n1 条，就可以使用LIMIT 1，告诉 SELECT\n语句只需要返回一条记录即可。这样的好处就是 SELECT\n不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。\n2.3 拓展\n在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB\n和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。\n\n如果是 SQL Server 和 Access，需要使用 TOP\n关键字，比如：\n\nSELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC\n\n如果是\nDB2，使用FETCH FIRST 5 ROWS ONLY这样的关键字：\n\nSELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY\n\n如果是 Oracle，你需要基于 ROWNUM 来统计行数：\n\nSELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;\n需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max\n从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用\nSELECT rownum, last_name,salaryFROM (    SELECT last_name,salary    FROM employees    ORDER BY salary DESC)WHERE rownum &lt; 10;\n得到与上述方法一致的结果。\n","categories":["Database","SQL"],"tags":["SQL,Sort","SQL,Page"]},{"title":"SQL 变量 流程控制 游标","url":"/2024/02/22/SQL-%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E6%B8%B8%E6%A0%87/","content":"SQL\n中变量与流程控制机制，涵盖变量作用域与赋值、异常处理、分支与循环结构、游标操作，以及\nMySQL 8.0 的全局变量持久化特性，助力提升脚本健壮性与开发效率。\n\n1. 变量\n在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。\n在 MySQL\n数据库中，变量分为系统变量以及用户自定义变量。\n1.1 系统变量\n1.1.1 系统变量分类\n变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数的默认值，要么是配置文件（例如my.ini等）中的参数值。大家可以通过网址\nhttps://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html\n查看MySQL文档的系统变量。\n系统变量分为全局系统变量（需要添加global\n关键字）以及会话系统变量（需要添加 session\n关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在\nMySQL 服务实例运行期间它们的值不能使用 set\n动态修改）属于特殊的全局系统变量。\n每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：\n\n全局系统变量针对于所有会话（连接）有效，但不能跨重启\n会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。\n会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。\n\n在MySQL中有些系统变量只能是全局的，例如 max_connections\n用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如\ncharacter_set_client\n用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如\npseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。\n1.1.2 查看系统变量\n\n查看所有或部分系统变量\n\n#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;或SHOW VARIABLES;\n#查看满足条件的部分系统变量。SHOW GLOBAL VARIABLES LIKE '%标识符%';#查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE '%标识符%';\n举例：\nSHOW GLOBAL VARIABLES LIKE 'admin_%';\n\n查看指定系统变量\n\n作为 MySQL 编码规范，MySQL\n中的系统变量以两个“@”开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。\n#查看指定的系统变量的值SELECT @@global.变量名;#查看指定的会话变量的值SELECT @@session.变量名;#或者SELECT @@变量名;\n\n修改系统变量的值\n\n有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：\n方式1：修改MySQL配置文件，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）\n方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值\n#为某个系统变量赋值#方式1：SET @@global.变量名=变量值;#方式2：SET GLOBAL 变量名=变量值;#为某个会话变量赋值#方式1：SET @@session.变量名=变量值;#方式2：SET SESSION 变量名=变量值;\n举例：\nSELECT @@global.autocommit;SET GLOBAL autocommit=0;\nSELECT @@session.tx_isolation;SET @@session.tx_isolation='read-uncommitted';\nSET GLOBAL max_connections = 1000;SELECT @@global.max_connections;\n1.2 用户变量\n1.2.1 用户变量分类\n用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL\n中的用户变量以一个“@”开头。根据作用范围不同，又分为会话用户变量和局部变量。\n\n会话用户变量：作用域和会话变量一样，只对当前连接会话有效。\n局部变量：只在 BEGIN 和 END\n语句块中有效。局部变量只能在存储过程和函数中使用。\n\n1.2.2 会话用户变量\n\n变量的定义\n\n#方式1：“=”或“:=”SET @用户变量 = 值;SET @用户变量 := 值;#方式2：“:=” 或 INTO关键字SELECT @用户变量 := 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量  [FROM 等子句];\n\n查看用户变量的值 （查看、比较、运算等）\n\nSELECT @用户变量\n\n举例\n\nSET @a = 1;SELECT @a;\nSELECT @num := COUNT(*) FROM employees;SELECT @num;\nSELECT AVG(salary) INTO @avgsalary FROM employees;SELECT @avgsalary;\nSELECT @big;  #查看某个未声明的变量时，将得到NULL值\n1.2.3 局部变量\n定义：可以使用DECLARE语句定义一个局部变量\n作用域：仅仅在定义它的 BEGIN … END 中有效\n位置：只能放在 BEGIN … END 中，而且只能放在第一句\nBEGIN\t#声明局部变量\tDECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];\tDECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];\t#为局部变量赋值\tSET 变量名1 = 值;\tSELECT 值 INTO 变量名2 [FROM 子句];\t#查看局部变量的值\tSELECT 变量1,变量2,变量3;END\n1.定义变量\nDECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL\n举例：\nDECLARE　myparam　INT　DEFAULT 100;\n2.变量赋值\n方式1：一般用于赋简单的值\nSET 变量名=值;SET 变量名:=值;\n方式2：一般用于赋表中的字段值\nSELECT 字段名或表达式 INTO 变量名 FROM 表;\n3.使用变量（查看、比较、运算等）\nSELECT 局部变量名;\n举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary\nDELIMITER //CREATE PROCEDURE set_value()BEGIN\tDECLARE emp_name VARCHAR(25);\tDECLARE sal DOUBLE(10,2);\t\tSELECT last_name,salary INTO emp_name,sal\tFROM employees \tWHERE employee_id = 102;\t\tSELECT emp_name,sal;END //DELIMITER ;\n举例2：声明两个变量，求和并打印\n（分别使用会话用户变量、局部变量的方式实现）\n#方式1：使用用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;\n#方式2：使用局部变量DELIMITER //CREATE PROCEDURE add_value()BEGIN\t#局部变量\tDECLARE m INT DEFAULT 1;\tDECLARE n INT DEFAULT 3;\tDECLARE SUM INT;\t\tSET SUM = m+n;\tSELECT SUM;END //DELIMITER ;\n举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。\n#声明DELIMITER //CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)BEGIN\t#声明局部变量\tDECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;\tDECLARE mgr_id INT;\t\tSELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;\tSELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;\tSELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;\tSET dif_salary = mgr_sal - emp_sal;END //DELIMITER ;#调用SET @emp_id = 102;CALL different_salary(@emp_id,@diff_sal);#查看SELECT @diff_sal;\n1.2.4\n对比会话用户变量与局部变量\n\t\t\t  作用域\t\t\t\t\t定义位置\t\t\t\t  语法会话用户变量\t  当前会话\t\t\t\t   会话的任何地方\t\t\t\t加@符号，不用指定类型局部变量\t   定义它的BEGIN END中 \t\tBEGIN END的第一句话\t\t  一般不用加@,需要指定类型\n2. 定义条件与处理程序\n定义条件是事先定义程序执行过程中可能遇到的问题，处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。\n说明：定义条件和处理程序在存储过程、存储函数中都是支持的。\n2.1 案例分析\n案例分析：创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：\nDELIMITER //CREATE PROCEDURE UpdateDataNoCondition()\tBEGIN\t\tSET @x = 1;\t\tUPDATE employees SET email = NULL WHERE last_name = 'Abel';\t\tSET @x = 2;\t\tUPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';\t\tSET @x = 3;\tEND //DELIMITER ;\n调用存储过程：\nmysql&gt; CALL UpdateDataNoCondition();ERROR 1048 (23000): Column 'email' cannot be nullmysql&gt; SELECT @x;+------+| @x   |+------+|   1  |+------+1 row in set (0.00 sec)\n可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。\n2.2 定义条件\n定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和指定的错误条件关联起来。这个名字可以随后被用在定义处理程序的DECLARE HANDLER语句中。\n定义条件使用DECLARE语句，语法格式如下：\nDECLARE 错误名称 CONDITION FOR 错误码（或错误条件）\n错误码的说明：\n\nMySQL_error_code和sqlstate_value都可以表示MySQL的错误。\n\nMySQL_error_code是数值类型错误代码。\nsqlstate_value是长度为5的字符串类型错误代码。\n\n例如，在ERROR 1418\n(HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。\n例如，在ERROR\n1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。\n\n举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR\n1048 (23000)”对应。\n#使用MySQL_error_codeDECLARE Field_Not_Be_NULL CONDITION FOR 1048;#使用sqlstate_valueDECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';\n举例2：定义”ERROR\n1148(42000)“错误，名称为command_not_allowed。\n#使用MySQL_error_codeDECLARE command_not_allowed CONDITION FOR 1148;#使用sqlstate_valueDECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';\n2.3 定义处理程序\n可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：\nDECLARE 处理方式 HANDLER FOR 错误类型 处理语句\n\n处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。\n\nCONTINUE：表示遇到错误不处理，继续执行。\nEXIT：表示遇到错误马上退出。\nUNDO：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。\n\n错误类型（即条件）可以有如下取值：\n\nSQLSTATE '字符串错误码'：表示长度为5的sqlstate_value类型的错误代码；\nMySQL_error_code：匹配数值类型错误代码；\n错误名称：表示DECLARE …\nCONDITION定义的错误条件名称。\nSQLWARNING：匹配所有以01开头的SQLSTATE错误代码；\nNOT FOUND：匹配所有以02开头的SQLSTATE错误代码；\nSQLEXCEPTION：匹配所有没有被SQLWARNING或NOT\nFOUND捕获的SQLSTATE错误代码；\n\n处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“SET 变量 = 值”这样的简单语句，也可以是使用BEGIN ... END编写的复合语句。\n\n定义处理程序的几种方式，代码如下：\n#方法1：捕获sqlstate_valueDECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE';#方法2：捕获mysql_error_valueDECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';#方法3：先定义条件，再调用DECLARE no_such_table CONDITION FOR 1146;DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE';#方法4：使用SQLWARNINGDECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR';#方法5：使用NOT FOUNDDECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE';#方法6：使用SQLEXCEPTIONDECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';\n2.4 案例解决\n在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1。\nDELIMITER //CREATE PROCEDURE UpdateDataNoCondition()\tBEGIN\t\t#定义处理程序\t\tDECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;\t\t\t\tSET @x = 1;\t\tUPDATE employees SET email = NULL WHERE last_name = 'Abel';\t\tSET @x = 2;\t\tUPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';\t\tSET @x = 3;\tEND //DELIMITER ;\n调用过程：\nmysql&gt; CALL UpdateDataWithCondition();Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT @x,@proc_value;+------+-------------+| @x   | @proc_value |+------+-------------+|    3 |       \t -1  |+------+-------------+1 row in set (0.00 sec)\n举例：\n创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。\n在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。\n#准备工作CREATE TABLE departmentsASSELECT * FROM atguigudb.`departments`;ALTER TABLE departmentsADD CONSTRAINT uk_dept_name UNIQUE(department_id);\nDELIMITER //CREATE PROCEDURE InsertDataWithCondition()\tBEGIN\t\tDECLARE duplicate_entry CONDITION FOR SQLSTATE '23000' ;\t\tDECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;\t\t\t\tSET @x = 1;\t\tINSERT INTO departments(department_name) VALUES('测试');\t\tSET @x = 2;\t\tINSERT INTO departments(department_name) VALUES('测试');\t\tSET @x = 3;\tEND //DELIMITER ;\n调用存储过程：\nmysql&gt; CALL InsertDataWithCondition();Query OK, 0 rows affected (0.01 sec)mysql&gt; SELECT @x,@proc_value;+------+-------------+| @x   | @proc_value |+------+-------------+|    2 |       \t -1  |+------+-------------+1 row in set (0.00 sec)\n3. 流程控制\n解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL\n操作。流程控制语句的作用就是控制存储过程中 SQL\n语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：\n\n顺序结构：程序从上往下依次执行\n分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行\n循环结构：程序满足一定条件下，重复执行一组语句\n\n针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。\n\n条件判断语句：IF 语句和 CASE 语句\n循环语句：LOOP、WHILE 和 REPEAT 语句\n跳转语句：ITERATE 和 LEAVE 语句\n\n3.1 分支结构之 IF\n\nIF 语句的语法结构是：\n\nIF 表达式1 THEN 操作1[ELSEIF 表达式2 THEN 操作2]……[ELSE 操作N]END IF\n根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。\n\n特点：① 不同的表达式对应不同的操作 ② 使用在begin end中\n举例1：\nIF val IS NULL \tTHEN SELECT 'val is null';ELSE SELECT 'val is not null';END IF;\n举例2：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。\nDELIMITER //CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)BEGIN\tDECLARE emp_salary DOUBLE;\tDECLARE hire_year DOUBLE;\tSELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;\tSELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year\tFROM employees WHERE employee_id = emp_id;\tIF emp_salary &lt; 8000 AND hire_year &gt; 5\tTHEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;\tEND IF;END //DELIMITER ;\n举例3：声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。\nDELIMITER //CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)BEGIN\tDECLARE emp_salary DOUBLE;\tDECLARE hire_year DOUBLE;\tSELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;\tSELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year\tFROM employees WHERE employee_id = emp_id;\tIF emp_salary &lt; 8000 AND hire_year &gt; 5\t\tTHEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;\tELSE \t\tUPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;\tEND IF;END //DELIMITER ;\n举例4：声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。\nDELIMITER //CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)BEGIN\tDECLARE emp_salary DOUBLE;\tDECLARE bonus DECIMAL(3,2);\tSELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;\tSELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;\tIF emp_salary &lt; 9000\t\tTHEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;\tELSEIF emp_salary &lt; 10000 AND bonus IS NULL\t\tTHEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;\tELSE\t\tUPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;\tEND IF;END //DELIMITER ;\n\n3.2 分支结构之 CASE\nCASE 语句的语法结构1：\n#情况一：类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）\nCASE 语句的语法结构2：\n#情况二：类似于多重ifCASE WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）\n\n举例1：\n\n使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。\nCASE val　　　WHEN 1 THEN SELECT 'val is 1';　　　WHEN 2 THEN SELECT 'val is 2';　　　ELSE SELECT 'val is not 1 or 2';END CASE;\n\n举例2：\n\n使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。\nCASE\tWHEN val IS NULL THEN SELECT 'val is null';\tWHEN val &lt; 0 THEN SELECT 'val is less than 0';\tWHEN val &gt; 0 THEN SELECT 'val is greater than 0';\tELSE SELECT 'val is 0';END CASE;\n\n举例3：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。\n\nDELIMITER //CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)BEGIN\tDECLARE emp_sal DOUBLE;\tDECLARE bonus DECIMAL(3,2);\tSELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;\tSELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;\tCASE\tWHEN emp_sal&lt;9000\t\tTHEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;\tWHEN emp_sal&lt;10000 AND bonus IS NULL\t\tTHEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;\tELSE\t\tUPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;\tEND CASE;END //DELIMITER ;\n\n举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年，薪资涨300；如果是4年，薪资涨400；其他的涨薪500。\n\nDELIMITER //CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)BEGIN\tDECLARE emp_sal DOUBLE;\tDECLARE hire_year DOUBLE;\tSELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;\t\tSELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees WHERE employee_id = emp_id;\tCASE hire_year\t\tWHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;\t\tWHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;\t\tWHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;\t\tWHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;\t\tWHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;\t\tELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;\tEND CASE;END //DELIMITER ;\n3.3 循环结构之LOOP\nLOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。\nLOOP语句的基本格式如下：\n[loop_label:] LOOP\t循环执行的语句END LOOP [loop_label]\n其中，loop_label表示LOOP语句的标注名称，该参数可以省略。\n举例1：\n使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。\nDECLARE id INT DEFAULT 0;add_loop:LOOP\tSET id = id +1;\tIF id &gt;= 10 THEN LEAVE add_loop;\tEND IF;END LOOP add_loop;\n举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。\nDELIMITER //CREATE PROCEDURE update_salary_loop(OUT num INT)BEGIN\tDECLARE avg_salary DOUBLE;\tDECLARE loop_count INT DEFAULT 0;\t\tSELECT AVG(salary) INTO avg_salary FROM employees;\t\tlabel_loop:LOOP\t\tIF avg_salary &gt;= 12000 THEN LEAVE label_loop;\t\tEND IF;\t\t\t\tUPDATE employees SET salary = salary * 1.1;\t\tSET loop_count = loop_count + 1;\t\tSELECT AVG(salary) INTO avg_salary FROM employees;\tEND LOOP label_loop;\t\tSET num = loop_count;END //DELIMITER ;\n3.4 循环结构之WHILE\nWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：\n[while_label:] WHILE 循环条件  DO\t循环体END WHILE [while_label];\nwhile_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。\n举例1：\nWHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：\nDELIMITER //CREATE PROCEDURE test_while()BEGIN\t\tDECLARE i INT DEFAULT 0;\t\tWHILE i &lt; 10 DO\t\tSET i = i + 1;\tEND WHILE;\t\tSELECT i;END //DELIMITER ;#调用CALL test_while();\n举例2：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。\nDELIMITER //CREATE PROCEDURE update_salary_while(OUT num INT)BEGIN\tDECLARE avg_sal DOUBLE ;\tDECLARE while_count INT DEFAULT 0;\t\tSELECT AVG(salary) INTO avg_sal FROM employees;\t\tWHILE avg_sal &gt; 5000 DO\t\tUPDATE employees SET salary = salary * 0.9;\t\t\t\tSET while_count = while_count + 1;\t\t\t\tSELECT AVG(salary) INTO avg_sal FROM employees;\tEND WHILE;\t\tSET num = while_count;END //DELIMITER ;\n3.5 循环结构之REPEAT\nREPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT\n循环首先会执行一次循环，然后在 UNTIL\n中进行表达式的判断，如果满足条件就退出，即 END\nREPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。\nREPEAT语句的基本格式如下：\n[repeat_label:] REPEAT　　　　循环体的语句UNTIL 结束循环的条件表达式END REPEAT [repeat_label]\nrepeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。\n举例1：\nDELIMITER //CREATE PROCEDURE test_repeat()BEGIN\t\tDECLARE i INT DEFAULT 0;\t\tREPEAT \t\tSET i = i + 1;\tUNTIL i &gt;= 10\tEND REPEAT;\t\tSELECT i;END //DELIMITER ;\n举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。\nDELIMITER //CREATE PROCEDURE update_salary_repeat(OUT num INT)BEGIN\tDECLARE avg_sal DOUBLE ;\tDECLARE repeat_count INT DEFAULT 0;\t\tSELECT AVG(salary) INTO avg_sal FROM employees;\t\tREPEAT\t\tUPDATE employees SET salary = salary * 1.15;\t\t\t\tSET repeat_count = repeat_count + 1;\t\t\t\tSELECT AVG(salary) INTO avg_sal FROM employees;\tUNTIL avg_sal &gt;= 13000\tEND REPEAT;\t\tSET num = repeat_count;\t\tEND //DELIMITER ;\n对比三种循环结构：\n1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。\n2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行\nREPEAT：先执行后判断，无条件至少执行一次\n3.6 跳转语句之LEAVE语句\nLEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END\n包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把\nLEAVE 理解为 break。\n基本格式如下：\nLEAVE 标记名\n其中，label参数表示循环的标志。LEAVE和BEGIN …\nEND或循环一起被使用。\n举例1：创建存储过程\n“leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。\n\n如果num&lt;=0，则使用LEAVE语句退出BEGIN…END；\n如果num=1，则查询“employees”表的平均薪资；\n如果num=2，则查询“employees”表的最低薪资；\n如果num&gt;2，则查询“employees”表的最高薪资。\n\nIF语句结束后查询“employees”表的总人数。\nDELIMITER //CREATE PROCEDURE leave_begin(IN num INT)\tbegin_label: BEGIN\t\tIF num&lt;=0 \t\t\tTHEN LEAVE begin_label;\t\tELSEIF num=1 \t\t\tTHEN SELECT AVG(salary) FROM employees;\t\tELSEIF num=2 \t\t\tTHEN SELECT MIN(salary) FROM employees;\t\tELSE \t\t\tSELECT MAX(salary) FROM employees;\t\tEND IF;\t\t\t\tSELECT COUNT(*) FROM employees;\tEND //DELIMITER ;\n举例2：\n当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。\nDELIMITER //CREATE PROCEDURE leave_while(OUT num INT)BEGIN \t#\tDECLARE avg_sal DOUBLE;#记录平均工资\tDECLARE while_count INT DEFAULT 0; #记录循环次数\t\tSELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件\t\twhile_label:WHILE TRUE DO  #② 循环条件\t\t\t\t#③ 循环体\t\tIF avg_sal &lt;= 10000 THEN\t\t\tLEAVE while_label;\t\tEND IF;\t\t\t\tUPDATE employees SET salary  = salary * 0.9;\t\tSET while_count = while_count + 1;\t\t\t\t#④ 迭代条件\t\tSELECT AVG(salary) INTO avg_sal FROM employees;\t\tEND WHILE;\t\t#赋值\tSET num = while_count;END //DELIMITER ;\n3.7 跳转语句之ITERATE语句\nITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把\nITERATE 理解为 continue，意思为“再次循环”。\n语句基本格式如下：\nITERATE label\nlabel参数表示循环的标志。ITERATE语句必须跟在循环标志前面。\n举例： 定义局部变量num，初始值为0。循环结构中执行num\n+ 1操作。\n\n如果num &lt; 10，则继续执行循环；\n如果num &gt; 15，则退出循环结构；\n\nDELIMITER //CREATE PROCEDURE test_iterate()BEGIN\tDECLARE num INT DEFAULT 0;\t\tmy_loop:LOOP\t\tSET num = num + 1;\t\t\tIF num &lt; 10 \t\t\tTHEN ITERATE my_loop;\t\tELSEIF num &gt; 15 \t\t\tTHEN LEAVE my_loop;\t\tEND IF;\t\t\tSELECT '尚硅谷：让天下没有难学的技术';\t\tEND LOOP my_loop;END //DELIMITER ;\n4. 游标\n4.1 什么是游标（或光标）\n虽然我们也可以通过筛选条件 WHERE 和\nHAVING，或者是限定返回记录的关键字 LIMIT\n返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录，并对记录的数据进行处理。\n这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让\nSQL 这种面向集合的语言有了面向过程开发的能力。\n在 SQL\n中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作。\nMySQL中游标可以在存储过程和函数中使用。\n比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：\nSELECT employee_id,last_name,salary FROM employeesWHERE salary &gt; 15000;\n这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。\n4.2 使用游标步骤\n游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。\n如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS\n中，使用游标的语法可能略有不同。\n第一步，声明游标\n在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：\nDECLARE cursor_name CURSOR FOR select_statement; \n这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle\n或者 PostgreSQL，需要写成：\nDECLARE cursor_name CURSOR IS select_statement;\n要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里\nselect_statement 代表的是 SELECT\n语句，返回一个用于创建游标的结果集。\n比如：\nDECLARE cur_emp CURSOR FOR SELECT employee_id,salary FROM employees;\nDECLARE cursor_fruit CURSOR FOR SELECT f_name, f_price FROM fruits ;\n第二步，打开游标\n打开游标的语法如下：\nOPEN cursor_name\n当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候\nSELECT\n语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备。\nOPEN　cur_emp ;\n第三步，使用游标（从游标中取得数据）\n语法如下：\nFETCH cursor_name INTO var_name [, var_name] ...\n这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到\nvar_name\n这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在\nINTO 关键字后面赋值给多个变量名即可。\n注意：var_name必须在声明游标之前就定义好。\nFETCH　cur_emp INTO emp_id, emp_sal ;\n注意：游标的查询结果集中的字段数，必须跟 INTO\n后面的变量数一致，否则，在存储过程执行的时候，MySQL\n会提示错误。\n第四步，关闭游标\nCLOSE cursor_name\n有 OPEN 就会有\nCLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。\n关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。\nCLOSE　cur_emp;\n4.3 举例\n创建存储过程“get_count_by_limit_total_salary()”，声明IN参数\nlimit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。\nDELIMITER //CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)BEGIN\tDECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资\tDECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值\tDECLARE emp_count INT DEFAULT 0; #记录循环个数\t#定义游标\tDECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;\t#打开游标\tOPEN emp_cursor;\t\tREPEAT\t\t#使用游标（从游标中获取数据）\t\tFETCH emp_cursor INTO cursor_salary;\t\t\t\tSET sum_salary = sum_salary + cursor_salary;\t\tSET emp_count = emp_count + 1;\t\t\t\tUNTIL sum_salary &gt;= limit_total_salary\tEND REPEAT;\t\tSET total_count = emp_count;\t#关闭游标\tCLOSE emp_cursor;\tEND //DELIMITER ;\n4.5 小结\n游标是 MySQL\n的一个重要的功能，为逐条读取结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。\n但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源，造成内存不足，这是因为游标是在内存中进行的处理。\n建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。\n补充：MySQL\n8.0的新特性—全局变量的持久化\n在MySQL数据库中，全局变量可以通过SET\nGLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：\nSET GLOBAL MAX_EXECUTION_TIME=2000;\n使用SET\nGLOBAL语句设置的变量值只会临时生效。数据库重启后，服务器又会从MySQL配置文件中读取变量的默认值。\nMySQL\n8.0版本新增了SET PERSIST命令。例如，设置服务器的最大连接数为1000：\nSET PERSIST global max_connections = 1000;\nMySQL会将该命令的配置保存到数据目录下的mysqld-auto.cnf文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。\n举例：\n查看全局变量max_connections的值，结果如下：\nmysql&gt; show variables like '%max_connections%';+------------------------+-------+| Variable_name          | Value |+------------------------+-------+| max_connections        | 151   || mysqlx_max_connections | 100   |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)\n设置全局变量max_connections的值：\nmysql&gt; set persist max_connections=1000;Query OK, 0 rows affected (0.00 sec)\n重启MySQL服务器，再次查询max_connections的值：\nmysql&gt; show variables like '%max_connections%';+------------------------+-------+| Variable_name          | Value |+------------------------+-------+| max_connections        | 1000  || mysqlx_max_connections | 100   |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)\n","categories":["Database","SQL"],"tags":["SQL"]},{"title":"SQL 存储过程与存储函数","url":"/2024/02/22/SQL-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/","content":"简要介绍了 SQL 中存储过程与存储函数的定义、使用方法及常见示例\n\n1. 存储过程概述\n1.1 理解\n含义：存储过程的英文是\nStored Procedure。它的思想很简单，就是一组经过预先编译的\nSQL 语句的封装。\n执行过程：存储过程预先存储在 MySQL\n服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列\nSQL 语句全部执行。\n好处：\n1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力\n2、减少操作过程中的失误，提高效率\n3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）\n4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性\n和视图、函数的对比：\n它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的\nSQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。\n一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的。\n1.2 分类\n存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：\n1、没有参数（无参数无返回） 2、仅仅带 IN 类型（有参数无返回）\n3、仅仅带 OUT 类型（无参数有返回） 4、既带 IN 又带 OUT（有参数有返回）\n5、带 INOUT（有参数有返回）\n注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。\n2. 创建存储过程\n2.1 语法分析\n语法：\nCREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN\t存储过程体END\n类似于Java中的方法：\n修饰符 返回类型 方法名(参数类型 参数名,...){\t方法体;}\n说明：\n1、参数前面的符号的意思\n\nIN：当前参数为输入参数，也就是表示入参；\n存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是 IN，表示输入参数。\nOUT：当前参数为输出参数，也就是表示出参；\n执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。\nINOUT：当前参数既可以为输入参数，也可以为输出参数。\n\n2、形参类型可以是 MySQL数据库中的任意类型。\n3、characteristics\n表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：\nLANGUAGE SQL| [NOT] DETERMINISTIC| { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }| SQL SECURITY { DEFINER | INVOKER }| COMMENT 'string'\n\nLANGUAGE SQL：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。\n[NOT] DETERMINISTIC：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT\nDETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT\nDETERMINISTIC。\n{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。\n\nCONTAINS\nSQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；\nNO SQL表示当前存储过程的子程序中不包含任何SQL语句；\nREADS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；\nMODIFIES SQL\nDATA表示当前存储过程的子程序中包含写数据的SQL语句。\n默认情况下，系统会指定为CONTAINS SQL。\n\nSQL SECURITY { DEFINER | INVOKER }：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。\n\nDEFINER表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；\nINVOKER表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。\n如果没有设置相关的值，则MySQL默认指定值为DEFINER。\n\nCOMMENT 'string'：注释信息，可以用来描述存储过程。\n\n4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略\nBEGIN 和 END\n编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL\n语句。\n1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。3. SET：赋值语句，用于对变量进行赋值。4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。\n5、需要设置新的结束标记\nDELIMITER 新的结束标记\n因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。\n比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END\n//”结束存储过程。存储过程定义完毕之后再使用“DELIMITER\n;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。\n当使用DELIMITER命令时，应该避免使用反斜杠（‘’）字符，因为反斜线是MySQL的转义字符。\n示例：\nDELIMITER $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)[characteristics ...]BEGIN\tsql语句1;\tsql语句2;END $\n2.2 代码举例\n举例1：创建存储过程select_all_data()，查看 emps 表的所有数据\nDELIMITER $CREATE PROCEDURE select_all_data()BEGIN\tSELECT * FROM emps;\tEND $DELIMITER ;\n举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资\nDELIMITER //CREATE PROCEDURE avg_employee_salary ()BEGIN\tSELECT AVG(salary) AS avg_salary FROM emps;END //DELIMITER ;\n举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。\nCREATE PROCEDURE show_max_salary()\tLANGUAGE SQL\tNOT DETERMINISTIC\tCONTAINS SQL\tSQL SECURITY DEFINER\tCOMMENT '查看最高薪资'\tBEGIN\t\tSELECT MAX(salary) FROM emps;\tEND //DELIMITER ;\n举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出\nDELIMITER //CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)\tBEGIN\t\tSELECT MIN(salary) INTO ms FROM emps;\tEND //DELIMITER ;\n举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。\nDELIMITER //CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))\tBEGIN\t\tSELECT salary FROM emps WHERE ename = empname;\tEND //DELIMITER ;\n举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。\nDELIMITER //CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)\tBEGIN\t\tSELECT salary INTO empsalary FROM emps WHERE ename = empname;\tEND //DELIMITER ;\n举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。\nDELIMITER //CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))\tBEGIN\t\tSELECT ename INTO empname FROM emps\t\tWHERE eid = (SELECT MID FROM emps WHERE ename=empname);\tEND //DELIMITER ;\n3. 调用存储过程\n3.1 调用格式\n存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL\ndbname.procname。\nCALL 存储过程名(实参列表)\n格式：\n1、调用in模式的参数：\nCALL sp1('值');\n2、调用out模式的参数：\nSET @name;CALL sp1(@name);SELECT @name;\n3、调用inout模式的参数：\nSET @name=值;CALL sp1(@name);SELECT @name;\n3.2 代码举例\n举例1：\nDELIMITER //CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGIN\tSELECT COUNT(*) INTO num FROM fruits \tWHERE s_id = sid;END //DELIMITER ;\n调用存储过程：\nmysql&gt; CALL CountProc (101, @num);Query OK, 1 row affected (0.00 sec)\n查看返回结果：\nmysql&gt; SELECT @num;\n该存储过程返回了指定 s_id=101\n的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为3。\n举例2：创建存储过程，实现累加运算，计算 1+2+…+n\n等于多少。具体的代码如下：\nDELIMITER //CREATE PROCEDURE `add_num`(IN n INT)BEGIN       DECLARE i INT;       DECLARE sum INT;              SET i = 1;       SET sum = 0;       WHILE i &lt;= n DO              SET sum = sum + i;              SET i = i +1;       END WHILE;       SELECT sum;END //DELIMITER ;\n如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat\n会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。\n直接使用 CALL add_num(50);即可。这里我传入的参数为\n50，也就是统计 1+2+…+50 的积累之和。\n3.3 如何调试\n在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java\n等）那样有专门的集成开发环境。因此，你可以通过 SELECT\n语句，把程序执行的中间结果查询出来，来调试一个 SQL\n语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL\n语句之后，再调试下一个 SQL\n语句。这样逐步推进，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的\nSQL 语句复制出来，逐段单独调试。\n4. 存储函数的使用\n前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。\n4.1 语法分析\n学过的函数：LENGTH、SUBSTR、CONCAT等\n语法格式：\nCREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回值类型[characteristics ...]BEGIN\t函数体   #函数体中肯定有 RETURN 语句END\n说明：\n1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。\n2、RETURNS type 语句表示函数返回数据的类型；\nRETURNS子句只能对FUNCTION做指定，对函数而言这是强制的。它用来指定函数的返回类型，而且函数体必须包含一个RETURN value语句。\n3、characteristic\n创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。\n4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。\n4.2 调用存储函数\n在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的。\nSELECT 函数名(实参列表)\n4.3 代码举例\n举例1：\n创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。\nDELIMITER //CREATE FUNCTION email_by_name()RETURNS VARCHAR(25)DETERMINISTICCONTAINS SQLBEGIN\tRETURN (SELECT email FROM employees WHERE last_name = 'Abel');END //DELIMITER ;\n调用：\nSELECT email_by_name();\n举例2：\n创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。\nDELIMITER //CREATE FUNCTION email_by_id(emp_id INT)RETURNS VARCHAR(25)DETERMINISTICCONTAINS SQLBEGIN\tRETURN (SELECT email FROM employees WHERE employee_id = emp_id);END //DELIMITER ;\n调用：\nSET @emp_id = 102;SELECT email_by_id(102);\n举例3：\n创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。\nDELIMITER //CREATE FUNCTION count_by_id(dept_id INT)RETURNS INT\tLANGUAGE SQL\tNOT DETERMINISTIC\tREADS SQL DATA\tSQL SECURITY DEFINER\tCOMMENT '查询部门平均工资'BEGIN\tRETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);\tEND //DELIMITER ;\n调用：\nSET @dept_id = 50;SELECT count_by_id(@dept_id);\n注意：\n若在创建存储函数中报错“you might want to use the less safe log_bin_trust_function_creators variable”，有两种处理方法：\n\n方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL |\nNO SQL | READS SQL DATA | MODIFIES SQL DATA}”\n方式2：\n\nmysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;\n4.4 对比存储函数和存储过程\n\n\n\n\n\n\n\n\n\n\n\n关键字\n调用语法\n返回值\n应用场景\n\n\n\n\n存储过程\nPROCEDURE\nCALL 存储过程()\n理解为有0个或多个\n一般用于更新\n\n\n存储函数\nFUNCTION\nSELECT 函数()\n只能是一个\n一般用于查询结果为一个值并返回时\n\n\n\n此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。\n5.\n存储过程和函数的查看、修改、删除\n5.1 查看\n创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？\nMySQL存储了存储过程和函数的状态信息，用户可以使用SHOW\nSTATUS语句或SHOW\nCREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。\n1. 使用SHOW\nCREATE语句查看存储过程和函数的创建信息\n基本语法结构如下：\nSHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名\n举例：\nSHOW CREATE FUNCTION test_db.CountProc \\G\n2. 使用SHOW\nSTATUS语句查看存储过程和函数的状态信息\n基本语法结构如下：\nSHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']\n这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。\n[LIKE\n‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。\n举例：SHOW STATUS语句示例，代码如下：\nmysql&gt; SHOW PROCEDURE STATUS LIKE 'SELECT%' \\G *************************** 1. row ***************************                  Db: test_db                Name: SelectAllData                Type: PROCEDURE             Definer: root@localhost            Modified: 2021-10-16 15:55:07             Created: 2021-10-16 15:55:07       Security_type: DEFINER             Comment: character_set_client: utf8mb4collation_connection: utf8mb4_general_ci  Database Collation: utf8mb4_general_ci1 row in set (0.00 sec)\n3.\n从information_schema.Routines表中查看存储过程和函数的信息\nMySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：\nSELECT * FROM information_schema.RoutinesWHERE ROUTINE_NAME='存储过程或函数的名' [AND ROUTINE_TYPE = {'PROCEDURE|FUNCTION'}];\n说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。\n举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：\nSELECT * FROM information_schema.RoutinesWHERE ROUTINE_NAME='count_by_id'　AND　ROUTINE_TYPE = 'FUNCTION' \\G\n5.2 修改\n修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。\nALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]\n其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。\n{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }| SQL SECURITY { DEFINER | INVOKER }| COMMENT 'string'\n\nCONTAINS SQL，表示子程序包含SQL语句，但不包含读或写数据的语句。\nNO SQL，表示子程序中不包含SQL语句。\nREADS SQL DATA，表示子程序中包含读数据的语句。\nMODIFIES SQL DATA，表示子程序中包含写数据的语句。\nSQL SECURITY { DEFINER | INVOKER }，指明谁有权限来执行。\n\nDEFINER，表示只有定义者自己才能够执行。\nINVOKER，表示调用者可以执行。\n\nCOMMENT 'string'，表示注释信息。\n\n\n修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER\nFUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。\n\n举例1：\n修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL\nDATA，并指明调用者可以执行，代码如下：\nALTER　PROCEDURE　CountProcMODIFIES SQL DATASQL SECURITY INVOKER ;\n查询修改后的信息：\nSELECT specific_name,sql_data_access,security_typeFROM information_schema.`ROUTINES`WHERE routine_name = 'CountProc' AND routine_type = 'PROCEDURE';\n结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_\nACCESS）已经变成MODIFIES SQL\nDATA，安全类型（SECURITY_TYPE）已经变成INVOKER。\n举例2：\n修改存储函数CountProc的定义。将读写权限改为READS SQL\nDATA，并加上注释信息“FIND NAME”，代码如下：\nALTER　FUNCTION　CountProcREADS SQL DATACOMMENT 'FIND NAME' ;\n存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS\nSQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。\n5.3 删除\n删除存储过程和函数，可以使用DROP语句，其语法结构如下：\nDROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名\nIF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW\nWARNINGS查看的警告。\n举例：\nDROP PROCEDURE CountProc;\nDROP FUNCTION CountProc;\n6. 关于存储过程使用的争议\n尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？\n6.1 优点\n1、存储过程可以一次编译多次使用。存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了\nSQL 的执行效率。\n2、可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。\n3、存储过程的安全性强。我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。\n4、可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。\n5、良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的\nSQL\n语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。\n6.2 缺点\n基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM\n等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？\n\n阿里开发规范\n【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。\n\n存储过程虽然有诸如上面的好处，但缺点也是很明显的。\n1、可移植性差。存储过程不能跨数据库移植，比如在\nMySQL、Oracle 和 SQL Server\n里编写的存储过程，在换成其他数据库时都需要重新编写。\n2、调试困难。只有少数 DBMS\n支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。\n3、存储过程的版本管理很困难。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。\n4、它不适合高并发的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。\n小结：\n存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。\n","categories":["Database","SQL"],"tags":["SQL,存储过程","SQL,存储函数"]},{"title":"SSM: Spring & SpringMVC & MyBatis 手动整合","url":"/2024/07/09/SSM-Spring-SpringMVC-MyBatis-%E6%89%8B%E5%8A%A8%E6%95%B4%E5%90%88/","content":"SSM 手动整合演练涵盖从引入 mybatis-spring-boot-starter 依赖、数据源与\nMyBatis 配置、CRUD 编写，到 SpringBoot\n自动配置原理解析、自动配置生效类调试，以及扩展第三方数据源（如\nDruid）等全流程，帮助快速搭建稳定的 Spring + SpringMVC + MyBatis\n数据访问架构。\n\n整合SSM场景\nSpringBoot 整合\nSpring、SpringMVC、MyBatis\n进行数据访问场景开发\n1. 创建SSM整合项目\n&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;\n2. 配置数据源\nspring.datasource.url=jdbc:mysql://192.168.200.100:3306/demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.type=com.zaxxer.hikari.HikariDataSource\n安装MyBatisX 插件，帮我们生成Mapper接口的xml文件即可\n3. 配置MyBatis\n#指定mapper映射文件位置mybatis.mapper-locations=classpath:/mapper/*.xml#参数项调整mybatis.configuration.map-underscore-to-camel-case=true\n4. CRUD编写\n\n编写Bean\n编写Mapper\n使用mybatisx插件，快速生成MapperXML\n测试CRUD\n\n5. 自动配置原理\nSSM整合总结：\n\n导入mybatis-spring-boot-starter\n配置数据源信息\n配置mybatis的mapper接口扫描与xml映射文件扫描\n编写bean，mapper，生成xml，编写sql 进行crud。\n事务等操作依然和Spring中用法一样\n效果：\n\n所有sql写在xml中\n所有mybatis配置写在application.properties下面\n\n\n\njdbc场景的自动配置：\n\nmybatis-spring-boot-starter导入\nspring-boot-starter-jdbc\nJdbc场景的几个自动配置\n\norg.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n\n数据源的自动配置 -\n所有和数据源有关的配置都绑定在DataSourceProperties -\n默认使用 HikariDataSource\n\norg.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration\n\n给容器中放了JdbcTemplate操作数据库\n\norg.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration\norg.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration\n\n基于XA二阶提交协议的分布式事务数据源\n\norg.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration\n\n支持事务\n\n\n具有的底层能力：数据源、JdbcTemplate、事务\n\nMyBatisAutoConfiguration：配置了MyBatis的整合流程\n\nmybatis-spring-boot-starter导入\nmybatis-spring-boot-autoconfigure（mybatis的自动配置包），\n默认加载两个自动配置类：\n\norg.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration\norg.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration\n\n必须在数据源配置好之后才配置\n\n给容器中SqlSessionFactory组件。创建和数据库的一次会话\n给容器中SqlSessionTemplate组件。操作数据库\n\n\n\nMyBatis的所有配置绑定在MybatisProperties\n每个Mapper接口的代理对象是怎么创建放到容器中。详见@MapperScan原理：\n\n利用@Import(MapperScannerRegistrar.class)批量给容器中注册组件。解析指定的包路径里面的每一个类，为每一个Mapper接口类，创建Bean定义信息，注册到容器中。\n\n\n\n\n如何分析哪个场景导入以后，开启了哪些自动配置类。\n找：classpath:/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中配置的所有值，就是要开启的自动配置类，但是每个类可能有条件注解，基于条件注解判断哪个自动配置类生效了。\n\n6. 快速定位生效的配置\n#开启调试模式，详细打印开启了哪些自动配置debug=true# Positive（生效的自动配置）  Negative（不生效的自动配置）\n7. 扩展：整合其他数据源\n1. Druid 数据源\n暂不支持 SpringBoot3\n\n导入druid-starter\n写配置\n分析自动配置了哪些东西，怎么用\n\nDruid官网：https://github.com/alibaba/druid\n#数据源基本配置spring.datasource.url=jdbc:mysql://192.168.200.100:3306/demospring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.username=rootspring.datasource.password=123456spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# 配置StatFilter监控spring.datasource.druid.filter.stat.enabled=truespring.datasource.druid.filter.stat.db-type=mysqlspring.datasource.druid.filter.stat.log-slow-sql=truespring.datasource.druid.filter.stat.slow-sql-millis=2000# 配置WallFilter防火墙spring.datasource.druid.filter.wall.enabled=truespring.datasource.druid.filter.wall.db-type=mysqlspring.datasource.druid.filter.wall.config.delete-allow=falsespring.datasource.druid.filter.wall.config.drop-table-allow=false# 配置监控页，内置监控页面的首页是 /druid/index.htmlspring.datasource.druid.stat-view-servlet.enabled=truespring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=adminspring.datasource.druid.stat-view-servlet.allow=*# 其他 Filter 配置不再演示# 目前为以下 Filter 提供了配置支持，请参考文档或者根据IDE提示（spring.datasource.druid.filter.*）进行配置。# StatFilter# WallFilter# ConfigFilter# EncodingConvertFilter# Slf4jLogFilter# Log4jFilter# Log4j2Filter# CommonsLogFilter\n附录：示例数据库\nCREATE TABLE `t_user`(    `id`         BIGINT(20)   NOT NULL AUTO_INCREMENT COMMENT '编号',    `login_name` VARCHAR(200) NULL DEFAULT NULL COMMENT '用户名称' COLLATE 'utf8_general_ci',    `nick_name`  VARCHAR(200) NULL DEFAULT NULL COMMENT '用户昵称' COLLATE 'utf8_general_ci',    `passwd`     VARCHAR(200) NULL DEFAULT NULL COMMENT '用户密码' COLLATE 'utf8_general_ci',    PRIMARY KEY (`id`));insert into t_user(login_name, nick_name, passwd) VALUES ('zhangsan','张三','123456');\n","categories":["后端","Spring"],"tags":["MyBatis","SpringMVC"]},{"title":"SQL 约束","url":"/2024/02/22/SQL-%E7%BA%A6%E6%9D%9F/","content":"常见的 SQL 约束汇总，包括 NOT NULL、UNIQUE、PRIMARY\nKEY、AUTO_INCREMENT、FOREIGN KEY、CHECK 和 DEFAULT\n的定义、使用场景与示例。\n\n1. 约束(constraint)概述\n1.1 为什么需要约束\n数据完整性（Data\nIntegrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。\n为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：\n\n实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录\n域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女”\n引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门\n用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。\n\n1.2 什么是约束\n约束是表级的强制规定。\n可以在创建表时规定约束（通过 CREATE TABLE\n语句），或者在表创建之后通过 ALTER TABLE\n语句规定约束。\n1.3 约束的分类\n\n根据约束数据列的限制，约束可分为：\n\n单列约束：每个约束只约束一列\n多列约束：每个约束可约束多列数据\n\n根据约束的作用范围，约束可分为：\n\n列级约束：只能作用在一个列上，跟在列的定义后面\n表级约束：可以作用在多个列上，不与列一起，而是单独定义\n\n\n\t\t\t位置\t\t\t支持的约束类型\t\t\t\t\t是否可以起约束名列级约束：\t列的后面\t\t语法都支持，但外键没有效果\t\t不可以表级约束：\t所有列的下面\t   默认和非空不支持，其他支持\t   可以（主键没有效果）\n\n根据约束起的作用，约束可分为：\n\nNOT NULL\n非空约束，规定某个字段不能为空\nUNIQUE\n唯一约束，规定某个字段在整个表中是唯一的\nPRIMARY KEY 主键(非空且唯一)约束\nFOREIGN KEY 外键约束\nCHECK 检查约束\nDEFAULT 默认值约束\n\n\n\n注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果\n\n\n查看某个表已有的约束\n\n#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';\n2. 非空约束\n2.1 作用\n限定某个字段/某列的值不允许为空\n2.2 关键字\nNOT NULL\n2.3 特点\n\n默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型\n非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空\n一个表可以有很多列都分别限定了非空\n空字符串’’不等于NULL，0也不等于NULL\n\n2.4 添加非空约束\n（1）建表时\nCREATE TABLE 表名称(\t字段名  数据类型,    字段名  数据类型 NOT NULL,      字段名  数据类型 NOT NULL);\n举例：\nCREATE TABLE emp(id INT(10) NOT NULL,NAME VARCHAR(20) NOT NULL,sex CHAR NULL);\nCREATE TABLE student(\tsid int,    sname varchar(20) not null,    tel char(11) ,    cardid char(18) not null);\ninsert into student values(1,'张三','13710011002','110222198912032545'); #成功insert into student values(2,'李四','13710011002',null);#身份证号为空ERROR 1048 (23000): Column 'cardid' cannot be nullinsert into student values(2,'李四',null,'110222198912032546');#成功，tel允许为空insert into student values(3,null,null,'110222198912032547');#失败ERROR 1048 (23000): Column 'sname' cannot be null\n（2）建表后\nalter table 表名称 modify 字段名 数据类型 not null;\n举例：\nALTER TABLE empMODIFY sex VARCHAR(30) NOT NULL;\nalter table student modify sname varchar(20) not null;\n2.5 删除非空约束\nalter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空或 alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空\n3. 唯一性约束\n3.1 作用\n用来限制某个字段/某列的值不能重复。\n3.2 关键字\nUNIQUE\n3.3 特点\n\n同一个表可以有多个唯一约束。\n唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。\n唯一性约束允许列值为空。\n在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。\nMySQL会给唯一约束的列上默认创建一个唯一索引。\n\n3.4 添加唯一约束\n（1）建表时\ncreate table 表名称(\t字段名  数据类型,    字段名  数据类型  unique,      字段名  数据类型  unique key,    字段名  数据类型);create table 表名称(\t字段名  数据类型,    字段名  数据类型,      字段名  数据类型,    [constraint 约束名] unique key(字段名));\n举例：\ncreate table student(\tsid int,    sname varchar(20),    tel char(11) unique,    cardid char(18) unique key);\nCREATE TABLE t_course(\tcid INT UNIQUE,\tcname VARCHAR(100) UNIQUE,\tdescription VARCHAR(200));\nCREATE TABLE USER( id INT NOT NULL, NAME VARCHAR(25), PASSWORD VARCHAR(16), -- 使用表级约束语法 CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD));\n\n表示用户名和密码组合不能重复\n\ninsert into student values(1,'张三','13710011002','101223199012015623');insert into student values(2,'李四','13710011003','101223199012015624');\nmysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel         | cardid             |+-----+-------+-------------+--------------------+|   1 | 张三  | 13710011002 | 101223199012015623 ||   2 | 李四  | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)\ninsert into student values(3,'王五','13710011004','101223199012015624'); #身份证号重复ERROR 1062 (23000): Duplicate entry '101223199012015624' for key 'cardid'insert into student values(3,'王五','13710011003','101223199012015625'); ERROR 1062 (23000): Duplicate entry '13710011003' for key 'tel'\n（2）建表后指定唯一键约束\n#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的#方式1：alter table 表名称 add unique key(字段列表); \n#方式2：alter table 表名称 modify 字段名 字段类型 unique;\n举例：\nALTER TABLE USER ADD UNIQUE(NAME,PASSWORD);\nALTER TABLE USER ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);\nALTER TABLE USER MODIFY NAME VARCHAR(20) UNIQUE;\n举例：\ncreate table student(\tsid int primary key,    sname varchar(20),    tel char(11) ,    cardid char(18) );\nalter table student add unique key(tel);alter table student add unique key(cardid);\n3.5 关于复合唯一约束\ncreate table 表名称(\t字段名  数据类型,    字段名  数据类型,      字段名  数据类型,    unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的);\n#学生表create table student(\tsid int,\t#学号    sname varchar(20),\t\t\t#姓名    tel char(11) unique key,  #电话    cardid char(18) unique key #身份证号);#课程表create table course(\tcid int,  #课程编号    cname varchar(20)     #课程名称);#选课表create table student_course(    id int,\tsid int,    cid int,    score int,    unique key(sid,cid)  #复合唯一);\ninsert into student values(1,'张三','13710011002','101223199012015623');#成功insert into student values(2,'李四','13710011003','101223199012015624');#成功insert into course values(1001,'Java'),(1002,'MySQL');#成功\nmysql&gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel         | cardid             |+-----+-------+-------------+--------------------+|   1 | 张三  | 13710011002 | 101223199012015623 ||   2 | 李四  | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid  | cname |+------+-------+| 1001 | Java  || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)\ninsert into student_course values(1, 1, 1001, 89),(2, 1, 1002, 90),(3, 2, 1001, 88),(4, 2, 1002, 56);#成功\nmysql&gt; select * from student_course;+----+------+------+-------+| id | sid  | cid  | score |+----+------+------+-------+|  1 |    1 | 1001 |    89 ||  2 |    1 | 1002 |    90 ||  3 |    2 | 1001 |    88 ||  4 |    2 | 1002 |    56 |+----+------+------+-------+4 rows in set (0.00 sec)\ninsert into student_course values (5, 1, 1001, 88);#失败#ERROR 1062 (23000): Duplicate entry '1-1001' for key 'sid'   违反sid-cid的复合唯一\n3.5 删除唯一约束\n\n添加唯一性约束的列上也会自动创建唯一索引。\n删除唯一约束只能通过删除唯一索引的方式删除。\n删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。\n如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。\n\nSELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; #查看都有哪些约束\nALTER TABLE USER DROP INDEX uk_name_pwd;\n\n注意：可以通过 show index from 表名称;查看表的索引\n\n4. PRIMARY KEY 约束\n4.1 作用\n用来唯一标识表中的一行记录。\n4.2 关键字\nprimary key\n4.3 特点\n\n主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。\n一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。\n主键约束对应着表中的一列或者多列（复合主键）\n如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。\nMySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。\n当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。\n需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。\n\n4.4 添加主键约束\n（1）建表时指定主键约束\ncreate table 表名称(\t字段名  数据类型  primary key, #列级模式    字段名  数据类型,      字段名  数据类型  );create table 表名称(\t字段名  数据类型,    字段名  数据类型,      字段名  数据类型,    [constraint 约束名] primary key(字段名) #表级模式);\n举例：\ncreate table temp(\tid int primary key,    name varchar(20));\nmysql&gt; desc temp;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\ninsert into temp values(1,'张三');#成功insert into temp values(2,'李四');#成功\nmysql&gt; select * from temp;+----+------+| id | name |+----+------+|  1 | 张三 ||  2 | 李四 |+----+------+2 rows in set (0.00 sec)\ninsert into temp values(1,'张三');#失败ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） '1' for key 'PRIMARY'insert into temp values(1,'王五');#失败ERROR 1062 (23000): Duplicate entry '1' for key 'PRIMARY'insert into temp values(3,'张三');#成功\nmysql&gt; select * from temp;+----+------+| id | name |+----+------+|  1 | 张三 ||  2 | 李四 ||  3 | 张三 |+----+------+3 rows in set (0.00 sec)\ninsert into temp values(4,null);#成功insert into temp values(null,'李琦');#失败ERROR 1048 (23000): Column 'id' cannot be null\nmysql&gt; select * from temp;+----+------+| id | name |+----+------+|  1 | 张三 ||  2 | 李四 ||  3 | 张三 ||  4 | NULL |+----+------+4 rows in set (0.00 sec)\n#演示一个表建立两个主键约束create table temp(\tid int primary key,    name varchar(20) primary key);ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）\n再举例：\n\n列级约束\n\nCREATE TABLE emp4(id INT PRIMARY KEY AUTO_INCREMENT ,NAME VARCHAR(20));\n\n表级约束\n\nCREATE TABLE emp5(id INT NOT NULL AUTO_INCREMENT,NAME VARCHAR(20),pwd VARCHAR(15),CONSTRAINT emp5_id_pk PRIMARY KEY(id));\n（2）建表后增加主键约束\nALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键\nALTER TABLE student ADD PRIMARY KEY (sid);\nALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);\n4.5 关于复合主键\ncreate table 表名称(\t字段名  数据类型,    字段名  数据类型,      字段名  数据类型,    primary key(字段名1,字段名2)  #表示字段1和字段2的组合是唯一的，也可以有更多个字段);\n#学生表create table student(\tsid int primary key,  #学号    sname varchar(20)     #学生姓名);#课程表create table course(\tcid int primary key,  #课程编号    cname varchar(20)     #课程名称);#选课表create table student_course(\tsid int,    cid int,    score int,    primary key(sid,cid)  #复合主键);\ninsert into student values(1,'张三'),(2,'李四');insert into course values(1001,'Java'),(1002,'MySQL');\nmysql&gt; select * from student;+-----+-------+| sid | sname |+-----+-------+|   1 | 张三  ||   2 | 李四  |+-----+-------+2 rows in set (0.00 sec)mysql&gt; select * from course;+------+-------+| cid  | cname |+------+-------+| 1001 | Java  || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)\ninsert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);\nmysql&gt; select * from student_course;+-----+------+-------+| sid | cid  | score |+-----+------+-------+|   1 | 1001 |    89 ||   1 | 1002 |    90 ||   2 | 1001 |    88 ||   2 | 1002 |    56 |+-----+------+-------+4 rows in set (0.00 sec)\ninsert into student_course values(1, 1001, 100);ERROR 1062 (23000): Duplicate entry '1-1001' for key 'PRIMARY'\nmysql&gt; desc student_course;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| sid   | int(11) | NO   | PRI | NULL    |       || cid   | int(11) | NO   | PRI | NULL    |       || score | int(11) | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec)\n\n再举例\n\nCREATE TABLE emp6(id INT NOT NULL,NAME VARCHAR(20),pwd VARCHAR(15),CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd));\n4.6 删除主键约束\nalter table 表名称 drop primary key;\n举例：\nALTER TABLE student DROP PRIMARY KEY;\nALTER TABLE emp5 DROP PRIMARY KEY;\n\n说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。\n\n5. 自增列：AUTO_INCREMENT\n5.1 作用\n某个字段的值自增\n5.2 关键字\nauto_increment\n5.3 特点和要求\n（1）一个表最多只能有一个自增长列\n（2）当需要产生唯一标识符或顺序值时，可设置自增长\n（3）自增长列约束的列必须是键列（主键列，唯一键列）\n（4）自增约束的列的数据类型必须是整数类型\n（5）如果自增列指定了 0 和\nnull，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。\n错误演示：\ncreate table employee(\teid int auto_increment,    ename varchar(20));# ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key   \ncreate table employee(\teid int primary key,    ename varchar(20) unique key auto_increment);# ERROR 1063 (42000): Incorrect column specifier for column 'ename'  因为ename不是整数类型\n5.4 如何指定自增约束\n（1）建表时\ncreate table 表名称(\t字段名  数据类型  primary key auto_increment,    字段名  数据类型  unique key not null,      字段名  数据类型  unique key,    字段名  数据类型  not null default 默认值, );create table 表名称(\t字段名  数据类型 default 默认值 ,    字段名  数据类型 unique key auto_increment,      字段名  数据类型 not null default 默认值,,    primary key(字段名));\ncreate table employee(\teid int primary key auto_increment,    ename varchar(20));\nmysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| eid   | int(11)     | NO   | PRI | NULL    | auto_increment || ename | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)\n（2）建表后\nalter table 表名称 modify 字段名 数据类型 auto_increment;\n例如：\ncreate table employee(\teid int primary key ,    ename varchar(20));\nalter table employee modify eid int auto_increment;\nmysql&gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| eid   | int(11)     | NO   | PRI | NULL    | auto_increment || ename | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)\n5.5 如何删除自增约束\n#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除\nalter table employee modify eid int;\nmysql&gt; desc employee;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| eid   | int(11)     | NO   | PRI | NULL    |       || ename | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\n5.6 MySQL\n8.0新特性—自增变量的持久化\n在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary\nkey)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary\nkey)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。\n下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL\n5.7版本中，测试步骤如下：\n创建的数据表中包含自增主键的id字段，语句如下：\nCREATE TABLE test1(id INT PRIMARY KEY AUTO_INCREMENT);\n插入4个空值，执行如下：\nINSERT INTO test1VALUES(0),(0),(0),(0);\n查询数据表test1中的数据，结果如下：\nmysql&gt; SELECT * FROM test1;+----+| id |+----+|  1 ||  2 ||  3 ||  4 |+----+4 rows in set (0.00 sec)\n删除id为4的记录，语句如下：\nDELETE FROM test1 WHERE id = 4;\n再次插入一个空值，语句如下：\nINSERT INTO test1 VALUES(0);\n查询此时数据表test1中的数据，结果如下：\nmysql&gt; SELECT * FROM test1;+----+| id |+----+|  1 ||  2 ||  3 ||  5 |+----+4 rows in set (0.00 sec)\n从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。\n删除id为5的记录，结果如下：\nDELETE FROM test1 where id=5;\n重启数据库，重新插入一个空值。\nINSERT INTO test1 values(0);\n再次查询数据表test1中的数据，结果如下：\nmysql&gt; SELECT * FROM test1;+----+| id |+----+|  1 ||  2 ||  3 ||  4 |+----+4 rows in set (0.00 sec)\n从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。\n在MySQL\n5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。\n在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：\nmysql&gt; SELECT * FROM test1;+----+| id |+----+|  1 ||  2 ||  3 ||  6 |+----+4 rows in set (0.00 sec)\n从结果可以看出，自增变量已经持久化了。\nMySQL\n8.0将自增主键的计数器持久化到重做日志中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。\n6. FOREIGN KEY 约束\n6.1 作用\n限定某个表的某个字段的引用完整性。\n比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。\n6.2 关键字\nFOREIGN KEY\n6.3 主表和从表/父表和子表\n主表（父表）：被引用的表，被参考的表\n从表（子表）：引用别人的表，参考别人的表\n例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。\n例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。\n6.4 特点\n（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列\n​ 为什么？因为被依赖/被参考的值必须是唯一的\n（2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如\nstudent_ibfk_1;），也可以指定外键约束名。\n（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表\n（4）删表时，先删从表（或先删除外键约束），再删除主表\n（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据\n（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束\n（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR\n1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。\n​ 例如：都是表示部门编号，都是int类型。\n（8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）\n（9）删除外键约束后，必须手动删除对应的索引\n6.5 添加外键约束\n（1）建表时\ncreate table 主表名称(\t字段1  数据类型  primary key,    字段2  数据类型);create table 从表名称(\t字段1  数据类型  primary key,    字段2  数据类型,    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列\ncreate table dept( #主表\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(#从表\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did)   #在从表中指定外键约束    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);说明：（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。（2）删除表时，先删除从表emp，再删除主表dept\n（2）建表后\n一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。\n格式：\nALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];\n举例：\nALTER TABLE emp1ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);\n举例：\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int\t\t\t\t#员工所在的部门);#这两个表创建时，没有指定外键的话，那么创建顺序是随意\nalter table emp add foreign key (deptid) references dept(did);\n6.6 演示问题\n（1）失败：不是键列\ncreate table dept(\tdid int ,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是dept的did不是键列\n（2）失败：数据类型不一致\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid char,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致\n（3）成功，两个表字段名一样\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    did int,\t\t\t\t#员工所在的部门    foreign key (did) references dept(did)      #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号    #是否重名没问题，因为两个did在不同的表中);\n（4）添加、删除、修改问题\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did)      #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);\ninsert into dept values(1001,'教学部');insert into dept values(1003, '财务部');insert into emp values(1,'张三',1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门insert into emp values(2,'李四',1005);#添加从表记录失败ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门\nmysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部  || 1003 | 财务部  |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三   |   1001 |+-----+-------+--------+1 row in set (0.00 sec)\nupdate emp set deptid = 1002 where eid = 1;#修改从表失败 ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002update dept set did = 1002 where did = 1001;#修改主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。update dept set did = 1002 where did = 1003;#修改主表成功  因为部门表的1003部门没有被emp表引用，所以可以修改\ndelete from dept where did=1001; #删除主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除\n总结：约束关系是针对双方的\n\n添加了外键约束后，主表的修改和删除数据受约束\n添加了外键约束后，从表的添加和修改数据受约束\n在从表上建立外键，要求主表必须存在\n删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除\n\n6.7 约束等级\n\nCascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录\nSet null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not\nnull\nNo action方式：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作\nRestrict方式：同no action，\n都是立即检查外键约束\nSet default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别\n\n如果没有指定等级，就相当于Restrict方式。\n对于外键约束，最好是采用:\nON UPDATE CASCADE ON DELETE RESTRICT 的方式。\n（1）演示1：on update cascade on delete set null\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did)  on update cascade on delete set null    #把修改操作设置为级联修改等级，把删除操作设置为set null等级);\ninsert into dept values(1001,'教学部');insert into dept values(1002, '财务部');insert into dept values(1003, '咨询部');insert into emp values(1,'张三',1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,'李四',1001);insert into emp values(3,'王五',1002);\nmysql&gt; select * from dept;mysql&gt; select * from emp;\n#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了mysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来是1002，修改为1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   1001 ||   2 | 李四  |   1001 ||   3 | 王五  |   1004 | #原来是1002，跟着修改为1004+-----+-------+--------+3 rows in set (0.00 sec)\n#删除主表的记录成功，从表对应的字段的值被修改为nullmysql&gt; delete from dept where did = 1001;Query OK, 1 row affected (0.01 sec)mysql&gt; select * from dept;+------+--------+| did  | dname  | #记录1001部门被删除了+------+--------+| 1003 | 咨询部  || 1004 | 财务部  |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   NULL | #原来引用1001部门的员工，deptid字段变为null|   2 | 李四  |   NULL ||   3 | 王五  |   1004 |+-----+-------+--------+3 rows in set (0.00 sec)\n（2）演示2：on update set null on delete cascade\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did)  on update set null on delete cascade    #把修改操作设置为set null等级，把删除操作设置为级联删除等级);\ninsert into dept values(1001,'教学部');insert into dept values(1002, '财务部');insert into dept values(1003, '咨询部');insert into emp values(1,'张三',1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,'李四',1001);insert into emp values(3,'王五',1002);\nmysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   1001 ||   2 | 李四  |   1001 ||   3 | 王五  |   1002 |+-----+-------+--------+3 rows in set (0.00 sec)\n#修改主表，从表对应的字段设置为nullmysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来did是1002+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   1001 ||   2 | 李四  |   1001 ||   3 | 王五  |   NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null+-----+-------+--------+3 rows in set (0.00 sec)\n#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did  | dname  | #部门表中1001部门被删除+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |#原来1001部门的员工也被删除了+-----+-------+--------+|   3 | 王五  |   NULL |+-----+-------+--------+1 row in set (0.00 sec)\n（3）演示：on update cascade on delete cascade\ncreate table dept(\tdid int primary key,\t\t#部门编号    dname varchar(50)\t\t\t#部门名称);create table emp(\teid int primary key,  #员工编号    ename varchar(5),     #员工姓名    deptid int,\t\t\t\t#员工所在的部门    foreign key (deptid) references dept(did)  on update cascade on delete cascade    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级);\ninsert into dept values(1001,'教学部');insert into dept values(1002, '财务部');insert into dept values(1003, '咨询部');insert into emp values(1,'张三',1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,'李四',1001);insert into emp values(3,'王五',1002);\nmysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   1001 ||   2 | 李四  |   1001 ||   3 | 王五  |   1002 |+-----+-------+--------+3 rows in set (0.00 sec)\n#修改主表，从表对应的字段自动修改mysql&gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from dept;+------+--------+| did  | dname  |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #部门1002修改为1004+------+--------+3 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+|   1 | 张三  |   1001 ||   2 | 李四  |   1001 ||   3 | 王五  |   1004 | #级联修改+-----+-------+--------+3 rows in set (0.00 sec)\n#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from dept;+------+--------+| did  | dname  | #1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 | +------+--------+2 rows in set (0.00 sec)mysql&gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |  #1001部门的员工也被删除了+-----+-------+--------+|   3 | 王五  |   1004 |+-----+-------+--------+1 row in set (0.00 sec)\n6.8 删除外键约束\n流程如下：\n(1)第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;（2）第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名;\n举例：\nmysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = 'emp';mysql&gt; alter table emp drop foreign key emp_ibfk_1;Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0\nmysql&gt; show index from emp;mysql&gt; alter table emp drop index deptid;Query OK, 0 rows affected (0.01 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt;  show index from emp;\n6.9 开发场景\n问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？\n答：不是的\n问题2：建和不建外键约束有什么区别？\n答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。\n不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的引用完整性，只能依靠程序员的自觉，或者是在Java程序中进行限定。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。\n问题3：那么建和不建外键约束和查询有没有关系？\n答：没有\n\n在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL\n操作，有可能会不适合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢。所以，\nMySQL\n允许你不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。\n\n6.10 阿里开发规范\n【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的\nstudent_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的\nstudent_id\n更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。\n7. CHECK 约束\n7.1 作用\n检查某个字段的值是否符号xx要求，一般指的是值的范围\n2、关键字\nCHECK\n3、说明：MySQL 5.7 不支持\nMySQL5.7\n可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告\n但是MySQL 8.0中可以使用check约束了。\ncreate table employee(\teid int primary key,    ename varchar(5),    gender char check ('男' or '女'));\ninsert into employee values(1,'张三','妖');\nmysql&gt; select * from employee;+-----+-------+--------+| eid | ename | gender |+-----+-------+--------+|   1 | 张三   | 妖     |+-----+-------+--------+1 row in set (0.00 sec)\n\n再举例\n\nCREATE TABLE temp(id INT AUTO_INCREMENT,NAME VARCHAR(20),age INT CHECK(age &gt; 20),PRIMARY KEY(id));\n\n再举例\n\nage tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’))\n\n再举例\n\nCHECK(height&gt;=0 AND height&lt;3)\n8. DEFAULT约束\n8.1 作用\n给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。\n8.2 关键字\nDEFAULT\n8.3 如何给字段加默认值\n（1）建表时\ncreate table 表名称(\t字段名  数据类型  primary key,    字段名  数据类型  unique key not null,      字段名  数据类型  unique key,    字段名  数据类型  not null default 默认值, );create table 表名称(\t字段名  数据类型 default 默认值 ,    字段名  数据类型 not null default 默认值,      字段名  数据类型 not null default 默认值,    primary key(字段名),    unique key(字段名));说明：默认值约束一般不在唯一键和主键列上加\ncreate table employee(\teid int primary key,    ename varchar(20) not null,    gender char default '男',    tel char(11) not null default '' #默认是空字符串);\nmysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid    | int(11)     | NO   | PRI | NULL    |       || ename  | varchar(20) | NO   |     | NULL    |       || gender | char(1)     | YES  |     | 男      |       || tel    | char(11)    | NO   |     |         |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)\ninsert into employee values(1,'汪飞','男','13700102535'); #成功\nmysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel         |+-----+-------+--------+-------------+|   1 | 汪飞  | 男     | 13700102535 |+-----+-------+--------+-------------+1 row in set (0.00 sec)\ninsert into employee(eid,ename) values(2,'天琪'); #成功\nmysql&gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel         |+-----+-------+--------+-------------+|   1 | 汪飞  | 男     | 13700102535 ||   2 | 天琪  | 男     |             |+-----+-------+--------+-------------+2 rows in set (0.00 sec)\ninsert into employee(eid,ename) values(3,'二虎');#ERROR 1062 (23000): Duplicate entry '' for key 'tel'  #如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功\n再举例：\nCREATE TABLE myemp(id INT AUTO_INCREMENT PRIMARY KEY,NAME VARCHAR(15),salary DOUBLE(10,2) DEFAULT 2000);\n（2）建表后\nalter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null;\ncreate table employee(\teid int primary key,    ename varchar(20),    gender char,    tel char(11) not null);\nmysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid    | int(11)     | NO   | PRI | NULL    |       || ename  | varchar(20) | YES  |     | NULL    |       || gender | char(1)     | YES  |     | NULL    |       || tel    | char(11)    | NO   |     | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)\nalter table employee modify gender char default '男';  #给gender字段增加默认值约束alter table employee modify tel char(11) default ''; #给tel字段增加默认值约束\nmysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid    | int(11)     | NO   | PRI | NULL    |       || ename  | varchar(20) | YES  |     | NULL    |       || gender | char(1)     | YES  |     | 男      |       || tel    | char(11)    | YES  |     |         |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)\nalter table employee modify tel char(11) default ''  not null;#给tel字段增加默认值约束，并保留非空约束\nmysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid    | int(11)     | NO   | PRI | NULL    |       || ename  | varchar(20) | YES  |     | NULL    |       || gender | char(1)     | YES  |     | 男      |       || tel    | char(11)    | NO   |     |         |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)\n8.4 如何删除默认值约束\nalter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型  not null; #删除默认值约束，保留非空约束\nalter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除alter table employee modify tel char(11)  not null;#删除tel字段默认值约束，保留非空约束\nmysql&gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field  | Type        | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid    | int(11)     | NO   | PRI | NULL    |       || ename  | varchar(20) | YES  |     | NULL    |       || gender | char(1)     | YES  |     | NULL    |       || tel    | char(11)    | NO   |     | NULL    |       |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)\n9. 面试\n面试1、为什么建表时，加 not null default ’’ 或 default\n0\n答：不想让表中出现null值。\n面试2、为什么不想要 null 的值\n答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is\nnot null来比较。碰到运算符，通常返回null。\n​ （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null\ndefault ’’ 或 default 0\n面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？\n在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。\n面试4、并不是每个表都可以任意选择存储引擎？\n外键约束（FOREIGN KEY）不能跨引擎使用。\nMySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。\n","categories":["Database","SQL"],"tags":["SQL,Constraint"]},{"title":"SQL 运算符","url":"/2024/02/21/SQL-%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"常见的 SQL\n运算符汇总与用法示例，涵盖算术、比较、逻辑、位运算及正则匹配等多种操作符。\n\n1. 算术运算符\n算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（/）和取模（%）运算。\n\n\nimage-20211012100749193\n\n1．加法与减法运算符\nmysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;+-----+---------+---------+----------+--------------+------------+------------+| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |+-----+---------+---------+----------+--------------+------------+------------+| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |+-----+---------+---------+----------+--------------+------------+------------+1 row in set (0.00 sec)\n由运算结果可以得出如下结论：\n\n\n一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；\n一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；\n加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；\n在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）\n\n\n2．乘法与除法运算符\nmysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3  | 100 DIV 0 |+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+| 100 |     100 |     100.0 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+1 row in set (0.00 sec)\n#计算出员工的年基本工资SELECT employee_id,salary,salary * 12 annual_sal FROM employees;\n由运算结果可以得出如下结论：\n\n\n一个数乘以整数1和除以整数1后仍得原数；\n一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；\n一个数除以整数后，不管是否能除尽，结果都为一个浮点数；\n一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；\n乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。\n在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。\n\n\n3．求模（求余）运算符\n将t22表中的字段i对3和5进行求模（求余）运算。\nmysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual;+--------+----------+| 12 % 3 | 12 MOD 5 |+--------+----------+|      0 |        2 |+--------+----------+1 row in set (0.00 sec)\n#筛选出employee_id是偶数的员工SELECT * FROM employeesWHERE employee_id MOD 2 = 0;\n可以看到，100对3求模后的结果为3，对5求模后的结果为0。\n2. 比较运算符\n比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。\n比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。\n\n\n\nimage-20211012104955094\n\n1．等号运算符\n\n等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。\n在使用等号运算符时，遵循如下规则：\n\n如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。\n如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。\n如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。\n如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。\n\n对比：SQL中赋值符号使用 :=\n\nmysql&gt; SELECT 1 = 1, 1 = '1', 1 = 0, 'a' = 'a', (5 + 3) = (2 + 6), '' = NULL , NULL = NULL; +-------+---------+-------+-----------+-------------------+-----------+-------------+| 1 = 1 | 1 = '1' | 1 = 0 | 'a' = 'a' | (5 + 3) = (2 + 6) | '' = NULL | NULL = NULL |+-------+---------+-------+-----------+-------------------+-----------+-------------+|    1  |     1   |   0   |      1    |             1     |    NULL   |        NULL  |+-------+---------+-------+-----------+-------------------+-----------+-------------+1 row in set (0.00 sec)\nmysql&gt; SELECT 1 = 2, 0 = 'abc', 1 = 'abc' FROM dual;+-------+-----------+-----------+| 1 = 2 | 0 = 'abc' | 1 = 'abc' |+-------+-----------+-----------+|     0 |         1 |         0 |+-------+-----------+-----------+1 row in set, 2 warnings (0.00 sec)\n#查询salary=10000，注意在Java中比较是==SELECT employee_id,salary FROM employees WHERE salary = 10000;\n2．安全等于运算符\n安全等于运算符（&lt;=&gt;）与等于运算符（=）的作用是相似的，唯一的区别是‘&lt;=&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。\nmysql&gt; SELECT 1 &lt;=&gt; '1', 1 &lt;=&gt; 0, 'a' &lt;=&gt; 'a', (5 + 3) &lt;=&gt; (2 + 6), '' &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;+-----------+---------+-------------+---------------------+-------------+---------------+| 1 &lt;=&gt; '1' | 1 &lt;=&gt; 0 | 'a' &lt;=&gt; 'a' | (5 + 3) &lt;=&gt; (2 + 6) | '' &lt;=&gt; NULL | NULL &lt;=&gt; NULL |+-----------+---------+-------------+---------------------+-------------+---------------+|         1 |       0 |           1 |                   1 |           0 |             1 |+-----------+---------+-------------+---------------------+-------------+---------------+1 row in set (0.00 sec)\n#查询commission_pct等于0.40SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; 0.40;#如果把0.40改成 NULL 呢？\n可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。\n3．不等于运算符\n不等于运算符（&lt;&gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。\nSQL语句示例如下：\nmysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, 'a' != 'b', (3+4) &lt;&gt; (2+6), 'a' != NULL, NULL &lt;&gt; NULL; +--------+--------+------------+----------------+-------------+--------------+| 1 &lt;&gt; 1 | 1 != 2 | 'a' != 'b' | (3+4) &lt;&gt; (2+6) | 'a' != NULL | NULL &lt;&gt; NULL |+--------+--------+------------+----------------+-------------+--------------+|      0 |   1    |       1    |            1   |     NULL    |         NULL |+--------+--------+------------+----------------+-------------+--------------+1 row in set (0.00 sec)\n此外，还有非符号类型的运算符：\n\n\nimage-20211012105303219\n\n\n\nimage-20211012105030527\n\n\n\nimage-20211012105052456\n\n4. 空运算符 空运算符（IS\nNULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。\nSQL语句示例如下：\nmysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL('a'), 1 IS NULL;+--------------+--------------+-------------+-----------+| NULL IS NULL | ISNULL(NULL) | ISNULL('a') | 1 IS NULL |+--------------+--------------+-------------+-----------+|            1 |            1 |           0 |         0 |+--------------+--------------+-------------+-----------+1 row in set (0.00 sec)\n#查询commission_pct等于NULL。比较如下的四种写法SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;\nSELECT last_name, manager_idFROM   employeesWHERE  manager_id IS NULL;\n5. 非空运算符 非空运算符（IS NOT\nNULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。\nSQL语句示例如下：\nmysql&gt; SELECT NULL IS NOT NULL, 'a' IS NOT NULL,  1 IS NOT NULL; +------------------+-----------------+---------------+| NULL IS NOT NULL | 'a' IS NOT NULL | 1 IS NOT NULL |+------------------+-----------------+---------------+|                0 |               1 |             1 |+------------------+-----------------+---------------+1 row in set (0.01 sec)\n#查询commission_pct不等于NULLSELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL;SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);\n6. 最小值运算符\n语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。\nmysql&gt; SELECT LEAST (1,0,2), LEAST('b','a','c'), LEAST(1,NULL,2);+---------------+--------------------+-----------------+| LEAST (1,0,2) | LEAST('b','a','c') | LEAST(1,NULL,2) |+---------------+--------------------+-----------------+|       0       |        a           |      NULL       |+---------------+--------------------+-----------------+1 row in set (0.00 sec)\n由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。\n7. 最大值运算符\n语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。\nmysql&gt; SELECT GREATEST(1,0,2), GREATEST('b','a','c'), GREATEST(1,NULL,2);+-----------------+-----------------------+--------------------+| GREATEST(1,0,2) | GREATEST('b','a','c') | GREATEST(1,NULL,2) |+-----------------+-----------------------+--------------------+|               2 | c                     |               NULL |+-----------------+-----------------------+--------------------+1 row in set (0.00 sec)\n由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。\n8. BETWEEN AND运算符\nBETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND\nB，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。\nmysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, 'b' BETWEEN 'a' AND 'c';+-------------------+----------------------+-------------------------+| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | 'b' BETWEEN 'a' AND 'c' |+-------------------+----------------------+-------------------------+|                 1 |                    0 |                       1 |+-------------------+----------------------+-------------------------+1 row in set (0.00 sec)\nSELECT last_name, salaryFROM   employeesWHERE  salary BETWEEN 2500 AND 3500;\n9. IN运算符\nIN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。\nmysql&gt; SELECT 'a' IN ('a','b','c'), 1 IN (2,3), NULL IN ('a','b'), 'a' IN ('a', NULL);+----------------------+------------+-------------------+--------------------+| 'a' IN ('a','b','c') | 1 IN (2,3) | NULL IN ('a','b') | 'a' IN ('a', NULL) |+----------------------+------------+-------------------+--------------------+|            1         |        0   |         NULL      |         1          |+----------------------+------------+-------------------+--------------------+1 row in set (0.00 sec)\nSELECT employee_id, last_name, salary, manager_idFROM   employeesWHERE  manager_id IN (100, 101, 201);\n10. NOT IN运算符 NOT\nIN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。\nmysql&gt; SELECT 'a' NOT IN ('a','b','c'), 1 NOT IN (2,3);+--------------------------+----------------+| 'a' NOT IN ('a','b','c') | 1 NOT IN (2,3) |+--------------------------+----------------+|                 0        |            1   |+--------------------------+----------------+1 row in set (0.00 sec)\n11. LIKE运算符\nLIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。\nLIKE运算符通常使用如下通配符：\n“%”：匹配0个或多个字符。“_”：只能匹配一个字符。\nSQL语句示例如下：\nmysql&gt; SELECT NULL LIKE 'abc', 'abc' LIKE NULL;  +-----------------+-----------------+| NULL LIKE 'abc' | 'abc' LIKE NULL |+-----------------+-----------------+|          NULL   |          NULL   |+-----------------+-----------------+1 row in set (0.00 sec)\nSELECT\tfirst_nameFROM \temployeesWHERE\tfirst_name LIKE 'S%';\nSELECT last_nameFROM   employeesWHERE  last_name LIKE '_o%';\nESCAPE\n\n回避特殊符号的：使用转义符。例如：将[%]转为[]，然后再加上[ESCAPE‘$’]即可。\n\nSELECT job_idFROM   jobsWHERE  job_id LIKE ‘IT\\_%‘;\n\n如果使用，要省略ESCAPE。如果不是，则要加上ESCAPE。\n\nSELECT job_idFROM   jobsWHERE  job_id LIKE ‘IT$_%‘ escape ‘$‘;\n12. REGEXP运算符\nREGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。\nREGEXP运算符在进行匹配时，常用的有下面几种通配符：\n（1）‘^’匹配以该字符后面的字符开头的字符串。（2）‘$’匹配以该字符前面的字符结尾的字符串。（3）‘.’匹配任何一个单字符。（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。\nSQL语句示例如下：\nmysql&gt; SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';+------------------------+------------------------+-------------------------+| 'shkstart' REGEXP '^s' | 'shkstart' REGEXP 't$' | 'shkstart' REGEXP 'hk'  |+------------------------+------------------------+-------------------------+|                      1 |                      1 |                       1 |+------------------------+------------------------+-------------------------+1 row in set (0.01 sec)\nmysql&gt; SELECT 'atguigu' REGEXP 'gu.gu', 'atguigu' REGEXP '[ab]';+--------------------------+-------------------------+| 'atguigu' REGEXP 'gu.gu' | 'atguigu' REGEXP '[ab]' |+--------------------------+-------------------------+|                        1 |                       1 |+--------------------------+-------------------------+1 row in set (0.00 sec)\n3. 逻辑运算符\n逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。\nMySQL中支持4种逻辑运算符如下：\n1．逻辑非运算符\n逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。\nmysql&gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;    +-------+-------+----------+--------+----------+| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |+-------+-------+----------+--------+----------+|     0 |     1 |        0 |      1 |     NULL |+-------+-------+----------+--------+----------+1 row in set, 1 warning (0.00 sec)\nSELECT last_name, job_idFROM   employeesWHERE  job_id NOT IN ('IT_PROG', 'ST_CLERK', 'SA_REP');\n2．逻辑与运算符\n逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。\nmysql&gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;+----------+---------+------------+------------+| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |+----------+---------+------------+------------+|        1 |       0 |          0 |       NULL |+----------+---------+------------+------------+1 row in set (0.00 sec)\nSELECT employee_id, last_name, job_id, salaryFROM   employeesWHERE  salary &gt;=10000AND    job_id LIKE '%MAN%';\n3．逻辑或运算符\n逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。\nmysql&gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;     +---------+--------+-----------+-----------+--------------+| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |+---------+--------+-----------+-----------+--------------+|       1 |      1 |         1 |    NULL   |       NULL   |+---------+--------+-----------+-----------+--------------+1 row in set, 2 warnings (0.00 sec)\n#查询基本薪资不在9000-12000之间的员工编号和基本薪资SELECT employee_id,salary FROM employees WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);SELECT employee_id,salary FROM employees WHERE salary &lt;9000 OR salary &gt; 12000;SELECT employee_id,salary FROM employees WHERE salary NOT BETWEEN 9000 AND 12000;\nSELECT employee_id, last_name, job_id, salaryFROM   employeesWHERE  salary &gt;= 10000OR     job_id LIKE '%MAN%';\n\n注意：\nOR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。\n\n4．逻辑异或运算符\n逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。\nmysql&gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;+----------+---------+---------+------------+---------------+---------------+| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |+----------+---------+---------+------------+---------------+---------------+|        0 |       1 |       0 |       NULL |             1 |             0 |+----------+---------+---------+------------+---------------+---------------+1 row in set (0.00 sec)\nselect last_name,department_id,salary from employeeswhere department_id in (10,20) XOR salary &gt; 8000;\n4. 位运算符\n位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。\nMySQL支持的位运算符如下：\n1．按位与运算符\n按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。\nmysql&gt; SELECT 1 &amp; 10, 20 &amp; 30;+--------+---------+| 1 &amp; 10 | 20 &amp; 30 |+--------+---------+|      0 |      20 |+--------+---------+1 row in set (0.00 sec)\n1的二进制数为0001，10的二进制数为1010，所以1 &amp;\n10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20\n&amp; 30的结果为10100，对应的十进制数为20。\n2. 按位或运算符\n按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。\nmysql&gt; SELECT 1 | 10, 20 | 30; +--------+---------+| 1 | 10 | 20 | 30 |+--------+---------+|     11 |      30 |+--------+---------+1 row in set (0.00 sec)\n1的二进制数为0001，10的二进制数为1010，所以1 |\n10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20\n| 30的结果为11110，对应的十进制数为30。\n3. 按位异或运算符\n按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。\nmysql&gt; SELECT 1 ^ 10, 20 ^ 30; +--------+---------+| 1 ^ 10 | 20 ^ 30 |+--------+---------+|     11 |      10 |+--------+---------+1 row in set (0.00 sec)\n1的二进制数为0001，10的二进制数为1010，所以1 ^\n10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20\n^ 30的结果为01010，对应的十进制数为10。\n再举例：\nmysql&gt; SELECT 12 &amp; 5, 12 | 5,12 ^ 5 FROM DUAL;+--------+--------+--------+| 12 &amp; 5 | 12 | 5 | 12 ^ 5 |+--------+--------+--------+|      4 |     13 |      9 |+--------+--------+--------+1 row in set (0.00 sec)\n4. 按位取反运算符\n按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。\nmysql&gt; SELECT 10 &amp; ~1;+---------+| 10 &amp; ~1 |+---------+|      10 |+---------+1 row in set (0.00 sec)\n由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10\n&amp;\n~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。\n5. 按位右移运算符\n按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。\nmysql&gt; SELECT 1 &gt;&gt; 2, 4 &gt;&gt; 2;+--------+--------+| 1 &gt;&gt; 2 | 4 &gt;&gt; 2 |+--------+--------+|      0 |      1 |+--------+--------+1 row in set (0.00 sec)\n1的二进制数为0000 0001，右移2位为0000\n0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000\n0001，对应的十进制数为1。\n6. 按位左移运算符\n按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。\nmysql&gt; SELECT 1 &lt;&lt; 2, 4 &lt;&lt; 2;  +--------+--------+| 1 &lt;&lt; 2 | 4 &lt;&lt; 2 |+--------+--------+|      4 |     16 |+--------+--------+1 row in set (0.00 sec)\n1的二进制数为0000 0001，左移两位为0000\n0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001\n0000，对应的十进制数为16。\n拓展：使用正则表达式查询\n正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。\nMySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。\n\n\nimage-20210926151249943\n\n1. 查询以特定字符或字符串开头的记录\n字符‘^’匹配以特定字符或者字符串开头的文本。\n在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^b';\n2. 查询以特定字符或字符串结尾的记录\n字符‘$’匹配以特定字符或者字符串结尾的文本。\n在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'y$';\n3. 用符号”.”来替代字符串中的任意一个字符\n字符‘.’匹配任意一个字符。\n在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'a.g';\n**4. 使用”*“和”+“来匹配多个字符**\n星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^ba*';\n在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '^ba+';\n5. 匹配指定字符串\n正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。\n在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'on';\n在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'on|ap';\n之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。\n在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name like 'on';Empty set(0.00 sec)\n6. 匹配指定字符中的任意一个\n方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。\n在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP '[ot]';\n在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE s_id REGEXP '[456]';\n7. 匹配指定字符以外的字符\n“[^字符集合]”匹配不在指定集合中的任何字符。\n在fruits表中，查询f_id字段中包含字母ae和数字12以外字符的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_id REGEXP '[^a-e1-2]';\n8. 使用{n,}或者{n,m}来指定字符串连续出现的次数\n“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。\n在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'x{2,}';\n在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：\nmysql&gt; SELECT * FROM fruits WHERE f_name REGEXP 'ba{1,3}';\n","categories":["Database","SQL"],"tags":["SQL,Basic"]},{"title":"SQL 聚合函数","url":"/2024/02/21/SQL-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/","content":"SQL 中常见的聚合函数，包括 AVG、SUM、MAX、MIN、COUNT\n的用法与区别；讲解 GROUP BY 子句的分组操作与 WITH ROLLUP 扩展语法；分析\nHAVING 与 WHERE 的使用场景及性能差异；最后梳理了完整的 SELECT\n执行过程及其内部原理。\n\n1. 聚合函数介绍\n\n什么是聚合函数\n\n聚合函数作用于一组数据，并对一组数据返回一个值。\n\n聚合函数类型\n\nAVG()\nSUM()\nMAX()\nMIN()\nCOUNT() \n\n聚合函数语法\n\n\n\n1554981029920\n\n\n聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。\n\n1.1 AVG和SUM函数\n可以对数值型数据使用AVG 和 SUM 函数。\nSELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)FROM   employeesWHERE  job_id LIKE '%REP%';\n1.2 MIN和MAX函数\n可以对任意数据类型的数据使用 MIN 和 MAX 函数。\nSELECT MIN(hire_date), MAX(hire_date)FROM\t  employees;\n1.3 COUNT函数\n\nCOUNT(*)返回表中记录总数，适用于任意数据类型。\n\nSELECT COUNT(*)FROM\t  employeesWHERE  department_id = 50;\n\nCOUNT(expr) 返回expr不为空的记录总数。\n\nSELECT COUNT(commission_pct)FROM   employeesWHERE  department_id = 50;\n\n**问题：用count(*)，count(1)，count(列名)谁好呢?**\n其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。\nInnodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。\n**问题：能不能使用count(列名)替换count(*)?**\n不要使用 count(列名)来替代\ncount(*)，count(*)是 SQL92\n定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL\n值的行。\n\n2. GROUP BY\n2.1 基本使用\n可以使用GROUP BY子句将表中的数据分成若干组\nSELECT column, group_function(column)FROM table[WHERE\tcondition][GROUP BY\tgroup_by_expression][ORDER BY\tcolumn];\n\n明确：WHERE一定放在FROM后面\n\n在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP\nBY子句中\nSELECT   department_id, AVG(salary)FROM     employeesGROUP BY department_id ;\n包含在 GROUP BY 子句中的列不必包含在SELECT 列表中\nSELECT   AVG(salary)FROM     employeesGROUP BY department_id ;\n2.2 使用多个列分组\nSELECT   department_id dept_id, job_id, SUM(salary)FROM     employeesGROUP BY department_id, job_id ;\n2.3 GROUP BY中使用WITH ROLLUP\n使用WITH ROLLUP关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。\nSELECT department_id,AVG(salary)FROM employeesWHERE department_id &gt; 80GROUP BY department_id WITH ROLLUP;\n\n注意：\n当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER\nBY是互相排斥的。\n\n3. HAVING\n3.1 基本使用\n过滤分组：HAVING子句\n\n行已经被分组。\n使用了聚合函数。\n满足HAVING 子句中条件的分组将被显示。\nHAVING 不能单独使用，必须要跟 GROUP BY 一起使用。\n\n\n\n1554981808091\n\nSELECT   department_id, MAX(salary)FROM     employeesGROUP BY department_idHAVING   MAX(salary)&gt;10000 ;\n\n非法使用聚合函数 ： 不能在 WHERE\n子句中使用聚合函数。如下：\n\nSELECT   department_id, AVG(salary)FROM     employeesWHERE    AVG(salary) &gt; 8000GROUP BY department_id;\n3.2 WHERE和HAVING的对比\n区别1：WHERE\n可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING\n必须要与 GROUP BY\n配合使用，可以把分组计算的函数和分组字段作为筛选条件。\n这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE\n不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY\n之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY\n之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是\nWHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。\n区别2：如果需要通过连接从关联表中获取需要的数据，WHERE\n是先筛选后连接，而 HAVING 是先连接后筛选。\n这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE\n可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING\n则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。\n小结如下：\n\n\n\n\n\n\n\n\n\n优点\n缺点\n\n\n\n\nWHERE\n先筛选数据再关联，执行效率高\n不能使用分组中的计算函数进行筛选\n\n\nHAVING\n可以使用分组中的计算函数\n在最后的结果集中进行筛选，执行效率较低\n\n\n\n开发中的选择：\nWHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用\nWHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用\nWHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING\n可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。\n4. SELECT的执行过程\n4.1 查询的结构\n#方式1：SELECT ...,....,...FROM ...,...,....WHERE 多表的连接条件AND 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#方式2：SELECT ...,....,...FROM ... JOIN ... ON 多表的连接条件JOIN ...ON ...WHERE 不包含组函数的过滤条件AND/OR 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#其中：#（1）from：从哪些表中筛选#（2）on：关联多表查询时，去除笛卡尔积#（3）where：从表中筛选的条件#（4）group by：分组依据#（5）having：在统计结果中再次筛选#（6）order by：排序#（7）limit：分页\n4.2 SELECT执行顺序\n你需要记住 SELECT 查询时的两个顺序：\n1. 关键字的顺序是不能颠倒的：\nSELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...\n2.SELECT 语句的执行顺序（在 MySQL 和 Oracle\n中，SELECT 执行顺序基本相同）：\nFROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT\n\n\n1566872301088\n\n比如你写了一个 SQL\n语句，那么它的关键字顺序和执行顺序是下面这样的：\nSELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5FROM player JOIN team ON player.team_id = team.team_id # 顺序 1WHERE height &gt; 1.80 # 顺序 2GROUP BY player.team_id # 顺序 3HAVING num &gt; 2 # 顺序 4ORDER BY num DESC # 顺序 6LIMIT 2 # 顺序 7\n在 SELECT\n语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在\nSQL 的执行过程中，对于我们来说是不可见的。\n4.3 SQL 的执行原理\nSELECT 是先执行 FROM\n这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：\n\n首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual\ntable）1-1；\n通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表\nvt1-2；\n添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表\nvt1-2 的基础上增加外部行，得到虚拟表 vt1-3。\n\n当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。\n当我们拿到了查询数据表的原始数据，也就是最终的虚拟表\nvt1，就可以在此基础上再进行\nWHERE 阶段。在这个阶段中，会根据 vt1\n表的结果进行筛选过滤，得到虚拟表 vt2。\n然后进入第三步和第四步，也就是\nGROUP 和 HAVING 阶段。在这个阶段中，实际上是在虚拟表 vt2\n的基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和\nvt4。\n当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到\nSELECT 和 DISTINCT 阶段。\n首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT\n阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和\nvt5-2。\n当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是\nORDER BY 阶段，得到虚拟表 vt6。\n最后在 vt6 的基础上，取出指定行的记录，也就是\nLIMIT 阶段，得到最终的结果，对应的是虚拟表\nvt7。\n当然我们在写 SELECT\n语句的时候，不一定存在所有的关键字，相应的阶段就会省略。\n同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT\n语句的时候，还要注意相应的关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序。\n","categories":["Database","SQL"],"tags":["SQL,Function"]},{"title":"Search Algorithm","url":"/2022/12/08/Search-Algorithm/","content":"常见的搜索算法：记忆化搜索，迭代加深，meet in the middle，A* 和\nIDA*\n\n记忆化搜索\n思想可以用来进行搜索到DP的优化\n建一个备忘录memo[N][S] memo[i][j]表示在第i个点，状态为j时搜索结果。\n或者memo[N] memo[i]表示第i个点，搜索结果。\n上述备忘录初值memo[i]为0，说明该状态未被搜索。\nP1278\n单词游戏\n他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。\n游戏可以从任何一个单词开始。任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。\n游戏的复杂度定义为游戏中所使用的单词长度总和。\n编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。\nstatic int vis; //初始为0..0000(二进制表示下16个0) 说明任何字母都没有访问static int[] memo[] = new int[N][1&lt;&lt;N]; //N=16 只有16个状态 用二进制表示static int dfs(int c){    if (memo[c][vis] != 0) return memo[c][vis];    vis |= 1&lt;&lt;c; //开始访问第c个单词 把vis二进制第c位置1    char next = s[c].charAt(s[c].length()-1);    int res = 0;    for (int i = 0;i &lt; n;i++){        //判断i有没有访问过 即看第i位是不是1 (不能写成 (vis&amp;1&lt;&lt;i) == 1 )        if ((vis&gt;&gt;i&amp;1)==1 || s[i].charAt(0)!=next) continue;        res = max(dfs(i), res);    }    vis &amp;= ~(1&lt;&lt;c);//访问结束 把vis二进制第c位置0    return memo[c][vis] = res+s[c].length();//记得更新备忘录}\n\n迭代加深\n从小到大枚举答案所需步数，然后在搜索时一旦超出这个步数就不再搜索。根据搜索空间的一般规律，搜索的状态空间随着步数指数级增长。这样我们的时间主要取决于最后一次搜索的时间，DFS的缺点得到了一定程度的弥补。迭代加深搜索使用范围:1.在有一定的限制条件时使用（例如“如果能在1515步以内（包括1515步）到达目标状态，则输出步数“）。2.题目中说输出所以解中的任何一组解。\nstatic int[] res = new int[N];public static void main(String[] args) throws Exception {    res[1] = 1;    if (n == 1) out.println(1); //特殊    else{        int deep = 2;//dfs深度从二开始递增        while (!dfs(2, deep)) deep++; //不行的话就一直增        for (int i = 1;i &lt;= deep;i++) out.print(res[i]+\" \");        out.println();    }}static boolean dfs(int c, int max){    if (c==max+1) return res[c-1]==n;    int pre = res[c-1];    boolean s = false;    for (int i = c-1;i &gt;= 1 &amp;&amp; !s;i--){        int y = pre+res[i];        if (y&gt;pre &amp;&amp; y&lt;=n){           res[c] = y;           s |= dfs(c+1, max);        }else break;    }    return s;}\nAddition\nChains\n\nmeet in the middle\n折半搜索，又称为meet-in-the-middle。其做法为将整个搜索的过程分为两部分，然后每部分分别进行搜索，最后将得到两个答案序列，再将答案序列进行合并，即可得到最终的答案。\n我们知道，搜索的时间复杂度往往是指数级别的。\n比如，在每一层搜索时，假如都有两种选择，那么其时间复杂度为 O(2n) 。当 n\n较大时，往往会导致超时。此时，如果使用折半搜索，其时间复杂度将缩小为\nO(2n/2) + 合并时间复杂度)\n。\n所以当搜索范围n &gt; 40以上时，可优先考虑。\n合并常用策略：哈希表、排序加二分\n世界冰球锦标赛\n给出预算和每场比赛的票价，试求：如果总票价不超过预算，有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。\nstatic long money, ans;static int len1, len2, len;static long[] p = new long[N], sub1 = new long[1&lt;&lt;21], sub2 = new long[1&lt;&lt;21];public static void main(String[] args) throws Exception {    dfs(1, n/2, 0, sub1); //搜索前一半 把符合的结果存入 sub1[]    len1 = len; len = 0;  //len就是前一半搜索结果的数量（记得清0）    dfs(n/2+1, n, 0, sub2);//搜索后一半 把符合的结果存入 sub2[]    len2 = len;    Arrays.sort(sub1, 0, len1);     for (int i = 0;i &lt; len2;i++){        int l = 0, r = len1-1;        long t = money-sub2[i];        while (l &lt;= r){           int mid = l+r&gt;&gt;1;           if (sub1[mid]&gt;t) r = mid-1;           else l = mid+1;        }        ans += l;    }    println(ans);}static void dfs(int cur, int max, long sum, long[] sub){    if (sum &gt; money) return;    if (cur &gt; max){ // 所有数都遍历完 存入sub[]数组        sub[len++] = sum; return;    }    dfs(cur+1, max, sum+p[cur], sub); //每个数选和不选两种情况    dfs(cur+1, max, sum, sub);}\nBalanced Cow Subsets\nG\nA*\n用啥A*，IDA*不香吗\n\nIDA*\nIDA* =\nA* + 迭代加深\nIDA*\n是对结合迭代加深的DFS的优化。\n本质上只是在BFS和DFS上加上了一个估价函数。 ```\n","categories":["Algorithm","Template"],"tags":["Template","Search"]},{"title":"SSM整合原理和实战","url":"/2024/06/16/SSM%E6%95%B4%E5%90%88%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/","content":"本文系统性梳理了 SSM 框架整合的关键概念与实战配置，围绕 IoC\n容器数量、组件归属、配置类划分与初始化方式等核心问题展开深入分析，并通过完整的案例演示，介绍了从依赖整合到前后端联调的全过程。文章后半部分以“任务列表系统”为示例，讲解前端环境搭建、后端功能实现及接口对接的详细流程，帮助读者在理解\nSSM\n原理的基础上，掌握实际开发中的整合技巧与调试方法，适合有一定基础的读者查漏补缺或快速上手\nSSM 框架整合开发。\n\n一、SSM 整合理解\n1.1 什么是 SSM 整合？\n微观：将学习的 Spring SpringMVC Mybatis\n框架应用到项目中!\n\nSpringMVC 框架负责控制层\nSpring 框架负责整体和业务层的声明式事务管理\nMyBatis 框架负责数据库访问层\n\n宏观：Spring 接管一切（将框架核心组件交给 Spring\n进行 IoC 管理），代码更加简洁。\n\nSpringMVC 管理表述层、SpringMVC 相关组件\nSpring\n管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件\n使用 IoC 的方式管理一切所需组件\n\n实施：通过编写配置文件，实现 SpringIoC\n容器接管一切组件。\n1.2 SSM 整合核心问题明确\n1.2.1 第一问：SSM 整合需要几个\nIoC 容器？\n两个容器\n本质上说，整合就是将三层架构和框架核心 API 组件交给 SpringIoC\n容器管理！\n一个容器可能就够了，但是我们常见的操作是创建两个 IoC 容器（web 容器和\nroot 容器），组件分类管理！\n这种做法有以下好处和目的：\n\n分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能。\n解耦合：各个层次组件分离装配不同的 IoC\n容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性。\n灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配置文件也更加清晰和灵活。\n\n总的来说，初始化两个容器在 SSM\n整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！\n1.2.2 第二问：每个 IoC\n容器对应哪些类型组件？\n\n总结：\n\n\n\n\n\n\n\n容器名\n盛放组件\n\n\n\n\nweb 容器\nweb 相关组件（controller,springmvc 核心组件）\n\n\nroot 容器\n业务和持久层相关组件（service,aop,tx,dataSource,mybatis,mapper\n等）\n\n\n\n1.2.3 第三问：IoC\n容器之间关系和调用方向？\n情况 1：两个无关联 IoC 容器之间的组件无法注入！\n情况 2：子 IoC 容器可以单向的注入父 IoC 容器的组件！\n结论：web 容器是 root 容器的子容器。\n\n父容器：root 容器，盛放 service、mapper、mybatis 等相关组件\n子容器：web 容器，盛放 controller、web 相关组件\n\n源码体现：\nFrameworkServlet 655 行！\nprotected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) {    Class&lt;?&gt; contextClass = getContextClass();    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {      throw new ApplicationContextException(          \"Fatal initialization error in servlet with name '\" + getServletName() +          \"': custom WebApplicationContext class [\" + contextClass.getName() +          \"] is not of type ConfigurableWebApplicationContext\");    }    ConfigurableWebApplicationContext wac =        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);    wac.setEnvironment(getEnvironment());    //wac 就是web ioc容器    //parent 就是root ioc容器    //web容器设置root容器为父容器，所以web容器可以引用root容器    wac.setParent(parent);    String configLocation = getContextConfigLocation();    if (configLocation != null) {      wac.setConfigLocation(configLocation);    }    configureAndRefreshWebApplicationContext(wac);    return wac;  }\n调用流程图解：\n\n1.2.4\n第四问：具体多少配置类以及对应容器关系？\n配置类的数量不是固定的，但是至少要两个，为了方便编写，我们可以三层架构每层对应一个配置类，分别指定两个容器加载即可！\n\n建议配置文件：\n\n\n\n配置名\n对应内容\n对应容器\n\n\n\n\nWebJavaConfig\ncontroller,springmvc 相关\nweb 容器\n\n\nServiceJavaConfig\nservice,aop,tx 相关\nroot 容器\n\n\nMapperJavaConfig\nmapper,datasource,mybatis 相关\nroot 容器\n\n\n\n1.2.5 第五问：IoC\n初始化方式和配置位置？\n在 web 项目下，我们可以选择 web.xml 和配置类方式进行 ioc\n配置，推荐配置类。\n对于使用基于 web 的 Spring\n配置的应用程序，建议这样做，如以下示例所示：\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {  //指定root容器对应的配置类  //root容器的配置类  @Override  protected Class&lt;?&gt;[] getRootConfigClasses() {    return new Class&lt;?&gt;[] { ServiceJavaConfig.class,MapperJavaConfig.class };  }  //指定web容器对应的配置类 webioc容器的配置类  @Override  protected Class&lt;?&gt;[] getServletConfigClasses() {    return new Class&lt;?&gt;[] { WebJavaConfig.class };  }  //指定dispatcherServlet处理路径，通常为 /  @Override  protected String[] getServletMappings() {    return new String[] { \"/\" };  }}\n二、SSM 整合配置实战\n2.1 依赖整合和添加\n\n数据库准备\n依然沿用 mybatis 数据库测试脚本！\nCREATE DATABASE `mybatis-example`;USE `mybatis-example`;CREATE TABLE `t_emp`(  emp_id INT AUTO_INCREMENT,  emp_name CHAR(100),  emp_salary DOUBLE(10,5),  PRIMARY KEY(emp_id));INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"tom\",200.33);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"jerry\",666.66);INSERT INTO `t_emp`(emp_name,emp_salary) VALUES(\"andy\",777.77);\n准备项目\n转成 web 项目\n依赖导入\npom.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.atguigu&lt;/groupId&gt;    &lt;artifactId&gt;part04-ssm-integration&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;properties&gt;        &lt;spring.version&gt;6.0.6&lt;/spring.version&gt;        &lt;jakarta.annotation-api.version&gt;2.1.1&lt;/jakarta.annotation-api.version&gt;        &lt;jakarta.jakartaee-web-api.version&gt;9.1.0&lt;/jakarta.jakartaee-web-api.version&gt;        &lt;jackson-databind.version&gt;2.15.0&lt;/jackson-databind.version&gt;        &lt;hibernate-validator.version&gt;8.0.0.Final&lt;/hibernate-validator.version&gt;        &lt;mybatis.version&gt;3.5.11&lt;/mybatis.version&gt;        &lt;mysql.version&gt;8.0.25&lt;/mysql.version&gt;        &lt;pagehelper.version&gt;5.1.11&lt;/pagehelper.version&gt;        &lt;druid.version&gt;1.2.8&lt;/druid.version&gt;        &lt;mybatis-spring.version&gt;3.0.2&lt;/mybatis-spring.version&gt;        &lt;jakarta.servlet.jsp.jstl-api.version&gt;3.0.0&lt;/jakarta.servlet.jsp.jstl-api.version&gt;        &lt;logback.version&gt;1.2.3&lt;/logback.version&gt;        &lt;lombok.version&gt;1.18.26&lt;/lombok.version&gt;        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;/properties&gt;    &lt;!--     需要依赖清单分析:        spring          ioc/di            spring-context / 6.0.6            jakarta.annotation-api / 2.1.1  jsr250          aop            spring-aspects / 6.0.6          tx            spring-tx  / 6.0.6            spring-jdbc / 6.0.6        springmvc           spring-webmvc 6.0.6           jakarta.jakartaee-web-api 9.1.0           jackson-databind 2.15.0           hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final        mybatis           mybatis  / 3.5.11           mysql    / 8.0.25           pagehelper / 5.1.11        整合需要           加载spring容器 spring-web / 6.0.6           整合mybatis   mybatis-spring x x           数据库连接池    druid / x           lombok        lombok / 1.18.26           logback       logback/ 1.2.3  --&gt;    &lt;dependencies&gt;        &lt;!--spring pom.xml依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;            &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;            &lt;version&gt;${jakarta.annotation-api.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--       springmvc           spring-webmvc 6.0.6           jakarta.jakartaee-web-api 9.1.0           jackson-databind 2.15.0           hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final    --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;            &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;            &lt;version&gt;${jakarta.jakartaee-web-api.version}&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- jsp需要依赖! jstl--&gt;        &lt;dependency&gt;            &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;            &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;            &lt;version&gt;${jakarta.servlet.jsp.jstl-api.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;${jackson-databind.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;            &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;            &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;            &lt;version&gt;${hibernate-validator.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--      mybatis           mybatis  / 3.5.11           mysql    / 8.0.25           pagehelper / 5.1.11    --&gt;        &lt;!-- mybatis依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;${mybatis.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带! --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;${mysql.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;${pagehelper.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 整合第三方特殊依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;${mybatis-spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 日志 ， 会自动传递slf4j门面--&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;${logback.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;${lombok.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;${druid.version}&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;\n实体类添加\ncom.atguigu.pojo\n@Datapublic class Employee {    private Integer empId;    private String empName;    private Double empSalary;}\nlogback 配置\n位置：resources/logback.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration debug=\"true\"&gt;    &lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt;    &lt;appender name=\"STDOUT\"              class=\"ch.qos.logback.core.ConsoleAppender\"&gt;        &lt;encoder&gt;            &lt;!-- 日志输出的格式 --&gt;            &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;            &lt;pattern&gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR --&gt;    &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;    &lt;root level=\"DEBUG\"&gt;        &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;        &lt;appender-ref ref=\"STDOUT\" /&gt;    &lt;/root&gt;    &lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt;    &lt;logger name=\"com.atguigu.mybatis\" level=\"DEBUG\" /&gt;&lt;/configuration&gt;\n\n2.2 控制层配置编写(SpringMVC\n整合)\n\n主要配置 controller,springmvc 相关组件配置 \n\n位置：WebJavaConfig.java(命名随意)\n/** * projectName: com.atguigu.config * * 1.实现Springmvc组件声明标准化接口WebMvcConfigurer 提供了各种组件对应的方法 * 2.添加配置类注解@Configuration * 3.添加mvc复合功能开关@EnableWebMvc * 4.添加controller层扫描注解 * 5.开启默认处理器,支持静态资源处理 */@Configuration@EnableWebMvc@ComponentScan(\"com.atguigu.controller\")public class WebJavaConfig implements WebMvcConfigurer {    //开启静态资源    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable();    }}\n2.3 业务层配置编写(AOP / TX\n整合）\n\n主要配置 service,注解 aop 和声明事务相关配置\n\n位置：ServiceJavaConfig.java(命名随意)\n/** * projectName: com.atguigu.config * * 1. 声明@Configuration注解,代表配置类 * 2. 声明@EnableTransactionManagement注解,开启事务注解支持 * 3. 声明@EnableAspectJAutoProxy注解,开启aspect aop注解支持 * 4. 声明@ComponentScan(\"com.atguigu.service\")注解,进行业务组件扫描 * 5. 声明transactionManager(DataSource dataSource)方法,指定具体的事务管理器 */@EnableTransactionManagement@EnableAspectJAutoProxy@Configuration@ComponentScan(\"com.atguigu.service\")public class ServiceJavaConfig {    @Bean    public DataSourceTransactionManager transactionManager(DataSource dataSource){        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();        transactionManager.setDataSource(dataSource);        return transactionManager;    }}\n2.4 持久层配置编写(MyBatis\n整合)\n\n主要配置 mapper 代理对象，连接池和 mybatis 核心组件配置\n\n\nmybatis 整合思路\nmybatis 核心 api 使用回顾：\n//1.读取外部配置文件InputStream ips = Resources.getResourceAsStream(\"mybatis-config.xml\");//2.创建sqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);//3.创建sqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();//4.获取mapper代理对象EmpMapper empMapper = sqlSession.getMapper(EmpMapper.class);//5.数据库方法调用int rows = empMapper.deleteEmpById(1);System.out.println(\"rows = \" + rows);//6.提交和回滚sqlSession.commit();sqlSession.close();\nmybatis 核心 api 介绍回顾：\n\nSqlSessionFactoryBuilder\n这个类可以被实例化、使用和丢弃，一旦创建了\nSqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder\n实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需 ioc\n容器管理！\nSqlSessionFactory\n一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。\n使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此\nSqlSessionFactory 的最佳作用域是应用作用域。 需要 ioc\n容器管理！\nSqlSession\n每个线程都应该有它自己的 SqlSession 实例。SqlSession\n的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。\n无需 ioc 容器管理！\nMapper 映射器实例\n映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession\n中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的\nSqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。\n从作用域的角度来说，映射器实例不应该交给 ioc 容器管理！\n但是从使用的角度来说，业务类（service）需要注入 mapper\n接口，所以 mapper 应该交给 ioc 容器管理！\n\n总结\n\n将 SqlSessionFactory 实例存储到 IoC 容器\n将 Mapper 实例存储到 IoC 容器\n\n\n例如，自己实现 sqlSessionFactory 加入 ioc 容器：\n@Beanpublic SqlSessionFactory sqlSessionFactory(){   //1.读取外部配置文件  InputStream ips = Resources.getResourceAsStream(\"mybatis-config.xml\");  //2.创建sqlSessionFactory  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(ips);  return sqlSessionFactory;}\n过程比较繁琐，为了提高整合效率，mybatis 提供了提供封装\nSqlSessionFactory 和 Mapper 实例化的逻辑的 FactoryBean\n组件，我们只需要声明和指定少量的配置即可！\nSqlSessionFactoryBean 源码展示(mybatis 提供)：\npackage org.mybatis.spring;public class SqlSessionFactoryBean    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ContextRefreshedEvent&gt; {       //封装了实例化流程       public SqlSessionFactory getObject() throws Exception {          if (this.sqlSessionFactory == null) {            //实例化对象逻辑            afterPropertiesSet();          }          //返回对象逻辑          return this.sqlSessionFactory;       }}\nmybatis 整合思路总结：\n\n需要将 SqlSessionFactory 和 Mapper 实例加入到 IoC 容器\n使用 mybatis 整合包提供的 FactoryBean 快速整合\n\n准备外部配置文件\n\n数据库连接信息 位置：resources/jdbc.properties\n\njdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql:///mybatis-examplejdbc.driver=com.mysql.cj.jdbc.Driver\n整合方式 2（完全配置类 去掉\nmybatis-config.xml）\n\n介绍\n不在保留 mybatis 的外部配置文件（xml）,\n所有配置信息（settings、插件、别名等）全部在声明 SqlSessionFactoryBean\n的代码中指定！数据库信息依然使用 DruidDataSource 实例替代！\n\n优势：全部配置类，避免了 XML 文件解析效率低问题！\nmapper 配置类\n/** * projectName: com.atguigu.config * * description: 持久层配置和Druid和Mybatis配置 使用一个配置文件 */@Configuration@ComponentScan(\"org.example.mapper\")public class MapperJavaConfigNew {    /**     * 配置SqlSessionFactoryBean,指定连接池对象和外部配置文件即可     * @param dataSource 需要注入连接池对象     * @return 工厂Bean     */    @Bean    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){        //实例化SqlSessionFactory工厂        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();        //设置连接池        sqlSessionFactoryBean.setDataSource(dataSource);        //settings [包裹到一个configuration对象,切记别倒错包]        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();        configuration.setMapUnderscoreToCamelCase(true);        configuration.setLogImpl(Slf4jImpl.class);        configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL);        sqlSessionFactoryBean.setConfiguration(configuration);        //typeAliases        sqlSessionFactoryBean.setTypeAliasesPackage(\"com.atguigu.pojo\");        //分页插件配置        PageInterceptor pageInterceptor = new PageInterceptor();        Properties properties = new Properties();        properties.setProperty(\"helperDialect\",\"mysql\");        pageInterceptor.setProperties(properties);        sqlSessionFactoryBean.addPlugins(pageInterceptor);        return sqlSessionFactoryBean;    }    /**     * 配置Mapper实例扫描工厂,配置 &lt;mapper &lt;package 对应接口和mapperxml文件所在的包     * @return     */    @Bean    public MapperScannerConfigurer mapperScannerConfigurer(){        MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer();        //设置mapper接口和xml文件所在的共同包        mapperScannerConfigurer.setBasePackage(\"com.atguigu.mapper\");        return mapperScannerConfigurer;    }}\n\n\n2.5 容器初始化配置类\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {  //指定root容器对应的配置类  @Override  protected Class&lt;?&gt;[] getRootConfigClasses() {    return new Class&lt;?&gt;[] {MapperJavaConfig.class, ServiceJavaConfig.class, DataSourceJavaConfig.class };  }  //指定web容器对应的配置类  @Override  protected Class&lt;?&gt;[] getServletConfigClasses() {    return new Class&lt;?&gt;[] { WebJavaConfig.class };  }  //指定dispatcherServlet处理路径，通常为 /  @Override  protected String[] getServletMappings() {    return new String[] { \"/\" };  }}\n2.6 整合测试\n\n需求\n查询所有员工信息,返回对应 json 数据！\ncontroller\n@Slf4j@RestController@RequestMapping(\"/employee\")public class EmployeeController {    @Autowired    private EmployeeService employeeService;    @GetMapping(\"list\")    public List&lt;Employee&gt; retList(){        List&lt;Employee&gt; employees = employeeService.findAll();        log.info(\"员工数据:{}\",employees);        return employees;    }}\nservice \n@Servicepublic class EmployeeServiceImpl implements EmployeeService {    @Autowired    private EmployeeMapper employeeMapper;    /**     * 查询所有员工信息     */    @Override    public List&lt;Employee&gt; findAll() {        List&lt;Employee&gt; employeeList =  employeeMapper.queryAll();        return employeeList;    }}\nmapper\nmapper 接口 包：com.atguigu.mapper \npublic interface EmployeeMapper {     List&lt;Employee&gt; queryAll();}\nmapper XML 文件位置： resources/mappers\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=\"com.atguigu.mapper.EmployeeMapper\"&gt;    &lt;select id=\"queryAll\" resultType=\"employee\"&gt;        &lt;!-- #{empId}代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;        select emp_id empId,emp_name empName, emp_salary empSalary from t_emp    &lt;/select&gt;&lt;/mapper&gt;\n\n三、《任务列表案例》前端程序搭建和运行\n3.1 整合案例介绍和接口分析\n3.1.1 案例功能预览\n\n3.1.2 接口分析\n\n学习计划分页查询\n/*需求说明    查询全部数据页数据请求uri    schedule/{pageSize}/{currentPage}请求方式    get响应的json    {        \"code\":200,        \"flag\":true,        \"data\":{            //本页数据            data:            [            {id:1,title:'学习java',completed:true},            {id:2,title:'学习html',completed:true},            {id:3,title:'学习css',completed:true},            {id:4,title:'学习js',completed:true},            {id:5,title:'学习vue',completed:true}            ],            //分页参数            pageSize:5, // 每页数据条数 页大小            total:0 ,   // 总记录数            currentPage:1 // 当前页码        }    }*/\n学习计划删除\n/*需求说明    根据id删除日程请求uri    schedule/{id}请求方式    delete响应的json    {        \"code\":200,        \"flag\":true,        \"data\":null    }*/\n学习计划保存\n/*需求说明    增加日程请求uri    schedule请求方式    post请求体中的JSON    {        title: '',        completed: false    }响应的json    {        \"code\":200,        \"flag\":true,        \"data\":null    }*/\n学习计划修改\n/*需求说明    根据id修改数据请求uri    schedule请求方式    put请求体中的JSON    {        id: 1,        title: '',        completed: false    }响应的json    {        \"code\":200,        \"flag\":true,        \"data\":null    }*/\n\n3.2 前端工程导入\n3.2.1 前端环境搭建\n\nNode.js 是前端程序运行的服务器，类似 Java 程序运行的服务器 Tomcat Npm\n是前端依赖包管理工具，类似 maven 依赖管理工具软件\n\n\nnode 安装\n课程 node 版本：16.16.0\nhttps://nodejs.org/download/release/v16.16.0/\nnode 安装和测试：\n\n打开官网 https://nodejs.org/en/\n下载对应操作系统的 LTS 版本。（16.16.0）\n[node-v16.16.0-x64.msi](file/node-v16.16.0-x64_NU23iPcrzB.msi ”\nnode-v16.16.0-x64.msi”)\n双击安装包进行安装，安装过程中遵循默认选项即可。安装完成后，可以在命令行终端输入\nnode -v 和 npm -v 查看 Node.js 和 npm\n的版本号。\n\nnpm 使用 （maven）\n\nNPM 全称 Node Package Manager，是 Node.js 包管理工具，相当于后端的\nMaven。\n\n配置阿里镜像\nnpm config set registry https://registry.npmjs.org/\n更新 npm 版本 node16.16.0 对应的 npm 版本过低！需要升级！\nnpm install -g npm@9.6.6\nnpm 依赖下载命令\nnpm install 依赖名 / npm install 依赖名@版本\n\n\n安装 vscode \n[VSCodeUserSetup-x64-1.74.0.exe](file/VSCodeUserSetup-x64-1.74.0_byHx-Ntjau.exe\n” VSCodeUserSetup-x64-1.74.0.exe”)\n\n3.2.2 导入前端程序\n3.3 启动测试\nnpm install //安装依赖npm run dev //运行测试\n四、《任务列表案例》后端程序实现和测试\n4.1 准备工作\n\n准备数据库脚本\nCREATE TABLE schedule (  id INT NOT NULL AUTO_INCREMENT,  title VARCHAR(255) NOT NULL,  completed BOOLEAN NOT NULL,  PRIMARY KEY (id));INSERT INTO schedule (title, completed)VALUES    ('学习java', true),    ('学习Python', false),    ('学习C++', true),    ('学习JavaScript', false),    ('学习HTML5', true),    ('学习CSS3', false),    ('学习Vue.js', true),    ('学习React', false),    ('学习Angular', true),    ('学习Node.js', false),    ('学习Express', true),    ('学习Koa', false),    ('学习MongoDB', true),    ('学习MySQL', false),    ('学习Redis', true),    ('学习Git', false),    ('学习Docker', true),    ('学习Kubernetes', false),    ('学习AWS', true),    ('学习Azure', false);\n准备 pojo\n包：com.atguigu.pojo\n@Datapublic class Schedule {    private Integer id;    private String title;    private Boolean completed;}\n准备\n包：com.atguigu.utils\n@Datapublic class R {    private int code = 200; //200成功状态码    private boolean flag = true; //返回状态    private Object data;  //返回具体数据    public static R ok(Object data){        R r = new R();        r.data = data;        return r;    }    public static R  fail(Object data){        R r = new R();        r.code = 500; //错误码        r.flag = false; //错误状态        r.data = data;        return r;    }}\n准备 PageBean\n包：com.atguigu.utils\n@Data@NoArgsConstructor@AllArgsConstructorpublic class PageBean&lt;T&gt; {    private int currentPage;   // 当前页码    private int pageSize;      // 每页显示的数据量    private long total;    // 总数据条数    private List&lt;T&gt; data;      // 当前页的数据集合}\n\n4.2 功能实现\n\n分页查询\n\ncontroller\n/*    @CrossOrigin 注释在带注释的控制器方法上启用跨源请求 */@CrossOrigin@RequestMapping(\"schedule\")@RestControllerpublic class ScheduleController{    @Autowired    private ScheduleService scheduleService;    @GetMapping(\"/{pageSize}/{currentPage}\")    public R showList(@PathVariable(name = \"pageSize\") int pageSize, @PathVariable(name = \"currentPage\") int currentPage){        PageBean&lt;Schedule&gt; pageBean = scheduleService.findByPage(pageSize,currentPage);        return  R.ok(pageBean);    }}\nservice\n@Slf4j@Servicepublic class ScheduleServiceImpl  implements ScheduleService {    @Autowired    private ScheduleMapper scheduleMapper;    /**     * 分页数据查询,返回分页pageBean     *     * @param pageSize     * @param currentPage     * @return     */    @Override    public PageBean&lt;Schedule&gt; findByPage(int pageSize, int currentPage) {        //1.设置分页参数        PageHelper.startPage(currentPage,pageSize);        //2.数据库查询        List&lt;Schedule&gt; list = scheduleMapper.queryPage();        //3.结果获取        PageInfo&lt;Schedule&gt; pageInfo = new PageInfo&lt;&gt;(list);        //4.pageBean封装        PageBean&lt;Schedule&gt; pageBean = new PageBean&lt;&gt;(pageInfo.getPageNum(),pageInfo.getPageSize(),pageInfo.getTotal(),pageInfo.getList());        log.info(\"分页查询结果:{}\",pageBean);        return pageBean;    }}\nmapper\nmapper 接口\npublic interface ScheduleMapper {    List&lt;Schedule&gt; queryPage();}\nmapperxml 文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"        \"https://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;&lt;mapper namespace=\"com.atguigu.mapper.ScheduleMapper\"&gt;    &lt;select id=\"queryPage\" resultType=\"schedule\"&gt;        select * from schedule    &lt;/select&gt;&lt;/mapper&gt;\n\n计划添加\n\ncontroller\n@PostMappingpublic R saveSchedule(@RequestBody Schedule schedule){    scheduleService.saveSchedule(schedule);    return R.ok(null);}\nservice\n/** * 保存学习计划 * * @param schedule */@Overridepublic void saveSchedule(Schedule schedule) {    scheduleMapper.insert(schedule);}\nmapper\nmapper 接口\nvoid insert(Schedule schedule);\nmapperxml 文件\n&lt;insert id=\"insert\"&gt;    insert into schedule (title, completed)    values    (#{title}, #{completed});&lt;/insert&gt;\n\n计划删除\n\ncontroller\n@DeleteMapping(\"/{id}\")public R removeSchedule(@PathVariable Integer id){    scheduleService.removeById(id);    return R.ok(null);   }\nservice\n/** * 移除学习计划 * * @param id */@Overridepublic void removeById(Integer id) {    scheduleMapper.delete(id);}\nmapper mapper 接口\nvoid delete(Integer id);\nmapperxml 文件\n&lt;delete id=\"delete\"&gt;    delete from schedule where id = #{id}&lt;/delete&gt;\n\n计划修改\n\ncontroller\n@PutMapping    public R changeSchedule(@RequestBody Schedule schedule){    scheduleService.updateSchedule(schedule);    return R.ok(null);}\nservice\n/** * 更新学习计划 * * @param schedule */@Overridepublic void updateSchedule(Schedule schedule) {    scheduleMapper.update(schedule);}\nmapper mapper 接口\nvoid update(Schedule schedule);\nmapperxml 文件\n&lt;update id=\"update\"&gt;    update schedule set title = #{title} , completed = #{completed}         where id = #{id}&lt;/update&gt;\n\n\n4.3 前后联调\n\n后台项目根路径设计\n启动测试即可\n\n","categories":["后端","Spring"],"tags":["SSM"]},{"title":"Shell 基础","url":"/2025/04/22/Shell-%E5%9F%BA%E7%A1%80/","content":"Shell\n脚本基础语法概述，涵盖变量定义、环境变量、内建命令与条件判断等核心内容，系统梳理常见语法结构及其使用方式，为后续脚本编写与自动化任务奠定基础。\n\n基础语法\nhello world\n不管写啥，上来先输出个hello world。\n#!/bin/bashecho \"hello world\"\n创建一个文件hello.sh\n包含以上内容，同时赋予执行权限，然后执行，一个hello world\n就好了。\n# 添加执行权限$ chmod +x hello.sh$ ./hello.shhello world\n解释器\n我们看到这个hello.sh 脚本，第一行有个\n#!/bin/bash 。 这个是用来指定该脚本在 UNIX/Linux\n下执行时用到的解释器。\n执行cat /etc/shells\n我们可以看到自己的系统中都有哪些解释器。如我的：\n$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/bin/zsh/usr/bin/zsh/usr/bin/tmux\n注释\n用 # 来注释。\n#!/bin/bash# 这是注释echo \"hello world\"\n变量声明\nBash 中变量命名是大小写敏感的，很多喜欢全大写。当然你也可以使用\n小写英文字母，数字和下划线，但不能以数字开头。 给变量赋值的时候\n= 号前后不能有空格。\n# 有效的FIRSTLETTERS=\"ABC\"FIRST_THREE_LETTERS=\"ABC\"firstThreeLetters=\"ABC\"MY_SHELL=\"bash\"my_another_shell=\"my another shell\"My_Shell=\"My shell\"_myshell=\"My shell\"# 无效的3LETTERS=\"ABC\"first-three-letters=\"ABC\"first@Thtree@Letters=\"ABC\"ABC = \"ABC \"MY_SHELL = \"bash\"My-SHELL=\"bash\"1MY_SHELL=\"My shell\"\n变量引用\n当你要使用变量的时候，用 $ 来引用，\n如果后面要接一些其他字符，可以用{} 括起来。\n#!/bin/bashWORLD=\"world world\"echo \"hello $WORLD\"  # hello world worldecho \"hello ${WORLD}2\" # hello world world2\n在 Bash 中要注意 单引号 ' , 双引号 \"\n,反引号 ` 的区别。\n单引号，双引号都能用来保留引号内的为文字值，其差别在于，双引号在遇到\n$(参数替换) , 反引号 `(命令替换)\n的时候有例外，单引号则剥夺其中所有字符的特殊含义。\n而反引号的作用 和 $() 是差不多的。\n在执行一条命令的时候，会先执行其中的命令，再把结果放到原命令中。\n#!/bin/bashvar=\"music\"sports='sports'echo \"I like $var\"   # I like musicecho \"I like ${var}\" # I like musicecho I like $var     # I like musicecho 'I like $var'   # I like $varecho \"I like \\$var\"  # I like $varecho 'I like \\$var'  # I like \\$varecho `bash -version` # GNU bash, version 5.0.17(1)-release (x86_64-pc-linux-gnu)...echo 'bash -version' # bash -version\n环境变量\nLinux\n的环境变量包含了存储在系统中的信息。我们可以在终端中找到一些环境变量。\n你可以在脚本中引用这些环境变量。\n#!/bin/bashecho $SHELL, $USER, $HOME # /usr/bin/zsh, razeen, /home/razeen\n这里\n还有更多。\n内部变量\nBash 的内部变量也不少，有时我们可能会用到，如 $BASHPID\n$IFS $PWD 等，更多看这里\n。\n将命令输出分配给变量\n可以使用 $(command)\n将命令输出存储在变量中。例如这是一个info.sh脚本内容:\n#!/bin/bashLIST=$(ls -l)echo \"File information: $LIST\"\n执行（别忘了给执行权限）\n$ ./info.shFile information: total 8-rwxrwxr-x 1 razeen razeen 85 2月   5 07:35 hello.sh-rwxrwxr-x 1 razeen razeen 58 2月   5 07:36 info.sh\n下面的脚本会将时间和日期，用户名以及系统正常运行时间保存到日志文件中。\n其中 &gt; 是重定向之一，它将覆盖文件。使用\n&gt;&gt; 可以将输出追加到文件。\n#!/bin/bashDATE=$(date -u) # UTC 时间#!/bin/bashDATE=$(date -u) # UTC 时间WHO=$(whoami) # 用户名UPTIME=$(uptime) # 系统运行时间echo \"Today is $DATE. You are $WHO. Uptime info: $UPTIME\" &gt; logfileWHO=$(whoami) # 用户名UPTIME=$(uptime) # 系统运行时间echo \"Today is $DATE. You are $WHO. Uptime info: $UPTIME\" &gt; logfile\n内建命令\nShell\n内建命令是可以直接在Shell中运行的命令。可以这么查看内建命令：\n$ compgen -b | sort-.:[aliasautoloadbgbindkeybreakbuiltinbyecd\n也可以用 type 查看命令的类型。\n$ type cdcd is a shell builtin\n可以用 which 命令查看可执行文件的文件路径：\n# which sort/usr/bin/sort\n可通过 man builtins 查看内建命令的详细描述。\n测试\nIF条件表达式\nif 后面需要接者then：\nif [ condition-for-test ]then  command  ...fi\n或者，\nif [ condition-for-test ]; then  command  ...fi\n如：\n#!/bin/bash VAR=myvarif [ $VAR = myvar ]; then    echo \"1: \\$VAR is $VAR\"   # 1: $VAR is myvarfiif [ \"$VAR\" = myvar ]; then    echo \"2: \\$VAR is $VAR\"   # 2: $VAR is myvarfiif [ $VAR = \"myvar\" ]; then    echo \"3: \\$VAR is $VAR\"   # 3: $VAR is myvarfiif [ \"$VAR\" = \"myvar\" ]; then    echo \"4: \\$VAR is $VAR\"   # 4: $VAR is myvarfi\n上面，我们在比较时，可以用双引号把变量引用起来。\n但要注意单引号的使用。\n#!/bin/bashVAR=myvarif [ '$VAR' = 'myvar' ]; then    echo '5a: $VAR is $VAR'else    echo \"5b: Not equal.\"fibas# Output:# 5b: Not equal.\n上面这个就把 ‘$VAR’ 当一个字符串了。\n但如果变量是多个单词，我们就必须用到双引号了，如\n#!/bin/bash# 这样写就有问题VAR1=\"my var\"if [ $VAR1 = \"my var\" ]; then    echo \"\\$VAR1 is $VAR1\"fi# Output# error [: too many arguments# 用双引号if [ \"$VAR1\" = \"my var\" ]; then    echo \"\\$VAR1 is $VAR1\"fi\n总的来说，双引号可以一直加上。\n空格问题\n比较表达式中，如果=前后没有空格，那么整个表法式会被认为是一个单词，其判断结果为True.\n#!/bin/bash VAR2=2#  由于被识别成一个单词， [] 里面为 trueif [ \"$VAR2\"=1 ]; then    echo \"$VAR2 is 1.\"else    echo \"$VAR2 is not 1.\"fi# Output# 2 is 1.# 前后加上空格就好了if [ \"$VAR2\" = 1 ]; then    echo \"$VAR2 is 1.\"else    echo \"$VAR2 is not 1.\"fi# Output# 2 is not 1.\n另外需要注意的是， 在判断中，中括号 [\n和变量之间一定要有一个空格，= 或者 ==。\n如果缺少了空格，你可能会到这类似这样的错误：unary operator expected’ or missing\n]` 。\n# 正确， 符号前后有空格if [ $VAR2 = 1 ]; then    echo \"\\$VAR2 is 1.\"else    echo \"It's not 1.\"fi# Output# 2 is 1.# 错误， 符号前后无空格if [$VAR2=1]; then    echo \"$VAR2 is 1.\"else    echo \"It's not 1.\"fi# Output# line 3: =1: command not found# line 5: [=1]: command not found# It's not 1.\n文件测试表达式\n对文件进行相关测试，判断的表达式如下：\n\n\n\n表达式\nTrue\n\n\n\n\nfile1 -nt file2\nfile1 比 file2 新。\n\n\nfile1 -ot file2\nfile1 比 file2 老。\n\n\n-d file\n文件file存在，且是一个文件夹。\n\n\n-e file\n文件 file 存在。\n\n\n-f file\n文件file存在，且为普通文件。\n\n\n-L file\n文件file存在，且为符号连接。\n\n\n-O file\n文件 flle 存在, 且由有效用户ID拥有。\n\n\n-r file\n文件 flle 存在, 且是一个可读文件。\n\n\n-s file\n文件 flle 存在, 且长度大于0。\n\n\n-w file\n文件 flle 可写入。\n\n\n-x file\n文件 flle 可写执行。\n\n\n\n可以使用man test查看那详细的说明。\n当表达式为True时，测试命令返回退出状态\n0，而表达式为False时返回退出状态1。\n#!/bin/bashFILE=\"/etc/resolv.conf\"if [ -e \"$FILE\" ]; then  if [ -f \"$FILE\" ]; then      echo \"$FILE is a file.\"  fi  if [ -d \"$FILE\" ]; then      echo \"$FILE is a directory.\"  fi  if [ -r \"$FILE\" ]; then      echo \"$FILE is readable.\"  fifi\n字符串比较表达式\n\n\n\n\n\n\n\n表达式\nTrue\n\n\n\n\nstring1 = string2 或 string1 == string2\n两字符相等\n\n\nstring1 != string2\n两个字符串不相等\n\n\nstring1 &gt; string2\nstring1 大于 string2.\n\n\nstring1 &lt; string2\nstring1 小于string2.\n\n\n-n string\n字符串长度大于0\n\n\n-z string\n字符串长度等于0\n\n\n\n#!/bin/bashSTRING=\"\"if [ -z \"$STRING\" ]; then  echo \"There is no string.\" &gt;&amp;2   exit 1fi# Output# There is no string.\n其中&gt;&amp;2将错误信息定位到标准错误输出。\n数字比较表达式\n下面这些是用来比较数字的一些表达式。\n\n\n\n\n\n\n\n\n[…]\n((…))\nTrue\n\n\n\n\n[ “int1” -eq “int2” ]\n(( “int1” == “int2” ))\n相等.\n\n\n[ “int1” -nq “int2” ]\n(( “int1” != “int2” ))\n不等.\n\n\n[ “int1” -lt “int2” ]\n(( “int1” &lt; “int2” ))\nint2 大于 int1.\n\n\n[ “int1” -le “int2” ]\n(( “int1” &lt;= “int2” ))\nint2 大于等于 int1.\n\n\n[ “int1” -gt “int2” ]\n(( “int1 &gt; “int2” ))\nint1 大于 int2\n\n\n[ “int1” -ge “int2” ]\n(( “int1 &gt;= “int2” ))\nint1 大于等于 int2\n\n\n\n双括号 (())\n数值的比较或者计算可以用((... ))。\n#!/bin/basha=3b=4c=3if ((\"$a\" &lt; \"$b\")); then    echo \"$a is less than $b.\"else    echo \"$a is not less than $b.\"fiif ((\"$a\" != \"$c\")); then    echo \"$a is not equal to $c.\"else    echo \"$a is equal to $c.\"fi# 计算echo \"$a + $b = $(($a + $b))\"# Output# 3 is less than 4.# 3 is equal to 3.# 3 + 4 = 7\n怎么使用 if/else 和\nif/elif/else\n其实上面已经展示了不少了，这里总结下if...else 和\nif...elif...else 语句。\nif/else 语句格式如下：\nif [ condition-is-true ]then  command Aelse  command Bfi# 或if [ condition-is-true ]; then  command Aelse  command Bfi\n例如:\n#!/bin/bashMY_SHELL=\"csh\"if [ \"$MY_SHELL\" = \"bash\" ]then  echo \"You are using the bash shell.\"else  echo \"You are not using the bash shell.\"fi\nif/elif/else 语句格式如下：\nif [ condition-is-true ]then  command Aelif [ condition-is-true ]then  command Belse  command Cfi# orif [ condition-is-true ]; then  command Aelif [ condition-is-true ]; then  command Belse  command Cfi\n如:\n#!/bin/bashMY_SHELL=\"csh\"if [ \"$MY_SHELL\" = \"bash\" ]; then  echo \"You are using the bash shell.\"elif [ \"$MY_SHELL\" = \"csh\" ]; then  echo \"You are using csh.\"else  echo \"You are not using the bash shell.\"fi\n双中括号的使用[[]]\n如用用于比较的变量不是单个单词，就需要[[]] ,\n或者用单中括号(这时需要加双引号)。\n在平常的使用中，最好都使用[[]]。\n与单中括号相比，双中括号具有其他功能。\n如，可以对其中正则使用逻辑&amp;&amp;和||和=〜。\n#!/bin/bashVAR1=\"variable\"VAR2=\"variable 2\"if [[ (VAR1 == \"variable\")  ]]; then    echo \"They are the same.\"else    echo \"Not the same.\"fi# 使用 &amp;&amp;[[ ($VAR1 == variable) &amp;&amp; ($VAR2 == \"variable 2\") ]] &amp;&amp; echo \"They are the same again.\"\n#!/bin/bashdigit=4if [[ $digit =~ [0-9] ]]; then    echo \"$digit is a digit\"else    echo \"$digit isn't a digit\"filetter=\"abc\"if [[ $letter =~ [0-9] ]]; then    echo \"$letter is a digit\"else    echo \"$letter isn't a digit\"fi# Output# 4 is a digit# abc isn't a digit\n怎么使用 For 循环\nfor循环的使用如下：\nfor VARIABLE_NAME in ITEM_1 ITEM_Ndo  command Adone\n例如:\n#!/bin/bashfor COLOR in red green bluedo  echo \"COLOR: $COLOR\"done# Output# COLOR: red# COLOR: green# COLOR: blue\n可以在其中使用变量，如下：\n#!/bin/bashCOLORS=\"red green blue\"for COLOR in $COLORSdo  echo \"COLOR: $COLOR\"done\n用 for 循环重命名文件\n我们举个简单的例子，用for循环重命名当前目录下的jpg图片。\n#!/bin/bashIMGS=$(ls *jpg)DATE=$(date +%F)for IMG in $IMGSdo  echo \"Renaming ${IMG} to ${DATE}-${IMG}\"  mv ${IMG} ${DATE}-${IMG}done\n怎么传参\n执行脚本的时候，后面可以跟着很多参数，如：\n$ scriptname param1 param2 param3\nparam1 到 param3 称为可选参数，\n可以在脚本中用 $0, $1,\n$2等，来引用这些参赛。例如:\n#!/bin/bashecho \"'\\$0' is $0\"echo \"'\\$1' is $1\"echo \"'\\$2' is $2\"echo \"'\\$3' is $3\"\n输出:\n$ ./param.sh'$0' is ./param.sh'$1' is'$2' is'$3' is\n$0 参数0返回的是当前执行文件的名字，包括路径。\n可以用 $@ 接受所以的参数。\n#!/bin/bashfor PARAM in $@do  echo \"Param is: $PARAM\"done\nUsing this script:\n$ ./params.sh a b c d e fParam is: aParam is: bParam is: cParam is: dParam is: eParam is: f\n怎么接收用户输入\n用户输入称为STDIN。可以将read命令与-p（提示）选项一起使用来读取用户输入，它将输出提示字符串。\n-r 选项不允许反斜杠转义任何字符。\nread -rp \"PROMPT\" VARIABLE\n例如:\n#!/bin/bashread -rp \"Enter your programming languages: \" PROGRAMMESecho \"Your programming languages are: \"for PROGRAMME in $PROGRAMMES; do    echo \"$PROGRAMME \"done\n运行:\n$ ./read.shEnter your programming languages: go pyYour programming languages are:gopy\n用大括号来表示范围 {}\n如下所示，我们可以用大括号来表所一个数字或字母的范围。\n$ echo {0..3}$ echo {a..d}# output: # 0 1 2 3# a b c d\n你也可以在 for 循环中这么使用:\n#!/bin/bashfor i in {0..9}; do   touch file_\"$i\".txt; done\nThis will create different file names with different modification\ntimes.\n$ ls -al file_*-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_0.txt-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_1.txt-rw-rw-r-- 1 razeen razeen 0 2月  14 09:54 file_2.txt...\n怎么使用While\n当 While 后的表达式结果为 true时，执行循环内语句。\n#!/bin/bashi=1while [ $i -le 5 ]; do  echo $i  ((i++))done\nOutput:\n12345\n退出码/返回码 是什么？\n每个命令都返回退出状态，范围为0-255。 0代表成功，非0代表错误。\n可以用来进行错误检查。\n\n\n\n数值\n含义\n\n\n\n\n0\n成功\n\n\n2\n返回内置命令，从而提示错误\n\n\n126\n命令找到了，但不是可执行的\n\n\n127\n没有找到命令\n\n\n128+N\n由于接收到信号N，命令退出\n\n\n\n怎么检查退出码\n$? 包含了上一条命令执行的返回码。\n$ ls ./no/existls: cannot access './no/exist': No such file or directory$ echo \"$?\"2\n如，在if表达式中检查返回码:\n#!/bin/bashHOST=\"razeen.me\"ping -c 1 $HOSTRETURN_CODE=$?if [ \"$RETURN_CODE\" -eq \"0\" ]; then    echo \"$HOST reachable.\"else    echo \"$HOST unreachable.\"fi\n-c 1 参数表示发送一个可达包就停止发送。\n然后我们检查一下ping执行的返回码。\n输出:\n$ ./ex.shPING razeen.me (47.108.161.7) 56(84) bytes of data.64 bytes from 47.108.161.7 (47.108.161.7): icmp_seq=1 ttl=50 time=38.5 ms--- razeen.me ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 38.541/38.541/38.541/0.000 msrazeen.me reachable.\n怎么连接多个命令\n逻辑运算符和命令退出状态\n执行命令后都有退出状态，我们可以使用 &amp;&amp; 和\n||去决定下一步。\n退出命令\n你可以使用 exit 来决定退出码：\nexit 0exit 1exit 2etc.\n例如:\n#!/bin/bashHOST=\"razeen.me\"ping -c 1 $HOST  if [ \"$?\" -ne \"0\" ]then  echo \"$HOST unreachable.\"  exit 1fiexit 0\n我们可以将该脚本通过&amp;&amp;与其他脚本/命令连接。\n$ ./ex2.sh &amp;&amp; ls....2021-02-13-132m93.jpg   ex2.sh      file_1.txt  file_4.txt  \n如果./ex2.sh返回状态码非0，后面的就不会执行。\n逻辑与 (&amp;&amp;)\n当&amp;&amp;前面的语句返回的状态码为0时，执行后面的语句。\nmkdir /tmp/bak &amp;&amp; cp test.txt /tmp/bak\n逻辑或 (||)\n当||前面的语句返回的状态码非0时（也就是执行失败），执行后面的语句。\ncp test.txt /tmp/bak/ || cp test.test.txt /tmp\n例如：\n如果ping通了，就执行后面的输出。\n#!/bin/bashhost=\"razeen.me\"ping -c 1 $host &amp;&amp; echo \"You can reach ${host}.\"\n如果ping失败了，就执行后面的输出。\n#!/bin/bashhost=\"google.com\"ping -c 1 $host || echo \"You can't reach ${host}.\"\n分号 (;)\n分号不是一个逻辑运算符，但你可以用它来分割语句。\ncp text.txt /tmp/bak/ ; cp test.txt /tmp# 等同于cp text.txt /tmp/bak/  cp test.txt /tmp\n管道 |\n管道|两侧的命令在各自的子shell中运行，并且两者同时启动。\n如下：\n第一个命令将目录更改为主目录，并列出文件和目录。\n第二个命令仅显示执行该命令的文件和目录。\n$ echo \"$(cd ~ &amp;&amp; ls)\"$ echo \"$(cd ~ | ls)\"\n函数\n在Bash中，你可以使用function或者直接定义一个函数。\nfunction function-name(){}# 或function-name(){}\n当你调用函数的时候，只需要函数名，不用带()。\n#!/bin/bashfunction hello(){  echo \"Hello!\"}# 正确hello# 错误# hello()\n在函数中，可以调用其他函数。\n#!/bin/bashfunction hello(){  echo \"Hello!\"  now  bye}function now(){  echo \"It's $(date +%r)\"}function bye(){  echo \"Bye bye.\"}hello# Output# Hello!# It's 09:29:44 PM# Bye bye.\n但，需要注意函数的定义顺序。如果你在函数声明的前就去调用函数，函数就不会执行。如下，\n在hello中执行now函数，但now是定义hello执行下面的，结果就会出错。\n#!/bin/bash# this won't workfunction hello(){  echo \"Hello!\"  now}hellofunction now(){  echo \"It's $(date +%r)\"}\n输出：\n$ ./hello2.shHello!./hello2.sh: line 5: now: command not found\n函数传参\n和脚本执行的时候传参一样，函数的参数也用$1…,$@\n来输出。\n注意$0这里并不是函数的名字，而是当前脚本的名字。\n$N是第N个参数，$@表示所有的参数。\n#!/bin/bashfunction fullname(){  echo \"$0\"  echo \"My name is $1 $2\"}fullname Razeen Cheng# Output# ./func.sh# My name is Razeen Cheng\n#!/bin/bashfunction greeting(){  for NAME in $@  do    echo \"Hi $NAME.\"  done}greeting Tom Jerry\n变量的作用域\n默认变量的作用域是全局的，必须先声明，后使用。\n当然，最好在最上面就把需要的变量声明好。\n#!/bin/bashmy_func() {  GLOBAL_VAR=1}# 这时，变量还是空的echo \"Calling GLONAL_VAR before calling function my_func\"# echo $GLOBAL_VAR# 声明后，就可以输出了my_funcecho \"Calling GLONAL_VAR after calling function my_func\"echo $GLOBAL_VAR\n局部变量\n可以用local来定义局部变量，且只能在函数中使用。\n#!/bin/bash MY_VAR=1my_func () {  local MY_VAR=2  echo \"my_func: MY_VAR=$MY_VAR\" }echo \"global: MY_VAR=$MY_VAR\"my_func\n函数返回码\n你可以在函数中，指定返回码:\nreturn 0\n函数中最后执行的命令的退出状态将隐式返回。\n有效代码范围为0-255。0代表成功，$?可以显示退出码。\n$ my_function$ echo $?0\n可以在if 判断中用$? ：\n#!/bin/bash# 该函数用来创建一个备份文件function backup_file () {    local BACK # 声明局部变量    if [[ -f $1 ]];then # 检查参数（是否是文件）        BACK=\"/tmp/$(basename \"$1\").$(date +%F).$$\"        echo \"Backing up $1 to $BACK\"        cp \"$1\" \"$BACK\"    else        # 文件不存在.        return 1    fi}# 调用函数if [[ \"$1\" ]]; then    backup_file \"$1\"    # if [[ $? -eq 0 ]]; then    if [[ $(backup_file \"$1\") -eq 0 ]]; then        echo \"Backup succeeded.\"        exit 0    else        echo \"Backup failed.\"        # 备份失败，中断，并返回非0状态.        exit 1    fielse    backup_file /etc/hosts    echo \"/etc/hosts Backup succeeded.\"    exit 0fi\n上面这个脚本默认备份/etc/hosts文件，除非你制定一个文件外。如果你指定一个文件参数，他会先检查文件，然后备份到/tmp目录。\n$$ 返回 当前脚本执行的PID.\n每次运行PID都会发生变化。当你需要多次运行脚本时，或许对你有帮助。\nbasename ${1} 可以从你输入的路径中提取文件的名字. 如\nbasename /etc/hosts 是 hosts.\n$ ls /tmp$ ex1           Backing up /etc/hosts to /tmp/hosts.2020-10-04.77124Backup succeeded.$ ls /tmphosts.2020-10-04.77124\n关键字 exit 和 return\nreturn 会跳出当前函数,\nexit会结束当前脚本。\n内置变量\n在 Bash\n解释器中，内置了许多变量，这些变量的功能是解释器自带的，我们在编写shell脚本时如果能灵活的使用它们，对脚本的编写效率以及差错大有帮助,\n下面一一介绍这些变量\nFUNCNAME和LINENO变量经常用于脚本的调试\nFUNCNAME表示当前函数的名字，作用范围仅限函数中使用，在函数外无值\nLINENO表示当前所在脚本中变量出现在的行号\nPWD表示当前目录, 对应于 pwd命令\n现有个脚本 a.sh内容如下\n 1 #!/bin/bash 2 3  4 testa() 5 { 6  echo 'func='$FUNCNAME,$LINENO 7 } 8  9 10 testa11 12 echo 'lineno:'$LINENO13 echo 'xx:'$FUNCNAME14 echo 'curpath:'$PWD\n执行 ./a.sh命令, 输出如下\n[tt@ecs-centos-7 ~]$ ./a.sh func=testa,6lineno:12xx:curpath:/home/tt\n在 testa函数中 FUNCNAME变量值是\ntesta，也即函数名字，在函数外部无值\nLINENO变量无论是在函数中还是函数外，都表示当前所在的行号\n$、PPID\n这两个变量依次表示当前进程ID和父进程ID\n现有 a.sh脚本，内容如下\nsleep 20睡眠语句是为了让执行脚本进程暂缓退出，在另一个终端中验证输出的结果\n#!/bin/bash#set -uecho 'cur pid:'$$echo 'parent pid:'$PPIDsleep 20\n在当前终端执行 ./a.sh，结果如下\n[tt@ecs-centos-7 ~]$ ./a.sh cur pid:13095parent pid:12982\n在执行a.sh的脚本进程退出之前，打开另一个终端，执行\nps -o pid,ppid,time,cmd -p 12982,13095命令，结果如下\n[tt@ecs-centos-7 ~]$ ps -o pid,ppid,time,cmd -p 12982,13095  PID  PPID     TIME CMD12982 12981 00:00:00 -bash13095 12982 00:00:00 /bin/bash ./a.sh\n从上面的结果可以看出, 执行 ./a.sh命令之后，$$\n变量表示的是 执行a.sh脚本的进程ID 13095 ，而 12982\n是它的父进程ID，也即是 PPID变量的值，它是当前bash的实例\n0,1,2 … n,\n$#表示从命令行传入脚本的参数数量\n$0,$1,$2...$n是从命令行传递到脚本的参数\n$0是脚本本身的名字 $1是第一个参数\n$2是第二个参数，依此类推 $n是第n个参数\n第十个参数及以后的参数必须要用大括号括起来，例如: 、{12}\n依次表示第十一个变量、第十二个变量\n*\n都表示位置参数，不过它们之间也有些不同点\n使用 $*时，如果加上双引号，即 “的形式，那所有位置的参数会被当作一个单词来处理，如果不包含双引号即*\n的形式，则每个位置的参数都被当作一个独立的单词来处理\n而对于\n$@，无论是否加上双引号，每个位置的参数都被当作一个独立的单词来处理\n\n加入 参数是 a b c\n$*是一个字符串 : “a b c”\n$@是三个：“a”, “b”,\n“c”\n\n$?\n命令、函数或者脚本的退出状态，在判断命令的执行结果或者函数的调用结果时很有用处\n现有 e.sh和 f.sh测试脚本\ne.sh 脚本\n#!/bin/bashtest_func(){  if [[ $1 -eq 10 ]]; then        return 5  fi  return 6}if [ $# -ge 1 ]; then   name=\"$1\"   shift 1   $name \"$@\"fi\nf.sh 脚本\n#!/bin/bashsh e.sh test_func 3echo 'exit code1:'$?sh e.sh test_func 10echo 'exit code2:'$?test -f $PWD/xx.txtecho 'exit code3:'$?test -f $PWD/e.shecho 'exit code4:'$?\n执行 ./f.sh命令，结果如下\n[root@ecs-centos-7 ~]# ./f.sh exit code1:6exit code2:5exit code3:1exit code4:0\n脚本 e.sh中\ntest_func函数功能是：当参数等于10时，退出状态为 5，否则为\n6\nsh e.sh test_func 3命令会调用 e.sh脚本中的\ntest_func函数，传入参数是 3，所以退出状态为 6，同理可知,\nsh e.sh test_func 10命令的退出状态是 5\n在Linux中，命令执行成功，退出状态为 0 ，失败则为非 0\ntest -f $PWD/xx.txt命令是检查当前目录是否存在\nxx.txt文件，因当前目录并不存在\nxx.txt，所以命令执行失败，退出状态为非 0\n由于e.sh存在于当前目录下，所以\ntest -f $PWD/e.sh命令执行成功，退出状态为 0\n$IFS\n此变量用于 Bash\n识别字符串或单词边界，默认值是空格，脚本中根据需要可以修改此变量的值\n现有 b.sh脚本，内容如下\n#!/bin/bashva=\"a:b:c\"vb=\"x-y-z\"vc=\"e,f,g\"IFS=\":\"echo 'va:'$vaecho 'vb:'$vbecho 'vc:'$vcechoIFS=\"-\"echo 'va:'$vaecho 'vb:'$vbecho 'vc:'$vcechoIFS=\",\"echo 'va:'$vaecho 'vb:'$vbecho 'vc:'$vc\n执行 ./b.sh结果如下\n[tt@ecs-centos-7 ~]$ ./b.sh va:a b cvb:x-y-zvc:e,f,gva:a:b:cvb:x y zvc:e,f,gva:a:b:cvb:x-y-zvc:e f g\n从结果可以看出，当 $IFS为 :时，字符串\n\"a:b:c\"被解析成 a b c\n当 $IFS为 -时，字符串\n\"x-y-z\"被解析成 x y z\n当 $IFS为 ,时，字符串\n\"e,f,g\"被解析成 e f g\n、USER、、GROUPS\nHOME:   用户home目录USER:   当前用户名UID:    当前用户IDGROUPS: 当前用户组ID\n[tt@ecs-centos-7 ~]$ echo $HOME/home/tt[tt@ecs-centos-7 ~]$ echo $USERtt[tt@ecs-centos-7 ~]$ echo $UID1003[tt@ecs-centos-7 ~]$ echo $GROUPS1003\n、MACTYPE、$OSTYPE\n这些变量都表示系统硬件\n[tt@ecs-centos-7 ~]$ echo $HOSTTYPEx86_64[tt@ecs-centos-7 ~]$ echo $MACHTYPEx86_64-redhat-linux-gnu[tt@ecs-centos-7 ~]$ echo $OSTYPElinux-gnu\n参考\n\nVariables,\nInternal\nvariables\nshellcheck\nshellcheck\nwiki\nshell-format\nThe Bash Hackers\nWiki\nAdvanced\nBash-Scripting Guide\n\n","categories":["Terminal"],"tags":["Shell"]},{"title":"SpringBoot3 Web 开发","url":"/2024/07/08/SpringBoot3-Web-%E5%BC%80%E5%8F%91/","content":"本文深入解析了 Spring Boot 中 WebMvcAutoConfiguration\n自动配置的原理与应用，涵盖静态资源映射、内容协商机制、自定义 MVC\n行为、模板引擎 Thymeleaf\n的整合、国际化、错误处理、嵌入式容器支持以及如何通过 @EnableWebMvc 接管\nSpringMVC。最后介绍了 Web 新特性如 ProblemDetails 和函数式 Web\n编程，帮助开发者系统掌握 Spring Web 栈的使用与扩展能力。\n\n0. WebMvcAutoConfiguration\n原理\n1. 生效条件\n@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,\t\tValidationAutoConfiguration.class }) //在这些自动配置之后@ConditionalOnWebApplication(type = Type.SERVLET) //如果是web应用就生效，类型SERVLET、REACTIVE 响应式web@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) //容器中没有这个Bean，才生效。默认就是没有@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)//优先级@ImportRuntimeHints(WebResourcesRuntimeHints.class)public class WebMvcAutoConfiguration {}\n2. 效果\n\n放了两个 Filter：\n\nHiddenHttpMethodFilter：页面表单提交 Rest\n请求（GET、POST、PUT、DELETE）\nFormContentFilter： 表单内容 Filter，GET（数据放 URL\n后面）、POST（数据放请求体）请求可以携带数据，PUT、DELETE\n的请求体数据会被忽略\n\n给容器中放了WebMvcConfigurer组件；给 SpringMVC\n添加各种定制功能\n\n所有的功能最终会和配置文件进行绑定\nWebMvcProperties： spring.mvc配置文件\nWebProperties： spring.web配置文件\n\n\n@Configuration(proxyBeanMethods = false)@Import(EnableWebMvcConfiguration.class) //额外导入了其他配置@EnableConfigurationProperties({ WebMvcProperties.class, WebProperties.class })@Order(0)public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware{}\n3. WebMvcConfigurer 接口\n提供了配置 SpringMVC 底层的所有组件入口\n4. 静态资源规则源码\n@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) {    if (!this.resourceProperties.isAddMappings()) {        logger.debug(\"Default resource handling disabled\");        return;    }    addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(),            \"classpath:/META-INF/resources/webjars/\");    addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; {        registration.addResourceLocations(this.resourceProperties.getStaticLocations());        if (this.servletContext != null) {            ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);            registration.addResourceLocations(resource);        }    });}\n\n规则一：访问 /webjars/** 路径就去\nclasspath:/META-INF/resources/webjars/下找资源。\n规则二：访问 /** 路径就去\n静态资源默认的四个位置找资源\n\nclasspath:/META-INF/resources/\nclasspath:/resources/\nclasspath:/static/\nclasspath:/public/\n\n规则三：静态资源默认都有缓存规则的设置\n\n所有缓存的设置，直接通过配置文件：\nspring.web\ncachePeriod： 缓存周期； 多久不用找服务器要新的。 默认没有，以 s\n为单位\ncacheControl： HTTP 缓存控制；\nhttps://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching\nuseLastModified：是否使用最后一次修改。配合 HTTP Cache\n规则。\n\n\n如果浏览器访问了一个静态资源\nindex.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求。\nregistration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());\n5. EnableWebMvcConfiguration\n源码\n//SpringBoot 给容器中放 WebMvcConfigurationSupport 组件。//我们如果自己放了 WebMvcConfigurationSupport 组件，Boot的WebMvcAutoConfiguration都会失效。@Configuration(proxyBeanMethods = false)@EnableConfigurationProperties(WebProperties.class)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware{}\n6.\n为什么容器中放一个 WebMvcConfigurer 就能配置底层行为\n\nWebMvcAutoConfiguration 是一个自动配置类，它里面有一个\nEnableWebMvcConfiguration。\nEnableWebMvcConfiguration 继承\nDelegatingWebMvcConfiguration。\nDelegatingWebMvcConfiguration利用 DI 把容器中所有\nWebMvcConfigurer注入进来。\n这样无论哪一个WebMvcConfigurer里面配置的东西，都会被统一处理，放到一个公共的WebMvcConfigurer中，作为最终使用的配置类。\n\n\n这里存在一个Bean 注入顺序问题（案例）\n\nDelegatingWebMvcConfiguration 继承了\nWebMvcConfigurationSupport\n而 WebMvcAutoConfig 存在注解\n@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})\n但如上面所说 WebMvcAutoConfig 加载后也会导入\nDelegatingWebMvcConfiguration。\n\n所以说WebMvcAutoConfig注入的时间比WebMvcConfigurationSupport早。\n判断ConditionalOnMissingBean时，WebMvcConfigurationSupport还没有注入。\n因此WebMvcAutoConfig能生效。\n但如果我们手动添加了@EnableWebMvc注解，就会导致提前注入WebMvcConfigurationSupport\n从而使WebMvcAutoConfig失效，没有默认的配置了，只剩下用户自己定义的配置。\n\n7. WebMvcConfigurationSupport\n提供了很多的默认设置。\n判断系统中是否有相应的类：如果有，就加入相应的HttpMessageConverter\njackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &amp;&amp;\t\t\t\tClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);\n1. Web 场景\n1. 自动配置\n1、整合 web 场景\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\n2、引入了autoconfigure功能\n3、@EnableAutoConfiguration注解使用\n@Import(AutoConfigurationImportSelector.class)批量导入组件\n4、加载\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n文件中配置的所有组件\n5、所有自动配置类如下\norg.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfigurationorg.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration====以下是响应式web场景和现在的没关系======org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfigurationorg.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration================以上没关系=================org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfigurationorg.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration\n6、绑定了配置文件的一堆配置项\n\n1、SpringMVC 的所有配置 spring.mvc\n2、Web 场景通用配置 spring.web\n3、文件上传配置 spring.servlet.multipart\n4、服务器的配置 server: 比如：编码方式\n\n2. 默认效果\n默认配置：\n\n包含了 ContentNegotiatingViewResolver 和\nBeanNameViewResolver组件，方便视图解析。\n默认的静态资源处理机制：静态资源放在 static\n文件夹下即可直接访问。\n自动注册了Converter,GenericConverter,Formatter组件，适配常见数据类型转换和格式化需求\n。\n支持 HttpMessageConverters，可以方便返回 json\n等数据类型。\n注册\nMessageCodesResolver，方便国际化及错误消息处理。\n支持静态 index.html\n自动使用ConfigurableWebBindingInitializer，实现消息处理、数据绑定、类型转化、数据校验等功能\n\n重要：\n\n如果想保持 Springboot mvc 的默认配置，并且自定义更多的 mvc\n配置，如：interceptors,formatters,view controllers\n等。可以使用@Configuration注解添加一个\nWebMvcConfigurer 类型的配置类，并不要标注@EnableWebMvc\n如果想保持 boot mvc\n的默认配置，但要自定义核心组件实例，比如：RequestMappingHandlerMapping,\nRequestMappingHandlerAdapter, 或\nExceptionHandlerExceptionResolver，给容器中放一个 WebMvcRegistrations\n组件即可。\n如果想全面接管 Spring MVC，@Configuration\n标注一个配置类，并加上 @EnableWebMvc 注解，实现\nWebMvcConfigurer 接口。\n\n2. 静态资源\n1. 默认规则\n1. 静态资源映射\n静态资源映射规则在 WebMvcAutoConfiguration 中进行了定义：\n\n/webjars/** 的所有路径资源都在\nclasspath:/META-INF/resources/webjars/\n/** 的所有路径资源都在\nclasspath:/META-INF/resources/、classpath:/resources/、classpath:/static/、classpath:/public/\n所有静态资源都定义了缓存规则。【浏览器访问过一次，就会缓存一段时间】，但此功能参数无默认值。\n\nperiod： 缓存间隔。 默认 0S；\ncacheControl：缓存控制。 默认无；\nuseLastModified：是否使用 lastModified 头。 默认 false；\n\n\n2. 静态资源缓存\n如前面所述\n3. 欢迎页\n欢迎页规则在 WebMvcAutoConfiguration 中进行了定义：\n\n在静态资源目录下找 index.html\n没有就在 templates 下找 index 模板页\n\n4. Favicon\n在静态资源目录下找 favicon.ico\n5. 缓存实验\nserver.port=9000#1、spring.web：# 1.配置国际化的区域信息# 2.静态资源策略(开启、处理链、缓存)#开启静态资源映射规则spring.web.resources.add-mappings=true#设置缓存#spring.web.resources.cache.period=3600##缓存详细合并项控制，覆盖period配置：## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器spring.web.resources.cache.cachecontrol.max-age=7200#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304spring.web.resources.cache.use-last-modified=true\n2. 自定义静态资源规则\n自定义静态资源路径、自定义缓存规则\n1. 配置方式\nspring.mvc： 静态资源访问前缀路径\nspring.web：\n\n静态资源目录\n静态资源缓存策略\n\n#1、spring.web：# 1.配置国际化的区域信息# 2.静态资源策略(开启、处理链、缓存)#开启静态资源映射规则spring.web.resources.add-mappings=true#设置缓存spring.web.resources.cache.period=3600##缓存详细合并项控制，覆盖period配置：## 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器spring.web.resources.cache.cachecontrol.max-age=7200## 共享缓存spring.web.resources.cache.cachecontrol.cache-public=true#使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304spring.web.resources.cache.use-last-modified=true#自定义静态资源文件夹位置（到项目本地最终查找的路径）spring.web.resources.static-locations=classpath:/a/,classpath:/b/,classpath:/static/#2、 spring.mvc## 2.1. 自定义webjars路径前缀spring.mvc.webjars-path-pattern=/wj/**## 2.2. 静态资源访问路径前缀 （对网页输入的路径进行转换）spring.mvc.static-path-pattern=/static/**\n2. 代码方式\n\n容器中只要有一个 WebMvcConfigurer 组件。配置的底层行为都会生效\n@EnableWebMvc //禁用 boot\n的默认配置\n\n@Configuration //这是一个配置类public class MyConfig implements WebMvcConfigurer {    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) {        //保留以前规则        //自己写新的规则。        registry.addResourceHandler(\"/static/**\")                .addResourceLocations(\"classpath:/a/\",\"classpath:/b/\")                .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));    }}\n或者\n@Configuration //这是一个配置类,给容器中放一个 WebMvcConfigurer 组件，就能自定义底层public class MyConfig  /*implements WebMvcConfigurer*/ {    @Bean    public WebMvcConfigurer webMvcConfigurer(){        return new WebMvcConfigurer() {            @Override            public void addResourceHandlers(ResourceHandlerRegistry registry) {                registry.addResourceHandler(\"/static/**\")                        .addResourceLocations(\"classpath:/a/\", \"classpath:/b/\")                        .setCacheControl(CacheControl.maxAge(1180, TimeUnit.SECONDS));            }        };    }}\n3. 路径匹配\nSpring5.3\n之后加入了更多的请求路径匹配的实现策略；\n以前只支持 AntPathMatcher 策略, 现在提供了\nPathPatternParser\n策略。并且可以让我们指定到底使用那种策略。\n1. Ant 风格路径用法\nAnt 风格的路径模式语法具有以下规则：\n\n*：表示任意数量的字符。\n?：表示任意一个字符。\n**：表示任意数量的目录。\n{}：表示一个命名的模式占位符。\n[]：表示字符集合，例如[a-z]表示小写字母。\n\n例如：\n\n*.html 匹配任意名称，扩展名为.html 的文件。\n/folder1/*/*.java 匹配在 folder1 目录下的任意两级目录下的.java\n文件。\n/folder2/**/*.jsp 匹配在 folder2 目录下任意目录深度的.jsp\n文件。\n/{type}/{id}.html\n匹配任意文件名为{id}.html，在任意命名的{type}目录下的文件。\n\n注意：Ant 风格的路径模式语法中的特殊字符需要转义，如：\n\n要匹配文件路径中的星号，则需要转义为\\*。\n要匹配文件路径中的问号，则需要转义为\\?。\n\n2. 模式切换\nAntPathMatcher 与 PathPatternParser\n\nPathPatternParser 在 jmh 基准测试下，有 6~8 倍吞吐量提升，降低\n30%~40%空间分配率\nPathPatternParser 兼容 AntPathMatcher\n语法，并支持更多类型的路径模式\nPathPatternParser “**”\n多段匹配的支持仅允许在模式末尾使用\n\n@GetMapping(\"/a*/b?/{p1:[a-f]+}\")public String hello(HttpServletRequest request,                    @PathVariable(\"p1\") String path) {    log.info(\"路径变量p1： {}\", path);    //获取请求路径    String uri = request.getRequestURI();    return uri;}\n总结：\n\n使用默认的路径匹配规则，是由 PathPatternParser 提供的\n如果路径中间需要有 **，替换成 ant 风格路径\n\n# 改变路径匹配策略：# ant_path_matcher 老版策略；# path_pattern_parser 新版策略；spring.mvc.pathmatch.matching-strategy=ant_path_matcher\n4. 内容协商\n1. 多端内容适配\n1. 默认规则\n\n基于请求头内容协商：（默认开启）\n\n客户端向服务端发送请求，携带 HTTP 标准的Accept\n请求头。\nAccept:\napplication/json、text/xml、text/yaml\n服务端根据客户端请求头期望的数据类型进行动态返回\n\n基于请求参数内容协商：（需要手动开启)\n\n发送请求 GET /projects/spring-boot?format=json\n匹配到 @GetMapping(“/projects/spring-boot”)\n根据参数协商，优先返回 json\n类型数据【需要开启参数匹配设置】\n发送请求 GET /projects/spring-boot?format=xml\n则会优先返回 xml 类型数据\n\n\n2. 效果演示\n请求同一个接口，可以返回 json 和 xml 不同格式数据\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;&lt;/dependency&gt;\n@JacksonXmlRootElement  // 可以写出为xml文档@Datapublic class Person {    private Long id;    private String userName;    private String email;    private Integer age;}\n# 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启spring.mvc.contentnegotiation.favor-parameter=true# 指定内容协商时使用的参数名。默认是 formatspring.mvc.contentnegotiation.parameter-name=type\n3. 配置协商规则与支持类型\n修改内容协商方式\n#使用参数进行内容协商spring.mvc.contentnegotiation.favor-parameter=true#自定义参数名，默认为formatspring.mvc.contentnegotiation.parameter-name=type\n2. 自定义内容返回\n1. 增加 yaml 返回支持\n导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-yaml&lt;/artifactId&gt;&lt;/dependency&gt;\n把对象写出成 YAML\npublic static void main(String[] args) throws JsonProcessingException {    Person person = new Person();    person.setId(1L);    person.setUserName(\"张三\");    person.setEmail(\"aaa@qq.com\");    person.setAge(18);    YAMLFactory factory = new YAMLFactory().disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);    ObjectMapper mapper = new ObjectMapper(factory);    String s = mapper.writeValueAsString(person);    System.out.println(s);}\n编写配置\n#新增一种媒体类型spring.mvc.contentnegotiation.media-types.yaml=text/yaml\n增加HttpMessageConverter组件，专门负责把对象写出为 yaml\n格式\n@Beanpublic WebMvcConfigurer webMvcConfigurer(){    return new WebMvcConfigurer() {        @Override //配置一个能把对象转为yaml的messageConverter        public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {            converters.add(new MyYamlHttpMessageConverter());        }    };}\n2. 如何实现自定义\nMessageConverter 组件\n\n配置媒体类型支持:\n\nspring.mvc.contentnegotiation.media-types.yaml=text/yaml\n\n编写对应的HttpMessageConverter，要告诉 Boot\n这个支持的媒体类型\n\n按照 3 的示例\n\n把 MessageConverter 组件加入到底层\n\n容器中放一个WebMvcConfigurer\n组件，并配置底层的MessageConverter\n\n\n3. HttpMessageConverter\n的示例写法\npublic class MyYamlHttpMessageConverter extends AbstractHttpMessageConverter&lt;Object&gt; {    private ObjectMapper objectMapper = null; //把对象转成yaml    public MyYamlHttpMessageConverter(){        //告诉SpringBoot这个MessageConverter支持哪种媒体类型  //媒体类型        super(new MediaType(\"text\", \"yaml\", Charset.forName(\"UTF-8\")));        YAMLFactory factory = new YAMLFactory()                .disable(YAMLGenerator.Feature.WRITE_DOC_START_MARKER);        this.objectMapper = new ObjectMapper(factory);    }    @Override    protected boolean supports(Class&lt;?&gt; clazz) {        //只要是对象类型，不是基本类型        return true;    }    @Override  //@RequestBody 配置对象如何读入的    protected Object readInternal(Class&lt;?&gt; clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {        return null;    }    @Override //@ResponseBody 配置对象怎么写出去    protected void writeInternal(Object methodReturnValue, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {        //try-with写法，自动关流        try(OutputStream os = outputMessage.getBody()){            this.objectMapper.writeValue(os,methodReturnValue);        }    }}\n3.\n内容协商原理-HttpMessageConverter\n\nHttpMessageConverter 怎么工作？合适工作？\n定制 HttpMessageConverter 来实现多端内容协商\n编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter\n\n1. @ResponseBody 由\nHttpMessageConverter 处理\n标注了@ResponseBody的返回值 将会由支持它的\nHttpMessageConverter写给浏览器\n\n如果 controller 方法的返回值标注了\n@ResponseBody注解\n\n请求进来先来到DispatcherServlet的doDispatch()进行处理\n找到一个\nHandlerAdapter适配器。利用适配器执行目标方法\nRequestMappingHandlerAdapter来执行，调用invokeHandlerMethod来执行目标方法\n目标方法执行之前，准备好两个东西\nHandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值\nHandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理\n\nRequestMappingHandlerAdapter\n里面的invokeAndHandle真正执行目标方法\n\n目标方法执行完成，会返回返回值对象\n找到一个合适的返回值处理器\nHandlerMethodReturnValueHandler\n最终找到RequestResponseBodyMethodProcessor能处理标注了\n@ResponseBody注解的方法\nRequestResponseBodyMethodProcessor\n调用writeWithMessageConverters,利用MessageConverter把返回值写出去\n\n\n\n综上可知：@ResponseBody由HttpMessageConverter处理\n\n\nHttpMessageConverter 会先进行内容协商\n\n遍历所有的MessageConverter看谁支持这种内容类型的数据\n最终因为要json所以MappingJackson2HttpMessageConverter支持写出\njson\njackson 用ObjectMapper把对象写出去\n\n\n2.\nWebMvcAutoConfiguration 提供几种默认 HttpMessageConverters\n\nEnableWebMvcConfiguration通过\naddDefaultHttpMessageConverters添加了默认的MessageConverter\n\nByteArrayHttpMessageConverter： 支持字节数据读写\nStringHttpMessageConverter： 支持字符串读写\nResourceHttpMessageConverter：支持资源读写\nResourceRegionHttpMessageConverter:\n支持分区资源写出\nAllEncompassingFormHttpMessageConverter：支持表单\nxml/json 读写\nMappingJackson2HttpMessageConverter： 支持请求响应体\nJson 读写\n\n\n系统提供默认的 MessageConverter 功能有限，仅用于 json\n或者普通返回数据。额外增加新的内容协商功能，必须增加新的HttpMessageConverter\n5. 模板引擎\n\n由于 SpringBoot 使用了嵌入式 Servlet\n容器。所以 JSP\n默认是不能使用的。\n如果需要服务端页面渲染，优先考虑使用\n模板引擎。\n\n模板引擎页面默认放在 src/main/resources/templates\nSpringBoot 包含以下模板引擎的自动配置\n\nFreeMarker\nGroovy\nThymeleaf\nMustache\n\nThymeleaf 官网：https://www.thymeleaf.org/\n&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;\t&lt;title&gt;Good Thymes Virtual Grocery&lt;/title&gt;\t&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;\t&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"all\" th:href=\"@{/css/gtvg.css}\" /&gt;&lt;/head&gt;&lt;body&gt;\t&lt;p th:text=\"#{home.welcome}\"&gt;Welcome to our grocery store!&lt;/p&gt;&lt;/body&lt;/html&gt;\n1. Thymeleaf 整合\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;\n自动配置原理\n\n开启了\norg.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration\n自动配置\n属性绑定在 ThymeleafProperties 中，对应配置文件 spring.thymeleaf\n内容\n所有的模板页面默认在\nclasspath:/templates文件夹下\n默认效果\n\n所有的模板页面在 classpath:/templates/下面找\n找后缀名为.html的页面\n\n\n2. 基础语法\n1. 核心用法\nth:xxx：动态渲染指定的 html 标签属性值、或者 th\n指令（遍历、判断等）\n\nth:text：标签体内文本值渲染\n\nth:utext：不会转义，显示为 html 原本的样子。\n\nth:属性：标签指定属性渲染\nth:attr：标签任意属性渲染\nth:if，th:each...：其他 th 指令\n例如：\n\n&lt;p th:text=\"${content}\"&gt;原内容&lt;/p&gt;&lt;a th:href=\"${url}\"&gt;登录&lt;/a&gt;&lt;img\tsrc=\"../../images/gtvglogo.png\"\tth:attr=\"src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}\"/&gt;\n表达式：用来动态取值\n\n${}：变量取值；使用 model\n共享给页面的值都直接用${}\n@{}：url 路径\n#{}：国际化消息\n~{}：片段引用\n*{}：变量选择：需要配合 th:object 绑定对象\n\n系统工具&amp;内置对象：详细文档\n\nparam：请求参数对象\nsession：session 对象\napplication：application 对象\n#execInfo：模板执行信息\n#messages：国际化消息\n#uris：uri/url 工具\n#conversions：类型转换工具\n#dates：日期工具，是java.util.Date对象的工具类\n#calendars：类似#dates，只不过是java.util.Calendar对象的工具类\n#temporals： JDK8+ **java.time** API\n工具类\n#numbers：数字操作工具\n#strings：字符串操作\n#objects：对象操作\n#bools：bool 操作\n#arrays：array 工具\n#lists：list 工具\n#sets：set 工具\n#maps：map 工具\n#aggregates：集合聚合工具（sum、avg）\n#ids：id 生成工具\n\n2. 语法示例\n表达式：\n\n变量取值：${…}\nurl 取值：@...\n国际化消息：#{…}\n变量选择：*{…}\n片段引用: ~{…}\n\n常见：\n\n文本： ‘one text’，‘another one!’,…\n数字： 0,34,3.0,12.3,…\n布尔：true、false\nnull: null\n变量名： one,sometext,main…\n\n文本操作：\n\n拼串： +\n文本替换：| The name is ${name} |\n\n布尔操作：\n\n二进制运算： and,or\n取反：!,not\n\n比较运算：\n\n比较：&gt;，&lt;，&lt;=，&gt;=（gt，lt，ge,le）\n等值运算：==,!=（eq，ne）\n\n条件运算：\n\nif-then： (if)?(then)\nif-then-else: (if)?(then):(else)\ndefault: (value)?:(defaultValue)\n\n特殊语法：\n\n无操作：_\n\n所有以上都可以嵌套组合\n'User is of type ' + (${user.isAdmin()} ? 'Administrator' : (${user.type} ?: 'Unknown'))\n3. 属性设置\n\nth:href=“@/product/list”\nth:attr=“class=${active}”\nth:attr=“src=@/images/gtvglogo.png,title=${logo},alt=#{logo}”\nth:checked=“${user.active}”\n\n&lt;p th:text=\"${content}\"&gt;原内容&lt;/p&gt;&lt;a th:href=\"${url}\"&gt;登录&lt;/a&gt;&lt;img\tsrc=\"../../images/gtvglogo.png\"\tth:attr=\"src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}\"/&gt;\n4. 遍历\n语法： th:each=\"元素名,迭代状态 : ${集合}\"\n&lt;tr th:each=\"prod : ${prods}\"&gt;\t&lt;td th:text=\"${prod.name}\"&gt;Onions&lt;/td&gt;\t&lt;td th:text=\"${prod.price}\"&gt;2.41&lt;/td&gt;\t&lt;td th:text=\"${prod.inStock}? #{true} : #{false}\"&gt;yes&lt;/td&gt;&lt;/tr&gt;&lt;tr th:each=\"prod,iterStat : ${prods}\" th:class=\"${iterStat.odd}? 'odd'\"&gt;\t&lt;td th:text=\"${prod.name}\"&gt;Onions&lt;/td&gt;\t&lt;td th:text=\"${prod.price}\"&gt;2.41&lt;/td&gt;\t&lt;td th:text=\"${prod.inStock}? #{true} : #{false}\"&gt;yes&lt;/td&gt;&lt;/tr&gt;\niterStat 有以下属性：\n\nindex：当前遍历元素的索引，从 0 开始\ncount：当前遍历元素的索引，从 1 开始\nsize：需要遍历元素的总数量\ncurrent：当前正在遍历的元素对象\neven/odd：是否偶数/奇数行\nfirst：是否第一个元素\nlast：是否最后一个元素\n\n5. 判断\nth:if\n&lt;a  href=\"comments.html\"  th:href=\"@{/product/comments(prodId=${prod.id})}\"  th:if=\"${not #lists.isEmpty(prod.comments)}\"  &gt;view&lt;/a\nth:switch\n&lt;div th:switch=\"${user.role}\"&gt;\t&lt;p th:case=\"'admin'\"&gt;User is an administrator&lt;/p&gt;\t&lt;p th:case=\"#{roles.manager}\"&gt;User is a manager&lt;/p&gt;\t&lt;p th:case=\"*\"&gt;User is some other thing&lt;/p&gt;&lt;/div&gt;\n6. 属性优先级\n\n片段\n遍历\n判断\n\n&lt;ul&gt;\t&lt;li th:each=\"item : ${items}\" th:text=\"${item.description}\"&gt;\t\tItem description here...\t&lt;/li&gt;&lt;/ul&gt;\n\n\n\nOrder\nFeature\nAttributes\n\n\n\n\n1\n片段包含\nth:insert th:replace\n\n\n2\n遍历\nth:each\n\n\n3\n判断\nth:if th:unless th:switch th:case\n\n\n4\n定义本地变量\nth:object th:with\n\n\n5\n通用方式属性修改\nth:attr th:attrprepend th:attrappend\n\n\n6\n指定属性修改\nth:value th:href th:src …\n\n\n7\n文本值\nth:text th:utext\n\n\n8\n片段指定\nth:fragment\n\n\n9\n片段移除\nth:remove\n\n\n\n7. 行内写法\n[[...]] or [(...)]&lt;p&gt;Hello, [[${session.user.name}]]!&lt;/p&gt;\n8. 变量选择\n&lt;div th:object=\"${session.user}\"&gt;\t&lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;\t&lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;\t&lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;\n等同于\n&lt;div&gt;  &lt;p&gt;Name: &lt;span th:text=\"${session.user.firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;  &lt;p&gt;Surname: &lt;span th:text=\"${session.user.lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;  &lt;p&gt;Nationality: &lt;span th:text=\"${session.user.nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div\n9. 模板布局\n\n定义模板： th:fragment\n引用模板：~{templatename::selector}\n插入模板：th:insert、th:replace\n\n&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;body&gt;\t&lt;div th:insert=\"~{footer :: copy}\"&gt;&lt;/div&gt;\t&lt;div th:replace=\"~{footer :: copy}\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;body&gt;\t结果：\t&lt;body&gt;\t\t&lt;div&gt;\t\t\t&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;\t\t&lt;/div&gt;\t\t&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;\t&lt;/body&gt;&lt;/body&gt;\n10. devtools\n&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;\n修改页面后；ctrl+F9刷新效果；\njava 代码的修改，如果devtools热启动了，可能会引起一些\nbug，难以排查\n6. 国际化\n国际化的自动配置参照MessageSourceAutoConfiguration\n实现步骤：\n\nSpring Boot 在类路径根下查找 messages\n资源绑定文件。文件名为：messages.properties\n多语言可以定义多个消息文件，命名为messages_区域代码.properties。如：\n\nmessages.properties：默认\nmessages_zh_CN.properties：中文环境\nmessages_en_US.properties：英语环境\n\n在程序中可以自动注入\nMessageSource组件，获取国际化的配置项值\n在页面中可以使用表达式\n#{}获取国际化的配置项值\n\n@Autowired  //国际化取消息用的组件MessageSource messageSource;@GetMapping(\"/haha\")public String haha(HttpServletRequest request){    Locale locale = request.getLocale();    //利用代码的方式获取国际化配置文件中指定的配置项的值    String login = messageSource.getMessage(\"login\", null, locale);    return login;}\n7. 错误处理\n1. 默认机制\n错误处理的自动配置都在ErrorMvcAutoConfiguration中，两大核心机制：\n\nSpringBoot\n会自适应处理错误，响应页面或JSON\n数据\nSpringMVC 的错误处理机制依然保留，MVC\n处理不了，才会交给 boot 进行处理\n发生错误以后，转发给/error 路径，SpringBoot 在底层写好一个\nBasicErrorController 的组件，专门处理这个请求\n\n@RequestMapping(produces = MediaType.TEXT_HTML_VALUE) //返回HTMLpublic ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {    HttpStatus status = getStatus(request);    Map&lt;String, Object&gt; model = Collections        .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));    response.setStatus(status.value());    ModelAndView modelAndView = resolveErrorView(request, response, status, model);    return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model);}@RequestMapping  //返回 ResponseEntity, JSONpublic ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {    HttpStatus status = getStatus(request);    if (status == HttpStatus.NO_CONTENT) {        return new ResponseEntity&lt;&gt;(status);    }    Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));    return new ResponseEntity&lt;&gt;(body, status);}\n\n错误页面是这么解析到的\n\n//1、解析错误的自定义视图地址ModelAndView modelAndView = resolveErrorView(request, response, status, model);//2、如果解析不到错误页面的地址，默认的错误页就是 errorreturn (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model);\n容器中专门有一个错误视图解析器\n@Bean@ConditionalOnBean(DispatcherServlet.class)@ConditionalOnMissingBean(ErrorViewResolver.class)DefaultErrorViewResolver conventionErrorViewResolver() {    return new DefaultErrorViewResolver(this.applicationContext, this.resources);}\nSpringBoot 解析自定义错误页的默认规则\n@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) {    ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);    if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {        modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);    }    return modelAndView;}private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {    String errorViewName = \"error/\" + viewName;    TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,                                                                                           this.applicationContext);    if (provider != null) {        return new ModelAndView(errorViewName, model);    }    return resolveResource(errorViewName, model);}private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) {    for (String location : this.resources.getStaticLocations()) {        try {            Resource resource = this.applicationContext.getResource(location);            resource = resource.createRelative(viewName + \".html\");            if (resource.exists()) {                return new ModelAndView(new HtmlResourceView(resource), model);            }        }        catch (Exception ex) {        }    }    return null;}\n容器中有一个默认的名为 error 的 view； 提供了默认白页功能\n@Bean(name = \"error\")@ConditionalOnMissingBean(name = \"error\")public View defaultErrorView() {    return this.defaultErrorView;}\n封装了 JSON 格式的错误信息\n@Bean@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)public DefaultErrorAttributes errorAttributes() {    return new DefaultErrorAttributes();}\n规则：\n\n解析一个错误页\n\n如果发生了错误码 500、404、503、403 精确匹配\n\n如果有模板引擎，默认在\nclasspath:/templates/error/精确码.html\n如果没有模板引擎，在静态资源文件夹下找精确码.html\n\n如果匹配不到精确码.html这些精确的错误页，就去找5xx.html，4xx.html模糊匹配\n\n如果有模板引擎，默认在\nclasspath:/templates/error/5xx.html\n如果没有模板引擎，在静态资源文件夹下找5xx.html\n\n如果模板引擎路径templates下有\nerror.html页面，就直接渲染\n\n\n2. 自定义错误响应\n1. 自定义 json 响应\n使用@ControllerAdvice + @ExceptionHandler\n进行统一异常处理\n2. 自定义页面响应\n根据 boot 的错误页面查找规则，自定义页面模板\n3. 最佳实战\n\n前后分离\n\n@ControllerAdvice + @ExceptionHandler进行统一异常处理。\n\n服务端页面渲染\n\n不可预知的一些，HTTP\n码表示的服务器或客户端错误\n\n给classpath:/templates/error/下面，放常用精确的错误码页面。500.html，404.html\n给classpath:/templates/error/下面，放通用模糊匹配的错误码页面。\n5xx.html，4xx.html\n\n发生业务错误\n\n核心业务，每一种错误，都应该代码控制，跳转到自己定制的错误页。\n通用业务，classpath:/templates/error.html页面，显示错误信息。\n\n\n\n页面，JSON，可用的 Model 数据如下\n8. 嵌入式容器\nServlet 容器：管理、运行Servlet\n组件（Servlet、Filter、Listener）的环境，一般指服务器\n1. 自动配置原理\n\nSpringBoot 默认嵌入 Tomcat 作为 Servlet 容器。\n自动配置类是ServletWebServerFactoryAutoConfiguration，EmbeddedWebServerFactoryCustomizerAutoConfiguration\n自动配置类开始分析功能。xxxxAutoConfiguration\n\n@AutoConfiguration@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@ConditionalOnClass(ServletRequest.class)@ConditionalOnWebApplication(type = Type.SERVLET)@EnableConfigurationProperties(ServerProperties.class)@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,\t\tServletWebServerFactoryConfiguration.EmbeddedTomcat.class,\t\tServletWebServerFactoryConfiguration.EmbeddedJetty.class,\t\tServletWebServerFactoryConfiguration.EmbeddedUndertow.class })public class ServletWebServerFactoryAutoConfiguration {}\n\nServletWebServerFactoryAutoConfiguration\n自动配置了嵌入式容器场景\n绑定了ServerProperties配置类，所有和服务器有关的配置\nserver\nServletWebServerFactoryAutoConfiguration\n导入了嵌入式的三大服务器\nTomcat、Jetty、Undertow\n\n导入 Tomcat、Jetty、Undertow\n都有条件注解。系统中有这个类才行（也就是导了包）\n默认Tomcat配置生效。给容器中放\nTomcatServletWebServerFactory\n都给容器中 ServletWebServerFactory放了一个 web\n服务器工厂（造 web 服务器的）\nweb\n服务器工厂都有一个功能，getWebServer获取 web\n服务器\nTomcatServletWebServerFactory 创建了 tomcat。\n\nServletWebServerFactory 什么时候会创建 webServer 出来。\nServletWebServerApplicationContextioc\n容器，启动的时候会调用创建 web 服务器\nSpring\n容器刷新（启动）的时候，会预留一个时机，刷新子容器。onRefresh()\nrefresh() 容器刷新十二大步的刷新子容器会调用\nonRefresh()；\n\nWeb 场景的 Spring 容器启动，在 onRefresh 的时候，会调用创建 web\n服务器的方法。\nWeb 服务器的创建是通过 WebServerFactory\n搞定的。容器中又会根据导了什么包条件注解，启动相关的服务器配置，默认EmbeddedTomcat会给容器中放一个\nTomcatServletWebServerFactory，导致项目启动，自动创建出\nTomcat\n2. 自定义\n切换服务器\n&lt;properties&gt;    &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;&lt;/properties&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- Exclude the Tomcat dependency --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- Use Jetty instead --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;\n3. 最佳实践\n用法：\n\n修改server下的相关配置就可以修改服务器参数\n通过给容器中放一个ServletWebServerFactory，来禁用掉\nSpringBoot\n默认放的服务器工厂，实现自定义嵌入任意服务器。\n\n9. 全面接管 SpringMVC\n\nSpringBoot 默认配置好了 SpringMVC 的所有常用特性。\n如果我们需要全面接管 SpringMVC\n的所有配置并禁用默认配置，仅需要编写一个WebMvcConfigurer配置类，并标注\n@EnableWebMvc 即可\n全手动模式\n\n@EnableWebMvc : 禁用默认配置\nWebMvcConfigurer组件：定义 MVC 的底层行为\n\n\n1.\nWebMvcAutoConfiguration 到底自动配置了哪些规则\nSpringMVC\n自动配置场景给我们配置了如下所有默认行为\n\nWebMvcAutoConfigurationweb 场景的自动配置类\n\n支持 RESTful 的 filter：HiddenHttpMethodFilter\n支持非 POST 请求，请求体携带数据：FormContentFilter\n导入EnableWebMvcConfiguration：\n\nRequestMappingHandlerAdapter\nWelcomePageHandlerMapping：\n欢迎页功能支持（模板引擎目录、静态资源目录放\nindex.html），项目访问/就默认展示这个页面。\nRequestMappingHandlerMapping：找每个请求由谁处理的映射关系\nExceptionHandlerExceptionResolver：默认的异常解析器\nLocaleResolver：国际化解析器\nThemeResolver：主题解析器\nFlashMapManager：临时数据共享\nFormattingConversionService： 数据格式化\n、类型转化\nValidator：\n数据校验JSR303提供的数据校验功能\nWebBindingInitializer：请求参数的封装与绑定\nContentNegotiationManager：内容协商管理器\n\nWebMvcAutoConfigurationAdapter配置生效，它是一个WebMvcConfigurer，定义\nmvc 底层组件\n\n定义好 WebMvcConfigurer\n底层组件默认功能；所有功能详见列表\n视图解析器：InternalResourceViewResolver\n视图解析器：BeanNameViewResolver,视图名（controller\n方法的返回值字符串）就是组件名\n内容协商解析器：ContentNegotiatingViewResolver\n请求上下文过滤器：RequestContextFilter:\n任意位置直接获取当前请求\n静态资源链规则\nProblemDetailsExceptionHandler：错误详情\n\n\nSpringMVC 内部场景异常被它捕获：\n定义了 MVC 默认的底层行为: WebMvcConfigurer\n\n2. @EnableWebMvc 禁用默认行为\n\n@EnableWebMvc给容器中导入DelegatingWebMvcConfiguration组件，他是\nWebMvcConfigurationSupport\nWebMvcAutoConfiguration有一个核心的条件注解,\n@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)，容器中没有WebMvcConfigurationSupport，WebMvcAutoConfiguration才生效.\n@EnableWebMvc 导入\nWebMvcConfigurationSupport 导致\nWebMvcAutoConfiguration 失效。导致禁用了默认行为\n\n\n\n@EnableWebMVC 禁用了 Mvc\n的自动配置\nWebMvcConfigurer 定义 SpringMVC 底层组件的功能类\n\n\n3. WebMvcConfigurer 功能\n定义扩展 SpringMVC 底层功能\n\n\n\n\n\n\n\n\n\n提供方法\n核心参数\n功能\n默认\n\n\n\n\naddFormatters\nFormatterRegistry\n格式化器：支持属性上@NumberFormat 和@DatetimeFormat\n的数据类型转换\nGenericConversionService\n\n\ngetValidator\n无\n数据校验：校验 Controller 上使用@Valid\n标注的参数合法性。需要导入 starter-validator\n无\n\n\naddInterceptors\nInterceptorRegistry\n拦截器：拦截收到的所有请求\n无\n\n\nconfigureContentNegotiation\nContentNegotiationConfigurer\n内容协商：支持多种数据格式返回。需要配合支持这种类型的\nHttpMessageConverter\n支持 json\n\n\nconfigureMessageConverters\nList&lt;HttpMessageConverter&lt;?&gt;&gt;\n消息转换器：标注@ResponseBody 的返回值会利用\nMessageConverter 直接写出去\n8 个，支持 byte，string,multipart,resource，json\n\n\naddViewControllers\nViewControllerRegistry\n视图映射：直接将请求路径与物理视图映射。用于无 java\n业务逻辑的直接视图页渲染\n无 \n\n\nconfigureViewResolvers\nViewResolverRegistry\n视图解析器：逻辑视图转为物理视图\nViewResolverComposite\n\n\naddResourceHandlers\nResourceHandlerRegistry\n静态资源处理：静态资源路径映射、缓存控制\nResourceHandlerRegistry\n\n\nconfigureDefaultServletHandling\nDefaultServletHandlerConfigurer\n默认 Servlet：可以覆盖 Tomcat 的 DefaultServlet。让\nDispatcherServlet 拦截/\n无\n\n\nconfigurePathMatch\nPathMatchConfigurer\n路径匹配：自定义 URL\n路径匹配。可以自动为所有路径加上指定前缀，比如 /api\n无\n\n\nconfigureAsyncSupport\nAsyncSupportConfigurer\n异步支持：\nTaskExecutionAutoConfiguration\n\n\naddCorsMappings\nCorsRegistry\n跨域：\n无\n\n\naddArgumentResolvers\nList\n参数解析器：\nmvc 默认提供\n\n\naddReturnValueHandlers\nList\n返回值解析器：\nmvc 默认提供\n\n\nconfigureHandlerExceptionResolvers\nList\n异常处理器：\n默认 3 个 ExceptionHandlerExceptionResolver\nResponseStatusExceptionResolver DefaultHandlerExceptionResolver\n\n\ngetMessageCodesResolver\n无\n消息码解析器：国际化使用\n无\n\n\n\n10. 最佳实践\nSpringBoot 已经默认配置好了Web\n开发场景常用功能。我们直接使用即可。\n三种方式\n\n\n\n\n\n\n\n\n\n方式\n用法\n效果\n\n\n\n\n\n全自动\n直接编写控制器逻辑\n\n全部使用自动配置默认效果\n\n\n手自一体\n@Configuration + 配置WebMvcConfigurer+\n配置 WebMvcRegistrations\n不要标注 @EnableWebMvc\n保留自动配置效果 手动设置部分功能\n定义 MVC 底层组件\n\n\n全手动\n@Configuration + 配置WebMvcConfigurer\n标注 @EnableWebMvc\n禁用自动配置效果 全手动设置\n\n\n\n两种模式\n1、前后分离模式： @RestController 响应 JSON 数据\n2、前后不分离模式：@Controller + Thymeleaf 模板引擎\n11. Web 新特性\n1. Problemdetails\nRFC 7807: https://www.rfc-editor.org/rfc/rfc7807\n错误信息返回新格式\n原理\n@Configuration(proxyBeanMethods = false)//配置过一个属性 spring.mvc.problemdetails.enabled=true@ConditionalOnProperty(prefix = \"spring.mvc.problemdetails\", name = \"enabled\", havingValue = \"true\")static class ProblemDetailsErrorHandlingConfiguration {    @Bean    @ConditionalOnMissingBean(ResponseEntityExceptionHandler.class)    ProblemDetailsExceptionHandler problemDetailsExceptionHandler() {        return new ProblemDetailsExceptionHandler();    }}\n\nProblemDetailsExceptionHandler是一个\n@ControllerAdvice集中处理系统异常\n处理以下异常。如果系统出现以下异常，会被 SpringBoot 支持以\nRFC 7807规范方式返回错误数据\n\n@ExceptionHandler({    HttpRequestMethodNotSupportedException.class, //请求方式不支持    HttpMediaTypeNotSupportedException.class,    HttpMediaTypeNotAcceptableException.class,    MissingPathVariableException.class,    MissingServletRequestParameterException.class,    MissingServletRequestPartException.class,    ServletRequestBindingException.class,    MethodArgumentNotValidException.class,    NoHandlerFoundException.class,    AsyncRequestTimeoutException.class,    ErrorResponseException.class,    ConversionNotSupportedException.class,    TypeMismatchException.class,    HttpMessageNotReadableException.class,    HttpMessageNotWritableException.class,    BindException.class})\n效果：\n默认响应错误的 json。状态码 405\n{\t\"timestamp\": \"2023-04-18T11:13:05.515+00:00\",\t\"status\": 405,\t\"error\": \"Method Not Allowed\",\t\"trace\": \"org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'POST' is not supported\\r\\n\\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.handleNoMatch(RequestMappingInfoHandlerMapping.java:265)\\r\\n\\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.lookupHandlerMethod(AbstractHandlerMethodMapping.java:441)\\r\\n\\tat org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.getHandlerInternal(AbstractHandlerMethodMapping.java:382)\\r\\n\\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:126)\\r\\n\\tat org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.getHandlerInternal(RequestMappingInfoHandlerMapping.java:68)\\r\\n\\tat org.springframework.web.servlet.handler.AbstractHandlerMapping.getHandler(AbstractHandlerMapping.java:505)\\r\\n\\tat org.springframework.web.servlet.DispatcherServlet.getHandler(DispatcherServlet.java:1275)\\r\\n\\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057)\\r\\n\\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:974)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1011)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:914)\\r\\n\\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:563)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)\\r\\n\\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:631)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:205)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\\r\\n\\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\\r\\n\\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\\r\\n\\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\\r\\n\\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:174)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:149)\\r\\n\\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:166)\\r\\n\\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)\\r\\n\\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)\\r\\n\\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)\\r\\n\\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)\\r\\n\\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\\r\\n\\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:341)\\r\\n\\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:390)\\r\\n\\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)\\r\\n\\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:894)\\r\\n\\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1741)\\r\\n\\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)\\r\\n\\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)\\r\\n\\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\\r\\n\\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\\r\\n\\tat java.base/java.lang.Thread.run(Thread.java:833)\\r\\n\",\t\"message\": \"Method 'POST' is not supported.\",\t\"path\": \"/list\"}\n开启 ProblemDetails 返回, 使用新的 MediaType\nContent-Type: application/problem+json+ 额外扩展返回\n{\t\"type\": \"about:blank\",\t\"title\": \"Method Not Allowed\",\t\"status\": 405,\t\"detail\": \"Method 'POST' is not supported.\",\t\"instance\": \"/list\"}\n2. 函数式 Web\nSpringMVC 5.2 以后\n允许我们使用函数式的方式，定义 Web\n的请求处理流程。\n函数式接口\nWeb 请求处理的方式：\n\n@Controller + @RequestMapping：耦合式\n（路由、业务耦合）\n函数式 Web：分离式（路由、业务分离）\n\n1. 场景\n场景：User RESTful - CRUD\n\nGET /user/1 获取 1 号用户\nGET /users 获取所有用户\nPOST /user 请求体携带 JSON，新增一个用户\nPUT /user/1 请求体携带 JSON，修改 1 号用户\nDELETE /user/1 删除1 号用户\n\n2. 核心类\n\nRouterFunction\nRequestPredicate\nServerRequest\nServerResponse\n\n3. 示例\nimport org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.web.servlet.function.RequestPredicate;import org.springframework.web.servlet.function.RouterFunction;import org.springframework.web.servlet.function.ServerResponse;import static org.springframework.web.servlet.function.RequestPredicates.accept;import static org.springframework.web.servlet.function.RouterFunctions.route;@Configuration(proxyBeanMethods = false)public class MyRoutingConfiguration {    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);    @Bean    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) {        return route()                .GET(\"/{user}\", ACCEPT_JSON, userHandler::getUser)                .GET(\"/{user}/customers\", ACCEPT_JSON, userHandler::getUserCustomers)                .DELETE(\"/{user}\", ACCEPT_JSON, userHandler::deleteUser)                .build();    }}\nimport org.springframework.stereotype.Component;import org.springframework.web.servlet.function.ServerRequest;import org.springframework.web.servlet.function.ServerResponse;@Componentpublic class MyUserHandler {    public ServerResponse getUser(ServerRequest request) {        ...        return ServerResponse.ok().build();    }    public ServerResponse getUserCustomers(ServerRequest request) {        ...        return ServerResponse.ok().build();    }    public ServerResponse deleteUser(ServerRequest request) {        ...        return ServerResponse.ok().build();    }}\n","categories":["后端","Spring"],"tags":["SpringBoot3,WebMVC"]},{"title":"SpringBoot3 快速入门","url":"/2024/07/01/SpringBoot3-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"SpringBoot3 快速入门：基于 Java 17 环境，通过引入\nstarter、自动配置与约定大于配置的设计思路，能在几行配置和少量代码下快速搭建独立可执行的\nWeb 应用，并灵活定制依赖管理、自动配置机制以及日志与 YAML\n配置等核心能力。\n\n1、简介\n1. 前置知识\n\nJava17\nSpring、SpringMVC、MyBatis\nMaven、IDEA\n\n2. 环境要求\n\n\n\n环境&amp;工具\n版本（or later）\n\n\n\n\nSpringBoot\n3.0.5+\n\n\nIDEA\n2021.2.1+\n\n\nJava\n17+\n\n\nMaven\n3.5+\n\n\nTomcat\n10.0+\n\n\nServlet\n5.0+\n\n\nGraalVM Community\n22.3+\n\n\nNative Build Tools\n0.9.19+\n\n\n\n3. SpringBoot是什么\nSpringBoot 帮我们简单、快速地创建一个独立的、生产级别的\nSpring 应用（说明：SpringBoot底层是Spring）\n大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring\n平台以及第三方技术\n特性：\n\n快速创建独立 Spring 应用\nSSM：导包、写配置、启动运行\n直接嵌入Tomcat、Jetty or Undertow（无需部署 war\n包）【Servlet容器】\n\nlinux java tomcat mysql： war 放到 tomcat 的 webapps下\njar： java环境； java -jar\n\n重点：提供可选的starter，简化应用整合\n\n场景启动器（starter）：web、json、邮件、oss（对象存储）、异步、定时任务、缓存…\n为每一种场景准备了一个依赖；\nweb-starter，mybatis-starter\n\n重点：按需自动配置 Spring 以及 第三方库\n\n如果这些场景我要使用（生效）。这个场景的所有配置都会自动配置好。\n约定大于配置：每个场景都有很多默认配置。\n自定义：配置文件中修改几项就可以\n\n提供生产级特性：如 监控指标、健康检查、外部化配置等\n\n监控指标、健康检查（k8s）、外部化配置\n\n无代码生成、无xml\n\n总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。\n2、快速体验\n场景：浏览器发送/hello请求，返回”Hello,Spring\nBoot 3!”\n1. 开发流程\n1. 创建项目\nmaven 项目\n&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.5&lt;/version&gt;    &lt;/parent&gt;\n2. 导入场景\n场景启动器\n    &lt;dependencies&gt;&lt;!--        web开发的场景启动器 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n3. 主程序\n@SpringBootApplication //这是一个SpringBoot应用public class MainApplication {    public static void main(String[] args) {        SpringApplication.run(MainApplication.class,args);    }}\n4. 业务\n@RestControllerpublic class HelloController {    @GetMapping(\"/hello\")    public String hello(){        return \"Hello,Spring Boot 3!\";    }}\n5. 测试\n默认启动访问： localhost:8080\n6. 打包\n&lt;!--    SpringBoot应用打包插件--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;\nmvn clean package把项目打成可执行的jar包\njava -jar demo.jar启动项目\n2. 特性小结\n1. 简化整合\n导入相关的场景，拥有相关的功能。场景启动器\n默认支持的所有场景：https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters\n\n官方提供的场景：命名为：spring-boot-starter-*\n第三方提供场景：命名为：*-spring-boot-starter\n\n场景一导入，万物皆就绪\n2. 简化开发\n无需编写任何配置，直接开发业务\n3. 简化配置\napplication.properties：\n\n集中式管理配置。只需要修改这个文件就行 。\n配置基本都有默认值\n能写的所有配置都在：\nhttps://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties\n\n4. 简化部署\n打包为可执行的jar包。\nlinux服务器上有java环境。\n5. 简化运维\n修改配置（外部放一个application.properties文件）、监控、健康检查。\n\n对于application.properties文件：\n（1）默认是读取classpath下的application.properties文件。\n（2）jar包同级下的application.properties可以直接读取，启动命名不需要做调整。\n（3）jar包同级下的config/application.properties，可以直接读取，启动命令不需要调整。\n（4）jar包同级下的conf/application.properties，不可以直接读取，需要通过参数–\n\n3. Spring Initializr 创建\n3、应用分析\n1. 依赖管理机制\n1、为什么导入starter-web所有相关依赖都导入进来？\n\n开发什么场景，导入什么场景启动器。\nmaven依赖传递原则。A-B-C： A就拥有B和C\n导入 场景启动器。 场景启动器\n自动把这个场景的所有核心依赖全部导入进来\n\n2、为什么版本号都不用写？\n\n每个boot项目都有一个父项目spring-boot-starter-parent\nparent的父项目是spring-boot-dependencies\n父项目\n版本仲裁中心，把所有常见的jar的依赖版本都声明好了。\n比如：mysql-connector-j\n\n3、自定义版本号\n\n利用maven的就近原则\n直接在当前项目properties标签中声明父项目用的版本属性的key\n直接在导入依赖的时候声明版本\n\n4、第三方的jar包\n\nboot父项目没有管理的需要自行声明好\n\n&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt;\n2. 自动配置机制\n1. 初步理解\n\n自动配置的 Tomcat、SpringMVC 等\n导入场景，容器中就会自动配置好这个场景的核心组件。\n\n以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter….\n现在：自动配置好的这些组件\n验证：容器中有了什么组件，就具有什么功能\n\n\npublic static void main(String[] args) {    //java10： 局部变量类型的自动推断    var ioc = SpringApplication.run(MainApplication.class, args);    //1、获取容器中所有组件的名字    String[] names = ioc.getBeanDefinitionNames();    //2、挨个遍历：    // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver    // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。    for (String name : names) {        System.out.println(name);    }}\n\n默认的包扫描规则\n\n@SpringBootApplication 标注的类就是主程序类\nSpringBoot只会扫描主程序所在的包及其下面的子包，自动的component-scan功能\n\n自定义扫描路径\n\n@SpringBootApplication(scanBasePackages\n= “com.atguigu”)\n@ComponentScan(\"com.atguigu\") 直接指定扫描的路径\n\n配置默认值\n\n配置文件的所有配置项是和某个类的对象值进行一一绑定的。\n绑定了配置文件中每一项值的类称为：属性类。\n比如：\n\nServerProperties绑定了所有Tomcat服务器有关的配置\nMultipartProperties绑定了所有文件上传相关的配置\n\n\n按需加载自动配置\n\n导入场景spring-boot-starter-web\n场景启动器除了会导入相关功能依赖，导入一个spring-boot-starter，是所有starter的starter，基础核心starter\nspring-boot-starter导入了一个包\nspring-boot-autoconfigure。包里面都是各种场景的AutoConfiguration自动配置类\n虽然全场景的自动配置都在\nspring-boot-autoconfigure这个包，但是不是全都开启的。导入哪个场景就开启哪个自动配置。\n\n\n总结： 导入场景启动器、触发\nspring-boot-autoconfigure这个包的自动配置生效、容器中就会具有相关场景的功能\n2. 完整流程\n思考：\n1、SpringBoot怎么实现导一个**starter**、写一些简单配置，应用就能跑起来，我们无需关心整合\n2、为什么Tomcat的端口号可以配置在application.properties中，并且Tomcat能启动成功？\n3、导入场景后哪些自动配置能生效？\n自动配置流程细节梳理：\n1、导入starter-web：导入了web开发场景\n\n1、场景启动器导入了相关场景的所有依赖：starter-json、starter-tomcat、springmvc\n2、每个场景启动器都引入了一个spring-boot-starter，核心场景启动器。\n3、核心场景启动器引入了spring-boot-autoconfigure包。\n4、spring-boot-autoconfigure里面囊括了所有场景的所有配置。\n5、只要这个包下的所有类都能生效，那么相当于SpringBoot官方写好的整合功能就生效了。\n6、SpringBoot默认却扫描不到\nspring-boot-autoconfigure下写好的所有配置类。（这些配置类给我们做了整合操作），默认只扫描主程序所在的包。\n\n2、主程序：@SpringBootApplication\n\n1、@SpringBootApplication由三个注解组成@SpringBootConfiguration、@EnableAutoConfiguratio、@ComponentScan\n2、SpringBoot默认只能扫描自己主程序所在的包及其下面的子包，扫描不到\nspring-boot-autoconfigure包中官方写好的配置类\n3、@EnableAutoConfiguration：SpringBoot\n开启自动配置的核心。\n\n是由@Import(AutoConfigurationImportSelector.class)提供功能：批量给容器中导入组件。\nSpringBoot启动会默认加载 142个配置类。\n这142个配置类来自于spring-boot-autoconfigure下META-INF/spring/**org.springframework.boot.autoconfigure.AutoConfiguration**.imports文件\n项目启动的时候利用 @Import 批量导入组件机制把\nautoconfigure 包下的142\nxxxxAutoConfiguration类导入进来（自动配置类）\n\n4、按需生效：\n\n并不是这142个自动配置类都能生效\n每一个自动配置类，都有条件注解@ConditionalOnxxx，只有条件成立，才能生效\n\n\n3、xxxxAutoConfiguration自动配置类\n\n1、给容器中使用@Bean 放一堆组件。\n2、每个自动配置类都可能有这个注解@EnableConfigurationProperties(**ServerProperties**.class)，用来把配置文件中配的指定前缀的属性值封装到\nxxxProperties属性类中\n3、以Tomcat为例：把服务器的所有配置都是以server开头的。\n4、给容器中放的所有组件的一些核心参数，都来自于**xxxProperties**。**xxxProperties**都是和配置文件绑定。\n只需要改配置文件的值，核心组件的底层参数都能修改\n\n4、写业务，全程无需关心各种整合（底层这些整合写好了，而且也生效了）\n核心流程总结：\n1、导入starter，就会导入autoconfigure包。\n2、autoconfigure 包里面 有一个文件\nMETA-INF/spring/**org.springframework.boot.autoconfigure.AutoConfiguration**.imports,里面指定的所有启动要加载的自动配置类\n3、@EnableAutoConfiguration\n会自动的把上面文件里面写的所有自动配置类都导入进来。xxxAutoConfiguration\n是有条件注解进行按需加载\n4、xxxAutoConfiguration给容器中导入一堆组件，组件都是从\nxxxProperties中提取属性值\n5、xxxProperties又是和配置文件进行了绑定\n效果：导入starter、修改配置文件，就能修改底层行为。\n3. 如何学好SpringBoot\n框架的框架、底层基于Spring，能调整每一个场景的底层行为。\n100%的项目一定会用到底层自定义。\n\n理解自动配置原理\n\n导入starter –&gt; 生效xxxxAutoConfiguration\n–&gt; 组件 –&gt; xxxProperties\n–&gt; 配置文件\n\n理解其他框架底层\n\n拦截器\n\n可以随时定制化任何组件\n\n配置文件\n自定义组件\n\n\n普通开发：导入starter，Controller、Service、Mapper、偶尔修改配置文件\n高级开发：自定义组件、自定义配置、自定义starter\n核心：\n\n这个场景自动配置导入了哪些组件，我们能不能Autowired进来使用\n能不能通过修改配置改变组件的一些默认参数\n需不需要自己完全定义这个组件\n场景定制化\n\n最佳实战：\n\n选场景，导入到项目\n\n官方：starter\n第三方：去仓库搜\n\n写配置，改配置文件关键项\n\n数据库参数（连接地址、账号密码…）\n\n分析这个场景给我们导入了哪些能用的组件\n\n自动装配这些组件进行后续使用\n不满意boot提供的自动配好的默认组件\n\n定制化\n改配置\n\n自定义组件\n\n\n\n\n整合redis：\n\n选场景：spring-boot-starter-data-redis\n\nRedisAutoConfiguration 就是这个场景的自动配置类\n直接在IDEA中全局搜索就能找到\n\n写配置：\n\n分析到这个场景的自动配置类开启了哪些属性绑定关系\n@EnableConfigurationProperties(RedisProperties.class)\n找到RedisProperties这个类查看所有属性配置\n修改redis相关的配置\n\n分析组件：\n\n分析到 RedisAutoConfiguration 给容器中放了\nStringRedisTemplate\n给业务代码中自动装配 StringRedisTemplate\n\n定制化\n\n修改配置文件\n自定义组件，自己给容器中放一个 StringRedisTemplate\n\n\n4、核心技能\n1. 常用注解\nSpringBoot摒弃XML配置方式，改为全注解驱动\n1. 组件注册\n@Configuration、@SpringBootConfiguration\n@Bean、@Scope\n@Controller、 @Service、@Repository、@Component\n@Import\n@ComponentScan\n步骤：\n1、@Configuration\n编写一个配置类\n2、在配置类中，自定义方法给容器中注册组件。配合@Bean\n3、或使用@Import 导入第三方的组件\n2. 条件注解\n如果注解指定的条件成立，则触发指定行为\n@ConditionalOnXxx\n@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为\n@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为\n@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为\n@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为\n场景：\n\n如果存在FastsqlException这个类，给容器中放一个Cat组件，名cat01，\n否则，就给容器中放一个Dog组件，名dog01\n如果系统中有dog01这个组件，就给容器中放一个\nUser组件，名zhangsan\n否则，就放一个User，名叫lisi\n\n@ConditionalOnBean（value=组件类型，name=组件名字）：判断容器中是否有这个类型的组件，并且名字是指定的值\n@ConditionalOnRepositoryType\n(org.springframework.boot.autoconfigure.data) @ConditionalOnDefaultWebSecurity\n(org.springframework.boot.autoconfigure.security) @ConditionalOnSingleCandidate\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnWebApplication\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnWarDeployment\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnJndi\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnResource\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnExpression\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnClass\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnEnabledResourceChain\n(org.springframework.boot.autoconfigure.web) @ConditionalOnMissingClass\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnNotWebApplication\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnProperty\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnCloudPlatform\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnBean\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnMissingBean\n(org.springframework.boot.autoconfigure.condition) @ConditionalOnMissingFilterBean\n(org.springframework.boot.autoconfigure.web.servlet) @Profile\n(org.springframework.context.annotation) @ConditionalOnInitializedRestarter\n(org.springframework.boot.devtools.restart) @ConditionalOnGraphQlSchema\n(org.springframework.boot.autoconfigure.graphql) @ConditionalOnJava\n(org.springframework.boot.autoconfigure.condition)\n3. 属性绑定\n@ConfigurationProperties：\n声明组件的属性和配置文件哪些前缀开始项进行绑定\n@EnableConfigurationProperties：快速注册注解：\n\n场景：SpringBoot默认只扫描自己主程序所在的包。如果导入第三方包，即使组件上标注了\n@Component、@ConfigurationProperties\n注解，也没用。因为组件都扫描不进来，此时使用这个注解就可以快速进行属性绑定并把组件注册进容器\n\n将容器中任意组件（Bean）的属性值和配置文件的配置项的值进行绑定\n\n1、给容器中注册组件（@Component、@Bean）\n2、使用@ConfigurationProperties\n声明组件和配置文件的哪些配置项进行绑定\n\n更多注解参照：Spring注解驱动开发【1-26集】\n2. YAML配置文件\n痛点：SpringBoot\n集中化管理配置，application.properties\n问题：配置多以后难阅读和修改，层级结构辨识度不高\nYAML 是 “YAML Ain’t a Markup Language”（YAML\n不是一种标记语言）。在开发的这种语言时，YAML 的意思其实是：“Yet Another\nMarkup Language”（是另一种标记语言）。\n\n设计目标，就是方便人类读写\n层次分明，更适合做配置文件\n使用.yaml或 .yml作为文件后缀\n\n1. 基本语法\n\n大小写敏感\n使用缩进表示层级关系，k: v，使用空格分割k,v\n缩进时不允许使用Tab键，只允许使用空格。换行\n缩进的空格数目不重要，只要相同层级的元素左侧对齐即可\n#\n表示注释，从这个字符一直到行尾，都会被解析器忽略。\n\n支持的写法：\n\n对象：键值对的集合，如：映射（map）/\n哈希（hash） / 字典（dictionary）\n数组：一组按次序排列的值，如：序列（sequence） /\n列表（list）\n纯量：单个的、不可再分的值，如：字符串、数字、bool、日期\n\n2. 示例\n@Component@ConfigurationProperties(prefix = \"person\") //和配置文件person前缀的所有配置进行绑定@Data //自动生成JavaBean属性的getter/setter//@NoArgsConstructor //自动生成无参构造器//@AllArgsConstructor //自动生成全参构造器public class Person {    private String name;    private Integer age;    private Date birthDay;    private Boolean like;    private Child child; //嵌套对象    private List&lt;Dog&gt; dogs; //数组（里面是对象）    private Map&lt;String,Cat&gt; cats; //表示Map}@Datapublic class Dog {    private String name;    private Integer age;}@Datapublic class Child {    private String name;    private Integer age;    private Date birthDay;    private List&lt;String&gt; text; //数组}@Datapublic class Cat {    private String name;    private Integer age;}\nproperties表示法\nperson.name=张三person.age=18person.birthDay=2010/10/12 12:12:12person.like=trueperson.child.name=李四person.child.age=12person.child.birthDay=2018/10/12person.child.text[0]=abcperson.child.text[1]=defperson.dogs[0].name=小黑person.dogs[0].age=3person.dogs[1].name=小白person.dogs[1].age=2person.cats.c1.name=小蓝person.cats.c1.age=3person.cats.c2.name=小灰person.cats.c2.age=2\nyaml表示法\nperson:  name: 张三  age: 18  birthDay: 2010/10/10 12:12:12  like: true  child:    name: 李四    age: 20    birthDay: 2018/10/10    text: [\"abc\",\"def\"]  dogs:    - name: 小黑      age: 3    - name: 小白      age: 2  cats:    c1:      name: 小蓝      age: 3    c2: {name: 小绿,age: 2} #对象也可用{}表示\n3. 细节\n\nbirthDay 推荐写为 birth-day\n文本\n\n单引号不会转义【‘’ 则为普通字符串显示】\n双引号会转义【“”\n会显示为换行符】\n\n大文本\n\n|开头，大文本写在下层，保留文本格式，换行符正确显示\n&gt;开头，大文本写在下层，折叠换行符\n\n多文档合并\n\n使用---可以把多个yaml文档合并在一个文档中，每个文档区依然认为内容独立\n\n\n4. 小技巧：lombok\n简化JavaBean\n开发。自动生成构造器、getter/setter、自动生成Builder模式等\n&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;\n使用@Data等注解\n3. 日志配置\n\n规范：项目开发不要编写System.out.println()，应该用日志记录信息\n\n感兴趣日志框架关系与起源可参考：https://www.bilibili.com/video/BV1gW411W76m\n视频 21~27集\n1. 简介\n\nSpring使用commons-logging作为内部日志，但底层日志实现是开放的。可对接其他日志框架。\n支持 jul，log4j2 logback。SpringBoot\n提供了默认的控制台输出配置，也可以配置输出为文件。\nlogback是默认使用的。\n虽然日志框架很多，但使用 SpringBoot\n的默认配置就能工作的很好。\n\nSpringBoot怎么把日志默认配置好的\n1、每个starter场景，都会导入一个核心场景spring-boot-starter\n2、核心场景引入了日志的所用功能spring-boot-starter-logging\n3、默认使用了logback + slf4j 组合作为默认底层日志\n4、日志是系统一启动就要用，但xxxAutoConfiguration是系统启动好了以后放好的组件，系统启动完成后用的。\n5、日志是利用监听器机制配置好的。ApplicationListener。\n6、日志所有的配置都可以通过修改配置文件实现。以logging开始的所有配置。\n2. 日志格式\n2023-03-31T13:56:17.511+08:00  INFO 4944 --- [main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2023-03-31T13:56:17.511+08:00  INFO 4944 --- [main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.7]\n默认输出格式：\n\n时间和日期：毫秒级精度\n日志级别：ERROR, WARN, INFO, DEBUG, or TRACE.\n进程 ID\n—： 消息分割符\n线程名： 使用[]包含\nLogger名： 通常是产生日志的类名\n消息： 日志记录的内容\n\n注意： logback 没有FATAL级别，对应的是ERROR\n默认值：参照：spring-boot包additional-spring-configuration-metadata.json文件\n默认输出格式值：%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\n可修改为：'%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level [%thread] %logger{15} ===&gt; %msg%n'\n3. 记录日志\nLogger logger = LoggerFactory.getLogger(getClass());或者使用Lombok的@Slf4j注解\n4. 日志级别\n\n由低到高：ALL,TRACE, DEBUG, INFO, WARN, ERROR,FATAL,OFF；\n\n只会打印指定级别及以上级别的日志\nALL：打印所有日志\nTRACE：追踪框架详细流程日志，一般不使用\nDEBUG：开发调试细节日志\nINFO：关键、感兴趣信息日志\nWARN：警告但不是错误的信息日志，比如：版本过时\nERROR：业务错误日志，比如出现各种异常\nFATAL：致命错误日志，比如jvm系统崩溃\nOFF：关闭所有日志记录\n\n不指定级别的所有类，都使用root指定的级别作为默认级别\nSpringBoot日志 默认级别是INFO\n\n在application.properties/yaml中配置logging.level.=指定日志级别\nlevel可取值范围：TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF，定义在\nLogLevel类中\nroot\n的logger-name叫root，可以配置logging.level.root=warn，代表所有未指定日志级别都使用\nroot 的 warn 级别\n#默认所有日志没有精确指定级别就使用root的默认级别#logging.level.root=info#精确调整某个包下的日志级别#logging.level.com.atguigu.logging.controller=debug#logging.level.com.atguigu.logging.service=debug#logging.level.com.aaa=debug#logging.level.com.bbb=debug\n5. 日志分组\n比较有用的技巧是：\n将相关的logger分组在一起，统一配置。\n比如：Tomcat 相关的日志统一设置。\nlogging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcatlogging.level.tomcat=trace\nSpringBoot 预定义两个组\n\n\n\n\n\n\n\nName\nLoggers\n\n\n\n\nweb\norg.springframework.core.codec, org.springframework.http,\norg.springframework.web, org.springframework.boot.actuate.endpoint.web,\norg.springframework.boot.web.servlet.ServletContextInitializerBeans\n\n\nsql\norg.springframework.jdbc.core, org.hibernate.SQL,\norg.jooq.tools.LoggerListener\n\n\n\n6. 文件输出\nSpringBoot\n默认只把日志写在控制台，如果想额外记录到文件，可以在application.properties中添加\nlogging.file.name or logging.file.path。\n\n\n\n\n\n\n\n\n\nlogging.file.name\nlogging.file.path\n示例\n效果\n\n\n\n\n未指定\n未指定\n\n仅控制台输出\n\n\n指定\n未指定\nmy.log\n写入指定文件\n\n\n未指定\n指定\n/var/log\n写入指定目录，文件名为spring.log\n\n\n指定\n指定\n\n以logging.file.name为准\n\n\n\n7. 文件归档与滚动切割\n归档：每天的日志单独存到一个文档中。\n切割：每个文件10MB，超过大小切割成另外一个文件。\n\n每天的日志应该独立分割出来存档。如果使用logback（SpringBoot\n默认整合），可以通过application.properties/yaml文件指定日志滚动规则。\n如果是其他日志系统，需要自行配置（添加log4j2.xml或log4j2-spring.xml）\n支持的滚动规则设置如下\n\n\n\n\n\n\n\n\n配置项\n描述\n\n\n\n\nlogging.logback.rollingpolicy.file-name-pattern\n日志存档的文件名格式（默认值：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz）\n\n\nlogging.logback.rollingpolicy.clean-history-on-start\n应用启动时是否清除以前存档（默认值：false）\n\n\nlogging.logback.rollingpolicy.max-file-size\n存档前，每个日志文件的最大大小（默认值：10MB）\n\n\nlogging.logback.rollingpolicy.total-size-cap\n日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置1GB则磁盘存储超过\n1GB 日志后就会删除旧日志文件\n\n\nlogging.logback.rollingpolicy.max-history\n日志文件保存的最大天数(默认值：7).\n\n\n\n8. 自定义配置\n通常我们配置 application.properties\n就够了。当然也可以自定义。比如：\n\n\n\n\n\n\n\n日志系统\n自定义\n\n\n\n\nLogback\nlogback-spring.xml, logback-spring.groovy, logback.xml, or\nlogback.groovy\n\n\nLog4j2\nlog4j2-spring.xml or log4j2.xml\n\n\nJDK (Java Util Logging)\nlogging.properties\n\n\n\n如果可能，我们建议您在日志配置中使用-spring\n变量（例如，logback-spring.xml 而不是\nlogback.xml）。\n如果您使用标准配置文件，spring 无法完全控制日志初始化。\n最佳实战：自己要写配置，配置文件名加上 xx-spring.xml\n9. 切换日志组合\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;\nlog4j2支持yaml和json格式的配置文件\n\n\n\n\n\n\n\n\n格式\n依赖\n文件名\n\n\n\n\nYAML\ncom.fasterxml.jackson.core:jackson-databind +\ncom.fasterxml.jackson.dataformat:jackson-dataformat-yaml\nlog4j2.yaml + log4j2.yml\n\n\nJSON\ncom.fasterxml.jackson.core:jackson-databind\nlog4j2.json + log4j2.jsn\n\n\n\n10. 最佳实战\n\n导入任何第三方框架，先排除它的日志包，因为Boot底层控制好了日志\n修改 application.properties\n配置文件，就可以调整日志的所有行为。如果不够，可以编写日志框架自己的配置文件放在类路径下就行，比如logback-spring.xml，log4j2-spring.xml\n如需对接专业日志系统，也只需要把 logback\n记录的日志灌倒kafka之类的中间件，这和SpringBoot没关系，都是日志框架自己的配置，修改配置文件即可\n业务中使用slf4j-api记录日志。不要再 sout 了\n\n","categories":["后端","Spring"],"tags":["SpringBoot3"]},{"title":"String Algorithm","url":"/2022/11/30/String-Algorithm/","content":"常见的字符串算法以及模板，包含了\nKMP、Trie、AC自动机，字符串哈希等。\n\n字符串哈希\n\n            javac++// 大M取一个比较大的素数 1e9+7 4294967291 大P取一个比较小的素数 171 131long M = 0x60000005, P = 171;long[] p, h;p[0] = 1;for (int i = 1;i &lt;= n;i++){    h[i] = (h[i-1]*P+(s.charAt(i-1)-'a'+1))%M;    p[i] = p[i-1]*P%M;}long get(int l, int r){    return (h[r]-h[l-1]*p[r-l+1]%M+M)%M;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int rnd(int x, int y) {    return uniform_int_distribution&lt;int&gt;(x, y)(rng);}ll MOD = 1e18 + rnd(0, 1e9), BASE = 233 + rnd(0, 1e3);struct HashString {    vector&lt;__int128_t&gt; P, H;    HashString(string &amp;s) {        int n = s.size();        P.resize(n + 1);        P[0] = 1;        H.resize(n + 1);        H[0] = 0;        for (int i = 1; i &lt;= n; i++) {            P[i] = P[i - 1] * BASE % MOD;            H[i] = (H[i - 1] * BASE + s[i - 1]) % MOD;        }    }    ll query(int l, int r) {        return (H[r] - H[l - 1] * P[r - l + 1] % MOD + MOD) % MOD;    }};\n          \n\n字典树\nclass Node{ Node[] r = new Node[26]; boolean isEnd = false; // 判断是不是一个字符串末尾}static Node root = new Node();static add(String ss){ Node cur = root; for (int k = 0;k &lt; ss.length();k++){     int x = ss.charAt(k)-'a';     if (cur.r[x] == null) cur.r[x] = new Node();     cur = cur.r[x]; } cur.isEnd = true;}static boolean qurey(String ss){ Node cur = root; for (int k = 0;k &lt; ss.length();k++){     int x = ss.charAt(k)-'a';     if (cur.r[x] == null) return false; //下一个字符没有出现 直接false     cur = cur.r[x]; } return cur.isEnd; //字符都在 判断是不是结束了}\n\nKMP\n//两个字符串的下标都从 1 开始// 求ne过程,是p[]自己和自己匹配的过程； 起始i = 2,要注意for( int i = 2, j = 0; i &lt;=n; i++){    while( j &amp;&amp; p[i] != p[j + 1])   j = ne[j];    if( p[i] == p[j + 1]) j ++;    // 这里不用管是否匹配成功，ne[i]的值都要记录下来    ne[i] = j;}// kmp匹配过程 for(int i = 1, j = 0 ; i &lt;= m; i++){    // j 表示是否退回起点    while( j &amp;&amp; s[i] != p[ j + 1])  j = ne[j];    if ( s[i] == p [ j + 1 ])    j++;    if( j == n){        // 匹配成功，这里的 i - n 是第一个匹配元素的下标，本应该是 i - n + 1， 由于数组是从1开始计数，所以为 i - n        printf(\"%d \" , i - n );        // 匹配成功后找下一个匹配        j = ne[j];    }}fail = new int[m];for (int i = 1, j = 0; i &lt; m; ++i) {    while (j != 0 &amp;&amp; e.charAt(j) != e.charAt(i)) j = fail[j - 1];    if (e.charAt(j) == e.charAt(i)) ++j;    fail[i] = j;}\nAC自动机\nconst int N = 5e4+10, M = 26;struct ACA {    int tot, ch[N][M], deep[N], fail[N];    int cnt[N];    ACA() {        tot = 0;        for (int i = 0;i &lt; N;i++) memset(ch[i], 0, sizeof(int)*M);        memset(deep, 0, sizeof(int)*N);        memset(fail, 0, sizeof(int)*N);        memset(last, 0, sizeof(int)*N);        memset(cnt, 0, sizeof(int)*N);    }    void insert(string&amp; cur, int cost) {        int n = cur.size(), node = 0;        for (int i = 0;i &lt; n;i++) {            int c = cur[i]-'a';            if (!ch[node][c]) {                ch[node][c] = ++tot;                deep[tot] = i+1;            }            node = ch[node][c];        }        cnt[node] = cost;    }    void build() {        queue&lt;int&gt; q;        for (int i = 0;i &lt; M;i++) {            if (ch[0][i]) {                q.push(ch[0][i]);            }        }        while (q.size()) {            int cur = q.front(); q.pop();            for (int i = 0;i &lt; M;i++) {                int nxt = ch[cur][i], nf = ch[fail[cur]][i];                if (nxt) {                    fail[nxt] = nf;                    q.push(nxt);                } else {                    ch[cur][i] = nf;                }            }        }    }};int query(string s) {    int res = 0;    for (int i = 1, root = 0;i &lt;= n;i++) {        int c = target[i-1]-'a';        root = ac.ch[root][c];        for (int j = root;j;j = ac.fail[j]) {            res += ac.cnt[j];            ac.cnt[j] = 0;        }    }    return res;}\n","categories":["Algorithm","Template"],"tags":["Template","String"]},{"title":"SpringBoot3 源码分析","url":"/2025/01/20/SpringBoot3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","content":"SpringBoot3源码分析聚焦事件与监听器、自动配置原理与自定义Starter三大主题，深入剖析SpringApplicationRunListener生命周期、SPI驱动的自动配置加载流程，并演示Starter抽取与集成方法，帮助快速掌握SpringBoot底层扩展机制。\n\n1. 事件和监听器\n1. 生命周期监听\n场景：监听应用的生命周期\n1.\n监听器-SpringApplicationRunListener\n\n自定义SpringApplicationRunListener来监听事件；\n\n编写SpringApplicationRunListener\n实现类\n在 META-INF/spring.factories 中配置\norg.springframework.boot.SpringApplicationRunListener=自己的Listener，还可以指定一个有参构造器，接受两个参数(SpringApplication application, String[] args)\nspringboot 在spring-boot.jar中配置了默认的\nListener\n\n\n/** * Listener先要从 META-INF/spring.factories 读到 * * 1、引导： 利用 BootstrapContext 引导整个项目启动 *      starting：              应用开始，SpringApplication的run方法一调用，只要有了 BootstrapContext 就执行 *      environmentPrepared：   环境准备好（把启动参数等绑定到环境变量中），但是ioc还没有创建；【调一次】 * 2、启动： *      contextPrepared：       ioc容器创建并准备好，但是sources（主配置类）没加载。并关闭引导上下文；组件都没创建  【调一次】 *      contextLoaded：         ioc容器加载。主配置类加载进去了。但是ioc容器还没刷新（我们的bean没创建）。 *      =======截止以前，ioc容器里面还没造bean呢======= *      started：               ioc容器刷新了（所有bean造好了），但是 runner 没调用。 *      ready:                  ioc容器刷新了（所有bean造好了），所有 runner 调用完了。 * 3、运行 *     以前步骤都正确执行，代表容器running。 */\n2. 生命周期全流程\n2. 事件触发时机\n1. 各种回调监听器\n\nBootstrapRegistryInitializer：\n感知特定阶段：感知引导初始化\n\nMETA-INF/spring.factories\n创建引导上下文bootstrapContext的时候触发。\napplication.addBootstrapRegistryInitializer();\n场景：进行密钥校对授权。\n\nApplicationContextInitializer： 感知特定阶段：\n感知ioc容器初始化\n\nMETA-INF/spring.factories -\napplication.addInitializers();\n\nApplicationListener：\n感知全阶段：基于事件机制，感知事件。\n一旦到了哪个阶段可以做别的事\n\n@Bean或@EventListener：\n事件驱动 - SpringApplication.addListeners(…)或\nSpringApplicationBuilder.listeners(…) -\nMETA-INF/spring.factories\n\nSpringApplicationRunListener： 感知全阶段生命周期 +\n各种阶段都能自定义操作； 功能更完善。\n\nMETA-INF/spring.factories\n\nApplicationRunner:\n感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪\n\n@Bean\n\nCommandLineRunner：\n感知特定阶段：感知应用就绪Ready。卡死应用，就不会就绪\n\n@Bean\n\n\n最佳实战：\n\n如果项目启动前做事： BootstrapRegistryInitializer 和\nApplicationContextInitializer\n如果想要在项目启动完成后做事：**ApplicationRunner**和\n**CommandLineRunner**\n如果要干涉生命周期做事：**SpringApplicationRunListener**\n如果想要用事件机制：**ApplicationListener**\n\n2. 完整触发流程\n**大事件触发顺序&amp;时机\n\nApplicationStartingEvent：应用启动但未做任何事情,\n除注册listeners and initializers.\nApplicationEnvironmentPreparedEvent： Environment\n准备好，但context 未创建.\nApplicationContextInitializedEvent: ApplicationContext\n准备好，ApplicationContextInitializers 调用，但是任何bean未加载\nApplicationPreparedEvent：\n容器刷新之前，bean定义信息加载\nApplicationStartedEvent： 容器刷新完成，\nrunner未调用\n\n=========以下就开始插入了探针机制============\n\nAvailabilityChangeEvent：\nLivenessState.CORRECT应用存活；\n存活探针\nApplicationReadyEvent: 任何runner被调用\nAvailabilityChangeEvent：ReadinessState.ACCEPTING_TRAFFIC就绪探针，可以接请求\nApplicationFailedEvent：启动出错\n\n感知应用是否存活了：可能植物状态，虽然活着但是不能处理请求。\n应用是否就绪了：能响应请求，说明确实活的比较好。\n3. SpringBoot 事件驱动开发\n应用启动过程生命周期事件感知（9大事件）、应用运行中事件感知（无数种）。\n\n事件发布：ApplicationEventPublisherAware或注入：ApplicationEventMulticaster\n事件监听：组件 + @EventListener\n\n事件发布者\n@Servicepublic class EventPublisher implements ApplicationEventPublisherAware {    /**     * 底层发送事件用的组件，SpringBoot会通过ApplicationEventPublisherAware接口自动注入给我们     * 事件是广播出去的。所有监听这个事件的监听器都可以收到     */    ApplicationEventPublisher applicationEventPublisher;    /**     * 所有事件都可以发     * @param event     */    public void sendEvent(ApplicationEvent event) {        //调用底层API发送事件        applicationEventPublisher.publishEvent(event);    }    /**     * 会被自动调用，把真正发事件的底层组组件给我们注入进来     * @param applicationEventPublisher event publisher to be used by this object     */    @Override    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {        this.applicationEventPublisher = applicationEventPublisher;    }}\n事件订阅者\n@Servicepublic class CouponService {    @Order(1)    @EventListener    public void onEvent(LoginSuccessEvent loginSuccessEvent){        System.out.println(\"===== CouponService ====感知到事件\"+loginSuccessEvent);        UserEntity source = (UserEntity) loginSuccessEvent.getSource();        sendCoupon(source.getUsername());    }    public void sendCoupon(String username){        System.out.println(username + \" 随机得到了一张优惠券\");    }}\n2. 自动配置原理\n1. 入门理解\n应用关注的三大核心：场景、配置、组件\n1. 自动配置流程\n\n导入starter\n依赖导入autoconfigure\n寻找类路径下\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件\n启动，加载所有 自动配置类\nxxxAutoConfiguration\n\n给容器中配置功能组件\n组件参数绑定到\n属性类中。xxxProperties\n属性类和配置文件前缀项绑定\n@Contional派生的条件注解进行判断是否组件生效\n\n效果：\n\n修改配置文件，修改底层参数\n所有场景自动配置好直接使用\n可以注入SpringBoot配置好的组件随时使用\n\n\n2. SPI机制\n\nJava中的SPI（Service Provider\nInterface）是一种软件设计模式，用于在应用程序中动态地发现和加载组件。SPI的思想是，定义一个接口或抽象类，然后通过在classpath中定义实现该接口的类来实现对组件的动态发现和加载。\nSPI的主要目的是解决在应用程序中使用可插拔组件的问题。例如，一个应用程序可能需要使用不同的日志框架或数据库连接池，但是这些组件的选择可能取决于运行时的条件。通过使用SPI，应用程序可以在运行时发现并加载适当的组件，而无需在代码中硬编码这些组件的实现类。\n在Java中，SPI的实现方式是通过在META-INF/services目录下创建一个以服务接口全限定名为名字的文件，文件中包含实现该服务接口的类的全限定名。当应用程序启动时，Java的SPI机制会自动扫描classpath中的这些文件，并根据文件中指定的类名来加载实现类。\n通过使用SPI，应用程序可以实现更灵活、可扩展的架构，同时也可以避免硬编码依赖关系和增加代码的可维护性。\n\n3. 功能开关\n\n自动配置：全部都配置好，什么都不用管。\n\n自动批量导入\n项目一启动，spi文件中指定的所有都加载。\n\n@EnableXxxx：手动控制哪些功能的开启； 手动导入。\n\n开启xxx功能\n都是利用 @Import\n把此功能要用的组件导入进去\n\n\n2. 进阶理解\n1. @SpringBootApplication\n@SpringBootConfiguration\n就是： @Configuration\n，容器中的组件，配置类。spring ioc启动就会加载创建这个类对象\n@EnableAutoConfiguration：开启自动配置\n开启自动配置\n@AutoConfigurationPackage：扫描主程序包：加载自己的组件\n\n利用 @Import(AutoConfigurationPackages.Registrar.class)\n想要给容器中导入组件。\n把主程序所在的包的所有组件导入进来。\n为什么SpringBoot默认只扫描主程序所在的包及其子包\n\n@Import(AutoConfigurationImportSelector.class)：加载所有自动配置类：加载starter导入的组件\nList&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())    .getCandidates();\n扫描SPI文件：META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n@ComponentScan\n组件扫描：排除一些组件（哪些不要）\n排除前面已经扫描进来的配置类、和自动配置类。\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\n2. 完整启动加载流程\n生命周期启动加载流程\n3. 自定义starter\n场景：抽取聊天机器人场景，它可以打招呼。\n效果：任何项目导入此starter都具有打招呼功能，并且问候语中的人名需要可以在配置文件中修改\n\n\\1.\n创建自定义starter项目，引入spring-boot-starter基础依赖\n\\2. 编写模块功能，引入模块所有需要的依赖。\n\\3.\n编写xxxAutoConfiguration自动配置类，帮其他项目导入这个模块需要的所有组件\n\\4.\n编写配置文件META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports指定启动需要加载的自动配置\n\\5. 其他项目引入即可使用\n\n1. 业务代码\n自定义配置有提示。导入以下依赖重启项目，再写配置文件就有提示\n@ConfigurationProperties(prefix = \"robot\")  //此属性类和配置文件指定前缀绑定@Component@Datapublic class RobotProperties {    private String name;    private String age;    private String email;}\n&lt;!--        导入配置处理器，配置文件自定义的properties配置都会有提示--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\n2. 基本抽取\n\n创建starter项目，把公共代码需要的所有依赖导入\n把公共代码复制进来\n自己写一个\nRobotAutoConfiguration，给容器中导入这个场景需要的所有组件\n\n为什么这些组件默认不会扫描进去？ - starter所在的包和\n引入它的项目的主程序所在的包不是父子层级\n\n别人引用这个starter，直接导入这个\nRobotAutoConfiguration,就能把这个场景的组件导入进来\n功能生效。\n测试编写配置文件\n\n3. 使用@EnableXxx机制\n@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import(RobotAutoConfiguration.class)public @interface EnableRobot {}\n别人引入starter需要使用\n@EnableRobot开启功能\n4. 完全自动配置\n\n依赖SpringBoot的SPI机制\nMETA-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports\n文件中编写好我们自动配置类的全类名即可\n项目启动，自动加载我们的自动配置类\n\n","categories":["后端","Spring"],"tags":["SpringBoot3"]},{"title":"SpringMVC 实战演练","url":"/2024/06/15/SpringMVC-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83/","content":"SpringMVC\n实战演练涵盖框架组织结构与请求执行流程；演示多种参数接收方式（RequestParam、路径参数、JSON\n请求体、原生 Servlet API）及响应处理手段（模板渲染、页面跳转、JSON\n输出、静态资源访问）；并介绍全局异常处理、拦截器配置、参数校验等扩展功能，帮助开发者快速上手并灵活扩展框架能力。\n\n一、SpringMVC简介和体验\n1.1 介绍\nhttps://docs.spring.io/spring-framework/reference/web/webmvc.html\nSpring Web MVC是基于Servlet\nAPI构建的原始Web框架，从一开始就包含在Spring\nFramework中。正式名称“Spring Web MVC”来自其源模块的名称（\nspring-webmvc ），但它通常被称为“Spring MVC”。\n在控制层框架历经Strust、WebWork、Strust2等诸多产品的历代更迭之后，目前业界普遍选择了SpringMVC作为Java\nEE项目表述层开发的首选方案。之所以能做到这一点，是因为SpringMVC具备如下显著优势：\n\nSpring\n家族原生产品，与IOC容器等基础设施无缝对接\n表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案\n代码清新简洁，大幅度提升开发效率\n内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可\n性能卓著，尤其适合现代大型、超大型互联网项目要求\n\n原生Servlet API开发代码片段\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)                                                         throws ServletException, IOException {      String userName = request.getParameter(\"userName\");        System.out.println(\"userName=\"+userName);}\n基于SpringMVC开发代码片段\n@RequestMapping(\"/user/login\")public String login(@RequestParam(\"userName\") String userName,Sting password){        log.debug(\"userName=\"+userName);    //调用业务即可        return \"result\";}\n1.2 主要作用\n\nSSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化！\nSpringMVC的作用主要覆盖的是表述层，例如：\n\n请求映射\n数据输入\n视图界面\n请求分发\n表单回显\n会话控制\n过滤拦截\n异步交互\n文件上传\n文件下载\n数据校验\n类型转换\n……\n\n最终总结：\n\n简化前端参数接收(形参列表)\n简化后端数据响应(返回值)\n以及其他……\n\n1.3 核心组件和调用流程理解\nSpring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央\nServlet DispatcherServlet\n做整体请求处理调度！\n除了DispatcherServletSpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。\nSpringMVC处理请求流程：\n\nSpringMVC涉及组件理解：\n\nDispatcherServlet :\nSpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发！[\nCEO ]\nHandlerMapping :\nSpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler！[秘书]\nHandlerAdapter :\nSpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器！[经理]\nHandler :\nhandler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果！[打工人]\nViewResovler :\nSpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的！[财务]\n\n1.4 快速体验\n\n体验场景需求\n配置分析\n\nDispatcherServlet，设置处理所有请求！\nHandlerMapping,HandlerAdapter,Handler需要加入到IoC容器，供DS调用！\nHandler自己声明（Controller）需要配置到HandlerMapping中供DS查找！\n\n准备项目\n\n创建项目\nspringmvc-base-quick\n注意：需要转成maven/web程序！！\n导入依赖\n&lt;properties&gt;    &lt;spring.version&gt;6.0.6&lt;/spring.version&gt;    &lt;servlet.api&gt;9.1.0&lt;/servlet.api&gt;    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- springioc相关依赖  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- web相关依赖  --&gt;    &lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;    &lt;!--        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此在配置 DispatcherServlet 时需要使用         Jakarta EE 提供的相应类库和命名空间。错误信息 “‘org.springframework.web.servlet.DispatcherServlet’         is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’” 表明你使用了旧版本的         Servlet API，没有更新到 Jakarta EE 规范。    --&gt;    &lt;dependency&gt;        &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;        &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;        &lt;version&gt;${servlet.api}&lt;/version&gt;        &lt;scope&gt;provided&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- springwebmvc相关依赖  --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\nController声明\n@Controllerpublic class HelloController {    //handlers    /**     * handler就是controller内部的具体方法     * @RequestMapping(\"/springmvc/hello\") 就是用来向handlerMapping中注册的方法注解!     * @ResponseBody 代表向浏览器直接返回数据!     */    @RequestMapping(\"/springmvc/hello\")    @ResponseBody    public String hello(){        System.out.println(\"HelloController.hello\");        return \"hello springmvc!!\";    }}\nSpring MVC核心组件配置类\n\n声明springmvc涉及组件信息的配置类\n\n//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc     @Configuration@ComponentScan(basePackages = \"com.atguigu.controller\") //TODO: 进行controller扫//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {    @Bean    public HandlerMapping handlerMapping(){        return new RequestMappingHandlerMapping();    }    @Bean    public HandlerAdapter handlerAdapter(){        return new RequestMappingHandlerAdapter();    }    }\nSpringMVC环境搭建\n\n对于使用基于 Java 的 Spring\n配置的应用程序，建议这样做，如以下示例所示：\n\n//TODO: SpringMVC提供的接口,是替代web.xml的方案,更方便实现完全注解方式ssm处理!//TODO: Springmvc框架会自动检查当前类的实现类,会自动加载 getRootConfigClasses / getServletConfigClasses 提供的配置类//TODO: getServletMappings 返回的地址 设置DispatherServlet对应处理的地址public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {  /**   * 指定service / mapper层的配置类   */  @Override  protected Class&lt;?&gt;[] getRootConfigClasses() {    return null;  }  /**   * 指定springmvc的配置类   * @return   */  @Override  protected Class&lt;?&gt;[] getServletConfigClasses() {    return new Class&lt;?&gt;[] { SpringMvcConfig.class };  }  /**   * 设置dispatcherServlet的处理路径!   * 一般情况下为 / 代表处理所有请求!   */  @Override  protected String[] getServletMappings() {    return new String[] { \"/\" };  }}\n启动测试\n注意： tomcat应该是10+版本！方可支持 Jakarta EE API!\n\n二、SpringMVC接收数据\n2.1 访问路径设置\n@RequestMapping注解的作用就是将请求的\nURL 地址和处理请求的方式（handler方法）关联起来，建立映射关系。\nSpringMVC\n接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。\n\n精准路径匹配\n在@RequestMapping注解指定 URL\n地址时，不使用任何通配符，按照请求地址进行精确匹配。\n@Controllerpublic class UserController {    /**     * 精准设置访问地址 /user/login     */    @RequestMapping(value = {\"/user/login\"})    @ResponseBody    public String login(){        System.out.println(\"UserController.login\");        return \"login success!!\";    }    /**     * 精准设置访问地址 /user/register     */    @RequestMapping(value = {\"/user/register\"})    @ResponseBody    public String register(){        System.out.println(\"UserController.register\");        return \"register success!!\";    }    }\n模糊路径匹配\n在@RequestMapping注解指定 URL\n地址时，通过使用通配符，匹配多个类似的地址。\n@Controllerpublic class ProductController {    /**     *  路径设置为 /product/*       *    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler       *    /product/a/a 不可以     *  路径设置为 /product/**      *   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler       *   /product/a/a 也可以访问     */    @RequestMapping(\"/product/*\")    @ResponseBody    public String show(){        System.out.println(\"ProductController.show\");        return \"product show!\";    }}\n单层匹配和多层匹配：  /*：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“/*/*”以此类推。  /**：可以匹配URL地址中的多层。其中所谓的一层或多层是指一个URL地址字符串被“/”划分出来的各个层次这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。\n类和方法级别区别\n@RequestMapping\n注解可以用于类级别和方法级别，它们之间的区别如下：\n\n设置到类级别：@RequestMapping\n注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。\n设置到方法级别：@RequestMapping\n注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的\n@RequestMapping 注解进行更精细的映射。\n\n//1.标记到handler方法@RequestMapping(\"/user/login\")@RequestMapping(\"/user/register\")@RequestMapping(\"/user/logout\")//2.优化标记类+handler方法//类上@RequestMapping(\"/user\")//handler方法上@RequestMapping(\"/login\")@RequestMapping(\"/register\")@RequestMapping(\"/logout\")\n附带请求方式限制\nHTTP 协议定义了八种请求方式，在 SpringMVC\n中封装到了下面这个枚举类：\npublic enum RequestMethod {  GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE}\n默认情况下：@RequestMapping(“/logout”)\n任何请求方式都可以访问！\n如果需要特定指定：\n@Controllerpublic class UserController {    /**     * 精准设置访问地址 /user/login     * method = RequestMethod.POST 可以指定单个或者多个请求方式!     */    @RequestMapping(value = {\"/user/login\"} , method = RequestMethod.POST)    @ResponseBody    public String login(){        System.out.println(\"UserController.login\");        return \"login success!!\";    }    /**     * 精准设置访问地址 /user/register     */    @RequestMapping(value = {\"/user/register\"},method = {RequestMethod.POST,RequestMethod.GET})    @ResponseBody    public String register(){        System.out.println(\"UserController.register\");        return \"register success!!\";    }}\n注意：违背请求方式，会出现405异常！！！\n进阶注解\n还有 @RequestMapping 的 HTTP 方法特定快捷方式变体：\n\n@GetMapping\n@PostMapping\n@PutMapping\n@DeleteMapping\n@PatchMapping\n\n@RequestMapping(value=\"/login\",method=RequestMethod.GET)||@GetMapping(value=\"/login\")\n注意：进阶注解只能添加到handler方法上，无法添加到类上！\n常见配置问题\n出现原因：多个 handler 方法映射了同一个地址，导致 SpringMVC\n在接收到这个地址的请求时该找哪个 handler 方法处理。\n\nThere is already ‘demo03MappingMethodHandler’ bean method\ncom.atguigu.mvc.handler.Demo03MappingMethodHandler#empGet()\nmapped.\n\n\n2.2 接收参数（重点）\n2.2.1 param 和 json参数比较\n在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON\n类型。下面对这两种参数类型进行区别和对比：\n\n参数编码： \nparam 类型的参数会被编码为 ASCII 码。例如，假设\nname=john doe，则会被编码为\nname=john%20doe。而 JSON 类型的参数会被编码为\nUTF-8。\n参数顺序： \nparam 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON\n采用键值对的形式进行传递，其中键值对是有序排列的。\n数据类型： \nparam\n类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON\n类型的参数则支持更复杂的数据类型，如数组、对象等。\n嵌套性： \nparam 类型的参数不支持嵌套。但是，JSON\n类型的参数支持嵌套，可以传递更为复杂的数据结构。\n可读性： \nparam 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON\n格式在传递嵌套数据结构时更加清晰易懂。\n\n总的来说，param 类型的参数适用于单一的数据传递，而 JSON\n类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在\nGET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON\n类型的参数传递。\n2.2.2 param参数接收\n\n直接接值\n客户端请求\n\nhandler接收参数\n只要形参数名和类型与传递参数相同，即可自动接收!\n@Controller@RequestMapping(\"param\")public class ParamController {    /**     * 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18     *     * 可以利用形参列表,直接接收前端传递的param参数!     *    要求: 参数名 = 形参名     *          类型相同     * 出现乱码正常，json接收具体解决！！     * @return 返回前端数据     */    @GetMapping(value=\"/value\")    @ResponseBody    public String setupForm(String name,int age){        System.out.println(\"name = \" + name + \", age = \" + age);        return name + age;    }}\n@RequestParam注解\n可以使用 @RequestParam 注释将 Servlet\n请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。\n@RequestParam使用场景：\n\n指定绑定的请求参数名\n要求请求参数必须传递\n为请求参数提供默认值\n\n /** * 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18 *  *  使用@RequestParam注解标记handler方法的形参 *  指定形参对应的请求参数@RequestParam(请求参数名称) */@GetMapping(value=\"/data\")@ResponseBodypublic Object paramForm(@RequestParam(\"name\") String name,                         @RequestParam(\"stuAge\") int age){    System.out.println(\"name = \" + name + \", age = \" + age);    return name+age;}\n默认情况下，使用此批注的方法参数是必需的，但您可以通过将\n@RequestParam 批注的 required 标志设置为\nfalse！\n如果没有没有设置非必须，也没有传递参数会出现：\n\n将参数设置非必须，并且设置默认值：\n@GetMapping(value=\"/data\")@ResponseBodypublic Object paramForm(@RequestParam(\"name\") String name,                         @RequestParam(value = \"stuAge\",required = false,defaultValue = \"18\") int age){    System.out.println(\"name = \" + name + \", age = \" + age);    return name+age;}\n特殊场景接值\n\n一名多值\n多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！\n/** * 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝 * *  一名多值,可以使用集合接收即可!但是需要使用@RequestParam注解指定 */@GetMapping(value=\"/mul\")@ResponseBodypublic Object mulForm(@RequestParam List&lt;String&gt; hbs){    System.out.println(\"hbs = \" + hbs);    return hbs;}\n实体接收\nSpring MVC 是 Spring 框架提供的 Web\n框架，它允许开发者使用实体对象来接收 HTTP\n请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。下面是一个使用实体对象接收参数的示例：\n定义一个用于接收参数的实体类：\npublic class User {  private String name;  private int age = 18;  // getter 和 setter 略}\n在控制器中，使用实体对象接收，示例代码如下：\n@Controller@RequestMapping(\"param\")public class ParamController {    @RequestMapping(value = \"/user\", method = RequestMethod.POST)    @ResponseBody    public String addUser(User user) {        // 在这里可以使用 user 对象的属性来接收请求参数        System.out.println(\"user = \" + user);        return \"success\";    }}\n在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！\n\n\n2.2.3 路径 参数接收\n路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web\n应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而\nSpring MVC 框架提供了 @PathVariable\n注解来处理路径传递参数。\n@PathVariable 注解允许将 URL\n中的占位符映射到控制器方法中的参数。\n例如，如果我们想将 /user/{id} 路径下的 {id}\n映射到控制器方法的一个参数中，则可以使用 @PathVariable\n注解来实现。\n下面是一个使用 @PathVariable\n注解处理路径传递参数的示例：\n /** * 动态路径设计: /user/{动态部分}/{动态部分}   动态部分使用{}包含即可! {}内部动态标识! * 形参列表取值: @PathVariable Long id  如果形参名 = {动态标识} 自动赋值! *              @PathVariable(\"动态标识\") Long id  如果形参名 != {动态标识} 可以通过指定动态标识赋值! * * 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root */@GetMapping(\"/user/{id}/{name}\")@ResponseBodypublic String getUser(@PathVariable Long id,                       @PathVariable(\"name\") String uname) {    System.out.println(\"id = \" + id + \", uname = \" + uname);    return \"user_detail\";}\n2.2.4 json参数接收\n前端传递 JSON 数据时，Spring MVC 框架可以使用\n@RequestBody 注解来将 JSON 数据转换为 Java\n对象。@RequestBody\n注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value\n属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：\n\n前端发送 JSON 数据的示例：（使用postman测试）\n{  \"name\": \"张三\",  \"age\": 18,  \"gender\": \"男\"}\n定义一个用于接收 JSON 数据的 Java 类，例如：\npublic class Person {  private String name;  private int age;  private String gender;  // getter 和 setter 略}\n在控制器中，使用 @RequestBody 注解来接收 JSON\n数据，并将其转换为 Java 对象，例如：\n@PostMapping(\"/person\")@ResponseBodypublic String addPerson(@RequestBody Person person) {  // 在这里可以使用 person 对象来操作 JSON 数据中包含的属性  return \"success\";}\n在上述代码中，@RequestBody 注解将请求体中的 JSON\n数据映射到 Person 类型的 person\n参数上，并将其作为一个对象来传递给 addPerson()\n方法进行处理。\n完善配置\n测试：\n\n问题：\norg.springframework.web.HttpMediaTypeNotSupportedException:\nContent-Type ‘application/json;charset=UTF-8’ is not supported]\n原因：\n\n不支持json数据类型处理\n\n\n\n没有json类型处理的工具（jackson） 解决： springmvc\nhandlerAdpater配置json转化器,配置类需要明确：\n//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]    //TODO: 导入handlerMapping和handlerAdapter的三种方式   //1.自动导入handlerMapping和handlerAdapter [推荐]   //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载   //3.使用@Bean方式配置handlerMapper和handlerAdapter  @EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器  @Configuration  @ComponentScan(basePackages = \"com.atguigu.controller\") //TODO: 进行controller扫描    //WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现  public class SpringMvcConfig implements WebMvcConfigurer {  }\npom.xml 加入jackson依赖\n\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt;\n\n\n@EnableWebMvc注解说明xml\n@EnableWebMvc注解效果等同于在\nXML 配置中，可以使用 &lt;mvc:annotation-driven&gt;\n元素！我们来解析&lt;mvc:annotation-driven&gt;对应的解析工作！\n让我们来查看下&lt;mvc:annotation-driven&gt;具体的动作！\n\n先查看&lt;mvc:annotation-driven&gt;标签最终对应解析的Java类\n\n查看解析类中具体的动作即可\n打开源码：org.springframework.web.servlet.config.MvcNamespaceHandler\n\n打开源码：org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser\nclass AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {  public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();  public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();  static {    ClassLoader classLoader = AnnotationDrivenBeanDefinitionParser.class.getClassLoader();    javaxValidationPresent = ClassUtils.isPresent(\"jakarta.validation.Validator\", classLoader);    romePresent = ClassUtils.isPresent(\"com.rometools.rome.feed.WireFeed\", classLoader);    jaxb2Present = ClassUtils.isPresent(\"jakarta.xml.bind.Binder\", classLoader);    jackson2Present = ClassUtils.isPresent(\"com.fasterxml.jackson.databind.ObjectMapper\", classLoader) &amp;&amp;            ClassUtils.isPresent(\"com.fasterxml.jackson.core.JsonGenerator\", classLoader);    jackson2XmlPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.xml.XmlMapper\", classLoader);    jackson2SmilePresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.smile.SmileFactory\", classLoader);    jackson2CborPresent = ClassUtils.isPresent(\"com.fasterxml.jackson.dataformat.cbor.CBORFactory\", classLoader);    gsonPresent = ClassUtils.isPresent(\"com.google.gson.Gson\", classLoader);  }      @Override      @Nullable      public BeanDefinition parse(Element element, ParserContext context) {        //handlerMapping加入到ioc容器        readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME, handlerMappingDef);        //添加jackson转化器        addRequestBodyAdvice(handlerAdapterDef);        addResponseBodyAdvice(handlerAdapterDef);        //handlerAdapter加入到ioc容器        readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME, handlerAdapterDef);        return null;      }      //具体添加jackson转化对象方法      protected void addRequestBodyAdvice(RootBeanDefinition beanDef) {        if (jackson2Present) {          beanDef.getPropertyValues().add(\"requestBodyAdvice\",              new RootBeanDefinition(JsonViewRequestBodyAdvice.class));        }      }      protected void addResponseBodyAdvice(RootBeanDefinition beanDef) {        if (jackson2Present) {          beanDef.getPropertyValues().add(\"responseBodyAdvice\",              new RootBeanDefinition(JsonViewResponseBodyAdvice.class));        }      }\n\n\n2.3 接收Cookie数据\n可以使用 @CookieValue 注释将 HTTP Cookie\n的值绑定到控制器中的方法参数。\n考虑使用以下 cookie 的请求：\nJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84\n下面的示例演示如何获取 cookie 值：\n@GetMapping(\"/demo\")public void handle(@CookieValue(\"JSESSIONID\") String cookie) {   //...}\n2.4 接收请求头数据\n可以使用 @RequestHeader\n批注将请求标头绑定到控制器中的方法参数。\n请考虑以下带有标头的请求：\nHost                    localhost:8080Accept                  text/html,application/xhtml+xml,application/xml;q=0.9Accept-Language         fr,en-gb;q=0.7,en;q=0.3Accept-Encoding         gzip,deflateAccept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7Keep-Alive              300\n下面的示例获取 Accept-Encoding 和\nKeep-Alive 标头的值：\n@GetMapping(\"/demo\")public void handle(    @RequestHeader(\"Accept-Encoding\") String encoding,     @RequestHeader(\"Keep-Alive\") long keepAlive) {   //...}\n2.5 原生Api对象操作\nhttps://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html\n下表描述了支持的控制器方法参数\n\n\n\n\n\n\n\nController method argument 控制器方法参数\nDescription\n\n\n\n\njakarta.servlet.ServletRequest,\njakarta.servlet.ServletResponse\n请求/响应对象\n\n\njakarta.servlet.http.HttpSession\n强制存在会话。因此，这样的参数永远不会为 null 。\n\n\njava.io.InputStream, java.io.Reader\n用于访问由 Servlet API 公开的原始请求正文。\n\n\njava.io.OutputStream, java.io.Writer\n用于访问由 Servlet API 公开的原始响应正文。\n\n\n@PathVariable\n接收路径参数注解\n\n\n@RequestParam\n用于访问 Servlet\n请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。\n\n\n@RequestHeader\n用于访问请求标头。标头值将转换为声明的方法参数类型。\n\n\n@CookieValue\n用于访问Cookie。Cookie 值将转换为声明的方法参数类型。\n\n\n@RequestBody\n用于访问 HTTP 请求正文。正文内容通过使用\nHttpMessageConverter 实现转换为声明的方法参数类型。\n\n\njava.util.Map,\norg.springframework.ui.Model,\norg.springframework.ui.ModelMap\n共享域对象，并在视图呈现过程中向模板公开。\n\n\nErrors, BindingResult\n验证和数据绑定中的错误信息获取对象！\n\n\n\n获取原生对象示例：\n/** * 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序! * 注意: 接收原生对象,并不影响参数接收! */@GetMapping(\"api\")@ResponseBodypublic String api(HttpSession session , HttpServletRequest request,                  HttpServletResponse response){    String method = request.getMethod();    System.out.println(\"method = \" + method);    return \"api\";}\n2.6 共享域对象操作\n2.6.1 属性（共享）域作用回顾\n在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web\n应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。\n\nServletContext 共享域：ServletContext\n对象可以在整个 Web\n应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web\n应用程序的全局配置信息，以及所有用户都共享的数据。在\nServletContext 中保存的数据是线程安全的。\nHttpSession 共享域：HttpSession\n对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在\nHttpSession 中，让用户在多个页面间保持登录状态。\nHttpServletRequest\n共享域：HttpServletRequest\n对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在\nHttpServletRequest\n中，让处理器方法之间可以访问这些数据。\nPageContext 共享域：PageContext 对象是在\nJSP 页面Servlet 创建时自动创建的。它可以在 JSP\n的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope\n等作用域。\n\n共享域的作用是提供了方便实用的方式在同一 Web\n应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。\n\n2.6.2 Request级别属性（共享）域\n\n使用 Model 类型的形参\n@RequestMapping(\"/attr/request/model\")@ResponseBodypublic String testAttrRequestModel(            // 在形参位置声明Model类型变量，用于存储模型数据        Model model) {        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    model.addAttribute(\"requestScopeMessageModel\",\"i am very happy[model]\");        return \"target\";}\n使用 ModelMap 类型的形参\n@RequestMapping(\"/attr/request/model/map\")@ResponseBodypublic String testAttrRequestModelMap(            // 在形参位置声明ModelMap类型变量，用于存储模型数据        ModelMap modelMap) {        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    modelMap.addAttribute(\"requestScopeMessageModelMap\",\"i am very happy[model map]\");        return \"target\";}\n使用 Map 类型的形参\n@RequestMapping(\"/attr/request/map\")@ResponseBodypublic String testAttrRequestMap(            // 在形参位置声明Map类型变量，用于存储模型数据        Map&lt;String, Object&gt; map) {        // 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域    // 存入请求域这个动作也被称为暴露到请求域    map.put(\"requestScopeMessageMap\", \"i am very happy[map]\");        return \"target\";}\n使用原生 request 对象\n@RequestMapping(\"/attr/request/original\")@ResponseBodypublic String testAttrOriginalRequest(            // 拿到原生对象，就可以调用原生方法执行各种操作        HttpServletRequest request) {        request.setAttribute(\"requestScopeMessageOriginal\", \"i am very happy[original]\");        return \"target\";}\n使用 ModelAndView 对象\n@RequestMapping(\"/attr/request/mav\")public ModelAndView testAttrByModelAndView() {        // 1.创建ModelAndView对象    ModelAndView modelAndView = new ModelAndView();    // 2.存入模型数据    modelAndView.addObject(\"requestScopeMessageMAV\", \"i am very happy[mav]\");    // 3.设置视图名称    modelAndView.setViewName(\"target\");        return modelAndView;}\n\n2.6.3 Session级别属性（共享）域\n@RequestMapping(\"/attr/session\")@ResponseBodypublic String testAttrSession(HttpSession session) {    //直接对session对象操作,即对会话范围操作!    return \"target\";}\n2.6.4\nApplication级别属性（共享）域\n解释：springmvc会在初始化容器的时候，讲servletContext对象存储到ioc容器中！\n@Autowiredprivate ServletContext servletContext;@RequestMapping(\"/attr/application\")@ResponseBodypublic String attrApplication() {        servletContext.setAttribute(\"appScopeMsg\", \"i am hungry...\");        return \"target\";}\n三、SpringMVC响应数据\n3.1 handler方法分析\n理解handler方法的作用和组成：\n/** * TODO: 一个controller的方法是控制层的一个处理器,我们称为handler * TODO: handler需要使用@RequestMapping/@GetMapping系列,声明路径,在HandlerMapping中注册,供DS查找! * TODO: handler作用总结: *       1.接收请求参数(param,json,pathVariable,共享域等)  *       2.调用业务逻辑  *       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等) * TODO: handler如何处理呢 *       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数) *       2.调用业务: { 方法体  可以向后调用业务方法 service.xx() } *       3.响应数据: return 返回结果,可以快速响应前端数据 */@GetMappingpublic Object handler(简化请求参数接收){    调用业务方法    返回的结果 （页面跳转，返回数据（json））    return 简化响应前端数据;}\n总结： 请求数据接收，我们都是通过handler的形参列表\n 前端数据响应，我们都是通过handler的return关键字快速处理！\n3.2 页面跳转控制\n3.2.1 快速返回模板视图\n\n开发模式回顾\n在 Web 开发中，有两种主要的开发模式：前后端分离和混合开发。\n前后端分离模式：[重点]\n指将前端的界面和后端的业务逻辑通过接口分离开发的一种方式。开发人员使用不同的技术栈和框架，前端开发人员主要负责页面的呈现和用户交互，后端开发人员主要负责业务逻辑和数据存储。前后端通信通过\nAPI 接口完成，数据格式一般使用 JSON 或\nXML。前后端分离模式可以提高开发效率，同时也有助于代码重用和维护。\n混合开发模式：\n指将前端和后端的代码集成在同一个项目中，共享相同的技术栈和框架。这种模式在小型项目中比较常见，可以减少学习成本和部署难度。但是，在大型项目中，这种模式会导致代码耦合性很高，维护和升级难度较大。\n对于混合开发，我们就需要使用动态页面技术，动态展示Java的共享域数据！！\njsp技术了解\nJSP（JavaServer Pages）是一种动态网页开发技术，它是由 Sun\n公司提出的一种基于 Java 技术的 Web 页面制作技术，可以在 HTML 文件中嵌入\nJava 代码，使得生成动态内容的编写更加简单。\nJSP 最主要的作用是生成动态页面。它允许将 Java 代码嵌入到 HTML\n页面中，以便使用 Java 进行数据库查询、处理表单数据和生成 HTML\n等动态内容。另外，JSP 还可以与 Servlet 结合使用，实现更加复杂的 Web\n应用程序开发。\nJSP 的主要特点包括：\n\n简单：JSP 通过将 Java 代码嵌入到 HTML\n页面中，使得生成动态内容的编写更加简单。\n高效：JSP 首次运行时会被转换为\nServlet，然后编译为字节码，从而可以启用\nJust-in-Time（JIT）编译器，实现更高效的运行。\n多样化：JSP 支持多种标准标签库，包括 JSTL（JavaServer Pages\n标准标签库）、EL（表达式语言）等，可以帮助开发人员更加方便的处理常见的\nWeb 开发需求。 总之，JSP\n是一种简单高效、多样化的动态网页开发技术，它可以方便地生成动态页面和与\nServlet 结合使用，是 Java Web 开发中常用的技术之一。\n\n准备jsp页面和依赖\npom.xml依赖\n&lt;!-- jsp需要依赖! jstl--&gt;&lt;dependency&gt;    &lt;groupId&gt;jakarta.servlet.jsp.jstl&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.servlet.jsp.jstl-api&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;\njsp页面创建\n建议位置：/WEB-INF/下，避免外部直接访问！\n位置：/WEB-INF/views/home.jsp\n&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;        &lt;!-- 可以获取共享域的数据,动态展示! jsp== 后台vue --&gt;        ${msg}  &lt;/body&gt;&lt;/html&gt;\n快速响应模版页面\n\n配置jsp视图解析器\n@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = \"com.atguigu.controller\") //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) {        //快速配置jsp模板语言对应的视图        registry.jsp(\"/WEB-INF/views/\",\".jsp\");    }}\ncontroller方法中返回index会被解析为：“/WEB-INF/views/index.jsp”\nhandler返回视图\n/** *  跳转到提交文件页面  /save/jump *   *  如果要返回jsp页面! *     1.方法返回值改成字符串类型 *     2.返回逻辑视图名即可     *         &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/&gt; *            + 逻辑视图名 + *         &lt;property name=\"suffix\" value=\".jsp\"/&gt; */@GetMapping(\"jump\")public String jumpJsp(Model model){    System.out.println(\"FileController.jumpJsp\");    model.addAttribute(\"msg\",\"request data!!\");    return \"home\";}\n\n\n3.2.2 转发和重定向\n在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用\nredirect 或者 forward 关键字来实现重定向。\n@RequestMapping(\"/redirect-demo\")public String redirectDemo() {    // 重定向到 /demo 路径     return \"redirect:/demo\";}@RequestMapping(\"/forward-demo\")public String forwardDemo() {    // 转发到 /demo 路径    return \"forward:/demo\";}//注意： 转发和重定向到项目下资源路径都是相同，都不需要添加项目根路径！填写项目下路径即可！\n总结：\n\n将方法的返回值，设置String类型\n转发使用forward关键字，重定向使用redirect关键字\n关键字: /路径\n注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！\n不能添加@ResponseBody\n\n3.3 返回JSON数据（重点）\n3.3.1 前置准备\n导入jackson依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.15.0&lt;/version&gt;&lt;/dependency&gt;\n添加json数据转化器\n@EnableWebMvc\n\n//TODO: SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]//TODO: 导入handlerMapping和handlerAdapter的三种方式 //1.自动导入handlerMapping和handlerAdapter [推荐] //2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载 //3.使用@Bean方式配置handlerMapper和handlerAdapter@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = \"com.atguigu.controller\") //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {}\n3.3.2 @ResponseBody\n\n方法上使用@ResponseBody\n可以在方法上使用\n@ResponseBody注解，用于将方法返回的对象序列化为 JSON 或 XML\n格式的数据，并发送给客户端。在前后端分离的项目中使用！\n@GetMapping(\"/accounts/{id}\")@ResponseBodypublic Object handle() {  // ...  return obj;}\n具体来说，@ResponseBody\n注解可以用来标识方法或者方法返回值。\n表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。\n@RequestMapping(value = \"/user/detail\", method = RequestMethod.POST)@ResponseBodypublic User getUser(@RequestBody User userParam) {    System.out.println(\"userParam = \" + userParam);    User user = new User();    user.setAge(18);    user.setName(\"John\");    //返回的对象,会使用jackson的序列化工具,转成json返回给前端!    return user;}\n类上使用@ResponseBody\n如果类中每个方法上都标记了 @ResponseBody\n注解，那么这些注解就可以提取到类上。\n@ResponseBody  //responseBody可以添加到类上,代表默认类中的所有方法都生效!@Controller@RequestMapping(\"param\")public class ParamController {\n\n3.3.3 @RestController\n类上的 @ResponseBody 注解可以和 @Controller 注解合并为\n@RestController 注解。\n@RestController = @ResponseBody+@Controller。\nRestController源码:\n@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController {   /**   * The value may indicate a suggestion for a logical component name,   * to be turned into a Spring bean in case of an autodetected component.   * @return the suggested component name, if any (or empty String otherwise)   * @since 4.0.1   */  @AliasFor(annotation = Controller.class)  String value() default \"\"; }\n3.4 返回静态资源处理\n\n静态资源概念\n资源本身已经是可以直接拿到浏览器上使用的程度了，不需要在服务器端做任何运算、处理。典型的静态资源包括：\n\n纯HTML文件\n图片\nCSS文件\nJavaScript文件\n……\n\n静态资源访问和问题解决\n\nweb应用加入静态资源\n\n手动构建确保编译\n访问静态资源\n问题分析\n\nDispatcherServlet 的 url-pattern 配置的是“/”\n\nurl-pattern 配置“/”表示整个 Web 应用范围内所有请求都由 SpringMVC\n来处理\n\n对 SpringMVC 来说，必须有对应的 @RequestMapping\n才能找到处理请求的方法\n\n现在 images/mi.jpg 请求没有对应的 @RequestMapping 所以返回 404\n\n\n\n问题解决\n在 SpringMVC 配置配置类：\n@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = \"com.atguigu.controller\") //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) {        //快速配置jsp模板语言对应的        registry.jsp(\"/WEB-INF/views/\",\".jsp\");    }    //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable();    }}\n\n四、RESTFul风格设计和实战\n4.1 RESTFul风格概述\n4.1.1 RESTFul风格简介\nRESTful（Representational State\nTransfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准\nHTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发。\n通过遵循 RESTful\n架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web\n服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的\nHTTP 方法和状态码进行通信，不需要额外的协议和中间件。\n总而言之，RESTful 是一种基于 HTTP\n和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的\nWeb 服务和应用程序！\n\n学习RESTful设计原则可以帮助我们更好去设计HTTP协议的API接口！！\n4.1.2 RESTFul风格特点\n\n每一个URI代表1种资源（URI 是名词）；\n客户端使用GET、POST、PUT、DELETE\n4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；\n资源的表现形式是XML或者JSON；\n客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。\n\n4.1.3 RESTFul风格设计规范\n\nHTTP协议请求方式要求\nREST\n风格主张在项目设计、开发中，具体的操作符合HTTP协议定义的请求方式的语义。\n\n\n\n操作\n请求方式\n\n\n\n\n查询操作\nGET\n\n\n保存操作\nPOST\n\n\n删除操作\nDELETE\n\n\n更新操作\nPUT\n\n\n\nURL路径风格要求\nREST风格下每个资源都应该有一个唯一的标识符，例如一个\nURI（统一资源标识符）或者一个\nURL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！\n使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！\n\n\n\n\n\n\n\n\n操作\n传统风格\nREST 风格\n\n\n\n\n保存\n/CRUD/saveEmp\nURL 地址：/CRUD/emp\n请求方式：POST\n\n\n删除\n/CRUD/removeEmp?empId=2\nURL 地址：/CRUD/emp/2\n请求方式：DELETE\n\n\n更新\n/CRUD/updateEmp\nURL 地址：/CRUD/emp\n请求方式：PUT\n\n\n查询\n/CRUD/editEmp?empId=2\nURL 地址：/CRUD/emp/2\n请求方式：GET\n\n\n\n\n\n总结\n根据接口的具体动作，选择具体的HTTP协议请求方式\n路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可！\n\n4.1.4 RESTFul风格好处\n\n含蓄，安全\n使用问号键值对的方式给服务器传递数据太明显，容易被人利用来对系统进行破坏。使用\nREST 风格携带数据不再需要明显的暴露数据的名称。\n风格统一\nURL\n地址整体格式统一，从前到后始终都使用斜杠划分各个单词，用简单一致的格式表达语义。\n无状态\n在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了系统设计的复杂度。\n严谨，规范\n严格按照 HTTP1.1 协议中定义的请求方式本身的语义进行操作。\n简洁，优雅\n过去做增删改查操作需要设计4个不同的URL，现在一个就够了。\n丰富的语义\n通过 URL\n地址就可以知道资源之间的关系。它能够把一句话中的很多单词用斜杠连起来，反过来说就是可以在\nURL 地址中用一句话来充分表达语义。\n\nhttp://localhost:8080/shop http://localhost:8080/shop/product\nhttp://localhost:8080/shop/product/cellPhone\nhttp://localhost:8080/shop/product/cellPhone/iPhone\n\n\n4.2 RESTFul风格实战\n4.2.1 需求分析\n\n数据结构： User {id 唯一标识,name 用户名，age 用户年龄}\n功能分析\n\n用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认\n10）\n保存用户功能\n根据用户id查询用户详情功能\n根据用户id更新用户数据功能\n根据用户id删除用户数据功能\n多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数\n默认1，size 每页数量 默认 10）\n\n\n4.2.2 RESTFul风格接口设计\n\n接口设计\n\n\n\n\n\n\n\n\n\n功能\n接口和请求方式\n请求参数\n返回值\n\n\n\n\n分页查询\nGET /user\npage=1&amp;size=10\n{ 响应数据 }\n\n\n用户添加\nPOST /user\n{ user 数据 }\n{响应数据}\n\n\n用户详情\nGET /user/1\n路径参数\n{响应数据}\n\n\n用户更新\nPUT /user\n{ user 更新数据}\n{响应数据}\n\n\n用户删除\nDELETE /user/1\n路径参数\n{响应数据}\n\n\n条件模糊\nGET /user/search\npage=1&amp;size=10&amp;keywork=关键字\n{响应数据}\n\n\n\n问题讨论\n为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？\n误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递！\n在 RESTful API\n的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。\n\n对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合\nRESTful 风格的要求。\n而对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。\n此外，还有一些通用的原则可以遵循：\n路径参数应该用于指定资源的唯一标识或者\nID，而请求参数应该用于指定查询条件或者操作参数。\n请求参数应该限制在 10\n个以内，过多的请求参数可能导致接口难以维护和使用。\n对于敏感信息，最好使用 POST 和请求体来传递参数。\n\n\n4.2.3 后台接口实现\n准备用户实体类：\npublic class User {    private Integer id;    private String name;    private Integer age;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return \"User{\" +                \"id=\" + id +                \", name='\" + name + '\\'' +                \", age=\" + age +                '}';    }}\n准备用户Controller:\n@RequestMapping(\"user\")@RestControllerpublic class UserController {    /**     * 模拟分页查询业务接口     */    @GetMapping    public Object queryPage(@RequestParam(name = \"page\",required = false,defaultValue = \"1\")int page,                            @RequestParam(name = \"size\",required = false,defaultValue = \"10\")int size){        System.out.println(\"page = \" + page + \", size = \" + size);        System.out.println(\"分页查询业务!\");        return \"{'status':'ok'}\";    }    /**     * 模拟用户保存业务接口     */    @PostMapping    public Object saveUser(@RequestBody User user){        System.out.println(\"user = \" + user);        System.out.println(\"用户保存业务!\");        return \"{'status':'ok'}\";    }    /**     * 模拟用户详情业务接口     */    @PostMapping(\"/{id}\")    public Object detailUser(@PathVariable Integer id){        System.out.println(\"id = \" + id);        System.out.println(\"用户详情业务!\");        return \"{'status':'ok'}\";    }    /**     * 模拟用户更新业务接口     */    @PutMapping    public Object updateUser(@RequestBody User user){        System.out.println(\"user = \" + user);        System.out.println(\"用户更新业务!\");        return \"{'status':'ok'}\";    }    /**     * 模拟条件分页查询业务接口     */    @GetMapping(\"search\")    public Object queryPage(@RequestParam(name = \"page\",required = false,defaultValue = \"1\")int page,                            @RequestParam(name = \"size\",required = false,defaultValue = \"10\")int size,                            @RequestParam(name = \"keyword\",required= false)String keyword){        System.out.println(\"page = \" + page + \", size = \" + size + \", keyword = \" + keyword);        System.out.println(\"条件分页查询业务!\");        return \"{'status':'ok'}\";    }}\n五、SpringMVC其他扩展\n5.1 全局异常处理机制\n5.1.1 异常处理两种方式\n开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。\n对于异常的处理，一般分为两种方式：\n\n编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用\ntry-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在\nfinally\n块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。\n声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如\n@Throws 或\n@ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。\n\n站在宏观角度来看待声明式事务处理：\n整个项目从架构这个层面设计的异常处理的统一机制和规范。\n一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照\nA 方案处理异常，李四负责的模块按照 B\n方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。\n使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！\n5.1.2 基于注解异常声明异常处理\n\n声明异常处理控制器类\n异常处理控制类，统一定义异常处理handler方法！\n/** * projectName: com.atguigu.execptionhandler *  * description: 全局异常处理器,内部可以定义异常处理Handler! *//** * @RestControllerAdvice = @ControllerAdvice + @ResponseBody * @ControllerAdvice 代表当前类的异常处理controller!  */@RestControllerAdvicepublic class GlobalExceptionHandler {  }\n声明异常处理hander方法\n异常处理handler方法和普通的handler方法参数接收和响应都一致！\n只不过异常处理handler方法要映射异常，发生对应的异常会调用！\n普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！\n/** * 异常处理handler  * @ExceptionHandler(HttpMessageNotReadableException.class)  * 该注解标记异常处理Handler,并且指定发生异常调用该方法! *  *  * @param e 获取异常对象! * @return 返回handler处理结果! */@ExceptionHandler(HttpMessageNotReadableException.class)public Object handlerJsonDateException(HttpMessageNotReadableException e){        return null;}/** * 当发生空指针异常会触发此方法! * @param e * @return */@ExceptionHandler(NullPointerException.class)public Object handlerNullException(NullPointerException e){    return null;}/** * 所有异常都会触发此方法!但是如果有具体的异常处理Handler!  * 具体异常处理Handler优先级更高! * 例如: 发生NullPointerException异常! *       会触发handlerNullException方法,不会触发handlerException方法! * @param e * @return */@ExceptionHandler(Exception.class)public Object handlerException(Exception e){    return null;}\n配置文件扫描控制器类配置\n确保异常处理控制类被扫描\n&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;@ComponentScan(basePackages = {\"com.atguigu.controller\",\"com.atguigu.exceptionhandler\"})\n\n5.2 拦截器使用\n5.2.1 拦截器概念\n拦截器和过滤器解决问题\n\n生活中\n为了提高乘车效率，在乘客进入站台前统一检票。\n程序中\n在程序中，使用拦截器在请求到达具体 handler\n方法前，统一执行检测。\n\n拦截器 Springmvc VS 过滤器 javaWeb：\n\n相似点\n\n拦截：必须先把请求拦住，才能执行后续操作\n过滤：拦截器或过滤器存在的意义就是对请求进行统一处理\n放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源\n\n不同点\n\n工作平台不同\n\n过滤器工作在 Servlet 容器中\n拦截器工作在 SpringMVC 的基础上\n\n拦截的范围\n\n过滤器：能够拦截到的最大范围是整个 Web 应用\n拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求\n\nIOC 容器支持\n\n过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的\n拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC\n容器中装配组件，也就是可以直接得到 IOC 容器的支持\n\n\n\n功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器。\n\n5.2.2 拦截器使用\n\n创建拦截器类\npublic class Process01Interceptor implements HandlerInterceptor {    // if( ! preHandler()){return;}    // 在处理请求的目标 handler 方法前执行    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        System.out.println(\"request = \" + request + \", response = \" + response + \", handler = \" + handler);        System.out.println(\"Process01Interceptor.preHandle\");                 // 返回true：放行        // 返回false：不放行        return true;    }     // 在目标 handler 方法之后，handler报错不执行!    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        System.out.println(\"request = \" + request + \", response = \" + response + \", handler = \" + handler + \", modelAndView = \" + modelAndView);        System.out.println(\"Process01Interceptor.postHandle\");    }     // 渲染视图之后执行(最后),一定执行!    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        System.out.println(\"request = \" + request + \", response = \" + response + \", handler = \" + handler + \", ex = \" + ex);        System.out.println(\"Process01Interceptor.afterCompletion\");    }}\n拦截器方法拦截位置：\n\n修改配置类添加拦截器\n@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器@Configuration@ComponentScan(basePackages = {\"com.atguigu.controller\",\"com.atguigu.exceptionhandler\"}) //TODO: 进行controller扫描//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现public class SpringMvcConfig implements WebMvcConfigurer {    //配置jsp对应的视图解析器    @Override    public void configureViewResolvers(ViewResolverRegistry registry) {        //快速配置jsp模板语言对应的        registry.jsp(\"/WEB-INF/views/\",\".jsp\");    }    //开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;    @Override    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {        configurer.enable();    }    //添加拦截器    @Override    public void addInterceptors(InterceptorRegistry registry) {         //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求        registry.addInterceptor(new Process01Interceptor());    }}\n配置详解\n\n默认拦截全部\n@Overridepublic void addInterceptors(InterceptorRegistry registry) {    //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());}\n精准配置\n@Overridepublic void addInterceptors(InterceptorRegistry registry) {        //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());        //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可    //addPathPatterns(\"/common/request/one\") 添加拦截路径    //也支持 /* 和 /** 模糊路径。     //* 任意一层字符串 ** 任意层 任意字符串    registry.addInterceptor(new Process01Interceptor())        .addPathPatterns(\"/common/request/one\",\"/common/request/tow\");}\n排除配置\n//添加拦截器@Overridepublic void addInterceptors(InterceptorRegistry registry) {        //将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求    registry.addInterceptor(new Process01Interceptor());        //精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可    //addPathPatterns(\"/common/request/one\") 添加拦截路径    registry.addInterceptor(new Process01Interceptor())        .addPathPatterns(\"/common/request/one\",\"/common/request/tow\");        //排除匹配,排除应该在匹配的范围内排除    //addPathPatterns(\"/common/request/one\") 添加拦截路径    //excludePathPatterns(\"/common/request/tow\"); 排除路径,排除应该在拦截的范围内    registry.addInterceptor(new Process01Interceptor())            .addPathPatterns(\"/common/request/one\",\"/common/request/tow\")            .excludePathPatterns(\"/common/request/tow\");}\n\n多个拦截器执行顺序\n\npreHandle() 方法：SpringMVC\n会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle()\n方法。\npostHandle() 方法：SpringMVC\n会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle()\n方法。\nafterCompletion() 方法：SpringMVC\n会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个\nafterCompletion() 方法。\n\n\n5.3 参数校验\n\n在 Web\n应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。\n\n\n校验概述\nJSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在\nJavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max\n等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。\n\n\n\n\n\n\n\n注解\n规则\n\n\n\n\n@Null\n标注值必须为 null\n\n\n@NotNull\n标注值不可为 null\n\n\n@AssertTrue\n标注值必须为 true\n\n\n@AssertFalse\n标注值必须为 false\n\n\n@Min(value)\n标注值必须大于或等于 value\n\n\n@Max(value)\n标注值必须小于或等于 value\n\n\n@DecimalMin(value)\n标注值必须大于或等于 value\n\n\n@DecimalMax(value)\n标注值必须小于或等于 value\n\n\n@Size(max,min)\n标注值大小必须在 max 和 min 限定的范围内\n\n\n@Digits(integer,fratction)\n标注值值必须是一个数字，且必须在可接受的范围内\n\n\n@Past\n标注值只能用于日期型，且必须是过去的日期\n\n\n@Future\n标注值只能用于日期型，且必须是将来的日期\n\n\n@Pattern(value)\n标注值必须符合指定的正则表达式\n\n\n\nJSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator\n是 JSR 303\n的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：\n\n\n\n注解\n规则\n\n\n\n\n@Email\n标注值必须是格式正确的 Email 地址\n\n\n@Length\n标注值字符串大小必须在指定的范围内\n\n\n@NotEmpty\n标注值字符串不能是空字符串\n\n\n@Range\n标注值必须在指定的范围内\n\n\n\nSpring 4.0\n版本已经拥有自己独立的数据校验框架，同时支持JSR303标准的校验框架。\nSpring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。\n在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。\nSpring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator\n接口，也实现了 JSR 303 的 Validator 接口。\n只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的\nBean中。\nSpring本身并没有提供JSR 303的实现，所以必须将JSR\n303的实现者的jar包放到类路径下。\n配置 @EnableWebMvc后，SpringMVC\n会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注\n@Validated\n注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。\n操作演示\n\n导入依赖\n&lt;!-- 校验注解 --&gt;&lt;dependency&gt;    &lt;groupId&gt;jakarta.platform&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.jakartaee-web-api&lt;/artifactId&gt;    &lt;version&gt;9.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;        &lt;!-- 校验注解实现--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;    &lt;version&gt;8.0.0.Final&lt;/version&gt;&lt;/dependency&gt;\n应用校验注解\nimport jakarta.validation.constraints.Email;import jakarta.validation.constraints.Min;import org.hibernate.validator.constraints.Length;/** * projectName: com.atguigu.pojo */public class User {    //age   1 &lt;=  age &lt; = 150    @Min(10)    private int age;    //name 3 &lt;= name.length &lt;= 6    @Length(min = 3,max = 10)    private String name;    //email 邮箱格式    @Email    private String email;    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }}\nhandler标记和绑定错误收集\n@RestController@RequestMapping(\"user\")public class UserController {    /**     * @Validated 代表应用校验注解! 必须添加!     */    @PostMapping(\"save\")    public Object save(@Validated @RequestBody User user, BindingResult result){       //在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!       //判断是否有信息绑定错误! 有可以自行处理!        if (result.hasErrors()){            System.out.println(\"错误\");            String errorMsg = result.getFieldError().toString();            return errorMsg;        }        //没有,正常处理业务即可        System.out.println(\"正常\");        return user;    }}\n\n易混总结\n@NotNull、@NotEmpty、@NotBlank\n都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。\n\n@NotNull\n(包装类型不为null)\n@NotNull 注解是\nJSR 303 规范中定义的注解，当被标注的字段值为 null\n时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用\n@NotBlank 或 @NotEmpty 注解。\n@NotEmpty\n(集合类型长度大于0)\n@NotEmpty\n注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map\n或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者\nsize()==0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。\n@NotBlank\n（字符串，不为null，切不为” “字符串）\n@NotBlank 注解是\nHibernate Validator\n附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null\n或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank\n注解只能用于字符串类型的校验。\n总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。\n\n\n六、SpringMVC总结\n\n\n\n核心点\n掌握目标\n\n\n\n\nspringmvc框架\n主要作用、核心组件、调用流程\n\n\n简化参数接收\n路径设计、参数接收、请求头接收、cookie接收\n\n\n简化数据响应\n模板页面、转发和重定向、JSON数据、静态资源\n\n\nrestful风格设计\n主要作用、具体规范、请求方式和请求参数选择\n\n\n功能扩展\n全局异常处理、拦截器、参数校验注解\n\n\n\n","categories":["后端","Spring"],"tags":["SpringMVC"]},{"title":"Hello World","url":"/2021/10/01/hello-world/","content":"Welcome to Hexo! This is your very\nfirst post. Check documentation for\nmore info. If you get any problems when using Hexo, you can find the\nanswer in troubleshooting or\nyou can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new \"My New Post\"\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","categories":["Blog"],"tags":["Hexo"]},{"title":"Web-UI Event","url":"/2023/12/27/Web-UI-Event/","content":"本文系统梳理了 Web\n中的鼠标、键盘与指针事件机制，包括事件触发顺序、事件属性、组合键判断、坐标获取、防止默认行为，以及拖放操作与\nPointer Events 的使用。同时，解析了 event.key 与 event.code\n的区别，帮助开发者更精准地处理 UI 交互逻辑。\n\n鼠标事件\n事件顺序\n从上面的列表中我们可以看到，一个用户操作可能会触发多个事件。\n例如，点击鼠标左键，在鼠标左键被按下时，会首先触发\nmousedown，然后当鼠标左键被释放时，会触发\nmouseup 和 click。\n在单个动作触发多个事件时，事件的顺序是固定的。也就是说，会遵循\nmousedown → mouseup → click\n的顺序调用处理程序。\n鼠标按钮\n与点击相关的事件始终具有 button\n属性，该属性允许获取确切的鼠标按钮。\n通常我们不在 click 和 contextmenu\n事件中使用这一属性，因为前者只在单击鼠标左键时触发，后者只在单击鼠标右键时触发。\n不过，在 mousedown 和 mouseup\n事件中则可能需要用到\nevent.button，因为这两个事件在任何按键上都会触发，所以我们可以使用\nbutton 属性来区分是左键单击还是右键单击。\nevent.button 的所有可能值如下：\n\n\n\n鼠标按键状态\nevent.button\n\n\n\n\n左键 (主要按键)\n0\n\n\n中键 (辅助按键)\n1\n\n\n右键 (次要按键)\n2\n\n\nX1 键 (后退按键)\n3\n\n\nX2 键 (前进按键)\n4\n\n\n\n大多数鼠标设备只有左键和右键，对应的值就是 0 和\n2。触屏设备中的点按操作也会触发类似的事件。\n组合键：shift，alt，ctrl，meta\n所有的鼠标事件都包含有关按下的组合键的信息。\n\nshiftKey：Shift\naltKey：Alt（或对于 Mac 是 Opt）\nctrlKey：Ctrl\nmetaKey：对于 Mac 是 Cmd\n\n如果在事件期间按下了相应的键，则它们为 true。\n比如，下面这个按钮仅在 Alt+Shift+click 时才有效：\n&lt;button id=\"button\"&gt;Alt+Shift+Click on me!&lt;/button&gt;&lt;script&gt;\tbutton.onclick = function (event) {\t\tif (event.altKey &amp;&amp; event.shiftKey) {\t\t\talert(\"Hooray!\");\t\t}\t};&lt;/script&gt;\n坐标：clientX/Y，pageX/Y\n所有的鼠标事件都提供了两种形式的坐标：\n\n相对于窗口的坐标：clientX 和\nclientY。\n相对于文档的坐标：pageX 和 pageY。\n\n防止在鼠标按下时的选择\n双击鼠标会有副作用，在某些界面中可能会出现干扰：它会选择文本。\n比如，双击下面的文本，除了我们的处理程序外，还会选择文本：\n&lt;span ondblclick=\"alert('dblclick')\"&gt;Double-click me&lt;/span&gt;\n如果按下鼠标左键，并在不松开的情况下移动鼠标，这也常常会造成不必要的选择。\n在这种情况下，最合理的方式是防止浏览器对 mousedown\n进行操作。这样能够阻止刚刚提到的两种选择：\nBefore...&lt;b ondblclick=\"alert('Click!')\" onmousedown=\"return false\"&gt; Double-click me &lt;/b&gt;...After\n\n如果我们想禁用选择以保护我们页面的内容不被复制粘贴，那么我们可以使用另一个事件：oncopy。\n&lt;div oncopy=\"alert('Copying forbidden!');return false\"&gt;\tDear user, The copying is forbidden for you. If you know JS or HTML, then\tyou can get everything from the page source though.&lt;/div&gt;\n\n移动鼠标：mouseover/out，mouseenter/leave\n当鼠标指针移到某个元素上时，mouseover\n事件就会发生，而当鼠标离开该元素时，mouseout\n事件就会发生。\n事件 mouseenter/mouseleave 类似于\nmouseover/mouseout。它们在鼠标指针进入/离开元素时触发。\n但是有两个重要的区别：\n\n元素内部与后代之间的转换不会产生影响。\n事件 mouseenter/mouseleave 不会冒泡。\n\n鼠标拖放事件\n\n事件流：ball.mousedown →\ndocument.mousemove →\nball.mouseup（不要忘记取消原生\nondragstart）。\n在拖动开始时 ——\n记住鼠标指针相对于元素的初始偏移（shift）：shiftX/shiftY，并在拖动过程中保持它不变。\n使用 document.elementFromPoint 检测鼠标指针下的\n“droppable” 的元素。\n\n我们可以在此基础上做很多事情。\n\n在 mouseup\n上，我们可以智能地完成放置（drop）：更改数据，移动元素。\n我们可以高亮我们正在“飞过”的元素。\n我们可以将拖动限制在特定的区域或者方向。\n我们可以对 mousedown/up\n使用事件委托。一个大范围的用于检查 event.target\n的事件处理程序可以管理数百个元素的拖放。\n\n指针事件\n指针事件（Pointer\nEvents）是一种用于处理来自各种输入设备（例如鼠标、触控笔和触摸屏等）的输入信息的现代化解决方案。\n指针事件类型\n\n\n\n指针事件\n类似的鼠标事件\n\n\n\n\npointerdown\nmousedown\n\n\npointerup\nmouseup\n\n\npointermove\nmousemove\n\n\npointerover\nmouseover\n\n\npointerout\nmouseout\n\n\npointerenter\nmouseenter\n\n\npointerleave\nmouseleave\n\n\npointercancel\n-\n\n\ngotpointercapture\n-\n\n\nlostpointercapture\n-\n\n\n\n不难发现，每一个 mouse&lt;event&gt; 都有与之相对应的\npointer&lt;event&gt;。\n指针事件属性\n指针事件具备和鼠标事件完全相同的属性，包括 clientX/Y 和\ntarget 等，以及一些其他属性：\n\npointerId —— 触发当前事件的指针唯一标识符。\n浏览器生成的。使我们能够处理多指针的情况，例如带有触控笔和多点触控功能的触摸屏（下文会有相关示例）。\npointerType ——\n指针的设备类型。必须为字符串，可以是：“mouse”、“pen” 或 “touch”。\n我们可以使用这个属性来针对不同类型的指针输入做出不同响应。\nisPrimary ——\n当指针为首要指针（多点触控时按下的第一根手指）时为\ntrue。\n\n键盘：keydown 和 keyup\n当一个按键被按下时，会触发 keydown\n事件，而当按键被释放时，会触发 keyup 事件。\nevent.code 和 event.key\n事件对象的 key 属性允许获取字符，而事件对象的\ncode 属性则允许获取“物理按键代码”。\n例如，同一个按键 Z，可以与或不与 Shift\n一起按下。我们会得到两个不同的字符：小写的 z 和大写的\nZ。\nevent.key\n正是这个字符，并且它将是不同的。但是，event.code\n是相同的：\n\n\n\nKey\nevent.key\nevent.code\n\n\n\n\nZ\nz（小写）\nKeyZ\n\n\nShift+Z\nZ（大写）\nKeyZ\n\n\n\n如果用户使用不同的语言，那么切换到另一种语言将产生完全不同的字符，而不是\n\"Z\"。它将成为 event.key 的值，而\nevent.code 则始终都是一样的：\"KeyZ\"。\n","categories":["前端"],"tags":["Event"]},{"title":"Web Event","url":"/2023/12/27/Web-Event/","content":"本文系统梳理了 Web\n事件模型的三种绑定方式，重点讲解事件冒泡机制及事件委托的实现思路；通过\ndata-* 属性演示声明式行为绑定，并介绍如何使用 CustomEvent\n创建和触发自定义事件，深入理解浏览器事件处理流程。\n事件简介\n\nHTML 特性（attribute）：onclick=\"...\"。\nDOM 属性（property）：elem.onclick = function。\n方法（method）：elem.addEventListener(event, handler[, phase])\n用于添加，removeEventListener 用于移除。\n\nHTML 特性很少使用，因为 HTML 标签中的 JavaScript\n看起来有些奇怪且陌生。而且也不能在里面写太多代码。\nDOM\n属性用起来还可以，但我们无法为特定事件分配多个处理程序。在许多场景中，这种限制并不严重。\n最后一种方式是最灵活的，但也是写起来最长的。有少数事件只能使用这种方式。例如\ntranstionend 和\nDOMContentLoaded（上文中讲到了）。addEventListener\n也支持对象作为事件处理程序。在这种情况下，如果发生事件，则会调用\nhandleEvent 方法。\n无论你如何分类处理程序 ——\n它都会将获得一个事件对象作为第一个参数。该对象包含有关所发生事件的详细信息。\n冒泡\n冒泡（bubbling）原理很简单。\n当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序。\nevent.target\n父元素上的处理程序始终可以获取事件实际发生位置的详细信息。\n引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过\nevent.target 访问。\n注意与\nthis（=event.currentTarget）之间的区别：\n\nevent.target ——\n是引发事件的“目标”元素，它在冒泡过程中不会发生变化。\nthis ——\n是“当前”元素，其中有一个当前正在运行的处理程序。\n\n事件委托\n捕获和冒泡允许我们实现最强大的事件处理模式之一，即\n事件委托 模式。\n这个想法是，如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序\n—— 而是将单个处理程序放在它们的共同祖先上。\n在处理程序中，我们获取 event.target\n以查看事件实际发生的位置并进行处理。\n该表格有 9 个单元格（cell），但可以有 99 个或 9999\n个单元格，这都不重要。\n我们的任务是在点击时高亮显示被点击的单元格\n&lt;td&gt;。\n与其为每个 &lt;td&gt;（可能有很多）分配一个\nonclick 处理程序 —— 我们可以在 &lt;table&gt;\n元素上设置一个“捕获所有”的处理程序。\nlet selectedTd;table.onclick = function (event) {\tlet target = event.target; // 在哪里点击的？\tif (target.tagName != \"TD\") return; // 不在 TD 上？那么我们就不会在意\thighlight(target); // 高亮显示它};function highlight(td) {\tif (selectedTd) {\t\t// 移除现有的高亮显示，如果有的话\t\tselectedTd.classList.remove(\"highlight\");\t}\tselectedTd = td;\tselectedTd.classList.add(\"highlight\"); // 高亮显示新的 td}\n我们还可以使用事件委托将“行为（behavior）”以\n声明方式\n添加到具有特殊特性（attribute）和类的元素中。\n行为模式分为两个部分：\n\n我们将自定义特性添加到描述其行为的元素。\n用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上\n—— 则执行行为（action）。\n\n行为：计数器\n例如，这里的特性 data-counter\n给按钮添加了一个“点击增加”的行为。\nCounter: &lt;input type=\"button\" value=\"1\" data-counter&gt;One more counter: &lt;input type=\"button\" value=\"2\" data-counter&gt;&lt;script&gt;  document.addEventListener('click', function(event) {    if (event.target.dataset.counter != undefined) { // 如果这个特性存在...      event.target.value++;    }  });&lt;/script&gt;\n如果我们点击按钮 ——\n它的值就会增加。但不仅仅是按钮，一般的方法在这里也很重要。\n我们可以根据需要使用 data-counter\n特性，多少都可以。我们可以随时向 HTML\n添加新的特性。使用事件委托，我们属于对 HTML\n进行了“扩展”，添加了描述新行为的特性。\n行为：切换器\n再举一个例子。点击一个具有 data-toggle-id\n特性的元素将显示/隐藏具有给定 id 的元素：\n&lt;button data-toggle-id=\"subscribe-mail\"&gt;Show the subscription form&lt;/button&gt;&lt;form id=\"subscribe-mail\" hidden&gt;Your mail: &lt;input type=\"email\" /&gt;&lt;/form&gt;&lt;script&gt;\tdocument.addEventListener(\"click\", function (event) {\t\tlet id = event.target.dataset.toggleId;\t\tif (!id) return;\t\tlet elem = document.getElementById(id);\t\telem.hidden = !elem.hidden;\t});&lt;/script&gt;\n\n自定义数据属性：data-*\n这种方式通过访问一个元素的 dataset 属性来存取\ndata-*自定义属性的值。\n使用这种方法时，不是使用完整的属性名，如 data-id 来存取数据，应该去掉\ndata-前缀。\n还有一点特别注意的是：data-属性名如果包含了连字符，例如\ndata-id-and-class，连字符将被去掉，并转换为驼峰式的命名，前面的属性应该写成\nidAndClass。\n\n浏览器默认行为\n阻止浏览器行为\n有两种方式来告诉浏览器我们不希望它执行默认行为：\n\n主流的方式是使用 event 对象。有一个\nevent.preventDefault() 方法。\n如果处理程序是使用 on&lt;event&gt;（而不是\naddEventListener）分配的，那返回 false\n也同样有效。\n\n&lt;a href=\"/\" onclick=\"return false\"&gt;Click here&lt;/a&gt;or&lt;a href=\"/\" onclick=\"event.preventDefault()\"&gt;here&lt;/a&gt;\n创建自定义事件\n事件构造器\n内建事件类形成一个层次结构（hierarchy），类似于 DOM\n元素类。根是内建的 Event\n类。\n我们可以像这样创建 Event 对象：\nlet event = new Event(type[, options]);\n参数：\n\ntype —— 事件类型，可以是像这样\n\"click\" 的字符串，或者我们自己的像这样\n\"my-event\" 的参数。\noptions —— 具有两个可选属性的对象：\n\nbubbles: true/false —— 如果为\ntrue，那么事件会冒泡。\ncancelable: true/false —— 如果为\ntrue，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。\n\n默认情况下，以上两者都为\nfalse：{bubbles: false, cancelable: false}。\n\ndispatchEvent\n事件对象被创建后，我们应该使用 elem.dispatchEvent(event)\n调用在元素上“运行”它。\n自定义事件\n对于我们自己的全新事件类型，例如 \"hello\"，我们应该使用\nnew CustomEvent。从技术上讲，CustomEvent 和\nEvent 一样。除了一点不同。\n在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性\ndetail。\n&lt;h1 id=\"elem\"&gt;Hello for John!&lt;/h1&gt;&lt;script&gt;\t// 事件附带给处理程序的其他详细信息\telem.addEventListener(\"hello\", function (event) {\t\talert(event.detail.name);\t});\telem.dispatchEvent(\t\tnew CustomEvent(\"hello\", {\t\t\tdetail: { name: \"John\" },\t\t})\t);&lt;/script&gt;\n事件中的事件是同步的\n通常事件是在队列中处理的。也就是说：如果浏览器正在处理\nonclick，这时发生了一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的\nmousemove 处理程序将在 onclick\n事件处理完成后被调用。\n值得注意的例外情况就是，一个事件是在另一个事件中发起的。例如使用\ndispatchEvent。这类事件将会被立即处理，即在新的事件处理程序被调用之后，恢复到当前的事件处理程序。\n","categories":["前端"],"tags":["Event"]},{"title":"oh-my-posh 终端美化","url":"/2023/08/18/oh-myposh-%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/","content":"终端美化神器 oh-my-posh 全面教程，涵盖 Windows 与 Linux\n系统的安装方法、字体配置、主题设置与 VS Code 集成，详解自定义主题 JSON\n文件结构，附带作者推荐主题与常见问题解决方案，助你打造个性化高颜值终端环境。\n\n终端美化\n\nwindows\n\n下载oh-my-posh\nwinget install JanDeDobbeleer.OhMyPosh -s winget\n\n使用管理员身份执行\n\n下载字体\noh-my-posh font install\n\n​\n上下键选择，推荐Cousine，看起来很舒服（如上图）。\n打开powershell（推荐windows\nterminal打开）\n在界面里输入快捷键CTRL + SHIFT + ,打开终端配置文件,输入以下配置。\n\"defaults\": {    \"font\":     {    \t\"face\": \"Cousine\" //填入你实际下载的字体名称    }},\n或者直接打开terminal的默认设置，选择字体。\n\nvscode里设置\n打开设置选项，输入Integrated: Font Family，填入下载的字体即可。\n\n设置主题\nNew-Item -Path $PROFILE -Type File -Force //如果$Profile不存在，就执行这个notepad $PROFILE\n在弹出的文件里写入\noh-my-posh init pwsh --config \"$env:POSH_THEMES_PATH/ys.omp.json\" | Invoke-Expression\n其中ys.omp.json是主题配置文件，你可以自选。\n\n最后保存配置文件\n. $PROFILE\n\n以上过程如有任何问题，可能解决方法如下\n\n管理员身份执行命令\n执行 Install-Module PsReadLine -Force\n\n\n主题选择\nGet-PoshThemes\n会列出很多主题，你可以自己选择，甚至可以进入配置文件进行修改（文件地址在上面命令输出的最后几行）。\n个人使用的主题\nys.omp.json，在此基础上修改了一些，主打一个清爽，不是很花里胡哨😀\n\n{  \"$schema\": \"https://raw.githubusercontent.com/JanDeDobbeleer/oh-my-posh/main/themes/schema.json\",  \"blocks\": [    {      \"alignment\": \"left\",      \"segments\": [        {          \"foreground\": \"white\",          \"properties\": {            \"fetch_version\": false          },          \"style\": \"plain\",          \"template\": \"({{ if .Error }}{{ .Error }}{{ else }}{{ if .Venv }}{{ .Venv }} {{ end }}{{ .Full }}{{ end }})\",          \"type\": \"python\"        }      ],      \"type\": \"prompt\"    },    {      \"alignment\": \"left\",      \"newline\": false,      \"segments\": [        {          \"foreground\": \"lightBlue\",          \"style\": \"plain\",          \"template\": \"# \",          \"type\": \"text\"        },        {          \"foreground\": \"red\",          \"style\": \"plain\",          \"template\": \" % \",          \"type\": \"root\"        },        {          \"style\": \"plain\",          \"template\": \"&lt;cyan&gt;{{ .UserName }}&lt;/&gt;&lt;darkGray&gt;@&lt;/&gt;&lt;green&gt;{{ .HostName }}&lt;/&gt;\",          \"type\": \"session\"        },        {          \"foreground\": \"lightYellow\",          \"properties\": {            \"style\": \"full\"          },          \"style\": \"plain\",          \"template\": \" {{ .Path }} \",          \"type\": \"path\"        },        {            \"style\": \"plain\",            \"template\": \"&lt;darkGray&gt;on&lt;/&gt; &lt;white&gt;{{.RepoName}}:&lt;/&gt;&lt;cyan&gt;{{ .HEAD }}&lt;/&gt;{{ if .Working.Changed }}&lt;red&gt; x&lt;/&gt;{{ end }} \",            \"type\": \"git\",            \"properties\": {              \"fetch_status\": true            }          },        {          \"foreground\": \"darkGray\",          \"style\": \"plain\",          \"template\": \"[{{ .CurrentDate | date .Format }}]\",          \"type\": \"time\"        },        {          \"foreground\": \"red\",          \"style\": \"plain\",          \"template\": \" C:{{ if gt .Code 0 }}{{ .Code }}{{ end }} \",          \"type\": \"status\"        }      ],      \"type\": \"prompt\"    },    {      \"alignment\": \"left\",      \"newline\": true,      \"segments\": [        {          \"foreground\": \"lightRed\",          \"style\": \"plain\",          \"template\": \"$\",          \"type\": \"text\"        }      ],      \"type\": \"prompt\"    }  ],  \"final_space\": true,  \"version\": 2}\n\n\nLinux\n​ ubuntu 18.04\n\n下载\ncurl -s https://ohmyposh.dev/install.sh | bash -s\n安装font和windows一样\n设置主题\n首先区分你是要对所有用户都设置，还是只对当前用户？\n\n当前用户 ~/.bashrc\n所有用户（包括root）etc/bash.bashrc\n\n将下面的命令添加到上面的bash配置文件中第一行。\neval \"$(oh-my-posh init bash --config $theme_path)\"\n$theme_path是你保存主题文件的地方，在安装的时候会有信息，仔细找一下。\n\n如果你是对所有用户设置，记得把主题文件放在所有用户都能访问的地方，并且设置文件权限所有用户可读取。\n例如，copy一份放在/usr/src里\n\n\n最后 sourcebash配置文件即可。\n主题选择都和windows一样。\n\n欢迎加我好友一起学习😎\n\n本文作者：Decade 作者博客：https://decade.net.cn/\n联系方式：Github\n QQ：3237550600 转载要求：\n转载请在文首显眼出表明本文链接且在留言区告知我并附上你转载到哪里的链接。\n\n","categories":["Terminal"],"tags":["oh-my-posh"]},{"title":"儿童节吃个糖果！","url":"/2025/06/01/%E5%84%BF%E7%AB%A5%E8%8A%82%E5%90%83%E4%B8%AA%E7%B3%96%E6%9E%9C%EF%BC%81/","content":"135. 分发糖果\n[Hard] 题解\n利用拓扑排序求解约束性问题\n\nLeetcode 135. 分发糖果\nn 个孩子站成一排。给你一个整数数组 ratings\n表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：\n\n每个孩子至少分配到 1 个糖果。\n相邻两个孩子评分更高的孩子会获得更多的糖果。\n\n请你给每个孩子分发糖果，计算并返回需要准备的\n最少糖果数目 。\n示例 1：\n输入：ratings = [1,0,2]输出：5解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n示例 2：\n输入：ratings = [1,2,2]输出：4解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 \n提示：\n\nn == ratings.length\n1 &lt;= n &lt;= 2 * 10 ^ 4\n0 &lt;= ratings[i] &lt;= 2 * 10 ^ 4\n\n思路\n本质上是一个约束性问题，约束条件比较简单：对于相邻节点u, v，\n两者之中rating值更大的，分到的糖果数量更大。即：dis(u) &gt;  = dis(v) + 1,  if  rating[u] &gt; rating[v]。\n并且这个关系是可以传递的，比如rating[u] &gt; rating[v], rating[v] &gt; rating[k]，那么\ndis(u) &gt;  = dis[k] + 2。\n所以这个时候就可以把这个关系抽象成一个有向图，对于每一个u而言，如果它的左右邻居rating值大于他，那么就构造一条边u → v。\n对于图中任意一个链 u → v → x → y，由于\nu\n的入度为0，所以表明他前面不存在任何约束，即他可以分到最小的糖果数量\ndis(u) = 1。那对于\nv 而言，他前面有一个 u 约束，所以 dis[v]\n一定是大于 dis[u]\n的。由于题目要求最小值，所以 dis[v] = 2，依次类推。\n所以，我们可以用拓扑排序模拟这个过程：首先建图并统计入度，然后依次将入度为0的加入队列进行排序（入度为0代表该节点没有约束了），每个节点更新自己子节点的dis。\n代码\nclass Solution {public:    int candy(vector&lt;int&gt;&amp; ratings) {        int n = ratings.size();        vector&lt;int&gt; deg(n, 0), g[n];        for (int i = 0;i &lt; n;i++) {            if (i &gt; 0 &amp;&amp; ratings[i] &lt; ratings[i - 1]) {                g[i].push_back(i - 1);                ++deg[i - 1];            }            if (i &lt; n - 1 &amp;&amp; ratings[i] &lt; ratings[i + 1]) {                g[i].push_back(i + 1);                ++deg[i + 1];            }        }        deque&lt;int&gt; q;        for (int i = 0;i &lt; n;i++) {            if (deg[i] == 0) q.push_back(i);        }        vector&lt;int&gt; dis(n, 1);        while (q.size()) {            int cur = q.front(); q.pop_front();            for (int nxt : g[cur]) {                dis[nxt] = dis[cur] + 1;                if (--deg[nxt] == 0) q.push_back(nxt);            }        }        return reduce(dis.begin(), dis.end(), 0);    }};\n复杂度\n\n时间：O(n)\n空间：O(n)\n\n","categories":["Algorithm","Problem","Leetcode"],"tags":["拓扑排序"]},{"title":"Spring框架核心解剖","url":"/2024/06/12/Spring%E6%A1%86%E6%9E%B6%E6%A0%B8%E5%BF%83%E8%A7%A3%E5%89%96/","content":"Spring框架核心解剖聚焦 IoC/DI 容器、AOP\n切面编程与事务管理（TX）三大核心功能，深入探讨依赖注入原理、切面织入机制和声明式事务控制。\n\n一、技术体系结构\n1.1 总体技术体系\n\n单一架构\n一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in\none。\n单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis\n\n\nimg\n\n分布式架构\n一个项目（对应 IDEA 中的一个\nproject），拆分成很多个模块，每个模块是一个 IDEA 中的一个\nmodule。每一个工程都是运行在自己的 Tomcat\n上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。\n\n\nimg\n\n分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud ,\n中间件等\n\n1.2 框架概念和理解\n框架( Framework\n)是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。\n框架的优点包括以下几点：\n\n提高开发效率：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。\n降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。\n提高应用程序的稳定性：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。\n提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。\n\n框架的缺点包括以下几个方面：\n\n学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。\n可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。\n版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。\n架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。\n\n站在文件结构的角度理解框架，可以将框架总结：框架 =\njar包+配置文件\n莎士比亚说,“一千个观众眼中有一千个哈姆雷特”\n即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！\n常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。\n总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。\n二、SpringFramework介绍\n2.1 Spring 和\nSpringFramework概念\nhttps://spring.io/projects\n广义的 Spring：Spring 技术栈（全家桶）\n广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。\n经过十多年的发展，Spring\n已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如\nSpring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring\nData、Spring Security 等，其中 Spring Framework 是其他子项目的基础。\n这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。\n狭义的 Spring：Spring Framework（基础框架）\n狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring\n框架。\nSpring\nFramework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency\nInjection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。\nSpring全家桶的其他框架都是以SpringFramework框架为基础！\n对比理解：\nQQ 和 腾讯\n腾讯 = Spring\nQQ = SpringFramework\n2.2\nSpringFramework主要功能模块\nSpringFramework框架结构图：\n\n\nimg\n\n\n\n\n\n\n\n\n功能模块\n功能介绍\n\n\n\n\nCore Container\n核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。\n\n\nAOP&amp;Aspects\n面向切面编程\n\n\nTX\n声明式事务管理。\n\n\nSpring MVC\n提供了面向Web应用程序的集成功能。\n\n\n\n2.3 SpringFramework 主要优势\n\n丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring\nBoot、Spring Security、Spring Cloud\n等等，可以帮助开发人员快速构建高可靠性的企业应用程序。\n模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring\nFramework\n具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。\n简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和\nAPI，可以降低开发复杂度和学习成本。同时，Spring Framework\n支持各种应用场景，包括 Web 应用程序、RESTful\nAPI、消息传递、批处理等等。\n不断创新和发展：Spring Framework\n开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。\n\n因此，这些优点使得 Spring Framework\n成为了一个稳定、可靠、且创新的框架，为企业级 Java\n开发提供了一站式的解决方案。\nSpring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用\nJava 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM\n上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring\nFramework 6.0.6开始，Spring 需要 Java 17+。\n三、Spring IoC容器和核心概念\n3.1 组件和组件管理概念\n\n*3.1.1 什么是组件?*\n回顾常规的三层架构处理请求流程：\n\n\nimg\n\n整个项目就是由各种组件搭建而成的：\n\n\nimg\n\n*3.1.2 我们的期待*\n\n有人替我们创建组件的对象\n有人帮我们保存组件的对象\n有人帮助我们自动组装\n有人替我们管理事务\n有人协助我们整合其他框架\n……\n\n*3.1.3\nSpring充当组件管理角色（IoC）*\n那么谁帮我们完成我们的期待，帮我们管理组件呢？\n当然是Spring 框架了！\n组件可以完全交给Spring\n框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！\nSpring具体的组件管理动作包含：\n\n组件对象实例化\n组件属性属性赋值\n组件对象之间引用\n组件对象存活周期管理\n…… 我们只需要编写元数据（配置文件）告知Spring\n管理哪些类组件和他们的关系即可！\n注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！\n组件一定是对象\n对象不一定是组件 综上所述，Spring\n充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！\n\n*3.1.4 组件交给Spring管理优势*!\n\n降低了组件之间的耦合性：Spring\nIoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。\n提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring\nIoC容器处理，使得组件代码更加模块化、可重用、更易于维护。\n方便了配置和管理：Spring\nIoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。\n交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等\n\n\n3.2 Spring IoC容器和容器实现\n\n*3.2.1 普通和复杂容器*\n*普通容器*\n\n普通容器只能用来存储，没有更多功能。 程序中的普通容器\n\n数组\n集合：List\n集合：Set\n\n\n*复杂容器* Servlet 容器能够管理\nServlet(init,service,destroy)、Filter、Listener\n这样的组件的一生，所以它是一个复杂容器。\n\n\n\n\n\n\n\n\n\n名称\n时机\n次数\n\n\n\n\n创建对象\n默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中\n一次\n\n\n初始化操作\n创建对象之后\n一次\n\n\n处理请求\n接收到请求\n多次\n\n\n销毁操作\nWeb应用卸载之前\n一次\n\n\n我们即将要学习的 SpringIoC\n容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。\n\n\n\n\n\n\n总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！\n*3.2.2 SpringIoC容器介绍*\nSpring IoC 容器，负责实例化、配置和组装\nbean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以\n*XML、Java 注解或 Java\n代码*形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。\n\n\nimg\n\n上图显示了 Spring\n容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。\n*3.2.3\nSpringIoC容器具体接口和实现类*\n*SpringIoc容器接口*：\nBeanFactory\n接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！\nApplicationContext 是 BeanFactory\n的子接口。它扩展了以下功能：\n\n更容易与 Spring 的 AOP 功能集成\n消息资源处理（用于国际化）\n特定于应用程序给予此接口实现，例如Web 应用程序的\nWebApplicationContext 简而言之， BeanFactory\n提供了配置框架和基本功能，而 ApplicationContext\n添加了更多特定于企业的功能。 ApplicationContext 是\nBeanFactory 的完整超集！\n*ApplicationContext容器实现类*：\n\n\n\n\n\n\n\n\n类型名\n简介\n\n\n\n\nClassPathXmlApplicationContext\n通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象\n\n\nFileSystemXmlApplicationContext\n通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象\n\n\nAnnotationConfigApplicationContext\n通过读取Java配置类创建 IOC 容器对象\n\n\nWebApplicationContext\n专门为 Web 应用准备，基于 Web 环境创建 IOC\n容器对象，并将对象引入存入 ServletContext 域中。\n\n\n\n*3.2.4 SpringIoC容器管理配置方式*\nSpring IoC\n容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉\nSpring 容器实例化、配置和组装应用程序中的对象。\nSpring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式\n\nXML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring\nIoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。\n\n\n\n注解方式：从Spring\n2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component,\n@Service, @Autowired等），将Bean注册到Spring\nIoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。\n\n*Java配置类*方式：从Spring\n3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。\n为了迎合当下开发环境，我们将以*配置类+注解方式*为主进行讲解！\n\n\n3.3 Spring IoC / DI概念总结\n\n*IoC容器*\nSpring IoC 容器，负责实例化、配置和组装\nbean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。\n*IoC（Inversion of\nControl）控制反转*\nIoC\n主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由\nIoC 容器来创建和管理，即控制权由应用程序转移到 IoC\n容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即\nIoC 容器维护着构成应用程序的对象，并负责创建这些对象。\n*DI (Dependency Injection)\n依赖注入*\nDI\n是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在\nSpring 中，DI 是通过 XML\n配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter\n方法注入和接口注入。\n\n四、Spring IoC实践和应用\n4.1 Spring IoC / DI 实现步骤\n\n我们总结下，组件交给Spring\nIoC容器管理，并且获取和使用的基本步骤！\n\n\n*配置元数据（配置）*\n配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://www.springframework.org/schema/beans    https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;  &lt;bean id=\"...\" [1] class=\"...\" [2]&gt;      &lt;!-- collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;bean id=\"...\" class=\"...\"&gt;    &lt;!-- collaborators and configuration for this bean go here --&gt;  &lt;/bean&gt;  &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt;\nSpring IoC 容器管理一个或多个组件。这些\n组件是使用你提供给容器的配置元数据（例如，以 XML\n&lt;bean/&gt; 定义的形式）创建的。\n 标签 == 组件信息声明\n\nid 属性是标识单个 Bean 定义的字符串。\n\n\n\nclass 属性定义 Bean 的类型并使用完全限定的类名。\n\n\n*实例化IoC容器*\n提供给 ApplicationContext\n构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java\nCLASSPATH 等）加载配置元数据。\n我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：\n//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作ApplicationContext context =            new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n*获取Bean（组件）*\nApplicationContext 是一个高级工厂的接口，能够维护不同\nbean 及其依赖项的注册表。通过使用方法\nT getBean(String name, Class&lt;T&gt; requiredType)\n，您可以检索 bean 的实例。\n允许读取 Bean 定义并访问它们，如以下示例所示：\n//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");//获取ioc容器的组件对象PetStoreService service = context.getBean(\"petStore\", PetStoreService.class);//使用组件对象List&lt;String&gt; userList = service.getUsernameList();\n\n4.2 基于XML配置方式组件管理\n4.2.1 实验一：\n组件（Bean）信息声明配置（IoC）\n\n目标\nSpring IoC 容器管理一个或多个 bean。这些 Bean\n是使用您提供给容器的配置元数据创建的（例如，以 XML\n&lt;bean/&gt; 定义的形式）。\n我们学习如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC\n容器进行组件管理！\n思路\n\n\nimg\n\n准备项目\n\n创建maven工程（spring-ioc-xml-01）\n导入SpringIoC相关依赖\npom.xml\n&lt;dependencies&gt;    &lt;!--spring context依赖--&gt;    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit5测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n基于无参数构造函数\n\n当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由\nSpring\n使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定\nBean\n类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。\n\n\nbean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息\nid属性：bean的唯一标识,方便后期获取Bean！\nclass属性：组件类的全限定符！\n注意：要求当前组件类必须包含无参数构造函数！\n\npublic class HappyComponent {    //默认包含无参数构造函数    public void doWork() {        System.out.println(\"HappyComponent.doWork\");    }}\n&lt;bean id=\"happyComponent\" class=\"com.atguigu.ioc.HappyComponent\"/&gt;\n基于静态工厂方法实例化\n\n除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置\n！\n\npublic class ClientService {  private static ClientService clientService = new ClientService();  private ClientService() {}  public static ClientService createInstance() {      return clientService;  }}\n&lt;bean id=\"clientService\"  class=\"examples.ClientService\"  factory-method=\"createInstance\"/&gt;\n\nclass属性：指定工厂类的全限定符！\nfactory-method:\n指定静态工厂方法，注意，该方法必须是static方法。\n\n基于实例工厂方法实例化\npublic class DefaultServiceLocator {  private static ClientServiceImplclientService = new ClientServiceImpl();  public ClientService createClientServiceInstance() {    return clientService;  }}\n&lt;!-- 将工厂类进行ioc配置 --&gt;&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt;&lt;/bean&gt;&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;&lt;bean id=\"clientService\"  factory-bean=\"serviceLocator\"  factory-method=\"createClientServiceInstance\"/&gt;\n\nfactory-bean属性：指定当前容器中工厂Bean 的名称。\nfactory-method:\n指定实例工厂方法名。注意，实例方法必须是非static的！\n\n图解IoC配置流程\n\n\nimg\n\n\n4.2.2 实验二：\n组件（Bean）依赖注入配置（DI）\n\n目标\n通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。\n主要涉及注入场景：基于构造函数的依赖注入和基于 Setter\n的依赖注入。\n思路\n\n\nimg\n\n基于构造函数的依赖注入（单个构造参数）\n\n基于构造函数的 DI\n是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。\n\npublic class UserDao {}public class UserService {        private UserDao userDao;    public UserService(UserDao userDao) {        this.userDao = userDao;    }}\n&lt;beans&gt;  &lt;!-- 引用类bean声明 --&gt;  &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt;   &lt;!-- 构造函数引用 --&gt;    &lt;constructor-arg ref=\"userDao\"/&gt;  &lt;/bean&gt;  &lt;!-- 被引用类bean声明 --&gt;  &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt;&lt;/beans&gt;\n\nconstructor-arg标签：可以引用构造参数 有value和ref两个属性\n\nref引用其他bean的标识。\nvalue为直接属性值。\n\n\n基于构造函数的依赖注入（多构造参数解析）\n\n基于构造函数的 DI\n是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。\n\npublic class UserDao {}public class UserService {        private UserDao userDao;        private int age;        private String name;    public UserService(int age , String name ,UserDao userDao) {        this.userDao = userDao;        this.age = age;        this.name = name;    }}\n&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;&lt;beans&gt;  &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt;    &lt;!-- value直接注入基本类型值 --&gt;    &lt;constructor-arg  value=\"18\"/&gt;    &lt;constructor-arg  value=\"赵伟风\"/&gt;        &lt;constructor-arg  ref=\"userDao\"/&gt;  &lt;/bean&gt;  &lt;!-- 被引用类bean声明 --&gt;  &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;&lt;beans&gt;  &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt;    &lt;!-- value直接注入基本类型值 --&gt;    &lt;constructor-arg name=\"name\" value=\"赵伟风\"/&gt;    &lt;constructor-arg name=\"userDao\" ref=\"userDao\"/&gt;    &lt;constructor-arg name=\"age\"  value=\"18\"/&gt;  &lt;/bean&gt;  &lt;!-- 被引用类bean声明 --&gt;  &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt;&lt;/beans&gt;&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据            index从0开始 构造函数(0,1,2....)--&gt;&lt;beans&gt;    &lt;bean id=\"userService\" class=\"x.y.UserService\"&gt;    &lt;!-- value直接注入基本类型值 --&gt;    &lt;constructor-arg index=\"1\" value=\"赵伟风\"/&gt;    &lt;constructor-arg index=\"2\" ref=\"userDao\"/&gt;    &lt;constructor-arg index=\"0\"  value=\"18\"/&gt;  &lt;/bean&gt;  &lt;!-- 被引用类bean声明 --&gt;  &lt;bean id=\"userDao\" class=\"x.y.UserDao\"/&gt;&lt;/beans&gt;\n\nconstructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值\n\n*基于Setter方法依赖注入*\n\n开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！\n\npublic Class MovieFinder{}public class SimpleMovieLister {  private MovieFinder movieFinder;    private String movieName;  public void setMovieFinder(MovieFinder movieFinder) {    this.movieFinder = movieFinder;  }    public void setMovieName(String movieName){    this.movieName = movieName;  }  // business logic that actually uses the injected MovieFinder is omitted...}\n&lt;bean id=\"simpleMovieLister\" class=\"examples.SimpleMovieLister\"&gt;  &lt;!-- setter方法，注入movieFinder对象的标识id       name = setter方法名（去除前面的set，并将首字母改为小写）  \t\tref = 引用bean的id值   --&gt;  &lt;property name=\"movieFinder\" ref=\"movieFinder\" /&gt;  &lt;!-- setter方法，注入基本数据类型movieName       name = setter方法名（去除前面的set，并将首字母改为小写）  \t\tvalue= 基本类型值   --&gt;  &lt;property name=\"movieName\" value=\"消失的她\"/&gt;&lt;/bean&gt;&lt;bean id=\"movieFinder\" class=\"examples.MovieFinder\"/&gt;\n\nproperty标签： 可以给setter方法对应的属性赋值\nproperty 标签：\nname属性代表*set方法标识*、ref代表引用bean的标识id、value属性代表基本属性值\n\n\n总结：\n依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！\n需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。\n4.2.3 实验三： IoC容器创建和使用\n\n介绍\n上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！\n想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！\n容器实例化\n//方式1:实例化并且指定配置文件//参数：String...locations 传入一个或者多个配置文件ApplicationContext context =            new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");           //方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  ApplicationContext context =            new ClassPathXmlApplicationContext();   //设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置iocContainer1.setConfigLocations(\"services.xml\", \"daos.xml\");//后配置的文件,需要调用refresh方法,触发刷新配置iocContainer1.refresh();           \nBean对象读取\n//方式1: 根据id获取//没有指定类型,返回为Object,需要类型转化!HappyComponent happyComponent =         (HappyComponent) iocContainer.getBean(\"bean的id标识\");//使用组件对象        happyComponent.doWork();//方式2: 根据类型获取//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);happyComponent.doWork();//方式3: 根据id和类型获取HappyComponent happyComponent = iocContainer.getBean(\"bean的id标识\", HappyComponent.class);happyComponent.doWork();//根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，//只要返回的是true就可以认定为和类型匹配，能够获取到。// 例如A为一个接口，B实现了A。在IOC配置中要声明实例化对象B。// 而在使用中getBean(B.class)和getBean(A.class)是等价的。\n\n4.2.4 实验四：\n高级特性：组件（Bean）作用域和周期方法配置\n\n组件周期方法配置\n\n周期方法概念\n我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！\n类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。\n周期方法声明\n\npublic class BeanOne {  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表  public void init() {    // 初始化逻辑  }}public class BeanTwo {  public void cleanup() {    // 释放资源逻辑  }}\n\n周期方法配置\n\n&lt;beans&gt;  &lt;bean id=\"beanOne\" class=\"examples.BeanOne\" init-method=\"init\" /&gt;  &lt;bean id=\"beanTwo\" class=\"examples.BeanTwo\" destroy-method=\"cleanup\" /&gt;&lt;/beans&gt;\n组件作用域配置\n\nBean作用域概念\n\n&lt;bean\n标签声明Bean，只是将Bean的信息配置给SpringIoC容器！\n在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部\nBeanDefinition 对象，BeanDefinition\n对象内，包含定义的信息（id,class,属性等等）！\n这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。\n具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！\n\n作用域可选值\n\n\n\n\n\n\n\n\n\n\n取值\n含义\n创建对象的时机\n默认值\n\n\n\n\nsingleton\n在 IOC 容器中，这个 bean\n的对象始终为单实例\nIOC 容器初始化时\n是\n\n\nprototype\n这个 bean 在 IOC 容器中有多个实例\n获取 bean 时\n否\n\n\n\n如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：\n\n\n\n取值\n含义\n创建对象的时机\n默认值\n\n\n\n\nrequest\n请求范围内有效的实例\n每次请求\n否\n\n\nsession\n会话范围内有效的实例\n每次会话\n否\n\n\n\n\n作用域配置\n配置scope范围\n&lt;!--bean的作用域     准备两个引用关系的组件类即可！！--&gt;&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;&lt;bean id=\"happyMachine8\" scope=\"prototype\" class=\"com.atguigu.ioc.HappyMachine\"&gt;    &lt;property name=\"machineName\" value=\"happyMachine\"/&gt;&lt;/bean&gt;&lt;bean id=\"happyComponent8\" scope=\"singleton\" class=\"com.atguigu.ioc.HappyComponent\"&gt;    &lt;property name=\"componentName\" value=\"happyComponent\"/&gt;&lt;/bean&gt;\n作用域测试\n@Testpublic void testExperiment08()  {    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(\"配置文件名\");    HappyMachine bean = iocContainer.getBean(HappyMachine.class);    HappyMachine bean1 = iocContainer.getBean(HappyMachine.class);    //多例对比 false    System.out.println(bean == bean1);    HappyComponent bean2 = iocContainer.getBean(HappyComponent.class);    HappyComponent bean3 = iocContainer.getBean(HappyComponent.class);    //单例对比 true    System.out.println(bean2 == bean3);}\n\n\n4.2.5 实验五：\n高级特性：FactoryBean特性和使用\n\nFactoryBean简介\nFactoryBean 接口是Spring\nIoC容器实例化逻辑的可插拔性点。\n用于配置复杂的Bean对象，可以将创建过程存储在FactoryBean\n的getObject方法！\nFactoryBean&lt;T&gt; 接口提供三种方法：\n\nT getObject():\n返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！\nboolean isSingleton():\n如果此 FactoryBean 返回单例，则返回 true\n，否则返回 false 。此方法的默认实现返回 true\n（注意，lombok插件使用，可能影响效果）。\nClass&lt;?&gt; getObjectType(): 返回\ngetObject() 方法返回的对象类型，如果事先不知道类型，则返回\nnull 。 \n\nFactoryBean使用场景\n\n代理类的创建\n第三方框架整合\n复杂对象实例化等\n\nFactorybean应用\n\n准备FactoryBean实现类\n// 实现FactoryBean接口时需要指定泛型// 泛型类型就是当前工厂要生产的对象的类型public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; {        private String machineName;        public String getMachineName() {        return machineName;    }        public void setMachineName(String machineName) {        this.machineName = machineName;    }        @Override    public HappyMachine getObject() throws Exception {            // 方法内部模拟创建、设置一个对象的复杂过程        HappyMachine happyMachine = new HappyMachine();            happyMachine.setMachineName(this.machineName);            return happyMachine;    }        @Override    public Class&lt;?&gt; getObjectType() {            // 返回要生产的对象的类型        return HappyMachine.class;    }}\n配置FactoryBean实现类\n&lt;!-- FactoryBean机制 --&gt;&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;&lt;bean id=\"happyMachine7\" class=\"com.atguigu.ioc.HappyFactoryBean\"&gt;    &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt;    &lt;property name=\"machineName\" value=\"iceCreamMachine\"/&gt;&lt;/bean&gt;\n测试读取FactoryBean和FactoryBean.getObject对象\n@Testpublic void testExperiment07()  {    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(\"spring-bean-07.xml\");    //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象    HappyMachine happyMachine = iocContainer.getBean(\"happyMachine7\",HappyMachine.class);    System.out.println(\"happyMachine = \" + happyMachine);    //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可!  &amp;happyMachine7 这是一种固定的约束    Object bean = iocContainer.getBean(\"&amp;happyMachine7\");    System.out.println(\"bean = \" + bean);}\n\nFactoryBean和BeanFactory区别\n*FactoryBean*是 Spring 中一种特殊的\nbean，可以在 getObject()\n工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的\nBean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用\ngetObject() 方法来得到其所生产的 Bean。因此，FactoryBean\n可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。\n一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！\n*BeanFactory* 是 Spring\n框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean\n的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory\n接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean\n实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java\n配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory\n还包含很多子类（例如，ApplicationContext\n接口）提供了额外的强大功能。\n总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建\nbean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean\n的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。\n\n4.2.6 实验六：\n基于XML方式整合三层架构组件\n\n需求分析\n搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！\n\n\nimg\n\n数据库准备\ncreate database studb;use studb;CREATE TABLE students (  id INT PRIMARY KEY,  name VARCHAR(50) NOT NULL,  gender VARCHAR(10) NOT NULL,  age INT,  class VARCHAR(50));INSERT INTO students (id, name, gender, age, class)VALUES  (1, '张三', '男', 20, '高中一班'),  (2, '李四', '男', 19, '高中二班'),  (3, '王五', '女', 18, '高中一班'),  (4, '赵六', '女', 20, '高中三班'),  (5, '刘七', '男', 19, '高中二班'),  (6, '陈八', '女', 18, '高中一班'),  (7, '杨九', '男', 20, '高中三班'),  (8, '吴十', '男', 19, '高中二班');\n项目准备\n\n项目创建\nspring-xml-practice-02\n依赖导入\n&lt;dependencies&gt;      &lt;!--spring context依赖--&gt;      &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;          &lt;version&gt;6.0.6&lt;/version&gt;      &lt;/dependency&gt;      &lt;!-- 数据库驱动和连接池--&gt;      &lt;dependency&gt;          &lt;groupId&gt;mysql&lt;/groupId&gt;          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;          &lt;version&gt;8.0.25&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;druid&lt;/artifactId&gt;          &lt;version&gt;1.2.8&lt;/version&gt;      &lt;/dependency&gt;      &lt;!-- spring-jdbc --&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;          &lt;version&gt;6.0.6&lt;/version&gt;      &lt;/dependency&gt;&lt;/dependencies&gt; \n实体类准备\npublic class Student {    private Integer id;    private String name;    private String gender;    private Integer age;    private String classes;    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getClasses() {        return classes;    }    public void setClasses(String classes) {        this.classes = classes;    }    @Override    public String toString() {        return \"Student{\" +                \"id=\" + id +                \", name='\" + name + '\\'' +                \", gender='\" + gender + '\\'' +                \", age=\" + age +                \", classes='\" + classes + '\\'' +                '}';    }}\n\nJdbcTemplate技术讲解\n\n为了在特定领域帮助我们简化代码，Spring 封装了很多\n『Template』形式的模板类。例如：RedisTemplate、RestTemplate\n等等，包括我们今天要学习的 JdbcTemplate。 jdbc.properties\n提取数据库连接信息\n\natguigu.url=jdbc:mysql://localhost:3306/studbatguigu.driver=com.mysql.cj.jdbc.Driveratguigu.username=rootatguigu.password=root\nspringioc配置文件\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;        &lt;!-- 导入外部属性文件 --&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt;        &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt;        &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt;        &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt;        &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 JdbcTemplate --&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;!-- 装配数据源 --&gt;        &lt;property name=\"dataSource\" ref=\"druidDataSource\"/&gt;    &lt;/bean&gt;    &lt;/beans&gt;\n基于jdbcTemplate的CRUD使用\npublic class JdbcTemplateTest {    /**     * 使用jdbcTemplate进行DML动作     */    @Test    public void testDML(){        ApplicationContext applicationContext =            new ClassPathXmlApplicationContext(\"spring-ioc.xml\");        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);        //TODO 执行插入一条学员数据        String sql = \"insert into students (id,name,gender,age,class) values (?,?,?,?,?);\";        /*        参数1: sql语句        参数2: 可变参数,占位符的值     */        int rows = jdbcTemplate.update(sql, 9,\"十一\", \"男\", 18, \"二年三班\");        System.out.println(\"rows = \" + rows);    }    /**     * 查询单条实体对象     *   public class Student {     *     private Integer id;     *     private String name;     *     private String gender;     *     private Integer age;     *     private String classes;     */    @Test    public void testDQLForPojo(){        String sql = \"select id , name , age , gender , class as classes from students where id = ? ;\";        ApplicationContext applicationContext =            new ClassPathXmlApplicationContext(\"spring-ioc.xml\");        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);        //根据id查询        Student student = jdbcTemplate.queryForObject(sql,  (rs, rowNum) -&gt; {            //自己处理结果映射            Student stu = new Student();            stu.setId(rs.getInt(\"id\"));            stu.setName(rs.getString(\"name\"));            stu.setAge(rs.getInt(\"age\"));            stu.setGender(rs.getString(\"gender\"));            stu.setClasses(rs.getString(\"classes\"));            return stu;        }, 2);        System.out.println(\"student = \" + student);    }    /**     * 查询实体类集合     */    @Test    public void testDQLForListPojo(){        String sql = \"select id , name , age , gender , class as classes from students  ;\";        ApplicationContext applicationContext =            new ClassPathXmlApplicationContext(\"spring-ioc.xml\");        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);        /*        query可以返回集合!        BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可     */        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));        System.out.println(\"studentList = \" + studentList);    }}\n三层架构搭建和实现\n\n持久层\n//接口public interface StudentDao {    /**     * 查询全部学生数据     * @return     */    List&lt;Student&gt; queryAll();}//实现类public class StudentDaoImpl implements StudentDao {    private JdbcTemplate jdbcTemplate;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {        this.jdbcTemplate = jdbcTemplate;    }    /**     * 查询全部学生数据     * @return     */    @Override    public List&lt;Student&gt; queryAll() {        String sql = \"select id , name , age , gender , class as classes from students ;\";        /*          query可以返回集合!          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可         */        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));        return studentList;   }}\n业务层\n//接口public interface StudentService {    /**     * 查询全部学员业务     * @return     */    List&lt;Student&gt; findAll();}//实现类public class StudentServiceImpl  implements StudentService {        private StudentDao studentDao;    public void setStudentDao(StudentDao studentDao) {        this.studentDao = studentDao;    }    /**     * 查询全部学员业务     * @return     */    @Override    public List&lt;Student&gt; findAll() {                List&lt;Student&gt; studentList =  studentDao.queryAll();                return studentList;    }}\n表述层\npublic class StudentController {        private StudentService studentService;    public void setStudentService(StudentService studentService) {        this.studentService = studentService;    }        public void  findAll(){       List&lt;Student&gt; studentList =  studentService.findAll();        System.out.println(\"studentList = \" + studentList);    }}\n\n三层架构IoC配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- 导入外部属性文件 --&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt;        &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt;        &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt;        &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt;        &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 JdbcTemplate --&gt;    &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;!-- 装配数据源 --&gt;        &lt;property name=\"dataSource\" ref=\"druidDataSource\"/&gt;    &lt;/bean&gt;    &lt;bean id=\"studentDao\" class=\"com.atguigu.dao.impl.StudentDaoImpl\"&gt;        &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt;    &lt;/bean&gt;    &lt;bean id=\"studentService\" class=\"com.atguigu.service.impl.StudentServiceImpl\"&gt;        &lt;property name=\"studentDao\" ref=\"studentDao\" /&gt;    &lt;/bean&gt;    &lt;bean id=\"studentController\" class=\"com.atguigu.controller.StudentController\"&gt;        &lt;property name=\"studentService\" ref=\"studentService\" /&gt;    &lt;/bean&gt;&lt;/beans&gt;\n运行测试\npublic class ControllerTest {    @Test    public  void testRun(){        ApplicationContext applicationContext =                new ClassPathXmlApplicationContext(\"spring-ioc.xml\");        StudentController studentController = applicationContext.getBean(StudentController.class);        studentController.findAll();    }}\nXMLIoC方式问题总结\n\n注入的属性必须添加setter方法、代码结构乱！\n配置文件和Java代码分离、编写不是很方便！\nXML配置文件解析效率低\n\n\n4.3 基于 注解 方式管理 Bean\n4.3.1 实验一： Bean注解标记和扫描\n(IoC)\n\n*注解理解*\n和 XML\n配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，\n然后针对这个位置按照注解标记的功能来执行具体操作。\n本质上：所有一切的操作都是 Java 代码来完成的，XML\n和注解只是告诉框架中的 Java 代码如何执行。\n*扫描理解*\nSpring\n为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。\n*准备Spring项目和组件*\n\n准备项目pom.xml\n&lt;dependencies&gt;    &lt;!--spring context依赖--&gt;    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit5测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n准备组件类\n普通组件\n/** * projectName: com.atguigu.components * * description: 普通的组件 */public class CommonComponent {}\nController组件\n/** * projectName: com.atguigu.components * * description: controller类型组件 */public class XxxController {}\nService组件\n/** * projectName: com.atguigu.components * * description: service类型组件 */public class XxxService {}\nDao组件\n/** * projectName: com.atguigu.components * * description: dao类型组件 */public class XxxDao {}\n\n*组件添加标记注解*\n\n组件标记注解和区别\nSpring 提供了以下多个注解，这些注解可以直接标注在 Java\n类上，将它们定义成 Spring Bean。\n\n\n\n\n\n\n\n注解\n说明\n\n\n\n\n@Component\n该注解用于描述 Spring 中的\nBean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如\nService 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。\n\n\n@Repository\n该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的\nBean，其功能与 @Component 相同。\n\n\n@Service\n该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring\n中的 Bean，其功能与 @Component 相同。\n\n\n@Controller\n该注解通常作用在控制层（如SpringMVC 的\nController），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n\n\n使用注解标记\n普通组件\n/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent {}\nController组件\n/** * projectName: com.atguigu.components * * description: controller类型组件 */@Controllerpublic class XxxController {}\nService组件\n/** * projectName: com.atguigu.components * * description: service类型组件 */@Servicepublic class XxxService {}\nDao组件\n/** * projectName: com.atguigu.components * * description: dao类型组件 */@Repositorypublic class XxxDao {}\n*配置文件确定扫描范围*\n情况1：基本扫描配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- 配置自动扫描的包 --&gt;    &lt;!-- 1.包要精准,提高性能!         2.会扫描指定的包和子包内容         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等    --&gt;    &lt;context:component-scan base-package=\"com.atguigu.components\"/&gt;  &lt;/beans&gt;\n情况2：指定排除组件\n&lt;!-- 情况三：指定不扫描的组件 --&gt;&lt;context:component-scan base-package=\"com.atguigu.components\"&gt;        &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;    &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;    &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;    &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt;\n情况3：指定扫描组件\n&lt;!-- 情况四：仅扫描指定的组件 --&gt;&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;&lt;context:component-scan base-package=\"com.atguigu.ioc.components\" use-default-filters=\"false\"&gt;        &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;    &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt;\n*组件BeanName问题*\n在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id\n属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。\n默认情况：\n类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean\n的 id 就是 soldierController。\n使用value属性指定：\n@Controller(value = \"tianDog\")public class SoldierController {}\n当注解中只设置一个属性时，value属性的属性名可以省略：\n@Service(\"smallDog\")public class SoldierService {}\n*总结*\n\n注解方式IoC只是标记哪些类要被Spring管理\n最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包\n*现阶段配置方式为 注解 （标记）+\nXML（扫描）*\n\n\n4.3.2 实验二：\n组件（Bean）作用域和周期方法注解\n\n组件周期方法配置\n\n周期方法概念\n我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！\n类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。\n周期方法声明\npublic class BeanOne {  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表  @PostConstruct  //注解制指定初始化方法  public void init() {    // 初始化逻辑  }}public class BeanTwo {    @PreDestroy //注解指定销毁方法  public void cleanup() {    // 释放资源逻辑  }}\n\n组件作用域配置\n\nBean作用域概念\n&lt;bean\n标签声明Bean，只是将Bean的信息配置给SpringIoC容器！\n在IoC容器中，这些&lt;bean标签对应的信息转成Spring内部\nBeanDefinition 对象，BeanDefinition\n对象内，包含定义的信息（id,class,属性等等）！\n这意味着，BeanDefinition与类概念一样，SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。\n具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！\n作用域可选值\n\n\n\n\n\n\n\n\n\n取值\n含义\n创建对象的时机\n默认值\n\n\n\n\nsingleton\n在 IOC 容器中，这个 bean 的对象始终为单实例\nIOC 容器初始化时\n是\n\n\nprototype\n这个 bean 在 IOC 容器中有多个实例\n获取 bean 时\n否\n\n\nrequest\n请求范围内有效的实例\n每次请求\n否\n\n\nsession\n会话范围内有效的实例\n每次会话\n否\n\n\n\n作用域配置\n\n    @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例  二选一    public class BeanOne {          //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表      @PostConstruct  //注解制指定初始化方法      public void init() {        // 初始化逻辑      }    }\n\n4.3.3 实验三：\nBean属性赋值：引用类型自动装配 (DI)\n\n*设定场景*\n\nSoldierController 需要 SoldierService\nSoldierService 需要 SoldierDao\n同时在各个组件中声明要调用的方法。\nSoldierController中声明方法\nimport org.springframework.stereotype.Controller;@Controller(value = \"tianDog\")public class SoldierController {    private SoldierService soldierService;    public void getMessage() {        soldierService.getMessage();    }}\nSoldierService中声明方法\n@Service(\"smallDog\")public class SoldierService {    private SoldierDao soldierDao;    public void getMessage() {        soldierDao.getMessage();    }}\nSoldierDao中声明方法\n@Repositorypublic class SoldierDao {    public void getMessage() {        System.out.print(\"I am a soldier\");    }}\n\n*自动装配实现*\n\n前提\n参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。\n注意：不区分IoC的方式！XML和注解都可以！\n@Autowired注解\n在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。\n给Controller装配Service\n@Controller(value = \"tianDog\")public class SoldierController {        @Autowired    private SoldierService soldierService;        public void getMessage() {        soldierService.getMessage();    }    }\n给Service装配Dao\n@Service(\"smallDog\")public class SoldierService {        @Autowired    private SoldierDao soldierDao;        public void getMessage() {        soldierDao.getMessage();    }}\n\n*@Autowired注解细节*\n\n标记位置\n\n成员变量\n这是最主要的使用方式！\n与xml进行bean ref引用不同，他不需要有set方法！\n@Service(\"smallDog\")public class SoldierService {        @Autowired    private SoldierDao soldierDao;        public void getMessage() {        soldierDao.getMessage();    }}\n构造器\n@Controller(value = \"tianDog\")public class SoldierController {        private SoldierService soldierService;        @Autowired    public SoldierController(SoldierService soldierService) {        this.soldierService = soldierService;    }    ……\nsetXxx()方法\n@Controller(value = \"tianDog\")public class SoldierController {    private SoldierService soldierService;    @Autowired    public void setSoldierService(SoldierService soldierService) {        this.soldierService = soldierService;    }    ……\n\n工作流程\n\n\nimg\n\n\n首先根据所需要的组件类型到 IOC 容器中查找\n\n能够找到唯一的 bean：直接执行装配\n如果完全找不到匹配这个类型的 bean：装配失败\n和所需类型匹配的 bean 不止一个\n\n没有 @Qualifier\n注解：根据 @Autowired 标记位置成员变量的变量名作为\nbean 的 id 进行匹配\n\n能够找到：执行装配\n找不到：装配失败\n\n使用 @Qualifier\n注解：根据 @Qualifier 注解中指定的名称作为 bean\n的id进行匹配\n\n能够找到：执行装配\n找不到：装配失败\n\n\n\n\n@Controller(value = \"tianDog\")public class SoldierController {     @Autowired    @Qualifier(value = \"maomiService222\")    // 根据面向接口编程思想，使用接口类型引入Service组件    private ISoldierService soldierService;\n\n*佛系装配*\n给 @Autowired\n注解设置 required = false\n属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性\n@Controller(value = \"tianDog\")public class SoldierController {    // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装    @Autowired(required = false)    private ISoldierService soldierService;\n*扩展JSR-250注解@Resource*\n\n理解JSR系列注解\nJSR（Java Specification\nRequests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列：\n\nJSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java\nSE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解：\n\n\n@Deprecated:\n标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。\n@Override: 标识一个方法重写了父类中的方法。\n@SuppressWarnings: 抑制编译时产生的警告消息。\n@SafeVarargs: 标识一个有安全性警告的可变参数方法。\n@FunctionalInterface:\n标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。\n\n\nJSR-250: 这个JSR主要用于在Java EE\n5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括：\n\n\n@Resource: 标识一个需要注入的资源，是实现Java\nEE组件之间依赖关系的一种方式。\n@PostConstruct: 标识一个方法作为初始化方法。\n@PreDestroy: 标识一个方法作为销毁方法。\n@Resource.AuthenticationType:\n标识注入的资源的身份验证类型。\n@Resource.AuthenticationType:\n标识注入的资源的默认名称。\n\n\nJSR-269: 这个JSR主要是Java SE\n6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有：\n\n\n@SupportedAnnotationTypes:\n标识注解处理器所处理的注解类型。\n@SupportedSourceVersion:\n标识注解处理器支持的Java源码版本。\n\n\nJSR-330:\n该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括：\n\n\n@Named: 标识一个被依赖注入的组件的名称。\n@Inject: 标识一个需要被注入的依赖组件。\n@Singleton:\n标识一个组件的生命周期只有一个唯一的实例。\n\n但是你要理解JSR是Java提供的*技术规范*，也就是说，他只是规定了注解和注解的含义，*JSR并不是直接提供特定的实现*，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。\nJSR-250 @Resource注解\n@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？\n\n@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)\n@Autowired注解是Spring框架自己的。\n*@Resource注解默认根据Bean名称装配，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。*\n*@Autowired注解默认根据类型装配，如果想根据名称装配，需要配合@Qualifier注解一起用。*\n@Resource注解用在属性上、setter方法上。\n@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。\n@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【*高于JDK11或低于JDK8需要引入以下依赖*】\n\n&lt;dependency&gt;    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;    &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;\n@Resource使用\n@Controllerpublic class XxxController {    /**     * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService     * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找     * 3. 可以指定name名称查找!  @Resource(name='test') == @Autowired + @Qualifier(value='test')     */    @Resource    private XxxService xxxService;    //@Resource(name = \"指定beanName\")    //private XxxService xxxService;    public void show(){        System.out.println(\"XxxController.show\");        xxxService.show();    }}\n\n\n4.3.4 实验四：\nBean属性赋值：基本类型属性赋值 (DI)\n@Value 通常用于注入外部化属性\n声明外部配置\napplication.properties\ncatalog.name=MovieCatalog\nxml引入外部配置\n&lt;!-- 引入外部配置文件--&gt;&lt;context:property-placeholder location=\"application.properties\" /&gt;\n@Value注解读取配置\npackage com.atguigu.components;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * projectName: com.atguigu.components * * description: 普通的组件 */@Componentpublic class CommonComponent {    /**     * 情况1: ${key} 取外部配置key对应的值!     * 情况2: ${key:defaultValue} 没有key,可以给与默认值     */    @Value(\"${catalog.name:Store}\")    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}\n4.3.5 实验五：\n基于注解+XML方式整合三层架构组件\n\n需求分析\n搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！\n数据库准备\n项目准备\n\n项目创建\nspring-annotation-practice-04\n依赖导入\n实体类准备\n\n三层架构搭建和实现\n\n持久层\n//接口public interface StudentDao {    /**     * 查询全部学生数据     * @return     */    List&lt;Student&gt; queryAll();}//实现类@Repositorypublic class StudentDaoImpl implements StudentDao {    @Autowired    private JdbcTemplate jdbcTemplate;    /**     * 查询全部学生数据     * @return     */    @Override    public List&lt;Student&gt; queryAll() {        String sql = \"select id , name , age , gender , class as classes from students ;\";        /*          query可以返回集合!          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可         */        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));        return studentList;    }}\n业务层\n//接口public interface StudentService {    /**     * 查询全部学员业务     * @return     */    List&lt;Student&gt; findAll();}//实现类@Servicepublic class StudentServiceImpl  implements StudentService {    @Autowired    private StudentDao studentDao;    /**     * 查询全部学员业务     * @return     */    @Override    public List&lt;Student&gt; findAll() {        List&lt;Student&gt; studentList =  studentDao.queryAll();        return studentList;    }}\n表述层\n@Controllerpublic class StudentController {    @Autowired    private StudentService studentService;    public void  findAll(){       List&lt;Student&gt; studentList =  studentService.findAll();        System.out.println(\"studentList = \" + studentList);    }}\n\n三层架构IoC配置\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;        &lt;!-- 导入外部属性文件 --&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt;    &lt;!-- 配置数据源 --&gt;    &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt;        &lt;property name=\"url\" value=\"${atguigu.url}\"/&gt;        &lt;property name=\"driverClassName\" value=\"${atguigu.driver}\"/&gt;        &lt;property name=\"username\" value=\"${atguigu.username}\"/&gt;        &lt;property name=\"password\" value=\"${atguigu.password}\"/&gt;    &lt;/bean&gt;    &lt;bean class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;        &lt;property name=\"dataSource\" ref=\"druidDataSource\" /&gt;    &lt;/bean&gt;    &lt;!-- 扫描Ioc/DI注解 --&gt;    &lt;context:component-scan base-package=\"com.atguigu.dao,com.atguigu.service,com.atguigu.controller\" /&gt;&lt;/beans&gt;\n运行测试\npublic class ControllerTest {    @Test    public  void testRun(){        ApplicationContext applicationContext =                new ClassPathXmlApplicationContext(\"spring-ioc.xml\");        StudentController studentController = applicationContext.getBean(StudentController.class);        studentController.findAll();    }}\n注解+XML IoC方式问题总结\n\n自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！\nXML格式解析效率低！\n\n\n4.4 基于 配置类 方式管理 Bean\n4.4.1 完全注解开发理解\nSpring 完全注解配置（Fully Annotation-based Configuration）是指通过\nJava配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML\n配置文件中的配置。相对于 XML\n配置，完全注解配置具有更强的类型安全性和更好的可读性。\n两种方式思维转化：\n\n\nimg\n\n4.4.2 实验一：配置类和扫描注解\nxml+注解方式\n配置文件application.xml\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- 配置自动扫描的包 --&gt;    &lt;!-- 1.包要精准,提高性能!         2.会扫描指定的包和子包内容         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等    --&gt;    &lt;context:component-scan base-package=\"com.atguigu.components\"/&gt;    &lt;!-- 引入外部配置文件--&gt;    &lt;context:property-placeholder location=\"application.properties\" /&gt;&lt;/beans&gt;\n测试创建IoC容器\n// xml方式配置文件使用ClassPathXmlApplicationContext容器读取ApplicationContext applicationContext =               new ClassPathXmlApplicationContext(\"application.xml\");\n配置类+注解方式（完全注解方式）\n配置类\n使用 @Configuration\n注解将一个普通的类标记为 Spring 的配置类。\nimport org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;//标注当前类是配置类，替代application.xml    @Configuration//使用注解读取外部配置，替代 &lt;context:property-placeholder标签@PropertySource(\"classpath:application.properties\")//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签@ComponentScan(basePackages = {\"com.atguigu.components\"})public class MyConfiguration {    }\n测试创建IoC容器\n// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext(MyConfiguration.class);\n可以使用 no-arg 构造函数实例化\nAnnotationConfigApplicationContext ，然后使用\nregister() 方法对其进行配置。此方法在以编程方式生成\nAnnotationConfigApplicationContext\n时特别有用。以下示例演示如何执行此操作：\n// AnnotationConfigApplicationContext-IOC容器对象ApplicationContext iocContainerAnnotation = new AnnotationConfigApplicationContext();//外部设置配置类iocContainerAnnotation.register(MyConfiguration.class);//刷新后方可生效！！iocContainerAnnotation.refresh();\n总结：\n@Configuration指定一个类为配置类，可以添加配置注解，替代配置xml文件\n@ComponentScan(basePackages =\n{“包”,“包”}) 替代&lt;context:component-scan标签实现注解扫描\n@PropertySource(“classpath:配置文件地址”)\n替代 &lt;context:property-placeholder标签\n配合IoC/DI注解，可以进行完整注解开发！\n4.4.3 实验二：@Bean定义组件\n场景需求：将Druid连接池对象存储到IoC容器\n需求分析：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！\nxml方式实现：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;    &lt;!-- 引入外部属性文件 --&gt;    &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;    &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt;    &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt;        &lt;property name=\"url\" value=\"${jdbc.url}\"/&gt;        &lt;property name=\"driverClassName\" value=\"${jdbc.driver}\"/&gt;        &lt;property name=\"username\" value=\"${jdbc.user}\"/&gt;        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n配置类方式实现：\n@Bean 注释用于指示方法实例化、配置和初始化要由 Spring\nIoC 容器管理的新对象。对于那些熟悉 Spring 的 &lt;beans/&gt;\nXML 配置的人来说， @Bean 注释与 &lt;bean/&gt;\n元素起着相同的作用。\n//标注当前类是配置类，替代application.xml    @Configuration//引入jdbc.properties文件@PropertySource({\"classpath:application.properties\",\"classpath:jdbc.properties\"})@ComponentScan(basePackages = {\"com.atguigu.components\"})public class MyConfiguration {    //如果第三方类进行IoC管理,无法直接使用@Component相关注解    //解决方案: xml方式可以使用&lt;bean标签    //解决方案: 配置类方式,可以使用方法返回值+@Bean注解    // 返回值类型：bean组件的类型或其父类    // 方法名字：bean组件ID    @Bean    public DataSource createDataSource(@Value(\"${jdbc.user}\") String username,                                       @Value(\"${jdbc.password}\")String password,                                       @Value(\"${jdbc.url}\")String url,                                       @Value(\"${jdbc.driver}\")String driverClassName){        //使用Java代码实例化        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUsername(username);        dataSource.setPassword(password);        dataSource.setUrl(url);        dataSource.setDriverClassName(driverClassName);        //返回结果即可        return dataSource;    }        // 或者全局声明属性    @Value(\"${jdbc.user}\")     private String username;}\n4.4.4 实验三：高级特性：@Bean注解细节\n\n*@Bean生成BeanName问题*\n@Bean注解源码：\npublic @interface Bean {    //前两个注解可以指定Bean的标识    @AliasFor(\"name\")    String[] value() default {};    @AliasFor(\"value\")    String[] name() default {};      //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。    //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，    //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。    boolean autowireCandidate() default true;    //指定初始化方法    String initMethod() default \"\";    //指定销毁方法    String destroyMethod() default \"(inferred)\";}\n指定@Bean的名称：\n@Configurationpublic class AppConfig {  @Bean(\"myThing\") //指定名称  public Thing thing() {    return new Thing();  }}\n使用此方法在指定为方法返回值的类型的 ApplicationContext\n中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示\n@Bean 方法声明：\n@Configurationpublic class AppConfig {  @Bean  public TransferServiceImpl transferService() {    return new TransferServiceImpl();  }}\n前面的配置完全等同于下面的Spring XML：\n&lt;beans&gt;  &lt;bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/&gt;&lt;/beans&gt;\n*@Bean 初始化和销毁方法指定*\n@Bean 注解支持指定任意初始化和销毁回调方法，非常类似于\nSpring XML 在 bean 元素上的 init-method 和\ndestroy-method 属性，如以下示例所示：\npublic class BeanOne {  public void init() {    // initialization logic  }}public class BeanTwo {  public void cleanup() {    // destruction logic  }}@Configurationpublic class AppConfig {  @Bean(initMethod = \"init\")  public BeanOne beanOne() {    return new BeanOne();  }  @Bean(destroyMethod = \"cleanup\")  public BeanTwo beanTwo() {    return new BeanTwo();  }}\n*@Bean Scope作用域*\n可以指定使用 @Bean 注释定义的 bean\n应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。\n默认作用域为 singleton ，但您可以使用\n@Scope 注释覆盖此范围，如以下示例所示：\n@Configurationpublic class MyConfiguration {  @Bean  @Scope(\"prototype\")  public Encryptor encryptor() {    // ...  }}\n*@Bean方法之间依赖*\n*准备组件*\npublic class HappyMachine {        private String machineName;        public String getMachineName() {        return machineName;    }        public void setMachineName(String machineName) {        this.machineName = machineName;    }}\npublic class HappyComponent {    //引用新组件    private HappyMachine happyMachine;    public HappyMachine getHappyMachine() {        return happyMachine;    }    public void setHappyMachine(HappyMachine happyMachine) {        this.happyMachine = happyMachine;    }    public void doWork() {        System.out.println(\"HappyComponent.doWork\");    }}\n*Java配置类实现：*\n方案1：\n直接调用方法返回 Bean 实例：在一个 @Bean\n方法中直接调用其他 @Bean 方法来获取 Bean\n实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如：\n@Configurationpublic class JavaConfig {    @Bean    public HappyMachine happyMachine(){        return new HappyMachine();    }    @Bean    public HappyComponent happyComponent(){        HappyComponent happyComponent = new HappyComponent();        //直接调用方法即可!         happyComponent.setHappyMachine(happyMachine());        return happyComponent;    }}\n方案2：\n参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean\n实例之间的依赖关系，例如：\npackage com.atguigu.config;import com.atguigu.ioc.HappyComponent;import com.atguigu.ioc.HappyMachine;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * projectName: com.atguigu.config * description: 配置HappyComponent和HappyMachine关系 */@Configurationpublic class JavaConfig {    @Bean    public HappyMachine happyMachine(){        return new HappyMachine();    }    /**     * 可以直接在形参列表接收IoC容器中的Bean!     *    情况1: 直接指定类型即可     *    情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称!     *           例如:     *               @Bean     *               public Foo foo1(){     *                   return new Foo();     *               }     *               @Bean     *               public Foo foo2(){     *                   return new Foo()     *               }     *               @Bean     *               public Component component(Foo foo1 / foo2 通过此处指定引入的bean)     */    @Bean    public HappyComponent happyComponent(HappyMachine happyMachine){        HappyComponent happyComponent = new HappyComponent();        //赋值        happyComponent.setHappyMachine(happyMachine);        return happyComponent;    }}\n\n4.4.5 实验四：高级特性：@Import扩展\n@Import 注释允许从另一个配置类加载 @Bean\n定义，如以下示例所示：\n@Configurationpublic class ConfigA {  @Bean  public A a() {    return new A();  }}@Configuration@Import(ConfigA.class)public class ConfigB {  @Bean  public B b() {    return new B();  }}\n现在，在实例化上下文时不需要同时指定 ConfigA.class 和\nConfigB.class ，只需显式提供 ConfigB\n，如以下示例所示：\npublic static void main(String[] args) {  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);  // now both beans A and B will be available...  A a = ctx.getBean(A.class);  B b = ctx.getBean(B.class);}\n此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的\n@Configuration 类。\n4.4.6\n实验五：基于注解+配置类方式整合三层架构组件\n\n需求分析\n搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！\n数据库准备\n项目准备\n\n项目创建\nspring-java-practice-06\n依赖导入\n实体类准备\n\n三层架构搭建和实现\n\n持久层\n业务层\n表述层\n\n三层架构IoC配置类\n@Configuration@ComponentScan(basePackages = \"com.atguigu\")@PropertySource(\"classpath:jdbc.properties\")public class JavaConfig {    @Value(\"${atguigu.url}\")    private String url;    @Value(\"${atguigu.driver}\")    private String driver;    @Value(\"${atguigu.username}\")    private String username;    @Value(\"${atguigu.password}\")    private String password;    @Bean(destroyMethod = \"close\")    public DruidDataSource dataSource(){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setUrl(url);        dataSource.setDriverClassName(driver);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    }    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)    @Bean    public JdbcTemplate jdbcTemplate(DataSource dataSource){        JdbcTemplate jdbcTemplate = new JdbcTemplate();        jdbcTemplate.setDataSource(dataSource);        return jdbcTemplate;    }}\n运行测试\npublic class ControllerTest {    @Test    public  void testRun(){        AnnotationConfigApplicationContext applicationContext =                new AnnotationConfigApplicationContext(JavaConfig.class);        StudentController studentController = applicationContext.getBean(StudentController.class);        studentController.findAll();    }}\n注解+配置类 IoC方式总结\n\n完全摒弃了XML配置文件\n自定义类使用IoC和DI注解标记\n第三方类使用配置类声明方法+@Bean方式处理\n完全注解方式（配置类+注解）是现在主流配置方式\n\n\n4.5 三种配置方式总结\n4.5.1 XML方式配置总结\n\n所有内容写到xml格式配置文件中\n声明bean通过&lt;bean标签\n&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name\nvalue / ref\n引入外部的properties文件可以通过&lt;context:property-placeholder\nIoC具体容器实现选择ClassPathXmlApplicationContext对象\n\n4.5.2 XML+注解方式配置总结\n\n注解负责标记IoC的类和进行属性装配\nxml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围\n标记IoC注解：@Component,@Service,@Controller,@Repository\n标记DI注解：@Autowired @Qualifier @Resource @Value\nIoC具体容器实现选择ClassPathXmlApplicationContext对象\n\n4.5.3 完全注解方式配置总结\n\n完全注解方式指的是去掉xml文件，使用配置类 + 注解实现\nxml文件替换成使用@Configuration注解标记的类\n标记IoC注解：@Component,@Service,@Controller,@Repository\n标记DI注解：@Autowired @Qualifier @Resource @Value\n&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages\n= {“com.atguigu.components”})替代\n&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,“classpath:jdbc.properties”})替代\n&lt;bean 标签使用@Bean注解和方法实现\nIoC具体容器实现选择AnnotationConfigApplicationContext对象\n\n4.6\n整合Spring5-Test5搭建测试环境\n\n整合测试环境作用\n好处1：不需要自己创建IOC容器对象了\n好处2：任何需要的bean都可以在测试类中直接享受自动装配\n导入相关依赖\n&lt;!--junit5测试--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;6.0.6&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;\n整合测试注解使用\n//@SpringJUnitConfig(locations = {\"classpath:spring-context.xml\"})  //指定配置文件xml@SpringJUnitConfig(value = {BeanConfig.class})  //指定配置类public class Junit5IntegrationTest {        @Autowired    private User user;        @Test    public void testJunit5() {        System.out.println(user);    }}\n\n五、Spring AOP面向切面编程\n5.1 场景设定和问题复现\n\n准备AOP项目\n项目名：spring-aop-annotation\npom.xml\n&lt;dependencies&gt;    &lt;!--spring context依赖--&gt;    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit5测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;        &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n声明接口\n/** *       + - * / 运算的标准接口! */public interface Calculator {        int add(int i, int j);        int sub(int i, int j);        int mul(int i, int j);        int div(int i, int j);    }\n接口实现\n/** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */public class CalculatorPureImpl implements Calculator {        @Override    public int add(int i, int j) {            int result = i + j;            return result;    }        @Override    public int sub(int i, int j) {            int result = i - j;            return result;    }        @Override    public int mul(int i, int j) {            int result = i * j;            return result;    }        @Override    public int div(int i, int j) {            int result = i / j;            return result;    }}\n声明带日志接口实现\n新需求：\n需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！\npackage com.atguigu.proxy;/** * 在每个方法中,输出传入的参数和计算后的返回结果! */public class CalculatorLogImpl implements Calculator {        @Override    public int add(int i, int j) {            System.out.println(\"参数是：\" + i + \",\" + j);        int result = i + j;        System.out.println(\"方法内部 result = \" + result);              return result;    }        @Override    public int sub(int i, int j) {            System.out.println(\"参数是：\" + i + \",\" + j);            int result = i - j;            System.out.println(\"方法内部 result = \" + result);        return result;    }        @Override    public int mul(int i, int j) {            System.out.println(\"参数是：\" + i + \",\" + j);            int result = i * j;            System.out.println(\"方法内部 result = \" + result);            return result;    }        @Override    public int div(int i, int j) {            System.out.println(\"参数是：\" + i + \",\" + j);            int result = i / j;            System.out.println(\"方法内部 result = \" + result);                return result;    }}\n代码问题分析\n\n代码缺陷\n\n对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力\n附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！\n\n解决思路\n核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。\n将重复的代码统一提取，并且[[动态插入]]到每个业务方法！\n技术困难\n解决问题的困难：提取重复附加功能代码到一个类中，可以实现\n但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！\n\n\n5.2 解决技术代理模式\n\n*代理模式*\n二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。\n无代理场景：\n有代理场景：\n生活中的代理：\n\n广告商找大明星拍广告需要经过经纪人\n合作伙伴找大老板谈合作要约见面时间需要经过秘书\n房产中介是买卖双方的代理\n太监是大臣和皇上之间的代理\n\n程序中的代理：\n\n代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)\n\n动词：指做代理这个动作，或这项工作\n名词：扮演代理这个角色的类、对象、方法\n\n目标：*被代理*“套用”了核心逻辑代码的类、对象、方法。(房东)\n代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]\n\n*静态代理*\n主动创建代理类：\npublic class CalculatorStaticProxy implements Calculator {        // 将被代理的目标对象声明为成员变量    private Calculator target;        public CalculatorStaticProxy(Calculator target) {        this.target = target;    }        @Override    public int add(int i, int j) {            // 附加功能由代理类中的代理方法来实现        System.out.println(\"参数是：\" + i + \",\" + j);            // 通过目标对象来实现核心业务逻辑        int addResult = target.add(i, j);            System.out.println(\"方法内部 result = \" + result);            return addResult;    }}\n静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。\n提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。\n*动态代理*\n动态代理技术分类\n\nJDK动态代理：JDK原生的实现方式，需要被代理的目标类必须*实现接口*！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）\ncglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）\nJDK动态代理技术实现（了解）\n\n\n代理工程：基于jdk代理技术，生成代理对象\npublic class ProxyFactory {    private Object target;    public ProxyFactory(Object target) {        this.target = target;    }    public Object getProxy(){        /**         * newProxyInstance()：创建一个代理实例         * 其中有三个参数：         * 1、classLoader：加载动态生成的代理类的类加载器         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                /**                 * proxy：代理对象                 * method：代理对象需要实现的方法，即其中需要重写的方法                 * args：method所对应方法的参数                 */                Object result = null;                try {                    System.out.println(\"[动态代理][日志] \"+method.getName()+\"，参数：\"+ Arrays.toString(args));                    result = method.invoke(target, args);                    System.out.println(\"[动态代理][日志] \"+method.getName()+\"，结果：\"+ result);                } catch (Exception e) {                    e.printStackTrace();                    System.out.println(\"[动态代理][日志] \"+method.getName()+\"，异常：\"+e.getMessage());                } finally {                    System.out.println(\"[动态代理][日志] \"+method.getName()+\"，方法执行完毕\");                }                return result;            }        };        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    }}\n测试代码：\n@Testpublic void testDynamicProxy(){    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());    Calculator proxy = (Calculator) factory.getProxy();    proxy.div(1,0);    //proxy.div(1,1);}\n\n*代理总结*\n*代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！*\n他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！\n但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！\n需要自己编写代理工厂等！\n但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring\nAOP]框架，\n他会简化动态代理的实现！！！\n\n5.3 面向切面编程思维（AOP）\n\n*面向切面编程思想AOP*\nAOP：Aspect Oriented Programming 面向切面编程\nAOP可以说是OOP（Object Oriented\nProgramming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross\ncutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\nAOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。\n使用AOP，可以在不修改原来代码的基础上添加新功能。\n*AOP思想主要的应用场景*\nAOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：\n\n日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。\n事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。\n安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。\n性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。\n异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。\n缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。\n动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。\n综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。\n\n*AOP术语名词介绍*\n1-横切关注点\n从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。\n这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。\nAOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。\n2-通知(增强)\n每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。\n\n前置通知：在被代理的目标方法前执行\n返回通知：在被代理的目标方法成功结束后执行（*寿终正寝*）\n异常通知：在被代理的目标方法异常结束后执行（*死于非命*）\n后置通知：在被代理的目标方法最终结束后执行（*盖棺定论*）\n环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n3-连接点 joinpoint\n这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring\n中，可以被动态代理拦截目标类的方法 4-切入点 pointcut\n定位连接点的方式，或者可以理解成被选中的连接点！\n是一个表达式，比如execution(*\ncom.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点。\n5-切面 aspect 切入点和通知的结合。是一个类。 6-目标 target\n被代理的目标对象。 7-代理 proxy\n向目标对象应用通知之后创建的代理对象。\n8-织入 weave\n指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。\n\n5.4 Spring\nAOP框架介绍和关系梳理\n\nAOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！\n代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！\nSpring\nAOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！\n\n5.5 Spring\nAOP基于注解方式实现和细节\n5.5.1 Spring AOP底层技术组成\n\n动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。\ncglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。\nAspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。\n\n5.5.2 初步实现\n\n加入依赖\n&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;    &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;\n准备接口\npublic interface Calculator {        int add(int i, int j);        int sub(int i, int j);        int mul(int i, int j);        int div(int i, int j);    }\n纯净实现类\n/** * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能! */@Componentpublic class CalculatorPureImpl implements Calculator {        @Override    public int add(int i, int j) {            int result = i + j;            return result;    }        @Override    public int sub(int i, int j) {            int result = i - j;            return result;    }        @Override    public int mul(int i, int j) {            int result = i * j;            return result;    }        @Override    public int div(int i, int j) {            int result = i / j;            return result;    }}\n声明切面类\npackage com.atguigu.advice;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect {            // @Before注解：声明当前方法是前置通知方法    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上    @Before(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")    public void printLogBeforeCore() {        System.out.println(\"[AOP前置通知] 方法开始了\");    }        @AfterReturning(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")    public void printLogAfterSuccess() {        System.out.println(\"[AOP返回通知] 方法成功返回了\");    }        @AfterThrowing(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")    public void printLogAfterException() {        System.out.println(\"[AOP异常通知] 方法抛异常了\");    }        @After(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")    public void printLogFinallyEnd() {        System.out.println(\"[AOP后置通知] 方法最终结束了\");    }    }\n开启aspectj注解支持\n\nxml方式\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"       xmlns:context=\"http://www.springframework.org/schema/context\"       xmlns:aop=\"http://www.springframework.org/schema/aop\"       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;    &lt;!-- 进行包扫描--&gt;    &lt;context:component-scan base-package=\"com.atguigu\" /&gt;    &lt;!-- 开启aspectj框架注解支持--&gt;    &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt;\n配置类方式\n@Configuration@ComponentScan(basePackages = \"com.atguigu\")//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!@EnableAspectJAutoProxypublic class MyConfig {}\n\n测试效果\n//@SpringJUnitConfig(locations = \"classpath:spring-aop.xml\")@SpringJUnitConfig(value = {MyConfig.class})public class AopTest {    @Autowired    private Calculator calculator;    @Test    public void testCalculator(){        calculator.add(1,1);    }}\n\n输出结果：\n[AOP前置通知] 方法开始了[AOP返回通知] 方法成功返回了[AOP后置通知] 方法最终结束了\n5.5.3 获取通知细节信息\n\n*JointPoint接口*\n需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。\n\n要点1：JoinPoint 接口通过 getSignature()\n方法获取目标方法的签名（方法声明时的完整信息）\n要点2：通过目标方法签名对象获取方法名\n要点3：通过 JoinPoint\n对象获取外界调用目标方法时传入的实参列表组成的数组\n\n// @Before注解标记前置通知方法// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表@Before(value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\")public void printLogBeforeCore(JoinPoint joinPoint) {        // 1.通过JoinPoint对象获取目标方法签名对象    // 方法的签名：一个方法的全部声明信息    Signature signature = joinPoint.getSignature();        // 2.通过方法的签名对象获取目标方法的详细信息    String methodName = signature.getName();    System.out.println(\"methodName = \" + methodName);        int modifiers = signature.getModifiers();    System.out.println(\"modifiers = \" + modifiers);        String declaringTypeName = signature.getDeclaringTypeName();    System.out.println(\"declaringTypeName = \" + declaringTypeName);        // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表    Object[] args = joinPoint.getArgs();        // 4.由于数组直接打印看不到具体数据，所以转换为List集合    List&lt;Object&gt; argList = Arrays.asList(args);        System.out.println(\"[AOP前置通知] \" + methodName + \"方法开始了，参数列表：\" + argList);}\n*方法返回值*\n在返回通知中，通过 *@AfterReturning*注解的returning属性获取目标方法的返回值！\n// @AfterReturning注解标记返回通知方法// 在返回通知中获取目标方法返回值分两步：// 第一步：在@AfterReturning注解中通过returning属性设置一个名称// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参@AfterReturning(        value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\",        returning = \"targetMethodReturnValue\")public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) {        String methodName = joinPoint.getSignature().getName();        System.out.println(\"[AOP返回通知] \"+methodName+\"方法成功结束了，返回值是：\" + targetMethodReturnValue);}\n*异常对象捕捉*\n在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象\n// @AfterThrowing注解标记异常通知方法// 在异常通知中获取目标方法抛出的异常分两步：// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们@AfterThrowing(        value = \"execution(public int com.atguigu.aop.api.Calculator.add(int,int))\",        throwing = \"targetMethodException\")public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) {        String methodName = joinPoint.getSignature().getName();        System.out.println(\"[AOP异常通知] \"+methodName+\"方法抛异常了，异常类型是：\" + targetMethodException.getClass().getName());}\n\n5.5.4 切点表达式语法\n\n*切点表达式作用*\nAOP切点表达式（Pointcut\nExpression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。\n*切点表达式语法*\n切点表达式总结\n语法细节\n\n第一位：execution( ) 固定开头\n第二位：方法访问修饰符\npublic private 直接描述对应修饰符即可\n第三位：方法返回值\nint String void 直接描述返回值类型\n\n\n特殊情况 不考虑 访问修饰符和返回值（要么都考虑，要么都不考虑）\nexecution(*)\n\n第四位：指定包的地址\n    固定的包: com.atguigu.api | service | dao单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名    任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!注意: ..不能用作包开头   public int .. 错误语法    找到任何包下: *..\n\n第五位：指定类名称\n固定名称: UserService任意类名: *部分任意: com..service.impl.*Impl任意包任意类: *..*\n第六位：指定方法名称\n语法和类名一致任意访问修饰符,任意类的任意方法: * *..*.*\n\n    \n第七位：方法参数\n​```java具体值: (String,int) != (int,String) 没有参数 ()\n模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊:\n第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String)\n字符串开头,int结尾 (String..int) 包含int类型(..int..) ```\n\n\n*切点表达式案例*\n1.查询com.org包dao类下，访问修饰符是公有，返回值是int的全部方法     public int com.org.dao.*(..)2.查询com.org包下类中第一个参数是String的方法    * com.org.*.*(String..)3.查询全部包下，无参数的方法！    * *..*.*()4.查询com包下，以int参数类型结尾的方法    * com..*.*(..int)5.查询com.org包下，Service开头类的私有返回值int的无参数方法    private int com.org.Service*.*()\n\n5.5.5 重用（提取）切点表达式\n\n重用切点表达式优点\n// @Before注解：声明当前方法是前置通知方法// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上@Before(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")public void printLogBeforeCore() {    System.out.println(\"[AOP前置通知] 方法开始了\");}@AfterReturning(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")public void printLogAfterSuccess() {    System.out.println(\"[AOP返回通知] 方法成功返回了\");}@AfterThrowing(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")public void printLogAfterException() {    System.out.println(\"[AOP异常通知] 方法抛异常了\");}@After(value = \"execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))\")public void printLogFinallyEnd() {    System.out.println(\"[AOP后置通知] 方法最终结束了\");}\n上面案例，是我们之前编写切点表达式的方式，发现，\n所有增强方法的切点表达式相同！\n出现了冗余，如果需要切换也不方便统一维护！\n我们可以将切点提取，在增强上进行引用即可！\n同一类内部引用\n提取\n// 切入点表达式重用@Pointcut(\"execution(public int com.atguigu.aop.api.Calculator.add(int,int)))\")public void declarPointCut() {}\n注意：提取切点注解使用@Pointcut(切点表达式) ，\n需要添加到一个无参数无返回值方法上即可！\n引用\n@Before(value = \"declarPointCut()\")public void printLogBeforeCoreOperation(JoinPoint joinPoint) {\n不同类中引用\n不同类在引用切点，只需要添加类的全限定符+方法名即可！\n@Before(value = \"com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()\")public Object roundAdvice(ProceedingJoinPoint joinPoint) {\n切点统一管理\n建议：将切点表达式统一存储到一个类中进行集中管理和维护！\n@Componentpublic class AtguiguPointCut {    @Pointcut(value = \"execution(public int *..Calculator.sub(int,int))\")    public void atguiguGlobalPointCut(){}    @Pointcut(value = \"execution(public int *..Calculator.add(int,int))\")    public void atguiguSecondPointCut(){}    @Pointcut(value = \"execution(* *..*Service.*(..))\")    public void transactionPointCut(){}}\n\n5.5.6 环绕通知\n环绕通知对应整个 try…catch…finally\n结构，包括前面四种通知的所有功能。\n// 使用@Around注解标明环绕通知方法@Around(value = \"com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()\")public Object manageTransaction(        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，        // Spring会将这个类型的对象传给我们        ProceedingJoinPoint joinPoint) {        // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组    Object[] args = joinPoint.getArgs();    // 通过ProceedingJoinPoint对象获取目标方法的签名对象    Signature signature = joinPoint.getSignature();    // 通过签名对象获取目标方法的方法名    String methodName = signature.getName();    // 声明变量用来存储目标方法的返回值    Object targetMethodReturnValue = null;    try {        // 在目标方法执行前：开启事务（模拟）        log.debug(\"[AOP 环绕通知] 开启事务，方法名：\" + methodName + \"，参数列表：\" + Arrays.asList(args));        // 过ProceedingJoinPoint对象调用目标方法        // 目标方法的返回值一定要返回给外界调用者        targetMethodReturnValue = joinPoint.proceed(args);        // 在目标方法成功返回后：提交事务（模拟）        log.debug(\"[AOP 环绕通知] 提交事务，方法名：\" + methodName + \"，方法返回值：\" + targetMethodReturnValue);    }catch (Throwable e){        // 在目标方法抛异常后：回滚事务（模拟）        log.debug(\"[AOP 环绕通知] 回滚事务，方法名：\" + methodName + \"，异常：\" + e.getClass().getName());    }finally {        // 在目标方法最终结束后：释放数据库连接        log.debug(\"[AOP 环绕通知] 释放数据库连接，方法名：\" + methodName);    }    return targetMethodReturnValue;}\n5.5.7 切面优先级设置\n相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。\n\n优先级高的切面：外面\n优先级低的切面：里面\n\n使用 @Order\n注解可以控制切面的优先级：\n\n@Order(较小的数)：优先级高\n@Order(较大的数)：优先级低\n\n实际意义\n实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。\n此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。\n5.5.8 CGLib动态代理生效\n在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试：\n@Servicepublic class EmployeeService {    public void getEmpList() {       System.out.print(\"方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList\");    }}\n测试：\n@Autowiredprivate EmployeeService employeeService;@Testpublic void testNoInterfaceProxy() {    employeeService.getEmpList();}\n没有接口：\n有接口：\n使用总结：\n​ a. 如果目标类有接口,选择使用jdk动态代理\n​ b. 如果目标类没有接口,选择cglib动态代理\n​ c. 如果有接口,接口接值\n​ d. 如果没有接口,类进行接值\n5.5.9 注解实现小结\n5.6 Spring\nAOP基于XML方式实现(了解)\n\n准备工作\n加入依赖\n和基于注解的 AOP 时一样。\n准备代码\n把测试基于注解功能时的Java类复制到新module中，去除所有注解。\n配置Spring配置文件\n&lt;!-- 配置目标类的bean --&gt;&lt;bean id=\"calculatorPure\" class=\"com.atguigu.aop.imp.CalculatorPureImpl\"/&gt;    &lt;!-- 配置切面类的bean --&gt;&lt;bean id=\"logAspect\" class=\"com.atguigu.aop.aspect.LogAspect\"/&gt;    &lt;!-- 配置AOP --&gt;&lt;aop:config&gt;        &lt;!-- 配置切入点表达式 --&gt;    &lt;aop:pointcut id=\"logPointCut\" expression=\"execution(* *..*.*(..))\"/&gt;        &lt;!-- aop:aspect标签：配置切面 --&gt;    &lt;!-- ref属性：关联切面类的bean --&gt;    &lt;aop:aspect ref=\"logAspect\" order=\"5\"&gt;        &lt;!-- aop:before标签：配置前置通知 --&gt;        &lt;!-- method属性：指定前置通知的方法名 --&gt;        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;        &lt;aop:before method=\"printLogBeforeCore\" pointcut-ref=\"logPointCut\"/&gt;            &lt;!-- aop:after-returning标签：配置返回通知 --&gt;        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;        &lt;aop:after-returning                method=\"printLogAfterCoreSuccess\"                pointcut-ref=\"logPointCut\"                returning=\"targetMethodReturnValue\"/&gt;            &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;        &lt;aop:after-throwing                method=\"printLogAfterCoreException\"                pointcut-ref=\"logPointCut\"                throwing=\"targetMethodException\"/&gt;            &lt;!-- aop:after标签：配置后置通知 --&gt;        &lt;aop:after method=\"printLogCoreFinallyEnd\" pointcut-ref=\"logPointCut\"/&gt;            &lt;!-- aop:around标签：配置环绕通知 --&gt;        &lt;!--&lt;aop:around method=\"……\" pointcut-ref=\"logPointCut\"/&gt;--&gt;    &lt;/aop:aspect&gt;    &lt;/aop:config&gt;\n测试\n@SpringJUnitConfig(locations = \"classpath:spring-aop.xml\")public class AopTest {    @Autowired    private Calculator calculator;    @Test    public void testCalculator(){        System.out.println(calculator);        calculator.add(1,1);    }}\n\n5.7 Spring\nAOP对获取Bean的影响理解\n5.7.1 根据类型装配 bean\n\n情景一\n\nbean 对应的类没有实现任何接口\n根据 bean 本身的类型获取 bean\n\n测试：IOC容器中同类型的 bean 只有一个\n正常获取到 IOC 容器中的那个 bean 对象\n测试：IOC 容器中同类型的 bean 有多个\n会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC\n容器中这个类型的 bean 有多个\n\n\n情景二\n\nbean 对应的类实现了接口，这个接口也只有这一个实现类\n\n测试：根据接口类型获取 bean\n测试：根据类获取 bean\n结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象\n\n\n情景三\n\n声明一个接口\n接口有多个实现类\n接口所有实现类都放入 IOC 容器\n\n测试：根据接口类型获取 bean\n会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC\n容器中这个类型的 bean 有多个\n测试：根据类获取bean\n正常\n\n\n情景四\n\n声明一个接口\n接口有一个实现类\n创建一个切面类，对上面接口的实现类应用通知\n\n测试：根据接口类型获取bean\n正常\n测试：根据类获取bean\n无法获取\n\n\n原因分析：\n\n应用了切面后，真正放在IOC容器中的是代理类的对象\n目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的\n\n情景五\n\n声明一个类\n创建一个切面类，对上面的类应用通知\n\n测试：根据类获取 bean，能获取到 debug查看实际类型：\n\n\n\n5.7.2 使用总结\n对实现了接口的类应用切面\n\n\nimg\n\n对没实现接口的类应用切面\n\n\nimg\n\n如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！\n六、Spring 声明式事务\n6.1 声明式事务概念\n6.1.1 编程式事务\n编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在\nJava 中，通常使用事务管理器(如 Spring 中的\nPlatformTransactionManager)来实现编程式事务。\n编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。\nConnection conn = ...;  try {    // 开启事务：关闭事务的自动提交    conn.setAutoCommit(false);    // 核心操作    // 业务代码    // 提交事务    conn.commit();  }catch(Exception e){      // 回滚事务    conn.rollBack();  }finally{      // 释放数据库连接    conn.close();  }\n编程式的实现方式存在缺陷：\n\n细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。\n代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。\n\n6.1.2 声明式事务\n声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。\n开发者只需要添加配置即可，\n具体事务的实现由第三方框架实现，避免我们直接进行事务操作！\n使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。\n区别：\n\n编程式事务需要手动编写代码来管理事务\n而声明式事务可以通过配置文件或注解来控制事务。\n\n6.1.3 Spring事务管理器\n\nSpring声明式事务对应依赖\n\nspring-tx:\n包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）\nspring-jdbc:\n包含DataSource方式事务管理器实现类DataSourceTransactionManager\nspring-orm:\n包含其他持久层框架的事务管理器实现类例如：Hibernate/Jpa等\n\nSpring声明式事务对应事务管理器接口\n\n\nimg\n\n我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合\nJDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！\nDataSourceTransactionManager类中的主要方法：\n\ndoBegin()：开启事务\ndoSuspend()：挂起事务\ndoResume()：恢复挂起的事务\ndoCommit()：提交事务\ndoRollback()：回滚事务\n\n\n6.2 基于注解的声明式事务\n6.2.1 准备工作\n\n准备项目\n&lt;dependencies&gt;    &lt;!--spring context依赖--&gt;    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--junit5测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;        &lt;version&gt;5.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;        &lt;version&gt;2.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 数据库驱动 和 连接池--&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;8.0.25&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.2.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring-jdbc --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 声明式事务依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n外部配置文件\njdbc.properties\natguigu.url=jdbc:mysql://localhost:3306/studbatguigu.driver=com.mysql.cj.jdbc.Driveratguigu.username=rootatguigu.password=root\nspring配置文件\n@Configuration@ComponentScan(\"com.atguigu\")@PropertySource(\"classpath:jdbc.properties\")public class JavaConfig {    @Value(\"${atguigu.driver}\")    private String driver;    @Value(\"${atguigu.url}\")    private String url;    @Value(\"${atguigu.username}\")    private String username;    @Value(\"${atguigu.password}\")    private String password;    //druid连接池    @Bean    public DataSource dataSource(){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driver);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    }    @Bean    //jdbcTemplate    public JdbcTemplate jdbcTemplate(DataSource dataSource){        JdbcTemplate jdbcTemplate = new JdbcTemplate();        jdbcTemplate.setDataSource(dataSource);        return jdbcTemplate;    }}\n准备dao/service层\ndao\n@Repositorypublic class StudentDao {        @Autowired    private JdbcTemplate jdbcTemplate;        public void updateNameById(String name,Integer id){        String sql = \"update students set name = ? where id = ? ;\";        int rows = jdbcTemplate.update(sql, name, id);    }    public void updateAgeById(Integer age,Integer id){        String sql = \"update students set age = ? where id = ? ;\";        jdbcTemplate.update(sql,age,id);    }}\nservice\n@Servicepublic class StudentService {        @Autowired    private StudentDao studentDao;        public void changeInfo(){        studentDao.updateAgeById(100,1);        System.out.println(\"-----------\");        studentDao.updateNameById(\"test1\",1);    }}\n测试环境搭建\n/** * projectName: com.atguigu.test * * description: */@SpringJUnitConfig(JavaConfig.class)public class TxTest {    @Autowired    private StudentService studentService;    @Test    public void  testTx(){        studentService.changeInfo();    }}\n\n6.2.2 基本事务控制\n\n配置事务管理器\n数据库相关的配置\n/** * projectName: com.atguigu.config * * description: 数据库和连接池配置类 */@Configuration@ComponenScan(\"com.atguigu\")@PropertySource(value = \"classpath:jdbc.properties\")@EnableTransactionManagementpublic class DataSourceConfig {    /**     * 实例化dataSource加入到ioc容器     * @param url     * @param driver     * @param username     * @param password     * @return     */    @Bean    public DataSource dataSource(@Value(\"${atguigu.url}\")String url,                                 @Value(\"${atguigu.driver}\")String driver,                                 @Value(\"${atguigu.username}\")String username,                                 @Value(\"${atguigu.password}\")String password){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driver);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    }    /**     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource     * @param dataSource     * @return     */    @Bean    public JdbcTemplate jdbcTemplate(DataSource dataSource){        JdbcTemplate jdbcTemplate = new JdbcTemplate();        jdbcTemplate.setDataSource(dataSource);        return jdbcTemplate;    }        /**     * 装配事务管理实现对象     * @param dataSource     * @return     */    @Bean    public TransactionManager transactionManager(DataSource dataSource){        return new DataSourceTransactionManager(dataSource);    }}\n使用声明事务注解@Transactional\n/** * projectName: com.atguigu.service * */@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    @Transactional    public void changeInfo(){        studentDao.updateAgeById(100,1);        System.out.println(\"-----------\");        int i = 1/0;        studentDao.updateNameById(\"test1\",1);    }}\n测试事务效果\n/** * projectName: com.atguigu.test * * description: *///@SpringJUnitConfig(locations = \"classpath:application.xml\")@SpringJUnitConfig(classes = DataSourceConfig.class)public class TxTest {    @Autowired    private StudentService studentService;    @Test    public void  testTx(){        studentService.changeInfo();    }}\n\n6.2.3 事务属性：只读\n\n只读介绍\n对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。\n设置方式\n// readOnly = true把当前事务设置为只读 默认是false!@Transactional(readOnly = true)\n针对DML动作设置只读模式\n会抛出下面异常：\nCaused by: java.sql.SQLException: Connection is read-only. Queries\nleading to data modification are not allowed\n@Transactional注解放在类上\n\n生效原则\n如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将\n@Transactional\n注解提取到类上。反过来说：@Transactional\n注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional\n注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了\n@Transactional\n注解。\n*对一个方法来说，离它最近的 @Transactional\n注解中的事务属性设置生效。*\n用法举例\n在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。\n然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为\nfalse。\n\n@Service@Transactional(readOnly = true)public class EmpService {        // 为了便于核对数据库操作结果，不要修改同一条记录    @Transactional(readOnly = false)    public void updateTwice(……) {    ……    }        // readOnly = true把当前事务设置为只读    // @Transactional(readOnly = true)    public String getEmpName(Integer empId) {    ……    }    }\n\n6.2.4 事务属性：超时时间\n\n需求\n事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。\n此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。\n概括来说就是一句话：超时回滚，释放资源。\n设置超时时间\n@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    /**     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!     */    @Transactional(readOnly = false,timeout = 3)    public void changeInfo(){        studentDao.updateAgeById(100,1);        //休眠4秒,等待方法超时!        try {            Thread.sleep(4000);        } catch (InterruptedException e) {            throw new RuntimeException(e);        }        studentDao.updateNameById(\"test1\",1);    }}\n测试超时效果\n执行抛出事务超时异常\n\n6.2.5 事务属性：事务异常\n\n默认情况\n默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：\n@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    /**     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!     */    @Transactional(readOnly = false,timeout = 3)    public void changeInfo() throws FileNotFoundException {        studentDao.updateAgeById(100,1);        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!         new FileInputStream(\"xxxx\");        studentDao.updateNameById(\"test1\",1);    }}\n设置回滚异常\nrollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and\nError 异常方可回滚!\n/** * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间! * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚! * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内! */@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)public void changeInfo() throws FileNotFoundException {    studentDao.updateAgeById(100,1);    //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!     new FileInputStream(\"xxxx\");     studentDao.updateNameById(\"test1\",1);}\n设置不回滚的异常\n在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。\nnoRollbackFor属性：指定哪些异常不会回滚,\n默认没有指定,如果指定,应该在rollbackFor的范围内!\n@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    /**     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!     */    @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)    public void changeInfo() throws FileNotFoundException {        studentDao.updateAgeById(100,1);        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!        new FileInputStream(\"xxxx\");        studentDao.updateNameById(\"test1\",1);    }}\n\n6.2.6 事务属性：事务隔离级别\n\n事务隔离级别\n数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：\n\n读未提交（Read\nUncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。\n读已提交（Read\nCommitted）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。\n可重复读（Repeatable\nRead）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。\n串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。\n不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。\n\n事务隔离级别设置\npackage com.atguigu.service;import com.atguigu.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Transactional;import java.io.FileInputStream;import java.io.FileNotFoundException;/** * projectName: com.atguigu.service */@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    /**     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!     */    @Transactional(readOnly = false,                   timeout = 3,                   rollbackFor = Exception.class,                   noRollbackFor = FileNotFoundException.class,                   isolation = Isolation.REPEATABLE_READ)    public void changeInfo() throws FileNotFoundException {        studentDao.updateAgeById(100,1);        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!        new FileInputStream(\"xxxx\");        studentDao.updateNameById(\"test1\",1);    }}\n\n6.2.7 事务属性：事务传播行为\n\n事务传播行为要研究的问题\n举例代码：\n@Transactionalpublic void MethodA(){    // ...    MethodB();    // ...}//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！@Transactional(propagation = Propagation.REQUIRES_NEW)public void MethodB(){    // ...}\npropagation属性\n@Transactional 注解通过 propagation\n属性设置事务的传播行为。它的默认值是：\nPropagation propagation() default Propagation.REQUIRED;\n\npropagation 属性的可选值由\norg.springframework.transaction.annotation.Propagation 枚举类提供：\n\n\n\n\n\n\n\n名称\n含义\n\n\n\n\nREQUIRED 默认值\n如果父方法有事务，就加入，如果没有就新建自己独立！\n\n\nREQUIRES_NEW\n不管父方法是否有事务，我都新建事务，都是独立的！\n\n\n\n\n测试\n\n声明两个业务方法\n@Servicepublic class StudentService {    @Autowired    private StudentDao studentDao;    /**     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!     */    @Transactional(readOnly = false,                   timeout = 3,                   rollbackFor = Exception.class,                   noRollbackFor = FileNotFoundException.class,                   isolation = Isolation.REPEATABLE_READ)    public void changeInfo() throws FileNotFoundException {        studentDao.updateAgeById(100,1);        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!        new FileInputStream(\"xxxx\");        studentDao.updateNameById(\"test1\",1);    }        /**     * 声明两个独立修改数据库的事务业务方法     */    @Transactional(propagation = Propagation.REQUIRED)    public void changeAge(){        studentDao.updateAgeById(99,1);    }    @Transactional(propagation = Propagation.REQUIRED)    public void changeName(){        studentDao.updateNameById(\"test2\",1);        int i = 1/0;    }}\n声明一个整合业务方法\n@Servicepublic class TopService {    @Autowired    private StudentService studentService;    @Transactional    public void  topService(){        studentService.changeAge();        studentService.changeName();    }}\n添加传播行为测试\n@SpringJUnitConfig(classes = AppConfig.class)public class TxTest {    @Autowired    private StudentService studentService;    @Autowired    private TopService topService;    @Test    public void  testTx() throws FileNotFoundException {        topService.topService();    }}\n*注意：*\n\n在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。\n其他传播行为值（了解）\n\nPropagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。\nPropagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。\nPropagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。\nPropagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。\nPropagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。\nPropagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。\nPropagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。\n\n\n七、Spring核心掌握总结\n\n\n\n核心点\n掌握目标\n\n\n\n\nspring框架理解\nspring家族和spring framework框架\n\n\nspring核心功能\nioc/di , aop , tx\n\n\nspring ioc / di\n组件管理、ioc容器、ioc/di , 三种配置方式\n\n\nspring aop\naop和aop框架和代理技术、基于注解的aop配置\n\n\n核心点\n掌握目标\n\n\nspring tx\n声明式和编程式事务、动态事务管理器、事务注解、属性\n\n\n\n","categories":["后端","Spring"],"tags":["IoC","AOP","TX"]},{"title":"数据库索引","url":"/2024/06/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/","content":"索引是加速数据库查询操作的数据结构，类似于书本的目录。合理使用索引能显著提升查询效率，但也可能带来写入性能下降和存储空间增加的问题。MySQL\n默认使用 B+\n树作为主要索引结构，因其高效的范围查询和有序性而广泛应用，此外还有哈希索引、全文索引等多种结构，分别适用于不同的使用场景。\n\n1. 为什么使用索引\n索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL\n中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。\n如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从\n1 到 6 行按顺序读取，这样就相当于进行了 6 次 IO\n操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找\nCol 2 = 89 这条记录，就要逐行去查找、去比较。从 Col 2 = 34\n开始，进行比较，发现不是，继续下一行。我们当前的表只有不到 10\n行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次硬盘I/0才能找到。现在要查找\nCol 2 = 89 这条记录。CPU\n必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘\nI/O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)）\n假如给数据使用 二叉树\n这样的数据结构进行存储，如下图所示\n对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2\n维护了一个索引的数据结构，即这个\n二叉搜索树。二叉搜索树的每个结点存储的是\n(K, V) 结构，key 是 Col 2，value 是该 key\n所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：(34, 0x07)。现在对\nCol 2 添加了索引，这时再去查找 Col 2 = 89\n这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34\n到内存，89 &gt; 34; 继续右侧数据，读 89\n到内存，89==89；找到数据返回。找到之后就根据当前结点的 value\n快速定位到要查找的记录对应的地址。我们可以发现，只需要\n查找两次 就可以定位到记录的地址，查询速度就提高了。\n这就是我们为什么要建索引，目的就是为了\n减少磁盘I/O的次数，加快查询速率。\n2. 索引及其优缺点\n2.1 索引概述\nMySQL 官方对索引的定义为：索引（Index）是帮助 MySQL\n高效获取数据的数据结构。\n索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。\n这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现\n高级查找算法 。\n索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的\n最大索引数和\n最大索引长度。所有存储引擎支持每个表至多 16\n个索引，总索引长度至多为 256\n字节。有些存储引擎支持更多的索引数和更大的索引长度。\n2.2 优点\n（1）类似大学图书馆建书目索引，提高数据检索的效率，降低\n数据库的 IO 成本 ，这也是创建索引最主要的原因。\n（2）通过创建唯一索引，可以保证数据库表中每一行\n数据的唯一性 。\n（3）在实现数据的 参考完整性方面，可以\n加速表和表之间的连接\n。换句话说，对于有依赖关系的子表和父表联合查询时，\n可以提高查询速度。\n（4）在使用分组和排序子句进行数据查询时，可以显著\n减少查询中分组和排序的时间 ，降低了 CPU 的消耗。\n2.3 缺点\n增加索引也有许多不利的方面，主要表现在如下几个方面：\n（1）创建索引和维护索引要 耗费时间 ，并\n且随着数据量的增加，所耗费的时间也会增加。\n（2）索引需要占 磁盘空间 ，除了数据表占数据空间之\n外，每一个索引还要占一定的物理空间， 存储在磁盘上\n，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。\n（3）虽然索引大大提高了查询速度，同时却会\n降低更新表的速度\n。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。\n因此，选择使用索引时，需要综合考虑索引的优点和缺点。\n因此，选择使用索引时，需要综合考虑索引的优点和缺点。\n\n提示：\n索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。\n\n3. InnoDB 中索引的推演\n3.1 索引之前的查找\n先来看一个精确匹配的例子：\nSELECT [列名列表] FROM 表名 WHERE 列名 = xxx;\n1. 在一个页中的查找\n假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：\n\n以主键为搜索条件\n可以在页目录中使用 二分法\n快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。\n以其他列作为搜索条件\n因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从\n最小记录 开始 依次遍历单链表中的每条记录，\n然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。\n\n2. 在很多页中查找\n在很多页中查找记录的活动可以分为两个步骤：\n\n定位到记录所在的页。\n从所在的页内中查找相应的记录。\n\n在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表\n一直往下找，在每一个页中根据我们上面的查找方式去查\n找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时\n的。如果一个表有一亿条记录呢？此时 索引 应运而生。\n3.2 设计索引\n建一个表：\nmysql&gt; CREATE TABLE index_demo(-&gt; c1 INT,-&gt; c2 INT,-&gt; c3 CHAR(1),-&gt; PRIMARY KEY(c1)-&gt; ) ROW_FORMAT = Compact;\n这个新建的 index_demo 表中有 2 个 INT 类型的列，1 个\nCHAR(1)类型的列，而且我们规定了 c1 列为主键， 这个表使用\nCompact 行格式来实际存储记录的。这里我们简化了\nindex_demo 表的行格式示意图：\n我们只在示意图里展示记录的这几个部分：\n\nrecord_type ：记录头信息的一项属性，表示记录的类型， 0\n表示普通记录、 2 表示最小记录、 3 表示最大记录、 1\n暂时还用不着，下面讲。\nnext_record\n：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用\n箭头来表明下一条记录是谁。\n各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2\n和 c3 。\n其他信息 ：除了上述 3\n种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。\n\n将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：\n把一些记录放到页里的示意图就是：\n1. 一个简单的索引设计方案\n我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们\n想快速的定位到需要查找的记录在哪些数据页\n中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录\n，建这个目录必须完成下边这些事：\n\n下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。\n假设：每个数据结构最多能存放 3\n条记录（实际上一个数据页非常大，可以存放下好多记录）。\nINSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');\n那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示：\n\nINSERT INTO index_demo VALUES(4, 4, 'a');\n因为 页 10 最多只能放 3\n条记录，所以我们不得不再分配一个新页：\n注意：新分配的\n数据页编号可能并不是连续的。它们只是通过维护者上一个页和下一个页的编号而建立了\n链表 关系。另外，页\n10中用户记录最大的主键值是 5，而页\n28中有一条记录的主键值是 4，因为\n5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为\n4 的记录的时候需要伴随着一次 记录移动，也就是把主键值为\n5 的记录移动到页 28 中，然后再把主键值为 4 的记录插入到页 10 中。\n这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如\n记录移动\n的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为\n页分裂。\n\n给所有的页建立一个目录项。\n\n由于数据页的 编号可能是不连续 的，所以在向\nindex_demo 表中插入许多条记录后，可能是这样的效果：\n我们需要给它们做个\n目录，每个页对应一个目录项，每个目录项包括下边两个部分：\n1）页的用户记录中最小的主键值，我们用 key\n来表示。\n2）页号，我们用 page_on 表示。\n以 页 28 为例，它对应 目录项 2 ，这个目录项中包含着该页的页号 28\n以及该页中用户记录的最小主 键值 5\n。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键\n值快速查找某条记录的功能了。比如：查找主键值为 20\n的记录，具体查找过程分两步：\n\n先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项 3\n中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页 9 。\n再根据前边说的在页中查找记录的方式去 页 9 中定位具体的记录。\n\n至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为\n索引 。\n2. InnoDB 中的索引方案\n① 迭代 1 次：目录项纪录的页\nInnoDB 怎么区分一条记录是普通的 用户记录 还是\n目录项记录 呢？使用记录头信息里的\nrecord_type 属性，它的各自取值代表的意思如下：\n\n0：普通的用户记录\n1：目录项记录\n2：最小记录\n3：最大记录\n\n我们把前边使用到的目录项放到数据页中的样子就是这样：\n从图中可以看出来，我们新分配了一个编号为 30\n的页来专门存储目录项记录。这里再次强调 目录项记录\n和普通的 用户记录 的不同点：\n\n目录项记录 的 record_type 值是 1，而\n普通用户记录 的 record_type 值是 0。\n目录项记录只有 主键值和页的编号\n两个列，而普通的用户记录的列是用户自己定义的，可能包含\n很多列 ，另外还有 InnoDB 自己添加的隐藏列。\n了解：记录头信息里还有一个叫 min_rec_mask\n的属性，只有在存储 目录项记录 的页中的主键值最小的\n目录项记录 的 min_rec_mask 值为\n1 ，其他别的记录的 min_rec_mask 值都是\n0 。\n\n相同点：两者用的是一样的数据页，都会为主键值生成\nPage Directory\n（页目录），从而在按照主键值进行查找时可以使用\n二分法 来加快查询速度。\n\n原始页中数据是链表存储，不好随机访问。\n页目录相当于一个数组，支持随机访问，方便二分。\n\n现在以查找主键为 20\n的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：\n\n先到存储 目录项记录 的页，也就是页 30 中通过 二分法\n快速定位到对应目录项，因为 12 &lt; 20 &lt; 209\n，所以定位到对应的记录所在的页就是页 9。\n再到存储用户记录的页 9 中根据 二分法 快速定位到主键值为 20\n的用户记录。\n\n② 迭代 2\n次：多个目录项纪录的页\n从图中可以看出，我们插入了一条主键值为 320\n的用户记录之后需要两个新的数据页：\n\n为存储该用户记录而新生成了 页 31 。\n因为原先存储目录项记录的 页 30 的容量已满 （我们前边假设只能存储 4\n条目录项记录），所以不得不需要一个新的 页 32 来存放 页 31\n对应的目录项。\n\n现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要\n3 个步骤，以查找主键值为 20 的记录为例：\n\n确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页 30 和 页\n32 ，又因为页 30 表示的目录项的主键值的 范围是 [1, 320) ，页 32\n表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目\n录项记录在 页 30 中。\n通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录\n的页中通过主键值定位一条目录项记录的方式说过了。\n在真实存储用户记录的页中定位到具体的记录。\n\n③ 迭代 3\n次：目录项记录页的目录页\n如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子：\n如图，我们生成了一个存储更高级目录项的 页 33\n，这个页中的两条记录分别代表页 30 和页 32，如果用 户记录的主键值在 [1,\n320) 之间，则到页 30 中查找更详细的目录项记录，如果主键值 不小于 320 的\n话，就到页 32 中查找更详细的目录项记录。\n我们可以用下边这个图来描述它：\n这个数据结构，它的名称是 B+树 。\n④ B+Tree\n一个\nB+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第\n0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页\n最多存放 3 条记录 ，存放目录项 记录的页 最多存放 4 条记录\n。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录\n的叶子节点代表的数据页可以存放 100 条用户记录\n，所有存放目录项记录的内节点代表的数据页可以存放 1000\n条目录项记录，那么：\n\n如果 B+树只有 1 层，也就是只有 1\n个用于存放用户记录的节点，最多能存放 100 条记录。\n如果 B+树有 2 层，最多能存放 1000×100=10,0000 条记录。\n如果 B+树有 3 层，最多能存放 1000×1000×100=1,0000,0000 条记录。\n如果 B+树有 4 层，最多能存放 1000×1000×1000×100=1000,0000,0000\n条记录。相当多的记录！\n\n你的表里能存放 100000000000\n条记录吗？所以一般情况下，我们用到的 B+树都不会超过 4\n层 ，那我们通过主键值去查找某条记录最多只需要做 4\n个页面内的查找（查找 3\n个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page\nDirectory （页目录），所以在页面内也可以通过\n二分法 实现快速 定位记录。\n3.3 常见索引概念\n索引按照物理实现方式，索引可以分为 2\n种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集索引称为二级索引或者辅助索引。\n1. 聚簇索引\n聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子结点），也就是所谓的\n索引即数据，数据即索引。\n\n术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起\n\n特点：\n\n使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：\n\n页内 的记录是按照主键的大小顺序排成一个\n单向链表 。\n各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表\n。\n存放 目录项记录的页\n分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个\n双向链表 。\n\nB+树的 叶子节点 存储的是完整的用户记录。\n所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。\n\n我们把具有这两种特性的\nB+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在\nMySQL 语句中显式的使用 INDEX 语句去创建，InnDB 存储引擎会\n自动 的为我们创建聚簇索引。\n优点：\n\n数据访问更快，因为聚簇索引将索引和数据保存在同一个\nB+树中，因此从聚簇索引中获取数据比非聚簇索引更快\n聚簇索引对于主键的 排序查找 和 范围查找\n速度非常快\n按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以\n节省了大量的io操作 。\n\n缺点：\n\n插入速度严重依赖于插入顺序\n，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于\nInnoDB 表，我们一般都会定义一个自增的ID列为主键\n更新主键的代价很高\n，因为将会导致被更新的行移动。因此，对于 InnoDB\n表，我们一般定义主键为不可更新\n二级索引访问需要两次索引查找\n，第一次找到主键值，第二次根据主键值找到行数据\n\n限制:\n\n对于 MySQL 数据库目前只有 InnoDB 数据引擎支持聚簇索引, 而 MyISAM\n并不支持聚簇索引。\n由于数据物理存储排序方式只能有一种，所以每个 MySQL\n的表只能有一个聚簇索引。一般情况下就是该表的主键。\n如果没有定义主键，Innodb\n会选择非空的唯一索引代替。如果没有这样的索引，Innodb\n会隐式的定义一个主键来作为聚簇索引。\n为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量\n选用有序的顺序 id，而不建议用无序的 id，比如\nUUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。\n\n2.\n二级索引（辅助索引、非聚簇索引）\n如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。\n答案：我们可以多建几颗B+树，不同的\nB+树中的数据采用不同的排列规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一课\nB+树。\n这个 B+树与上边介绍的聚簇索引有几处不同：\n\n使用记录 c2 列的大小进行记录和页的排序，这包括三个方面的含义：\n\n页内的记录是按照 c2 列的大小顺序排成一个单向链表。\n各个存放用户记录的页也是根据页中记录的 c2\n列大小顺序排成一个双向链表。\n存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的\nc2 列大小顺序排成一个双向链表。\n\nB+树的叶子节点存储的并不是完整的用户记录，而只是 c2\n列+主键(c1 列)这两个列的值。\n目录项记录中不再是 主键+页号 的搭配，而变成了 c2 列+页号\n的搭配。\n\n我们根据这个以 c2 列大小排序的\nB+树只能确定我们要查找记录的主键值，所以如果我们想根据 c2\n列的值查找到完整的用户记录的话，仍然需要到主键构成的聚簇索引中再查一遍，这个过程称为\n回表。也就是根据 c2 列的值查询一条完整的用户记录需要使用到 2 棵\nB+树！\n问题：为什么我们还需要一次 回表\n操作呢？直接把完整的用户记录放到叶子节点不 OK 吗？\n回答：如果把完整的用户记录放到叶子结点是可以不用回表。但是太占地方了，相当于每建立一课\nB+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。\n因为这种按照非主键列建立的\nB+树需要一次回表操作才可以定位到完整的用户记录，所以这种\nB+树也被称为二级索引，或者辅助索引。由于使用的是 c2\n列的大小作为 B+树的排序规则，所以我们也称这个 B+树为 c2 列的索引。\n非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。\n小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别：\n\n聚簇索引的叶子节点存储的就是我们的数据记录,\n非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。\n一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。\n使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。\n\n3.联合索引\n我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让\nB+树按 照 c2 和 c3 列 的大小进行排序，这个包含两层含义：\n\n先把各个记录和页按照 c2 列进行排序。\n在记录的 c2 列相同的情况下，采用 c3 列进行排序\n\n如图所示，我们需要注意以下几点：\n\n每条目录项都有 c2、c3、页号这三个部分组成，各条记录先按照 c2\n列的值进行排序，如果记录的 c2 列相同，则按照 c3 列的值进行排序\nB+树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成\n\n注意一点，以 c2 和 c3 列的大小为排序规则建立的 B+树称为 联合索引\n，本质上也是一个二级索引。它的意思与分别为 c2 和 c3\n列分别建立索引的表述是不同的，不同点如下：\n\n建立 联合索引 只会建立如上图一样的 1 棵 B+树。\n为 c2 和 c3 列分别建立索引会分别以 c2 和 c3 列的大小为排序规则建立 2\n棵 B+树。\n\n3.4 InnoDB 的\nB+树索引的注意事项\n1. 根页面位置万年不动\n实际上 B+树的形成过程是这样的：\n\n每当为某个表创建一个\nB+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个\n根结点 页面。最开始表中没有数据的时候，每个 B+树索引对应的\n根结点 中即没有用户记录，也没有目录项记录。\n随后向表中插入用户记录时，先把用户记录存储到这个根节点\n中。\n当根节点中的可用 空间用完时\n继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如\n页a 中，然后对这个新页进行 页分裂\n的操作，得到另一个新页，比如页b\n。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到\n页a 或者 页b 中，而 根节点\n便升级为存储目录项记录的页。\n\n这个过程特别注意的是：一个\nB+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是\nInnoDB\n存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。\n2. 内节点中目录项记录的唯一性\n我们知道 B+树索引的内节点中目录项记录的内容是\n索引列 + 页号\n的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo\n表为例，假设这个表中的数据是这样的：\n如果二级索引中目录项记录的内容只是 索引列 + 页号\n的搭配的话，那么为 c2 列简历索引后的 B+树应该长这样：\n如果我们想新插入一行记录，其中 c1 、c2\n、c3 的值分别是:\n9、1、c, 那么在修改这个为 c2\n列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 页3\n中存储的目录项记录是由 c2列 + 页号\n的值构成的，页3 中的两条目录项记录对应的 c2 列的值都是\n1，而我们 新插入的这条记录 的 c2 列的值也是\n1，那我们这条新插入的记录到底应该放在 页4\n中，还是应该放在 页5 中？答案：对不起，懵了\n为了让新插入记录找到自己在那个页面，我们需要保证在\nB+树的同一层页节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：\n\n索引列的值\n主键值\n页号\n\n也就是我们把主键值也添加到二级索引内节点中的目录项记录，这样就能保住\nB+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的。\n这样我们再插入记录(9, 1, 'c') 时，由于 页3\n中存储的目录项记录是由 c2列 + 主键 + 页号\n的值构成的，可以先把新纪录的 c2 列的值和 页3\n中各目录项记录的 c2 列的值作比较，如果 c2\n列的值相同的话，可以接着比较主键值，因为 B+树同一层中不同目录项记录的\nc2列 + 主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到\n页5 中。\n3. 一个页面最少存储 2 条记录\n一个\nB+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为\nB+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以\nInnoDB 的一个数据页至少可以存放两条记录。\n4. MyISAM 中的索引方案\nB 树索引使用存储引擎如表所示：\n\n\n\n索引 / 存储引擎\nMyISAM\nInnoDB\nMemory\n\n\n\n\nB-Tree 索引\n支持\n支持\n支持\n\n\n\n即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb\n和 MyISAM 默认的索引是 Btree 索引；而 Memory 默认的索引是 Hash\n索引。\nMyISAM 引擎使用 B+Tree 作为索引结构，叶子节点的 data\n域存放的是数据记录的地址。\n4.1 MyISAM 索引的原理\n我们知道 InnoDB 中索引即数据，也就是聚簇索引的那棵 B+\n树的叶子节点中已经把所有完整的用户记录都包含了，而 MyISAM\n的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：\n\n将表中的记录\n按照记录的插入顺序单独存储在一个文件中，称之为数据文件(.MYD)。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。\n使用 MyISAM\n存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中(.MYI)。MyISAM\n会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值\n+ 数据记录地址的组合。\n\n4.2 MyISAM 与 InnoDB 对比\nMyISAM 的索引方式都是“非聚簇”的，与 InnoDB 包含 1\n个聚簇索引是不同的。小结两种引擎中索引的区别：\n① 在 InnoDB 存储引擎中，我们只需要根据主键值对\n聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM\n中却需要进行一次 回表 操作，意味着 MyISAM\n中建立的索引相当于全部都是 二级索引。\n② InnoDB 的数据文件本身就是索引文件，而 MyISAM\n索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。\n③ InnoDB 的非聚簇索引 data 域存储相应记录主键的值，而 MyISAM\n索引记录的是地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data\n域。\n④ MyISAM\n的回表操作是十分快速的，因为是拿着地址偏移量直接到文件中取数据的，反观\nInnoDB\n是通过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。\n⑤ InnoDB 要求表 必须有主键（ MyISAM 可以没有 ）。如果没有显式指定，则\nMySQL 系统会自动选择一个\n可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则\nMySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6\n个字节，类型为长整型（Bigint）。\n5. 索引的代价\n索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：\n\n空间上的代价\n每建立一个索引都要为它建立一棵 B+树，每一棵\nB+树的每一个节点都是一个数据页，一个页默认会 占用 16KB\n的存储空间，一棵很大的\nB+树由许多数据页组成，那就是很大的一片存储空间。\n时间上的代价\n每次对表中的数据进行 增、删、改\n操作时，都需要去修改各个\nB+树索引。而且我们讲过，B+树每层节点都是按照索引列的值\n从小到大的顺序排序 而组成了 双向链表\n。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序\n而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需\n要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收\n等操作来维护好节点和记录的排序。如果\n我们建了许多索引，每个索引对应的\nB+树都要进行相关的维护操作，会给性能拖后腿。\n\n\n一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。\n为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。\n\n6. MySQL 数据结构选择的合理性\n从 MySQL 的角度讲，不得不考虑一个现实问题就是磁盘 10\n。如果我们能让索引的数据结构尽量减少硬盘的 1/0\n操作，所消耗的时间也就越小。可以说，磁盘的 I/O\n操作次数对索引的使用效率至关重要。\n查找都是索引操作，一般来说索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个\nG\n甚至更多，为了减少索引在内存的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么\nMySQL 衡量查询效率的标准就是磁盘 I/O 次数。\n6.1 全表查询\n这里都懒得说了。\n6.2 Hash 查询\n加快查找速度的数据结构，常见的有两类：\n\n树，例如平衡二叉搜索树，查询/插入/修改/删除的平均时间复杂度都是\nO(log2N);\n哈希，例如 HashMap，查询/插入/修改/删除的平均时间复杂度都是\nO(1); (key, value)\n\n哈希函数 h 有可能将两个不同的关键字映射到相同的位置，这叫做\n碰撞 ，在数据库中一般采用 链接法\n来解决。在链接法中，将散列到同一槽位的元素放在一个链表中。\n实验：体会数组和 hash 表的查找方面的效率区别\n// 算法复杂度为 O(n)@Testpublic void test1(){    int[] arr = new int[100000];    for(int i = 0;i &lt; arr.length;i++){        arr[i] = i + 1;    }    long start = System.currentTimeMillis();    for(int j = 1; j&lt;=100000;j++){        int temp = j;        for(int i = 0;i &lt; arr.length;i++){            if(temp == arr[i]){                break;            }        }    }    long end = System.currentTimeMillis();    System.out.println(\"time： \" + (end - start)); //time： 823}\n// 算法复杂度为 O(1)@Testpublic void test2(){    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(100000);    for(int i = 0;i &lt; 100000;i++){    \tset.add(i + 1);    }    long start = System.currentTimeMillis();    for(int j = 1; j&lt;=100000;j++) {        int temp = j;        boolean contains = set.contains(temp);    }    long end = System.currentTimeMillis();    System.out.println(\"time： \" + (end - start)); //time： 5}\nHash\n结构效率高，那为什么索引结构要设计成树型呢？\n原因 1：Hash 索引仅能满足 (=) (&lt;&gt;) 和 IN 查询。如果进行\n范围查询，时间复杂度会退化为 O(n) ；而树型的“有序”特性，依然能够保持 O(log2 N) 的高效率。\n原因 2：Hash\n索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY\n的情况下，使用 Hash 索引还需要对数据重新排序。\n原因 3：对于联合索引的情况，Hash\n值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。\n原因 4：对于等值查询来说，通常 Hash\n索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多,\n效率就会降低。这是因为遇到 Hash\n冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash\n索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。\nHash 索引适用存储引擎如表所示：\n\n\n\n索引 / 存储引擎\nMyISAM\nInnoDB\nMemory\n\n\n\n\nHASH 索引\n不支持\n不支持\n支持\n\n\n\nHash 索引的适用性：\nHash 索引存在着很多限制，相比之下在数据库中 B+\n树索引的使用面会更广，不过也有一些场景采用 Hash\n索引效率更高，比如在键值型 (Key-Value) 数据库中，Redis\n存储的核心就是 Hash 表。\nMySQL 中的 Memory 存储引擎支持 Hash\n存储，如果我们需要用到查询的临时表时，就可以选择 Memory\n存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash\n计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用\nHash 索引是个不错的选择。\n另外，InnoDB 本身不支持 Hash 索引，但是提供自适应 Hash\n索引 (Adaptive Hash Index)。什么情况下才会使用自适应 Hash\n索引呢?\n如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到\nHash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让\nB+ 树也具备了 Hash 索引的优点。\n采用自适应 Hash 索引目的是方便根据 SQL\n的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应\nHash 索引可以明显提高数据的检索效率。\n我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应\nHash\nshow variables like '%adaptive_hash_index';\n6.3 二叉搜索树\n如果我们利用二叉树作为索引结构，那么磁盘的 IO\n次数和索引树的高度是相关的。\n1. 二叉搜索树的特点\n\n一个节点只能有两个子节点，也就是一个节点度不能超过 2\n左子节点 &lt; 本节点; 右子节点 &gt;=\n本节点，比我大的向右，比我小的向左\n\n2. 查找规则\n为了提高查询效率，就需要 减少磁盘 IO 数 。为了减少磁盘 IO\n的次数，就需要尽量 降低树的高度 ，需要把\n原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。\n6.4 AVL 树\n为了解决上面二叉查找树退化成链表的问题，人们提出了平衡二叉搜索树（Balanced\nBinary Tree），又称为 AVL 树（有别于 AVL\n算法），它在二叉搜索树的基础上增加了约束，具有以下性质:\n它是一棵空树或它的左右两个子树的高度差的绝对值不超过\n1，并且左右两个子树都是一棵平衡二叉树。\n这里说一下，常见的平衡二叉树有很多种，包括了平衡二叉搜索树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。\n数据查询的时间主要依赖于磁盘 I/O\n的次数，如果我们采用二叉树的形式，即使通过平衡二叉搜索树进行了改进，树的深度也是\nO(log 2n) ，当 n\n比较大时，深度也是比较高的，比如下图的情况：\n每访问一次节点就需要进行一次磁盘 I/O\n操作，对于上面的树来说，我们需要进行 5 次 I/O\n操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I/O\n操作次数多，会影响整体数据查询的效率。\n针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M=3\n时，同样的 31 个节点可以由下面 的三叉树来进行存储：\n你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M\n大的时候，M 叉树的高度会远小于二叉树的高度 (M &gt;\n2)。所以，我们需要把树从“瘦高” 变 “矮胖”。\n6.5 B-Tree\nB 树的英文是 Balance Tree，也就是 多路平衡查找树。简写为\nB-Tree。它的高度远小于平衡二叉树的高度。\nB 树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B\n树的阶。每个磁盘块中包括了关键字和子节点的指针。如果一个磁盘块中包括了\nx 个关键字，那么指针数就是\nx + 1 。对于一个 100 阶的\nB 树来说，如果有 3\n层的话最多可以存储约 100 万的索引数据。对于大量的索引数据来说，采用\nB\n树的结构是非常适合的，因为树的高度要远小于二叉树的高度。\n一个 M 阶的 B 树（M&gt;2）有以下的特性：\n\n根节点的儿子数的范围是 [2,M]。\n每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量\n+1，k 的取值范围为 [ceil(M/2), M]。\n叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为\n[ceil(M/2), M]。\n假设中间节点节点的关键字为：Key[1], Key[2], …,\nKey[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1\n个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2],\n…, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于\n(Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。\n所有叶子节点位于同一层。\n\n在 B\n树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比\n较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O\n操作，消耗的时间比在内存中进行\n比较所需要的时间要多，是数据查找用时的重要因素。B\n树相比于平衡二叉树来说磁盘 I/O\n操作要少，在数据查询中比平衡二叉树效率要高。所以只要树的高度足够低，I/O\n次数足够少，就可以提高查询性能 。\n小结:\n\nB\n树在插入和删除节点的时候如果导致树不平衡，就通过自动调整节点的位置来保持树的自平衡。\n关键字集合分布在整棵树中,\n即叶子节点和非叶子节点都存放数据。搜索有可能在非叶子节点结束。\n其搜索性能等价于在关键字全集内做一次二分查找。\n\n6.6 B+Tree\nB+ 树也是一种多路搜索树，基于 B 树做出了改进，主流的 DBMS 都支持 B+\n树的索引方式，比如 MySQL。相比于 B-Tree，B+Tree\n适合文件索引系统。|\nB+ 树和 B 树的差异在于以下几点：\n\n有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B\n树中，孩子数量 = 关键字数 +1。\n非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最\n小）。\n非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而\nB 树中， 非 叶子节点既保存索引，也保存数据记录 。\n所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大\n小从小到大顺序链接。\n\n首先，B+ 树查询效率更稳定。因为 B+\n树每次只有访问到叶子节点才能找到对应的数据，而在 B\n树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。\n其次，B+\n树的查询效率更高。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘\nI/O 消耗。而因为 B+树的内部节点只是作为索引使用，而不像 B\n树那样每个节点都需要存储硬盘指针。也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了\nI/O 操作。\n不仅是对单个关键字的查询上，在查询范围上， B+ 树的效率也比 B 树高。这是因为所有关键字都出现在\nB+\n树的叶子节点中，叶子节点之间会有指针，数据又是递增的，这使得我们范围查找可以通过指针连接查找。而在\nB\n树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。\n\nB 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但\nB 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然。\n\n思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需\n1~3 次磁盘 IO\n思考题：为什么说 B+树比\nB-树更适合实际应用中操作系统的文件索引和数据库索引？\n思考题：Hash 索引与 B+ 树索引的区别\n6.7 R 树\nR-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型\n，支持该类型的存储引擎只有 myisam、bdb、 innodb、ndb、archive 几种。举个\nR 树在现实领域中能够解决的例子：查找 20 英里以内所有的餐厅。如果 没有 R\n树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记\n录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满\n足要求。如果一个地区有 100 家餐厅的话，我们就要进行 100\n次位置计算操作了，如果应用到谷歌、百度\n地图这种超大数据库中，这种方法便必定不可行了。R 树就很好的\n解决了这种高维空间搜索问题 。它把 B\n树的思想很好的扩展到了多维空间，采用了 B\n树分割空间的思想，并在添加、删除操作时采用合并、分解\n结点的方法，保证树的平衡性。因此，R 树就是一棵用来 存储高维数据的平衡树\n。相对于 B-Tree，R-Tree 的优势在于范围查找。\n\n\n\n索引 / 存储引擎\nMyISAM\nInnoDB\nMemory\n\n\n\n\nR-Tree 索引\n支持\n支持\n不支持\n\n\n\n6.8 小结\n使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利\n(提升查询效率) 和弊 (维护索引所需的代价)。|\n在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质是帮助我们提升数据检索的效率。\n","categories":["Database"],"tags":["DB-Index"]},{"title":"Typescript Learning Note","url":"/2024/01/05/Typescript-Learning-Note/","content":"这篇文章涵盖了 TypeScript 的基础和高级特性。首先介绍了 TypeScript\n的八种内置基础类型，以及 any、unknown\n类型的使用。接着，深入讲解了接口、对象类型、泛型、函数扩展、联合类型等内容，并介绍了如何通过\ntype 和 interface\n区分类型别名。文章还详细说明了 TypeScript\n的类型推论、枚举类型、元组、符号类型等。之后，内容转向高级用法，介绍了装饰器、命名空间、Mixins\n等概念，并提供了 TypeScript 项目构建的实用工具，如 Rollup 和 Webpack\n配置，最后讨论了 TypeScript 的进阶模式和工具类型。\n\n基础类型(TS – 1)\n\n\n全局安装 TSnpm install -g typescript\n检查是否安装成功tsc -v\n初始化生成配件文件tsc --init\n设置实时 TS 代码转换成 JS\n代码：shift+ctrl+B选择监视\n然后写的 TS 编译成 js，使用 node 在终端运行转换成功的 js 文件\n\n\nlet str: string = \"这是字符串类型\";//上方我们将str这个变量定义为了string类型，如果对他输入其他类型的内容就会报错，例如：let str: string = 666;//这个就会报错了，会提示你不能将类型\"number\"分配给类型\"string\"let muban: string = `web${str}`;//我们也可以使用ES6中的模板字符串let u: void = undefined;let u: void = null;//空值类型能够有这两种内容。void的内容也是不能去赋值给别人的//某种程度上来说，void 类型像是与 any 类型相反function fnvoid(): void {\treturn; //函数也可以定义为空值，如果定义了void则不能返回内容}//undefined跟null类型的也可以交换着用的，具体区别放在了下面\n八种内置类型\nlet str: string = \"jimmy\";let num: number = 24;let bool: boolean = false; //这里接收的是布尔值，不是布尔值对象(let b:boolean = new Boolean())let u: undefined = undefined;let n: null = null;let obj: object = { x: 1 };let big: bigint = 100n;let sym: symbol = Symbol(\"me\");\n注意点\nnull 和 undefined\n默认情况下 null 和 undefined\n是所有类型的子类型。 就是说你可以把 null 和\nundefined 赋值给其他类型。\n// null和undefined赋值给stringlet str: string = \"666\";str = null;str = undefined;// null和undefined赋值给numberlet num: number = 666;num = null;num = undefined;// null和undefined赋值给objectlet obj: object = {};obj = null;obj = undefined;// null和undefined赋值给Symbollet sym: symbol = Symbol(\"me\");sym = null;sym = undefined;// null和undefined赋值给booleanlet isDone: boolean = false;isDone = null;isDone = undefined;// null和undefined赋值给bigintlet big: bigint = 100n;big = null;big = undefined;\n如果你在 tsconfig.json 指定了 \"strictNullChecks\":true\n，null 和 undefined 只能赋值给\nvoid 和它们各自的类型。\nnumber 和 bigint\n虽然 number 和 bigint\n都表示数字，但是这两个类型不兼容。\nlet big: bigint = 100n;let num: number = 6;big = num;num = big;\n会抛出一个类型不兼容的 ts (2322) 错误。\n任意类型(TS – 2)\n\nnpm install @types/node -Dnpm install ts-node -g(装全局的)\n\n类型(任意值) – any\nlet anys: any = \"小满穿黑丝\";anys = [];anys = 18;anys = {};anys = Symbol(\"666\");//any类型就跟原生的是一样的，能够给任意的类型进行定义，所以在在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型 )。\n\n作用的地方：\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。\n这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。\n这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。\n那么我们可以使用 any 类型来标记这些变量\n在对现有代码进行改写的时候，any\n类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。\n你可能认为 Object 有相似的作用，就像它在其它语言中那样。\n但是 Object 类型的变量只是允许你给它赋任意值 -\n但是却不能够在它上面调用任意的方法，即便它真的有这些方法\n当你只知道一部分数据的类型时，any 类型也是有用的。\n比如，你有一个数组，它包含了不同的类型的数据\n\n\nunknown 类型\n\nunknown 类型比 any 类型更安全\n就像所有类型都可以被归为 any，所有类型也都可以被归为\nunknown。这使得 unknown 成为 TypeScript\n类型系统的另一种顶级类型（另一种的any）\n\nlet unknow: unknown = { a: (): number =&gt; 123 };unknow.a(); //报错//unkonwn类型是不能够去调用属性跟函数的，它是 any 类型对应的安全类型\n接口和对象类型(TS – 3)\n\n在 typescript\n中，我们定义对象的方式要用关键字\ninterface（接口），小满的理解是使用\ninterface\n来定义一种约束，让数据的结构满足约束的格式。\n我的理解是 interface\n是一个国企部门只招一个人的话，他们会针对走后门的那个人量身定制招聘要求，到面试的时候，这些条件少一个都不行，多了也不行，毕竟已经内定了，再叼、这些条件不仅满足了而且还会更多的技能也没用，别人就是不要你。(留下心酸的眼泪)\n\ninterface 类型\ninterface A{     readonly name:string//这个readonly是只读属性，意思就是说只能读取，不能将其他值赋值给他    age?:number//这个问号就是可选的意思，条件稍微宽松了一些，下面引用这个age的话有没有这个属性都可以，不会报错}let obj:A = {    name:\"小满嗷嗷叫\",//这里如果不写name就会报错，因为我们在上面定义了A类型集合，并且在这个变量中引入了(里面必须要有name属性且类型为字符串)    age:18}\n\n注意：这个规定的属性不能多也不能少，参考我上面的案例\n\n可选属性 – ?操作符\ninterface A{     readonly name:string    age?:number//这个问号就是可选的意思，条件稍微宽松了一些，下面引用这个age的话有没有这个属性都可以，不会报错}let obj:A = {    name:\"小满嗷嗷叫\"    age:18//age写不写无所谓}\n任意属性 – [propName:string]\n\n需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集\n\ninterface Person{    name:string,    age?:number,    [propName:string]:string|number//这个属性一旦定义了，引用这个Person的对象就能够写入任意属性，属性的形式主要看冒号后面你定义了什么类型，比如在这里定义的类型就是string和number类型，不是这两者的类型就会报错，包括在Person里面定义除了string跟number之外其他类型也会报错    //可以理解为这个 [propName:stirng]任意属性的优先度相当高    注意string与number中间的 `|` 符号，小飞棍来咯，这是联合类型，后面笔记会写，这里就当作将string和number类型关系到了一块，有点像逻辑或，满足联合起来的其中一个条件都行，两个也可以}\n只读属性 – readonly\n\n只读属性必须在声明时或构造函数里被初始化。\n\ninterface A{     readonly name:string//这个readonly是只读属性，意思就是说只能读取，不能将其他值赋值给他}let obj:A = {    name:\"小满嗷嗷叫\"}obj.name = \"小满芳龄18\"//报错console.log(obj)//能够读取let name1 = obj.nameconsole.log(name1)\n继承属性 – extends\n\n儿子在前面，父亲在后面。也就是说顺序是 儿子 继承于 父亲\n父亲的部分会继承给儿子，父亲的部分如果没有使用?操作符的话，引用儿子的\n对象\n是必须将父亲的部分都写下去。一说到这个就想到现在有的地方买房子，出政策能够绑定\n3\n代人一起还款，父债子还，跑不掉的，连债务都继承了还不能摆脱，这政策太鸡儿黑心了，绝户计\n\ninterface A {\tname: string;}interface B extends A {\tage: number;}let p: B = {\tname: \"有看到小满的裤子吗？\",\tage: 88, //两种类型都要写};\nObject 与 object{} – 加餐环节\n前置知识点补充\n\n\n\n原始数据类型（基础数据类型）\n中文称呼\n引用数据类型\n中文称呼\n\n\n\n\nUndefined\n未定义\n{}\n对象\n\n\nNull\n空值\nfunction\n函数\n\n\nBoolean\n布尔值\n[]\n数组\n\n\nNumber\n数字\n\n\n\n\nString\n字符串\n\n\n\n\n\n存储位置不同\n原始数据类型：直接存储在栈（stack）中的简单数据段，占据空间小，大小固定，属于被频繁使用的数据，所以存储在栈中；\n引用数据类型：存储在堆（heap）中的对象，占据空间大，大小不固定，如果存储在栈中，将会影响程序运行的性能。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后，从堆中获得实体。\n传值方式不同\n\n基本数据类型：按值传递\n\n不可变 (immutable) 性质：\n基本类型是不可变的 (immutable)，只有对象是可变的 (mutable).\n有时我们会尝试 “改变” 字符串的内容，但在 JS 中，任何看似对 string 值的\n“修改” 操作，实际都是创建新的 string\n值。任何方法都无法改变一个基本类型的值(在下面的字面量类型中会再次强调)\n\n引用类型：按引用传递\n\n引用类型的值是可变的\n引用类型的值是同时保存在栈内存和堆内存中的对象。javascript\n和其他语言不同，其不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，那我们操作啥呢？\n实际上，是操作对象的引用，引用类型的值是按引用访问的。\n\nobject、Object 以及\n{} 这三个类型(第三个类型为空对象字面量模式)大家可能不太理解\n这集加餐环节就是进行补充，一个冷门但是不邪门的知识点\n\nObject 类型\n//这个类型是跟原型链有关的原型链顶层就是 Object，所以值类型和引用类型最终都指向 Object，所以在TypeScript中Object他包含所有类型。就可以等于任何一个值//1.数字类型let a: Object = 123;//字符串类型let b: Object = \"小满今天没穿裤子\";//数组类型let c: Object = [1314, 520];//对象类型let d: Object = { name: \"草莓\", sex: \"女\", address: \"小满微信一群\" };//any或者functionlet e: Object = () =&gt; \"学姐贴贴\";\nObject 类型是所有 Object 类的实例的类型。\n由以下两个接口来定义：\n\nObject 接口定义了 Object.prototype\n原型对象上的属性；\nObjectConstructor 接口定义了 Object 类的属性，\n如上面提到的 Object.create()。\n\nobject 类型\n\nobject 代表所有非值类型(非原始类型)的类型，例如 数组 对象\n函数等，常用于泛型约束\n所有原始类型都不支持，所有引用类型都支持\n\n//错误 原始类型(字符串)let f: object = \"努力会获得回报的\";//错误 原始类型(数字)let g: object = 123;//错误 原始类型(布尔值类型)let h: object = true;//正确 引用类型(数组类型)let i: object = [123, \"学姐学习Vue3\", true];//正确 引用类型(对象类型)let j: object = {\tname: \"小满\",\tidentity: [\"B站UP主\", \"二次元\", \"京东员工\", \"全栈开发工程师\"],\tsex: \"女\",};//正确 引用类型(函数类型)let k: object = () =&gt; \"不要对自己pua，相信自己是最棒的，尊重自己，人生更精彩\";\n{}字面量类型\n\n看起来很别扭的一个东西 你可以把他理解成 new Object 就和我们的第一个\nObject 基本一样 包含所有类型\n\n//与Object类型一样let l: {} = 123; //等等，就不写了，跟Object一样//补充--字面量模式//这个虽然可以赋值任意类型，赋值结束后，是没办法进行一个修改和增加的操作的\n数组类型(TS – 4)\n\n普通的声明方式\n\n//类型加中括号let arr: number[] = [123];//这样会报错定义了数字类型出现字符串是不允许的let arr: number[] = [1, 2, 3, \"1\"];//操作方法添加也是不允许的let arr: number[] = [1, 2, 3];let arr: number[] = [1, 2, 3, 4]; //数字类型的数组let arr2: string[] = [\"1\", \"2\", \"3\", \"4\"]; //字符串类型的数组let arr3: any[] = [1, \"2\", true, undefined, [], {}]; //任意类型的数组let arr4: number[][][] = [[[]], [[]], [[]]];//这个也能够决定你二维数组还是三维数组想要套几层就写几层\n泛型 – Array &lt;类型&gt;\n\n规则 Array &lt;类型&gt;\n\nlet arr1: Array&lt;number&gt; = [1, 2, 3, 4, 5];let arr2: Array&lt;string&gt; = [\"1,2,3,4,5\"];let arr3: Array&lt;boolean&gt; = [true];//泛型数组套娃写法(还能够决定数组里面数组的类型之类的)let arr4: Array&lt;Array&lt;number&gt;&gt; = [[123], [456]];\n类数组 – arguments\n\n是所有参数的一个集合\n\nfunction Arr(...args: any): void {\t//...args为ES6的解构方式，任意类型，voidwei不能有返回值\tconsole.log(arguments); //输出{'0':4,'1':56,'2':789}\t// let arr:number[] = arguments//会报错，报缺少类型number[]的以下属性：pop,push,concat,join\tlet arr1: IArguments = arguments; //解决方法\t//其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：\tinterface IArguments {\t\t[index: number]: any;\t\tlength: number;\t\tcallee: Function;\t}}Arr(4, 56, 789);\n接口表示数组\n\n一般用来描述类数组\n\ninterface ArrNumber {\t[index: number]: number; //后面的才是定义类型的\t//[index: number]: string;这个就是定义字符串的了}let Arr: ArrNumber = [1, 2, 3, 4, 5];//let Arr: ArrNumber = [\"1, 2, 3, 4, 5\"];//表示：只要索引的类型是数字时，那么值的类型必须是数字。\n函数扩展(TS – 5)\n\n函数内参数类型也是可以定义的\n\nconst fn = (name:string,age:number):string =&gt;{    return name + age}let a = fn('小满',10000)//输入不符合上述参数内定义的类型就会出错console.log(a)//输出小满10000--------------------------------------------------------------------const fn = (name:string,age:number = 666):string =&gt;{//如果在下面使用的时候，没有参数传进来就会以你在这里设置的默认参数执行，比如这个666    return name + age}let a = fn('小满')//输入不符合上述参数内定义的类型就会出错console.log(a)//输出小满666--------------------------------------------------------------------const fn = (name:string,age?:number = 666):string =&gt;{//也可以使用这个`?`操作符，age传不传就变成可选的了    return name + age}let a = fn('小满穿女仆装')//输入不符合上述参数内定义的类型就会出错console.log(a)//输出小满穿女仆装\n对象形式的定义\n\n跟定义对象差不多，但是在针对多个参数的时候会更加的方便，且记得引用的时候要写成({xxxx})形式，不然会报错，输出的是数组形式的\n\ninterface User {\tname: string;\tage: number;}const fn = (user: User): User =&gt; {\t//这里的参数填写方式就变得简单了\treturn user;};let a = fn({\tname: \"'小满\",\tage: 18,}); //输入不符合上述参数内定义的类型就会出错console.log(a); //输出{name:'小满',age:18}\n函数重载\n\n重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。\n如果参数类型不同，则参数类型应设置为 any。\n参数数量不同你可以将不同的参数设置为可选。\n为了让编译器能够选择正确的检查类型，它与 JavaScript\n里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。\n如果匹配的话就使用这个。\n因此，在定义重载的时候，一定要把最精确的定义放在最前面。\n\nfunction fn(params:number):void//第一套规则function fn(params:string,params2:number):void//第二套规则function fn(params:any,params2?:any):void{    console.log(params)    console.log(params2)}let a = fn(1)//输出1跟undefined，因为遵循的是第一套规则let a = fn(\"1\",1)//输出\"1\"跟1，遵循的是第二套规则\n联合类型|类型断言|交叉类型(TS –\n6)\n联合类型\n\n联合类型能够让我们可选我们自己需要的类型部分，如果需要的类型超过或者达到\n2 个，那就可以使用。\n那为什么不使用 any\n呢？那是因为我们需要的并不是所有类型都能通过，我只希望这两个或者 3\n个类型能够通过，如果需要的类型超过或着达到两个都使用 any 的话，那就和\nJavaScript 原生没有区别了\n\n//例如我们的手机号通常是13XXXXXXX 为数字类型 这时候产品说需要支持座机//所以我们就可以使用联合类型支持座机字符串let myPhone: number | string = \"010-820\";//这样写是会报错的应为我们的联合类型只有数字和字符串并没有布尔值let myPhone: number | string = true; //报错\n函数使用联合类型\n\n这个!!是怎么回事呢？\n我们知道一串数字想变成字符串只要加上”“就能隐式转换成字符串。\n那一个类型只要!就能进行反转，!只有正反，也就是 false 跟\ntrue，这种就有点类似隐式转换了，我们连续转两次就相当于当前形式的布尔值类型了\n\nlet fn = function(type:number):boolean {    return !!type//将type强行转化为布尔值类型，如果没用进行转化的话是会报错的}--------------------------------------------------------------------let fn = function(type:number|boolean):boolean {    return !!type//将type强行转化为布尔值类型，如果没用进行转化的话是会报错的}let result = fn(1)console.log(result);//true\n交叉类型\n\n多种类型的集合，联合对象将具有所联合类型的所有成员\n\ninterface Pople{    name:string    age:number}interface Man{    sex:number}const xiaoman = (man:Pople &amp; Man):void =&gt; {//这里通过了&amp;将Pople跟Man交叉在了一起，则man需要处理Pople也要处理Man。还可以继续跟更多个interface    console.log(man)}xiaoman({    name:\"小满今天坏掉了\",    age:18,    sex:1//如果sex不写是会报错的，会提示你少写了一个sex})\n类型断言\n\n语法格式，值 as 类型 或者 &lt;类型&gt;值\n需要注意的是，类型断言只能够「欺骗」TypeScript\n编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误\n覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。TypeScript\n类型断言用来告诉编译器你比它更了解这个类型，并且它不应该再发出错误\n当 S 类型是 T 类型的子集，或者\nT 类型是 S 类型的子集时，S\n能被成功断言成\nT。这是为了在进行类型断言时提供额外的安全性，完全毫无根据的断言是危险的，如果你想这么做，你可以使用\nany。\n2、类型断言的用途\n（1）将一个联合类型推断为其中一个类型\n（2）将一个父类断言为更加具体的子类\n（3）将任何一个类型断言为 any\n（4）将 any 断言为一个具体的类型\n\n原型：let fn = function(num:number | string):void{    console.log(num.length);//这里会报错，因为我们确实没有.length这个内容}fn(\"12345\")--------------------------------------------------------断言写法let fn = function(num:number | string):void{    console.log((num as string).length);//用括号括起来，as断言他是string类型}fn(\"12345\")//这样会打印出5fn(12345)//这样会打印出undefined\n另一个例子\ninterface A{    run:string}interface B{    build:string}let fn = (type:A | B) =&gt;{    console.log((&lt;A&gt;type).run);}fn({    build:\"123\"//这里是没办法传过去的，断言是不能够滥用的，因为我们确实没有.run这个内容})\n临时断言\n\n1.使用 any 临时断言\n\nwindow.abc = 123//这样写会报错因为window没有abc这个东西(window as any).abc = 123//可以使用any临时断言在 any 类型的变量上，访问任何属性都是允许的。\n\n在下面的例子中，将 something 断言为 boolean\n虽然可以通过编译，但是并没有什么用\n并不会影响结果，因为编译过程中会删除类型断言\n\nfunction toBoolean(something: any): boolean {    return something as boolean;}let bbb =  toBoolean(1);console.log(bbb)// 返回值为 1//\nas const\n\n是对字面值的断言，与 const\n直接定义常量是有区别的\n如果是普通类型跟直接 const 声明是一样的\n\nconst names = '小满'names = 'aa' //无法修改let names2 = '小满' as constnames2 = 'aa' //无法修改\n// 数组let a1 = [10, 20] as const;const a2 = [10, 20];a1.unshift(30); // 错误，此时已经断言字面量为[10, 20],数据无法做任何修改a2.unshift(30); // 通过，没有修改指针。之所以没有修改指针是因为const的性质是决定了指针指向的位置是已经固定不会发生改变的了，这个30想要添加进去除非直接修改存储值的地方\n内置对象(TS – 7)\nECMAScript 的内置对象\n\nJavaScript 中有很多内置对象，它们可以直接在\nTypeScript中当做定义好了的类型。\nBoolean、Number、string、RegExp、Date、Error\n\nconst regexp: Regexp = /\\w\\d\\s/; //声明正则const date: Date = new Date(); //对象类型//const date:Date = new Date().getTime()  number类型const error: Error = new Error(\"错误\");\n总结\nlet b: Boolean = new Boolean(1);console.log(b);let n: Number = new Number(true);console.log(n);let s: String = new String(\"小满今天穿白丝\");console.log(s);let d: Date = new Date();console.log(d);let r: RegExp = /^1/;console.log(r);let e: Error = new Error(\"error!\");console.log(e);\nDOM 和 BOM 的内置对象\n\nDocument、HTMLElement、Event、NodeList\n等\n\nconst list: NodeList = document.querySelectorAll(\"#list li\");console.log(list);//NodeList 实例对象是一个类似数组的对象，它的成员是节点对象。Node.childNodes、document.querySelectorAll () 返回的都是 NodeList 实例对象。 [1]  NodeList 对象代表一个有序的节点列表。const body: HTMLElement = document.body;console.log(body);const div: HTMLDivElement = document.querySelector(\"div\");console.log(div);document.body.addEventListener(\"click\", (e: MouseEvent) =&gt; {\tconsole.log(e);});//promisefunction promise1(): Promise&lt;number&gt; {\t//Promise是类型,number是泛型\treturn (\t\tnew Promise() &lt;\t\tnumber &gt;\t\t((resolve, rejects) =&gt; {\t\t\tresolve(1); //如果不进行断言的话会报错\t\t})\t);}promise().then(res =&gt; {\tconsole.log(res); //返回1，这里会提示你res应该输入number类型});\nlet body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');//读取div 这种需要类型断言 或者加个判断应为读不到返回nulllet div:HTMLElement = document.querySelector('div') as HTMLDivElementdocument.addEventListener('click', function (e: MouseEvent) {});//dom元素的映射表interface HTMLElementTagNameMap {    \"a\": HTMLAnchorElement;    \"abbr\": HTMLElement;    \"address\": HTMLElement;    \"applet\": HTMLAppletElement;    \"area\": HTMLAreaElement;    \"article\": HTMLElement;    \"aside\": HTMLElement;    \"audio\": HTMLAudioElement;    \"b\": HTMLElement;    \"base\": HTMLBaseElement;    \"bdi\": HTMLElement;    \"bdo\": HTMLElement;    \"blockquote\": HTMLQuoteElement;    \"body\": HTMLBodyElement;    \"br\": HTMLBRElement;    \"button\": HTMLButtonElement;    \"canvas\": HTMLCanvasElement;    \"caption\": HTMLTableCaptionElement;    \"cite\": HTMLElement;    \"code\": HTMLElement;    \"col\": HTMLTableColElement;    \"colgroup\": HTMLTableColElement;    \"data\": HTMLDataElement;    \"datalist\": HTMLDataListElement;    \"dd\": HTMLElement;    \"del\": HTMLModElement;    \"details\": HTMLDetailsElement;    \"dfn\": HTMLElement;    \"dialog\": HTMLDialogElement;    \"dir\": HTMLDirectoryElement;    \"div\": HTMLDivElement;    \"dl\": HTMLDListElement;    \"dt\": HTMLElement;    \"em\": HTMLElement;    \"embed\": HTMLEmbedElement;    \"fieldset\": HTMLFieldSetElement;    \"figcaption\": HTMLElement;    \"figure\": HTMLElement;    \"font\": HTMLFontElement;    \"footer\": HTMLElement;    \"form\": HTMLFormElement;    \"frame\": HTMLFrameElement;    \"frameset\": HTMLFrameSetElement;    \"h1\": HTMLHeadingElement;    \"h2\": HTMLHeadingElement;    \"h3\": HTMLHeadingElement;    \"h4\": HTMLHeadingElement;    \"h5\": HTMLHeadingElement;    \"h6\": HTMLHeadingElement;    \"head\": HTMLHeadElement;    \"header\": HTMLElement;    \"hgroup\": HTMLElement;    \"hr\": HTMLHRElement;    \"html\": HTMLHtmlElement;    \"i\": HTMLElement;    \"iframe\": HTMLIFrameElement;    \"img\": HTMLImageElement;    \"input\": HTMLInputElement;    \"ins\": HTMLModElement;    \"kbd\": HTMLElement;    \"label\": HTMLLabelElement;    \"legend\": HTMLLegendElement;    \"li\": HTMLLIElement;    \"link\": HTMLLinkElement;    \"main\": HTMLElement;    \"map\": HTMLMapElement;    \"mark\": HTMLElement;    \"marquee\": HTMLMarqueeElement;    \"menu\": HTMLMenuElement;    \"meta\": HTMLMetaElement;    \"meter\": HTMLMeterElement;    \"nav\": HTMLElement;    \"noscript\": HTMLElement;    \"object\": HTMLObjectElement;    \"ol\": HTMLOListElement;    \"optgroup\": HTMLOptGroupElement;    \"option\": HTMLOptionElement;    \"output\": HTMLOutputElement;    \"p\": HTMLParagraphElement;    \"param\": HTMLParamElement;    \"picture\": HTMLPictureElement;    \"pre\": HTMLPreElement;    \"progress\": HTMLProgressElement;    \"q\": HTMLQuoteElement;    \"rp\": HTMLElement;    \"rt\": HTMLElement;    \"ruby\": HTMLElement;    \"s\": HTMLElement;    \"samp\": HTMLElement;    \"script\": HTMLScriptElement;    \"section\": HTMLElement;    \"select\": HTMLSelectElement;    \"slot\": HTMLSlotElement;    \"small\": HTMLElement;    \"source\": HTMLSourceElement;    \"span\": HTMLSpanElement;    \"strong\": HTMLElement;    \"style\": HTMLStyleElement;    \"sub\": HTMLElement;    \"summary\": HTMLElement;    \"sup\": HTMLElement;    \"table\": HTMLTableElement;    \"tbody\": HTMLTableSectionElement;    \"td\": HTMLTableDataCellElement;    \"template\": HTMLTemplateElement;    \"textarea\": HTMLTextAreaElement;    \"tfoot\": HTMLTableSectionElement;    \"th\": HTMLTableHeaderCellElement;    \"thead\": HTMLTableSectionElement;    \"time\": HTMLTimeElement;    \"title\": HTMLTitleElement;    \"tr\": HTMLTableRowElement;    \"track\": HTMLTrackElement;    \"u\": HTMLElement;    \"ul\": HTMLUListElement;    \"var\": HTMLElement;    \"video\": HTMLVideoElement;    \"wbr\": HTMLElement;}\nClass 类(TS – 8)\n\nES6提供了更接近传统语言的写法，引入了\nClass（类）这个概念，作为对象的模板。通过 class\n关键字，可以定义类。基本上，ES6 的 class\n可以看作只是一个语法糖，它的绝大部分功能，ES5\n都可以做到，新的 class\n写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用\nES6 的 “类” 改写\n\n\nJavaScript 写法\n\n//定义类      JavaScript写法class Person {\tconstructor(name: string, age: number, sub: boolean) {\t\tthis.name = name;\t\tthis.age = age;\t\tthis.sub = sub;\t}}new Person(\"小满\", 22, false);\n\nTypeScript 写法\n\n//在TypeScript中是需要提前声明类型的class Person {\tname: string;\tage: number;\tsub: boolean; //没错，没使用标红的是这些\tconstructor(name: string, age: number, sub: boolean) {\t\tthis.name = name;\t\tthis.age = age;\t\tthis.sub = sub; //上面定义了变量就需要使用，如果没用使用的话声明的变量就会标红(就算不标红不提示，真运行下去也会报错)，不能就那么放着，要么就用上，要么就给他个默认值0塞着\t}}new Person(\"小满\", 22, false);\npublic\n\npublic 内部外部都可以访问，如果定义了 public，像 p 就能够访问\nconstructor 内部的变量了。当然，默认情况下也是 public\n\n//在TypeScript中是需要提前声明类型的class Person {    public name:string    public age:number    public sub:boolean//没错，没使用标红的是这些    constructor (name:string,age:number,sub:boolean) { \t\tthis.name = name        this.age = age        this.sub = sub//上面定义了变量就需要使用，如果没用使用的话声明的变量就会标红(就算不标红不提示，真运行下去也会报错)，不能就那么放着，要么就用上，要么就给他个默认值0塞着    }}let p = new Person(\"小满\",22,false)p.age p.name p.sub//都可以访问\nprivate\n\nprivate 私有变量只能在内部访问\n\n//在TypeScript中是需要提前声明类型的class Person {    private name:string    private age:number    private sub:boolean//没错，没使用标红的是这些    constructor (name:string,age:number,sub:boolean) { \t\tthis.name = name        this.age = age        this.sub = sub//上面定义了变量就需要使用，如果没用使用的话声明的变量就会标红(就算不标红不提示，真运行下去也会报错)，不能就那么放着，要么就用上，要么就给他个默认值0塞着    }}let p = new Person(\"小满\",22,false)p.age p.name p.sub//都访问不到了\nprotected\n\nprotected 内部和子类中访问\nprovate 跟 protectd\n他们的区别是一个是只能在内部使用，一个是内部与子类访问，例子如下\n\n//在TypeScript中是需要提前声明类型的class Person {    protected name:string    private age:number    public sub:boolean//没错，没使用标红的是这些    constructor (name:string,age:number,sub:boolean) { \t\tthis.name = name        this.age = age        this.sub = sub//上面定义了变量就需要使用，如果没用使用的话声明的变量就会标红(就算不标红不提示，真运行下去也会报错)，不能就那么放着，要么就用上，要么就给他个默认值0塞着    }}class Man extends Person{    constructor(){        super(\"小满\",22,false)        this.name        this.sub//这两个都可以访问到，this.age访问不到。因为age是private，private只能在内部使用而不能在子类访问，Man是Person的子类    }}let p = new Person(\"小满\",22,false)p.age p.name p.sub\nstatic 静态属性 和 静态方法\n\n\n静态属性和非静态属性的区别：\n\n在内存中存放的位置不同：所有 static\n修饰的属性和方法都存放在内存的方法区里，而非静态的都存在堆内存中\n出现的时机不同：静态属性和方法在没创建对象之前就存在，而非静态的需要在创建对象才存在\n静态属性是整个类都公用的\n生命周期不一样，静态在类消失后被销毁，非静态在对象销毁后销毁\n用法：静态的可以直接通过类名访问，非静态只能通过对象进行访问\n\n使用static注意事项\n\n带静态修饰符的方法只能访问静态属性\n非静态方法既能访问静态属性也能访问非静态属性\n非静态方法不能定义静态变量\n静态方法不能使用 this 关键字\n静态方法不能调用非静态方法，反之可以\n\n父子类中静态和非静态的关系\n\n对于非静态属性，子类可以继承父类非静态属性，但是当父子类出现相同的非静态属性时，不会发生子类的重写并覆盖父类的非静态属性，而是隐藏父类的非静态属性\n对于非静态方法，子类可以继承并重写父类的非静态方法\n对于静态属性，子类可以继承父类的静态属性，但是如何和非静态属性一样时，会被隐藏\n对于静态方法，子类可以继承父类的静态方法，但是不能重写静态方法，同名时会隐藏父类的\n\n注：静态属性、静态方法、非静态属性都可以被继承和隐藏，但是不可以被重写，非静态方法可以被重写和继承\n\n\n\n\n静态代码块的作用：\n一般情况下，有些代码需要在项目启动的时候就执行，这时候就需要静态代码块，比如一个项目启动需要加载配置文件，或初始化内容等。\n静态代码块不能出现在任何方法体内\n对于普通方法：普通方法是需要加载类 new\n出一个实例化对象，通过运行这个对象才能运行代码块，而静态方法随着类加载就运行了。\n对于静态方法：在类加载时静态方法也加载了，但是必须需要类名或者对象名才可以访问，相比于静态代码块，静态方法是被动运行，而静态代码块是主动运行\n静态代码块不能访问普通变量\n普通变量只能通过对象调用的，所以普通变量不能放在静态代码块中。\n\n普通代码块和构造代码块\n\n静态代码块和构造代码块在声明上少一个 static\n关键字\n执行时机：\n构造代码块在创建对象时被调用，每次创建对象都会调用一次，且优先于构造函数执行。\n注：不是优先于构造函数执行，而是依托于构造函数，如果不创建对象就不会执行构造代码块\n普通代码块和构造代码块的区别在于，构造代码块是在类中定于的，而普通代码块是在方法体中定义的，执行顺序和书写顺序一致。\n\n执行顺序\n  **静态代码块 &gt; 构造代码块 &gt; 构造函数 &gt; 普通代码块**\n\nclass Person {    protected name:string    private age:number    public sub:boolean//没错，没使用标红的是这些    static aaa:string = '123456'//静态属性    constructor (name:string,age:number,sub:boolean) { \t\tthis.name = name        this.age = age        this.sub = sub//上面定义了变量就需要使用，如果没用使用的话声明的变量就会标红(就算不标红不提示，真运行下去也会报错)，不能就那么放着，要么就用上，要么就给他个默认值0塞着        this.run()//会报错，调用不了。互斥的，不能够通过静态函数去访问内部的变量，或者是在内部的变量去调用外部的静态函数        Person.run()//只能这样去调用    }    static run (){        this.dev()//静态函数之间可以互相调用        this.aaa//用this的话只能访问上面static类型的，其他的不管是public还是private或者是protected都是不能够访问的(会报不存在属性的错误)   因为这里的this指的是当前这个类，而构造函数里面的this指的是新的实例对象        return '789'    }    static dev(){        this.aaa//静态函数之间可以互相调用        return 'dev'    }}console.log(Person.run())//返回789Person.aaa//能够直接访问，不需要再new一下console.log(Person.aaa)let p = new Person(\"小满\",22,false)\ninterface 定义 类\n\nts interface 定义类 使用关键字 implements 后面跟 interface\n的名字多个用逗号隔开 继承还是用 extends\n通过接口去约束类\n\ninterface Person {\trun(type: boolean): boolean;}class Man implements Person {\t//会提示我们Man中缺少属性run，但类型Person中需要该属性}\n//通过接口去约束类interface Person {\trun(type: boolean): boolean;}interface H {\tset(): void;}class Man implements Person, H {\t//会报错，提示我们缺少set属性\trun(type: boolean): boolean {\t\treturn type;\t}}\ninterface Person {\trun(type: boolean): boolean;}interface H {\tset(): void;}class A {\t//也可以使用继承去使用\tparams: string;\tconstructor(params: string) {\t\tthis.params = params;\t}}class Man extends A implements Person, H {\trun(type: boolean): boolean {\t\treturn type;\t}\tset() {\t\t//啥也没有，这就是用接口去描述类\t}}\n抽象类(TypeScript8)\n\n用关键词abstract修饰的类称为 abstract\n类（抽象类）\n应用场景如果你写的类实例化之后毫无用处此时我可以把他定义为抽象类\n或者你也可以把他作为一个基类 -&gt;\n通过继承一个派生类去实现基类的一些方法\n对于 abstract\n方法只允许声明，不允许实现（因为没有方法体）（毕竟叫抽象，当然不能实实在在的让你实现），并且不允许使用\nfinal 和 abstract 同时修饰一个方法或者类，也不允许使用 static 修饰\nabstract 方法。也就是说，abstract 方法只能是实例方法，不能是类方法。\n\nabstract class A{    name:string    construct(name:string){//construct：构造器        this.name = name    }    //abstract getName(){//方法getName不能具有实现，因为它标记为抽象。定义抽象类的函数//    return 213//}    setName(name:string){        this.name = name    }    abstract getName():string//抽象类}class B extends A{//派生类。定义了抽象类必须在派生类里实现        //B类是继承A类的，此时A类就是一个抽象类    constructor(){        super('小满')    }    getName():string{        return this.name    }}//此时A类是无法被创建实例的(new A)，也就是无法创建抽象类的实例//B类是可以创建实例的(new B)let b = new Bb.setName(\"小满2\")//通过抽象类的设置，成功修改掉子类的内容//    setName(name:string){//        this.name = name//    }console.log(b.getName())\n元组类型(TS – 9)\n\n数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\nlet arr: [string, number] = [\"小满\", 22]; //这样的方式就叫做元组，定义了每个位置需要满足的不同类型arr[0].length; //有arr[1].length; //无，因为上面的定义类型会自动帮我们推断是否有该方法//Number 类型是没有 length 属性的\n越界的元组\n\n当添加的元组越界的时候，越界的类型会被限制为元组类型中每个类型的联合类型\n\nlet arr: [string, number] = [\"小满\", 22]; //这样的方式就叫做元组，定义了每个位置需要满足的不同类型arr.push(true); //会报错，因为类型boolean参数不能赋值给string|number的类型//这个就是元组对越界元素的处理arr.push(\"111\", 2222); //这种就可以//也可以对二维数组进行限制规定类型\n枚举类型(TS – 10)\n\n在 javaScript 中是没有枚举的概念的 TS\n帮我们定义了枚举这个类型\n\nenum 关键字定义枚举\n数字定义枚举\n\n默认从 0 开始的\n\nenum Color{    red,    green,    blue}console.log(Color.red,Color.blue,Color.green)//能够得到他们的顺序数字，这里返回0，2，1\n增长枚举\n\n能够通过自定义开头决定从哪个数字开始枚举，其他位置的都可以定义，后面的数字就按顺序枚举\n\nenum Color{    red=2,    green,    blue}console.log(Color.red,Color.blue,Color.green)//能够得到他们的顺序数字，这里返回2，4，3\n字符串枚举\n\n字符串枚举的概念很简单。\n在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\n由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。\n换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的\n-\n它并不能表达有用的信息，字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n\nenum Types{   Red = 'red',   Green = 'green',   BLue = 'blue'}\n异构枚举\n\n枚举可以混合字符串和数字成员\n\nenum Types{   No = \"No\",   Yes = 1,}console.log(Types.NO,Types.Yes)\n接口枚举\n\n定义一个枚举 Types 定义一个接口 A 他有一个属性 red 值为\nTypes.yyds\n声明对象的时候要遵循这个规则\n\n enum Color{     no = \"NO\",     yes = 1 }interface A{    red:Color.yes}let B:A = {    red:Color.yes    //或者直接red:1，只能填入这两个内容其中之一，其他的会报错}\nconst 枚举\n\nlet 和 var 都是不允许的声明只能使用 const\n大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。\n为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用\nconst 枚举。 常量枚举通过在枚举上使用 const\n修饰符来定义\nconst 声明的枚举会被编译成常量\n普通声明的枚举编译完后是个对象\n\nconst enum Types{//有没有const决定是编译成对象还是编译成常量    sucess,    fail}let code:number = 0if(code === Types.sucess){//是能执行的    console.log(\"我在人民广场吃炸鸡\")}\n反向映射\n\n它包含了正向映射（ name -&gt;\nvalue）和反向映射（ value -&gt;\nname）\n要注意的是 不会为字符串枚举成员生成反向映射。\n\nenum Types{    one}let success:number = Types.oneconsole.log(one)//读取得出来为0\nenum Types{    success}let success:number = Types.successlet key = Types[success]console.log(`value---${success}`,`key----${key}`)//value---0,key----success\n类型推论|类型别名(TS –\n11)代号：幼儿园\n类型推论\n\n我声明了一个变量但是没有定义类型\nTypeScript会在没有明确的指定类型的时候推测出一个类型，这就是类型推论(TS\n本身支持的功能)\n\nlet str = \"小满\";str = 123; //会报错，虽然我们没用明确限制类型，但是TS编辑器会自动推论为string类型。就不能够在赋值给别的类型\n\n如果你声明变量没有定义类型也没有赋值这时候 TS 会推断成 any\n类型可以进行任何操作\n\nlet str; //为any类型str = 123;str = \"马杀鸡\";str = false;str = [];\n联合类型\n\n指定多种类型，在前文有提到\n\ntype s = string | number;let str: s = \"永恒的紫罗兰花园\";let num: s = 520; //这有这两种类型可以\n函数式的类型别名\n\ntype\n关键字（可以给一个类型定义一个名字）多用于符合类型，但也可以要求有固定的东西\n\n定义类型别名\ntype str = string;let s: str = \"我是小满\";console.log(s);\n定义函数别名\ntype str = () =&gt; string;let s: str = () =&gt; \"我是小满\";console.log(s);\n定义联合类型别名\ntype str = string | number;let s: str = 123;let s2: str = \"123\";console.log(s, s2);\n定义值的别名\ntype value = boolean | 0 | \"213\";let s: value = true;//变量s的值  只能是上面value定义的值\n类型别名 type 跟 interface\n的区别\n\n\n区别 1：interface 是可以继承 type 的，但是 type 是没办法继承\ninterface 的，只能够使用&amp;进行合并\n区别 2：interface\n是没办法写联合类型的，必须要里面写一个属性才能够去写联合类型(不能直接在外面添加联合类型)，而\ntype 能够直接写联合类型\n区别 3：interface 重复写是会合并在一起的，type 不行\n\n\n//区别1type s = number[] &amp; B; //使用&amp;合并interface A extends B {\t//interface继承B}interface B {}\n//区别2type s = number[] | string; //type直接写联合类型interface A extends B {\tname: string | number; //要在内部属性才能写联合类型}interface B {}\n//区别3interface A {\tname: string | number;}interface A {\tage: number;} //name跟age会进行合并\n\n\nimage-20230209010245171\n\n类型别名高阶用法\n\nextends ：包含的意思\n左边的值 会作为右边类型的子类型\n\ntype num = 1 extends number ? 1 : 0//返回1//其中除了number之外，其他类型包括any、unknown、Object、Number也都是返回1//类型never返回0//其中的关系图放在下面，他们(类型)是有层级关系的，下面的图由上往下，层级逐级递减//never返回不了1是因为他是最底层的，连1都比不过，包含不了，所以返回0\n\n\nimage-20230209010955388\n\nnever 类型(TS – 12)\n\nTypeScript 将使用 never 类型来表示不应该存在的状态\n返回 never 的函数必须存在无法达到的终点\n\nfunction error(message: string): never {\t//因为必定抛出异常，所以 error 将不会有返回值\tthrow new Error(message);}function loop(): never {\twhile (true) {\t\t//因为这个是死循环，永远不会去返回的\t}}\ninterface A{    type:\"保安\"}interface B{    type:\"草莓\"}interface C{    type:\"卷心菜\"}type All = A|Bfunction type(val:All){    while(val.type){        case \"保安\":break        case \"草莓\":break        //case \"卷心菜\":break        default://兜底机制，此时C没有用上就会报错提示。这就算never的作用        const check:never = val        break    }}\nSymbol 类型\n\nsymbol 是一种新的原生类型，就像 number 和\nstring 一样\nsymbol类型的值是通过Symbol 构造函数创建的\n可以传递参做为唯一标识 只支持 string 和 number 类型的参数\n\nlet s: symbol = Symbol(\"小满\");let num: symbol = Symbol(\"小满\");let obj = {\t[num]: \"value\", //Symbol\t[s]: \"草莓\", //Symbol\tname: \"小满\",\tsex: \"男\",};console.log(obj[num]); //取到valueconsole.log(s, num); //返回Symbol(小满)Symbol(小满)console.log(s === num); //false//这个值看似一样，其实因为内存地址指针位置不同，所以是唯一值for (let key in obj) {\tconsole.log(key);} //只会打印出name跟sex，[num]与[s]将打印不出来console.log(Object.keys(obj)); //[\"name\",\"sex\"]console.log(Object.getOwnPropertyNames(obj)); //[\"name\",\"sex\"]，跟上面一样，打印不出来console.log(JSON.stringify(obj)); //[\"name\":\"小满\",\"sex\":\"男\"]，一样打印不出来\n能够读取到 Symbol 的两种方式\n\n静态方法 Reflect.ownKeys()\n返回一个由目标对象自身的属性键组成的数组(Array)。\n语法：Reflect.ownKeys(target) =&gt;\ntarget获取自身属性键的目标对象。\nReflect.ownKeys\n方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于\nObject.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。\n\nconsole.log(Object.getOwnPropertySymbols(obj)); //能打印出来两个Symbol，另外两个普通的不会打印出来Reflect.ownKeys(); //此属性是将所有的属性都列出来console.log(Reflect.ownKeys(obj)); //四个全部圆满的打印出来\nnever 类型(TS – 12)|重做\n\nnever类型通常用于表示不可能出现的情况，它可以用于增强代码的类型安全性和可读性。\n当一个变量被推断为never类型时，表示该变量的类型不能是任何其他类型，即不存在任何值与其兼容\n\ntype A = string &amp; number; //同时推断A是string和number类型，那显然是不可能的。这时就显示为never类型//当一个函数抛出异常时，其返回类型为never类型。因为抛出异常时，函数永远不会返回任何值(包括void的值)function xy(): never {\t//这里选择never，而不是void。void是指没有返回值，但其实还是会抛出错误的\tthrow new Error(\"小余\");\t//或者while死循环\twhile (true) {\t\t//xxx\t}}//在许多编程语言中，包括 TypeScript，void类型表示函数不返回任何值。这意味着函数执行完毕后不会返回任何内容，而只是执行某些操作或返回到调用方。//然而，当一个函数抛出异常时，它并没有正常地执行完毕。相反，它会在抛出异常的位置停止执行，并将控制权交回到调用方，因此它不会返回任何值，包括void类型的值。//在 TypeScript 中，never类型表示“永远不会发生”的值。函数的返回类型为never时，它表明函数不会正常地返回任何值，而是可能抛出异常、无限循环或导致类型错误等情况。//因此，当一个函数抛出异常时，其返回类型应该是never，而不是void。这有助于编译器在类型检查和推断方面更准确地处理异常情况\n\nnever 是底层的内容，所以在联合类型上面会有问题\n\ntype A = void | number | never; //联合类型中never类型会被忽略掉\n\n\nimage-20230223163056013\n\ntype A = \"唱\" | \"跳\" | \"rap\";function ikun(value: A) {\tswitch (value) {\t\tcase \"唱\":\t\t\tbreak;\t\tcase \"跳\":\t\t\tbreak;\t\tcase \"rap\":\t\t\tbreak;\t\tdefault: //兜底逻辑\t\t\t//最后来到这说明前面都没有生效，那就是超出我们预料的情况，这时候估计就是有问题的\t\t\tconst error: never = value; //看你想写啥来提示自己\t\t\tbreak;\t}}\n迭代器|生成器(TS – 13)\n\n迭代器:Symbol.Iterator\n迭代器（Iterator）是⼀种对象，它能够⽤来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址\n通俗点说，迭代器表现的像指针，读取集合或者数组中的⼀个值，读完以后⼜指向下⼀条数据，⼀个个数过去。\n生成器: for of\n\n迭代器\n\n迭代器Interator 的用法\n1.Interator是 es6 引入的一种新的遍历机制。两个核心：\n\n迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为\nSymbol.Iterator 的方法来实现。\n迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。\n\n使用迭代\n\n使用Symbol.interator 创建一个迭代器\n调用 next 方法向下迭代，next 方法会返回当前的位置\n当 done 为 true 时则遍历结束\n\n注意点：\n\n在迭代器迭代元素的过程中，不允许使⽤集合对象改变集合中的元素个数，如果需要添加或者删除只能使⽤迭代器的⽅法操作。\n如果使⽤了集合对象改变集合中的元素个数那么就会报错：不改变个数即可，替换也可以的。\n迭代器的⽣存周期为创建到使⽤结束的时段。\nforeach : Iterator 的封装变形，变得⽐ Iterator\n更简单。但是他也需要知道数组或集合的类型。并且，Iterator\n需要注意的，foreach 同样需要注意。\n\n\n\n存在 interator 迭代器的有 =&gt;\n\n数组[]里能够找到 Symbol(Symbol.interator)\nargument 内找到 Symbol(Symbol.interator)\nNodeList 内找到 Symbol(Symbol.interator)\nnew set()内的 Prototype 下一层 Symbol(Symbol.interator)\nnew Map 同理，一样有 Symbol(Symbol.interator)\n\n\nlet arr: Array&lt;number&gt; = [1, 5, 6];let it: Intertor&lt;number&gt; = arr[Symbol.interator](); //注意这里的接收类型&lt;number&gt;是固定要写的//next一次只遍历一个数，下一次调用将从上一次遍历到的位置开始下一个console.log(Iterator.next()); //{ value: 1, done: false }console.log(Iterator.next()); //{ value: 5, done: false }console.log(Iterator.next()); //{ value: 6, done: false }console.log(Iterator.next()); //{ value: undefined, done: true }//返回的有两个属性，一个value，一个done。value当读取到值的时候，done为false、读取不到为true\ntype mapKeys = string | number; //相当于起别名，在下方使用的时候集合了string与number就会相对方便不少let set: Set&lt;number&gt; = new Set([1, 2, 3]);let map: Map&lt;mapKeys, mapKeys&gt; = new Map(); //这里断言两个mapKeys，一个对应key，一个对应valuemap.set(\"1\", \"小满\");map.set(\"2\", \"看看腿\");//小迭代器的实现function gen(erg: any) {\t//这里定义为any类型是因为上面要传到这里的有多种不同类型\tlet it: interator&lt;any&gt; = erg[Symbol.interator]();\tlet next: any = { done: false };\twhile (!next.done) {\t\t//判断next，由于next默认为fasle，while循环只有true会通过，所以需要取反\t\tnext = it.next(); //刚开始是声明next给个默认值，等到开始循环的时候再把真正的值赋给他\t\tif (!next.done) {\t\t\tconsole.log(next);\t\t}\t}}gen(arr); //调用第一个代码块的arr，输出了与console.log(Iterator.next());一样的内容//对象是不支持迭代器的使用的，其实我们在控制台输出一个对象，查找他内置的属性，也是找不到Symbol.interator的\nSymbol 列表\nSymbol.hasInstance 方法，会被 instanceof\n运算符调用。构造器对象用来识别一个对象是否是其实例。\nSymbol.isConcatSpreadable\n布尔值，表示当在一个对象上调用 Array.prototype.concat\n时，这个对象的数组元素是否可展开。\nSymbol.Iterator 方法，被 for-of\n语句调用。返回对象的默认迭代器。\nSymbol.match 方法，被 String.prototype.match\n调用。正则表达式用来匹配字符串。\nSymbol.replace 方法，被 String.prototype.replace\n调用。正则表达式用来替换字符串中匹配的子串。\nSymbol.search 方法，被 String.prototype.search\n调用。正则表达式返回被匹配部分在字符串中的索引。\nSymbol.species\n函数值，为一个构造函数。用来创建派生对象。\nSymbol.split 方法，被 String.prototype.split\n调用。正则表达式来用分割字符串。\nSymbol.toPrimitive 方法，被 ToPrimitive\n抽象操作调用。把对象转换为相应的原始值。\nSymbol.toStringTag 方法，被内置方法\nObject.prototype.toString 调用。返回创建对象时默认的字符串描述。\nSymbol.unscopables 对象，它自己拥有的属性会被 with\n作用域排除在外。\n\n生成器（Builder）\n\n又称建造者模式，该模式是一种创建型设计模式，能够分步骤创建复杂对象。该模式允许使用相同的创建代码生成不同类型和形式的对象。\n具体内容请跳转链接查看：设计模式-生成器\nfor…of 语句\nfor…of 会遍历可迭代的对象，调用对象上的\nSymbol.Iterator方法。(此对象非彼对象，这个对象是指你即将下手的目标)\n对象也是不支持的，因为对象没用Symbol.Iterator方法。\n\ntype mapKeys = string | number; //相当于起别名，在下方使用的时候集合了string与number就会相对方便不少let set: Set&lt;number&gt; = new Set([1, 2, 3]);let map: Map&lt;mapKeys, mapKeys&gt; = new Map(); //这里断言两个mapKeys，一个对应key，一个对应valuemap.set(\"1\", \"小满\");map.set(\"2\", \"看看腿\");for (let item of set) {\tconsole.log(item);} //打印出1 2 3for (let item of arr) {\tconsole.log(item);} //打印出4 5 6for (let item of map) {\tconsole.log(item);} //打印出['1','小满']\t['2','看看腿']//其实这就是一个语法糖，将of后面的内容遍历存储到of前面的变量中\n跟 for in 的区别\n\nfor in 循环出来的是索引而不是内容，这个应该是最本质的区别了\n因为 for of 会调用底层 interator 里面那个 list 的.value\n\n泛型(generic) =&gt; (TS – 14 上)\n\n泛型简单来说就是类型变量，在 ts 中存在类型，如\nnumber、string、boolean\n等。泛型就是使用一个类型变量来表示一种类型，类型值通常是在使用的时候才会设置。泛型的使用场景非常多，可以在函数、类、interface\n接口中使用\nTypeScript 中不建议使用 any\n类型，不能保证类型安全，调试时缺乏完整的信息。\nTypeScript\n可以使用泛型来创建可重用的组件。支持当前数据类型，同时也能支持未来的数据类型。扩展灵活，可以在编译时发现类型错误，从而保证了类型安全。\n\n无泛型用法\n//数字类型function num(A: number, B: number): Array&lt;number&gt; {\t//Array&lt;number&gt;为希望返回number类型的数组\treturn [A, B];}num(6, 9);//字符串类型function str(A: string, B: string): Array&lt;string&gt; {\t//Array&lt;number&gt;为希望返回number类型的数组\treturn [A, B];}str(\"小满\", \"穿女装\");\n\n一个笨的方法就像上面那样，也就是说 JS\n提供多少种类型，就需要复制多少份代码，然后改下类型签名。这对程序员来说是致命的。这种复制粘贴增加了出错的概率，使得代码难以维护，牵一发而动全身。并且将来\nJS\n新增新的类型，你仍然需要修改代码，也就是说你的代码对修改开放，这样不好。\n如果你使用 any 的话，怎么写都是 ok 的，\n这就丧失了类型检查的效果。实际上我知道我传给你的是\nstring，返回来的也一定是 string，而 string 上没有 toFixed\n方法，因此需要报错才是我想要的。也就是说我真正想要的效果是：当我用到id的时候，你根据我传给你的类型进行推导。比如我传入的是\nstring，但是使用了 number 上的方法，你就应该报错。\n\n使用泛型优化\n\n为了解决上面的这些问题，我们使用泛型对上面的代码进行重构。和我们的定义不同，这里用了一个\n类型 T，这个 T\n是一个抽象类型，只有在调用的时候才确定它的值，这就不用我们复制粘贴无数份代码了。\n其中 T 代表\nType，在定义泛型时通常用作第一个类型变量名称。但实际上\nT 可以用任何有效名称代替。除了 T\n之外，以下是常见泛型变量代表的意思：\n\nK（Key）：表示对象中的键类型；\nV（Value）：表示对象中的值类型；\nE（Element）：表示元素类型。\n\n\nfunction add&lt;T&gt;(a: T, b: T): Array&lt;T&gt; {\t//通常定义的时候类型是不明确的，所以一般使用T来定义\treturn [a, b];}add &lt; number &gt; (1, 2); //1对应a，2对应b、返回的都是number类型add &lt; string &gt; (\"1\", \"2\"); //这个时候，我们只需要改动这个string，传递到上面的时候就会自动推断为string类型了//甚至我们可以简写add(1, 2);add(\"1\", \"2\"); //编辑器会自动推断类型，但最好还是写一下，如果你知道你具体需要的是什么的话//对泛型进行总结就是：定义前不明确类型，使用的时候再明确类型，能够给我们保留有足够的自由度，又不会像any丧失类型检查的效果\n\n我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。\n\nfunction Sub&lt;T, U&gt;(a: T, b: U): Array&lt;T | U&gt; {\t//这个T跟U随便起名字都行，没有强制规范\tconst params: Array&lt;T | U&gt; = [a, b];\treturn params;}Sub &lt; Boolean, number &gt; (false, 1); //我们这里就将其定义为布尔值类型跟数字类型\n定义泛型接口\n\n声明接口的时候 在名字后面加一个 &lt;参数&gt;\n使用的时候传递类型\n\ninterface MyInter&lt;T&gt; {\t(arg: T): T;}function fn&lt;T&gt;(arg: T): T {\treturn arg;}let result: MyInter&lt;number&gt; = fn;result(123);\n对象字面量泛型\nlet foo: { &lt;T&gt;(arg: T): T };foo = function &lt;T&gt;(arg: T): T {\treturn arg;};foo(123);\n泛型约束(函数类)\n\n我们期望在一个泛型的变量上面，获取其 length\n参数，但是，有的数据类型是没有 length 属性的\n\nfunction getLegnth&lt;T&gt;(arg: T) {\treturn arg.length;}\n\n这个时候，我们就可以对其进行约束\n\ninterface Len{    length:number}function getLegth&lt;T extends Len&gt;(arg:T) {//使用接口让泛型T继承了Len  return arg.length}getLength(1)//这个时候我们这样使用就会提示我们类型\"number\"的参数不能赋给\"Len\"的参数//我们依次对数组、字符串、布尔值都进行尝试，分别为可以、可以、不可以\n泛型约束|泛型类(TS – 14 下)\n使用 keyof 约束对象\n\n其中使用了 TS 泛型和泛型约束。首先定义了 T 类型并使用 extends\n关键字继承 object 类型的子类型，然后使用 keyof 操作符获取 T\n类型的所有键，它的返回 类型是联合 类型，最后利用 extends 关键字约束 K\n类型必须为 keyof T 联合类型的子类型\n\nfunction prop&lt;T, K extends keyof T&gt;(obj: T, key: K) {   return obj[key]}let o = { a: 1, b: 2, c: 3 }prop(o, 'a')prop(o, 'd') //，我们需要约束一下这个o里面并没有的东西，此时就会报错发现找不到//通过提示，我门可以看到类型\"d\"的参数不能赋给类型\"a\"|\"b\"|\"c\"的参数\n泛型类\n\n声明方法跟函数类似名称后面定义 &lt;类型&gt;\n使用的时候确定类型 new Sub()\n\n//定义泛型的一个类class Sub&lt;T&gt;{    attr:T[] = []//这里的:只是普通的：    add(a:T):T[]{        return [a]    }}let s = new Sub&lt;number&gt;()//这里已经使用泛型固定为number了s.attr = [123]//正常运行s.attr = ['123']//报错s.add(123)//也是只能传数字let str = new Sub&lt;string&gt;()//这里已经使用泛型固定为number了str.attr = [123]//报错str.attr = ['123']//正常运行str.add('123')//也是只能传字符串console.log(s,str)\n泛型工具类型(大量补充额外内容)\n\n作者使用了 Typora\n作为写笔记的编辑器，这里可以对目录进行折叠方面我们查阅我们想要的部分\n\n\n为了方便开发者 TypeScript 内置了一些常用的工具类型，比如\nPartial、Required、Readonly、Record 和 ReturnType\n等。不过在具体介绍之前，我们得先介绍一些相关的基础知识，方便读者可以更好的学习其它的工具类型。\n1.typeof\ntypeof\n的主要用途是在类型上下文中获取变量或者属性的类型，下面我们通过一个具体示例来理解一下。\ninterface Person {\tname: string;\tage: number;}const sem: Person = { name: \"semlinker\", age: 30 };type Sem = typeof sem; // type Sem = Person\n在上面代码中，我们通过 typeof 操作符获取 sem\n变量的类型并赋值给 Sem 类型变量，之后我们就可以使用 Sem 类型：\nconst lolo: Sem = { name: \"lolo\", age: 5 };\n你也可以对嵌套对象执行相同的操作：\nconst Message = {\tname: \"jimmy\",\tage: 18,\taddress: {\t\tprovince: \"四川\",\t\tcity: \"成都\",\t},};type message = typeof Message;/* type message = {    name: string;    age: number;    address: {        province: string;        city: string;    };}*/\n此外，typeof\n操作符除了可以获取对象的结构类型之外，它也可以用来获取函数对象的类型，比如：\nfunction toArray(x: number): Array&lt;number&gt; {\treturn [x];}type Func = typeof toArray; // -&gt; (x: number) =&gt; number[]\n2.keyof\nkeyof 操作符是在 TypeScript 2.1\n版本引入的，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。\ninterface Person {  name: string;  age: number;}type K1 = keyof Person; // \"name\" | \"age\"type K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\"type K3 = keyof { [x: string]: Person };  // string | number\n在 TypeScript 中支持两种索引签名，数字索引和字符串索引：\ninterface StringArray {\t// 字符串索引 -&gt; keyof StringArray =&gt; string | number\t[index: string]: string;}interface StringArray1 {\t// 数字索引 -&gt; keyof StringArray1 =&gt; number\t[index: number]: string;}\n为了同时支持两种索引类型，就得要求数字索引的返回值必须是字符串索引返回值的子类。其中的原因就是当使用数值索引时，JavaScript\n在执行索引操作时，会先把数值索引先转换为字符串索引。所以\nkeyof { [x: string]: Person } 的结果会返回\nstring | number。\nkeyof 也支持基本数据类型：\nlet K1: keyof boolean; // let K1: \"valueOf\"let K2: keyof number; // let K2: \"toString\" | \"toFixed\" | \"toExponential\" | ...let K3: keyof symbol; // let K1: \"valueOf\"\nkeyof 的作用\nJavaScript\n是一种高度动态的语言。有时在静态类型系统中捕获某些操作的语义可能会很棘手。以一个简单的\nprop 函数为例：\nfunction prop(obj, key) {\treturn obj[key];}\n该函数接收 obj 和 key\n两个参数，并返回对应属性的值。对象上的不同属性，可以具有完全不同的类型，我们甚至不知道\nobj 对象长什么样。\n那么在 TypeScript 中如何定义上面的 prop\n函数呢？我们来尝试一下：\nfunction prop(obj: object, key: string) {\treturn obj[key];}\n在上面代码中，为了避免调用 prop 函数时传入错误的参数类型，我们为 obj\n和 key 参数设置了类型，分别为 {} 和 string\n类型。然而，事情并没有那么简单。针对上述的代码，TypeScript\n编译器会输出以下错误信息：\nElement implicitly has an 'any' type because expression of type 'string' can't be used to index type '{}'.\n元素隐式地拥有 any 类型，因为 string\n类型不能被用于索引 {}\n类型。要解决这个问题，你可以使用以下非常暴力的方案：\nfunction prop(obj: object, key: string) {  return (obj as any)[key];}\n很明显该方案并不是一个好的方案，我们来回顾一下 prop\n函数的作用，该函数用于获取某个对象中指定属性的属性值。因此我们期望用户输入的属性是对象上已存在的属性，那么如何限制属性名的范围呢？这时我们可以利用本文的主角\nkeyof 操作符：\nfunction prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) {  return obj[key];}\n在以上代码中，我们使用了 TypeScript\n的泛型和泛型约束。首先定义了 T 类型并使用 extends\n关键字约束该类型必须是 object 类型的子类型，然后使用 keyof\n操作符获取 T 类型的所有键，其返回类型是联合类型，最后利用\nextends 关键字约束 K 类型必须为 keyof T\n联合类型的子类型。\n是骡子是马拉出来遛遛就知道了，我们来实际测试一下：\ntype Todo = {  id: number;  text: string;  done: boolean;}const todo: Todo = {  id: 1,  text: \"Learn TypeScript keyof\",  done: false}function prop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K) {  return obj[key];}const id = prop(todo, \"id\"); // const id: numberconst text = prop(todo, \"text\"); // const text: stringconst done = prop(todo, \"done\"); // const done: boolean\n很明显使用泛型，重新定义后的\nprop&lt;T extends object, K extends keyof T&gt;(obj: T, key: K)\n函数，已经可以正确地推导出指定键对应的类型。那么当访问 todo\n对象上不存在的属性时，会出现什么情况？比如：\nconst date = prop(todo, \"date\");\n对于上述代码，TypeScript 编译器会提示以下错误：\nArgument of type '\"date\"' is not assignable to parameter of type '\"id\" | \"text\" | \"done\"'.\n这就阻止我们尝试读取不存在的属性。\n3.in\nin 用来遍历联合类型：\ntype Keys = \"a\" | \"b\" | \"c\"type Obj =  {  [p in Keys]: any} // -&gt; { a: any, b: any, c: any }\n4.infer\n在条件类型语句中，可以用 infer\n声明一个类型变量并且对它进行使用。\ntype ReturnType&lt;T&gt; = T extends (  ...args: any[]) =&gt; infer R ? R : any;\n以上代码中 infer R\n就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。\n5.extends\n有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过\nextends 关键字添加泛型约束。\ninterface Lengthwise {  length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {  console.log(arg.length);  return arg;}\n现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\nloggingIdentity(3); // Error, number doesn't have a .length property\n这时我们需要传入符合约束类型的值，必须包含 length 属性：\nloggingIdentity({ length: 10, value: 3 });\n索引类型\n在实际开发中，我们经常能遇到这样的场景，在对象中获取一些属性的值，然后建立对应的集合。\nlet person = {\tname: \"musion\",\tage: 35,};function getValues(person: any, keys: string[]) {\treturn keys.map(key =&gt; person[key]);}console.log(getValues(person, [\"name\", \"age\"])); // ['musion', 35]console.log(getValues(person, [\"gender\"])); // [undefined]\n在上述例子中，可以看到 getValues (persion, [‘gender’]) 打印出来的是\n[undefined]，但是 ts 编译器并没有给出报错信息，那么如何使用 ts\n对这种模式进行类型约束呢？这里就要用到了索引类型，改造一下 getValues\n函数，通过 索引类型查询和 索引访问\n操作符：\nfunction getValues&lt;T, K extends keyof T&gt;(person: T, keys: K[]): T[K][] {  return keys.map(key =&gt; person[key]);}interface Person {    name: string;    age: number;}const person: Person = {    name: 'musion',    age: 35}getValues(person, ['name']) // ['musion']getValues(person, ['gender']) // 报错：// Argument of Type '\"gender\"[]' is not assignable to parameter of type '(\"name\" | \"age\")[]'.// Type \"gender\" is not assignable to type \"name\" | \"age\".\n编译器会检查传入的值是否是 Person\n的一部分。通过下面的概念来理解上面的代码：\nT[K]表示对象T的属性K所表示的类型，在上述例子中，T[K][] 表示变量T取属性K的值的数组// 通过[]索引类型访问操作符, 我们就能得到某个索引的类型class Person {    name:string;    age:number; } type MyType = Person['name'];  //Person中name的类型为string type MyType = string\n介绍完概念之后，应该就可以理解上面的代码了。首先看泛型，这里有 T 和 K\n两种类型，根据类型推断，第一个参数 person 就是 person，类型会被推断为\nPerson。而第二个数组参数的类型推断（K extends keyof T），keyof\n关键字可以获取 T，也就是 Person 的所有属性名，即 [‘name’, ‘age’]。而\nextends 关键字让泛型 K 继承了 Person 的所有属性名，即 [‘name’,\n‘age’]。这三个特性组合保证了代码的动态性和准确性，也让代码提示变得更加丰富了\ngetValues(person, [\"gender\"]); // 报错：// Argument of Type '\"gender\"[]' is not assignable to parameter of type '(\"name\" | \"age\")[]'.// Type \"gender\" is not assignable to type \"name\" | \"age\".\n映射类型\n\n根据旧的类型创建出新的类型，我们称之为映射类型\n\n比如我们定义一个接口\ninterface TestInterface {\tname: string;\tage: number;}\n我们把上面定义的接口里面的属性全部变成可选\n// 我们可以通过+/-来指定添加还是删除type OptionalTestInterface&lt;T&gt; = {  [p in keyof T]+?:T[p]}type newTestInterface = OptionalTestInterface&lt;TestInterface&gt;// type newTestInterface = {//    name?:string,//    age?:number// }\n比如我们再加上只读\ntype OptionalTestInterface&lt;T&gt; = { +readonly [p in keyof T]+?:T[p]}type newTestInterface = OptionalTestInterface&lt;TestInterface&gt;// type newTestInterface = {//   readonly name?:string,//   readonly age?:number// }\n由于生成只读属性和可选属性比较常用，所以 TS\n内部已经给我们提供了现成的实现 Readonly / Partial,\n会面内置的工具类型会介绍.\n内置的工具类型\nPartial\n\nPartial&lt;T&gt; 将类型的属性变成可选\n\n定义\ntype Partial&lt;T&gt; = {  [P in keyof T]?: T[P];};\n在以上代码中，首先通过 keyof T 拿到 T\n的所有属性名，然后使用 in 进行遍历，将值赋给\nP，最后通过 T[P] 取得相应的属性值的类。中间的\n? 号，用于将所有属性变为可选。\n举例说明\ninterface UserInfo {\tid: string;\tname: string;}// error：Property 'id' is missing in type '{ name: string; }' but required in type 'UserInfo'const xiaoming: UserInfo = {\tname: \"xiaoming\",};\n使用 Partial&lt;T&gt;\ntype NewUserInfo = Partial&lt;UserInfo&gt;;const xiaoming: NewUserInfo = {\tname: \"xiaoming\",};\n这个 NewUserInfo 就相当于\ninterface NewUserInfo {\tid?: string;\tname?: string;}\n但是 Partial&lt;T&gt;\n有个局限性，就是只支持处理第一层的属性，如果我的接口定义是这样的\ninterface UserInfo {\tid: string;\tname: string;\tfruits: {\t\tappleNumber: number,\t\torangeNumber: number,\t};}type NewUserInfo = Partial&lt;UserInfo&gt;;// Property 'appleNumber' is missing in type '{ orangeNumber: number; }' but required in type '{ appleNumber: number; orangeNumber: number; }'.const xiaoming: NewUserInfo = {\tname: \"xiaoming\",\tfruits: {\t\torangeNumber: 1,\t},};\n可以看到，第二层以后就不会处理了，如果要处理多层，就可以自己实现\nDeepPartial(非内置)\ntype DeepPartial&lt;T&gt; = {     // 如果是 object，则递归类型    [U in keyof T]?: T[U] extends object      ? DeepPartial&lt;T[U]&gt;      : T[U]};type PartialedWindow = DeepPartial&lt;T&gt;; // 现在T上所有属性都变成了可选啦\nRequired\n\nRequired 将类型的属性变成必选\n\n定义\ntype Required&lt;T&gt; = {    [P in keyof T]-?: T[P]};\n其中 -? 是代表移除 ? 这个 modifier\n的标识。再拓展一下，除了可以应用于 ? 这个 modifiers\n，还有应用在 readonly ，比如 Readonly&lt;T&gt;\n这个类型\ntype Readonly&lt;T&gt; = {    readonly [p in keyof T]: T[p];}\nReadonly\n\nReadonly&lt;T&gt;\n的作用是将某个类型所有属性变为只读属性，也就意味着这些属性不能被重新赋值。\n\n定义\ntype Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P];};\n举例说明\ninterface Todo {\ttitle: string;}const todo: Readonly&lt;Todo&gt; = {\ttitle: \"Delete inactive users\",};todo.title = \"Hello\"; // Error: cannot reassign a readonly property\nPick\n\nPick 从某个类型中挑出一些属性出来\n\n定义\ntype Pick&lt;T, K extends keyof T&gt; = {    [P in K]: T[P];};\n举例说明\ninterface Todo {\ttitle: string;\tdescription: string;\tcompleted: boolean;}type TodoPreview = Pick&lt;Todo, \"title\" | \"completed\"&gt;;const todo: TodoPreview = {\ttitle: \"Clean room\",\tcompleted: false,};\n可能是TodoPreview中只有title和completed属性\nRecord\n\nRecord&lt;K extends keyof any, T&gt; 的作用是将\nK 中所有的属性的值转化为 T 类型。\n\n定义\ntype Record&lt;K extends keyof any, T&gt; = {    [P in K]: T;};\n举例说明\ninterface PageInfo {\ttitle: string;}type Page = \"home\" | \"about\" | \"contact\";const x: Record&lt;Page, PageInfo&gt; = {\tabout: { title: \"about\" },\tcontact: { title: \"contact\" },\thome: { title: \"home\" },};\nReturnType\n\n用来得到一个函数的返回值类型\n\n定义\ntype ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (  ...args: any[]) =&gt; infer R  ? R  : any;\ninfer\n在这里用于提取函数类型的返回值类型。ReturnType&lt;T&gt;\n只是将 infer R 从参数位置移动到返回值位置，因此此时 R\n即是表示待推断的返回值类型。\n举例说明\ntype Func = (value: number) =&gt; string;const foo: ReturnType&lt;Func&gt; = \"1\";\nReturnType 获取到 Func 的返回值类型为\nstring，所以，foo\n也就只能被赋值为字符串了。\nExclude\n\nExclude&lt;T, U&gt;\n的作用是将某个类型中属于另一个的类型移除掉。\n\n定义\ntype Exclude&lt;T, U&gt; = T extends U ? never : T;\n如果 T 能赋值给 U 类型的话，那么就会返回\nnever 类型，否则返回 T\n类型。最终实现的效果就是将 T 中某些属于 U\n的类型移除掉。\n举例说明\ntype T0 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\"&gt;; // \"b\" | \"c\"type T1 = Exclude&lt;\"a\" | \"b\" | \"c\", \"a\" | \"b\"&gt;; // \"c\"type T2 = Exclude&lt;string | number | (() =&gt; void), Function&gt;; // string | number\nExtract\n\nExtract&lt;T, U&gt; 的作用是从 T 中提取出\nU。\n\n定义\ntype Extract&lt;T, U&gt; = T extends U ? T : never;\n举例说明\ntype T0 = Extract&lt;\"a\" | \"b\" | \"c\", \"a\" | \"f\"&gt;; // \"a\"type T1 = Extract&lt;string | number | (() =&gt; void), Function&gt;; // () =&gt;void\nOmit\n\nOmit&lt;T, K extends keyof any&gt; 的作用是使用\nT 类型中除了 K\n类型的所有属性，来构造一个新的类型。\n\n定义\ntype Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;\n举例说明\ninterface Todo {\ttitle: string;\tdescription: string;\tcompleted: boolean;}type TodoPreview = Omit&lt;Todo, \"description\"&gt;;const todo: TodoPreview = {\ttitle: \"Clean room\",\tcompleted: false,};\nNonNullable\n\nNonNullable&lt;T&gt; 的作用是用来过滤类型中的\nnull 及 undefined 类型。\n\n定义\ntype NonNullable&lt;T&gt; = T extends null | undefined ? nerver : T\n举例说明\ntype T0 = NonNullable&lt;string | number | undefined&gt;; // string | numbertype T1 = NonNullable&lt;string[] | null | undefined&gt;; // string[]\nParameters\n\nParameters&lt;T&gt;\n的作用是用于获得函数的参数类型组成的元组类型。\n\n定义\ntype Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: infer P) =&gt; any? P : never;\n举例说明\ntype A = Parameters&lt;() =&gt; void&gt;; // []type B = Parameters&lt;typeof Array.isArray&gt;; // [any]type C = Parameters&lt;typeof parseInt&gt;; // [string, (number | undefined)?]type D = Parameters&lt;typeof Math.max&gt;; // number[]\ntsconfig.json 配置文件(TS –\n15)\n生成 tsconfig.json 文件\n\n这个文件是通过 tsc --init 命令生成的\ntsconfig.json 是 TypeScript 项目的配置文件。如果一个目录下存在一个\ntsconfig.json 文件，那么往往意味着这个目录就是 TypeScript\n项目的根目录。\ntsconfig.json 包含 TypeScript\n编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出\nES6、ES5、node 的代码。\n\n配置详解\n\"compilerOptions\": {  \"incremental\": true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度  \"tsBuildInfoFile\": \"./buildFile\", // 增量编译文件的存储位置  \"diagnostics\": true, // 打印诊断信息  \"target\": \"ES5\", // 目标语言的版本  \"module\": \"CommonJS\", // 生成代码的模板标准  \"outFile\": \"./app.js\", // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置\"module\": \"AMD\",  \"lib\": [\"DOM\", \"ES2015\", \"ScriptHost\", \"ES2019.Array\"], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入\"ES2019.Array\",  \"allowJS\": true, // 允许编译器编译JS，JSX文件  \"checkJs\": true, // 允许在JS文件中报错，通常与allowJS一起使用  \"outDir\": \"./dist\", // 指定输出目录  \"rootDir\": \"./\", // 指定输出文件目录(用于输出)，用于控制输出目录结构  \"declaration\": true, // 生成声明文件，开启后会自动生成声明文件  \"declarationDir\": \"./file\", // 指定生成声明文件存放目录  \"emitDeclarationOnly\": true, // 只生成声明文件，而不会生成js文件  \"sourceMap\": true, // 生成目标文件的sourceMap文件  \"inlineSourceMap\": true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中  \"declarationMap\": true, // 为声明文件生成sourceMap  \"typeRoots\": [], // 声明文件目录，默认时node_modules/@types  \"types\": [], // 加载的声明文件包  \"removeComments\":true, // 删除注释  \"noEmit\": true, // 不输出文件,即编译后不会生成任何js文件  \"noEmitOnError\": true, // 发送错误时不输出任何文件  \"noEmitHelpers\": true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用  \"importHelpers\": true, // 通过tslib引入helper函数，文件必须是模块  \"downlevelIteration\": true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现  \"strict\": true, // 开启所有严格的类型检查  \"alwaysStrict\": true, // 在代码中注入'use strict'  \"noImplicitAny\": true, // 不允许隐式的any类型  \"strictNullChecks\": true, // 不允许把null、undefined赋值给其他类型的变量  \"strictFunctionTypes\": true, // 不允许函数参数双向协变  \"strictPropertyInitialization\": true, // 类的实例属性必须初始化  \"strictBindCallApply\": true, // 严格的bind/call/apply检查  \"noImplicitThis\": true, // 不允许this有隐式的any类型  \"noUnusedLocals\": true, // 检查只声明、未使用的局部变量(只提示不报错)  \"noUnusedParameters\": true, // 检查未使用的函数参数(只提示不报错)  \"noFallthroughCasesInSwitch\": true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)  \"noImplicitReturns\": true, //每个分支都会有返回值  \"esModuleInterop\": true, // 允许export=导出，由import from 导入  \"allowUmdGlobalAccess\": true, // 允许在模块中全局变量的方式访问umd模块  \"moduleResolution\": \"node\", // 模块解析策略，ts默认用node的解析策略，即相对的方式导入  \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录  \"paths\": { // 路径映射，相对于baseUrl    // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置    \"jquery\": [\"node_modules/jquery/dist/jquery.min.js\"]  },  \"rootDirs\": [\"src\",\"out\"], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错  \"listEmittedFiles\": true, // 打印输出文件  \"listFiles\": true// 打印编译的文件(包括引用的声明文件)}// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）\"include\": [   \"src/**/*\"],// 指定一个排除列表（include的反向操作） \"exclude\": [   \"demo.ts\"],// 指定哪些文件使用该配置（属于手动一个个指定文件） \"files\": [   \"demo.ts\"]\n\n上面的配置详解有点繁杂，我们或许可以将其分类一下\n\n配置分类(compilerOptions\n选项)\n{  \"compilerOptions\": {    /* 基本选项 */    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'    \"module\": \"commonjs\",                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'    \"lib\": [],                             // 指定要包含在编译中的库文件    \"allowJs\": true,                       // 允许编译 javascript 文件    \"checkJs\": true,                       // 报告 javascript 文件中的错误    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'    \"declaration\": true,                   // 生成相应的 '.d.ts' 文件    \"sourceMap\": true,                     // 生成相应的 '.map' 文件    \"outFile\": \"./\",                       // 将输出文件合并为一个文件    \"outDir\": \"./\",                        // 指定输出目录    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.    \"removeComments\": true,                // 删除编译后的所有的注释    \"noEmit\": true,                        // 不生成输出文件    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.    /* 严格的类型检查选项 */    \"strict\": true,                        // 启用所有严格类型检查选项    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错    \"strictNullChecks\": true,              // 启用严格的 null 检查    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'    /* 额外的检查 */    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）    /* 模块解析选项 */    \"moduleResolution\": \"node\",            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容    \"typeRoots\": [],                       // 包含类型声明的文件列表    \"types\": [],                           // 需要包含的类型声明文件名列表    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。    /* Source Map Options */    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性    /* 其他选项 */    \"experimentalDecorators\": true,        // 启用装饰器    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持  }}\n常用的配置\n\n终端命令\n\necho ’’&gt;index.ts(创建一个空的名叫 index.ts 的文件)\ntsc -init(创建一个 tsconfig.json)\ndel index.js(删除名叫 index.js 文件)\nmkdir dist(创建一个名叫 dist 的文件夹)\ntsc(运行)\n\n\n\n1.include\n指定编译文件默认是编译当前目录下所有的 ts 文件\n\n\n这个是在中括号中填入路径，路径指向的那个 ts 文件会被编译出一个 js\n文件出来。这个我们就可以用来编译指定文件\n\n\n2.exclude\n指定排除的文件\n\n\n跟include反过来了，除了写入的路径之外，其他全部编译\n\n\n3.target\n指定编译 js 的版本例如 es5 es6\n\n\n有些低配置的浏览器是不兼容 es6 的，这个时候我们就可以将其编译成 es5\n使其适配\n\n\n4.allowJS\n是否允许编译 js 文件\n\n\n是否允许 TypeScript 帮你编译 js 文件，默认是不允许的\n\n\n5.removeComments\n是否在编译过程中删除文件中的注释\n\n\n6.rootDir\n编译文件的目录\n\n\n7.outDir\n输出的目录\n\n\n改变输出的目录，也就是编译后输出到这里设置的文件夹目录中\n\n\n8.sourceMap\n代码源文件\n\n\n这个文件会打包压缩成一行，sourceMap\n会记录行数，到时候会比较好找\n\n\n9.strict\n严格模式\n\n严格模式的限制\n\n严格模式主要有以下限制：\n\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用 with 语句\n不能对只读属性赋值，否则报错\n不能使用前缀 0 表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量 delete prop，会报错，只能删除属性 delete global\n[prop]\neval 不会在它的外层作用域引入变量\neval 和 arguments 不能被重新赋值\narguments 不会自动反映函数参数的变化\n不能使用 arguments.callee\n不能使用 arguments.caller\n禁止 this 指向全局对象\n不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈\n增加了保留字（比如 protected、static 和 interface）\n\n要注意 this 的限制。ES6 模块之中，顶层的 this 指向\nundefined，即不应该在顶层代码使用 this。\n\n\n10.module\n默认 common.js 可选 es6 模式 amd umd 等\n\nnamespace 命名空间(TS – 16)\n我们在工作中无法避免全局变量造成的污染，TypeScript\n提供了 namespace 避免这个问题出现\n\n内部模块，主要用于组织代码，避免命名冲突。\n命名空间内的类默认私有\n通过 export 暴露\n通过 namespace 关键字定义\n\n\nTypeScript 与 ECMAScript 2015 一样，任何包含顶级 import\n或者 export\n的文件都被当成一个模块。相反地，如果一个文件不带有顶级的\nimport 或者 export\n声明，那么它的内容被视为全局可见的（因此对模块也是可见的）\n\n\n命名空间中通过 export\n将想要暴露的部分导出\n如果不用 export 导出是无法读取其值的\n\nnamespace a {    export const Time: number = 1000    export const fn = &lt;T&gt;(arg: T): T =&gt; {        return arg    }    fn(Time)}namespace b {     export const Time: number = 1000     export const fn = &lt;T&gt;(arg: T): T =&gt; {        return arg    }    fn(Time)}a.Timeb.Time\n\n案例\n\n//文件1与文件2位于同一文件夹下//文件1 =&gt; index.tsconst aa = 23;//文件3 =&gt; index2.tsconst aa = 66; //此时就会报错，因为我们在文件1已经声明过aa了\n//文件1 =&gt; index.tsnamespace A{    export const aa =23}//文件2 =&gt; index.tsnamespace B{    export const aa =66}//不会报错//要读取的话怎么做呢？此时在文件1console.log(A.a);//像使用对象一样。实际上也确实包了一层对象\n\n实际编译成 js 文件的样子\n\n\"use strict\";var A;(function (A) {\tA.a = 1;})(A || (A = {}));console.log(A, a);//到此js文件所在目录下使用node index.js运行，输出1\n嵌套命名空间\n\n就是提取内容的时候需要多.几次。比如下方，原本只需要 a.b，现在需要\na.b.value\n编译成 js 文件的话，就是在 function 又套了一层\n\nnamespace a {    export namespace b {        export class Vue {            parameters: string            constructor(parameters: string) {                this.parameters = parameters            }        }    }}let v = a.b.Vuenew v('1')\n抽离命名空间\n\n将命名空间的内容抽离出来，通过 import 引入到其他文件中使用\n\n//在index2.ts文件下expost namespace B{    export const a = 2}//在index.ts文件下import xx from './index2.ts'namespace A{    export namespace C{        export const D = 5    }}console.log(A.C.D,B)//将B抽离成了文件//将此文件用tsc进行终端编译，然后在tscondig.json将module修改为CommonJs(node.js不认识defined，node.js是基于CommonJS的)，进去js文件夹、终端运行node index\n简化命名空间\n\n可以给命名空间路径起个名字，然后直接使用这个名字就可以代替命名空间路径了\n这个是不能够在 ts-node 的环境下去使用的\n\n//在index2.ts文件下expost namespace B{    export const a = 2}//在index.ts文件下import xx from './index2.ts'namespace A{    export namespace C{        export const D = 5    }}console.log(A.C.D,B)//将B抽离成了文件import AAA = A.C.Dconsole.log(AAA)//起到跟A.C.D一样的作用import AAA = A.Cconsole.log(AAA.D)//起到跟A.C.D一样的作用\n命名空间的合并\n\n如果命名空间的命名一样的话(重名)，会自动合并\n\n//案例1namespace A{    export const b = 2}namespace A{    export const d = 3}//案例2namespace A{    export const b = 2    export const d = 3//案例1跟案例2是一模一样的，会自动合并}\n三斜线指令(TS – 17)\n\n三斜线指令是包含单个XML标签的单行注释。\n注释的内容会做为编译器指令使用。\n三斜线指令仅可放在包含它的文件的最顶端。\n一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。\n如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。\n/// &lt;reference path=\"...\" /&gt;指令是三斜线指令中最常见的一种。\n它用于声明文件间的 依赖。\n三斜线引用告诉编译器在编译过程中要引入的额外的文件。也可以认为是另一个\nimport\n你也可以把它理解能\nimport，它可以告诉编译器在编译过程中要引入的额外的文件\n相较于抽离命名空间。范围更广，将整个文件都抽离出来了。\n\n//在a.tsnamespace A {    export const fn = () =&gt; 'a'}//在b.tsnamespace A {    export const fn2 = () =&gt; 'b'}//在index.ts///&lt;reference path=\"./a.ts\" /&gt;///&lt;reference path=\"./b.ts\" /&gt;//引入之后直接可以使用变量 Aconsole.log(A);\n\n这个时候小满将 outFile\n打开了，这个的作用是：将输出文件合并为一个文件，并编译到指定的路径中\n这个时候样式的还在\n这个时候，我们再打开\nremoveComments，他的作用是：删除编译后的所有的注释\n编译好后，那些样式就不在了\n\n引入声明文件\n\n例如，把 /// &lt;reference types=\"node\" /&gt;\n引入到声明文件，表明这个文件使用了 @types/node/index.d.ts\n里面声明的名字；\n并且，这个包需要在编译阶段与声明文件一起被包含进来。\n仅当在你需要写一个 d.ts 文件时才使用这个指令。\n使用的话，需要将声明文件装起来(npm install @types/node -D)\n\n///&lt;reference types=\"node\" /&gt;//这个node文件他会自己去找\n声明文件 d.ts(TS – 18)\n\n声明文件 declare ，d.ts 中 d 的简写\n当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。\n\ndeclare var       声明全局变量declare function  声明全局方法declare class     声明全局类declare enum      声明全局枚举类型declare namespace 声明（含有子属性的）全局对象interface 和 type 声明全局类型/// &lt;reference /&gt; 三斜线指令\n\n先：npm init -y\nnpm init -y 在文件夹下生成默认的\npackage.json 文件，使用命令生成的 package.json\n文件内容与不使用命令生产的不一样\n后：npm install express -S 正式线安装\nnpm install axios\n\n\n从node_modules的axios的 package.json\n可以发现 types:“index.d.ts”，可以发现声明文件已经被指定了\n\n我们在去看 index.d.ts 文件可以看到最后通过 declare 将其导出了\n\n在引入使用的时候，发现 express 在引入的时候爆红了\n\n同样的在 node_nodules 可以找到 express 中的\npackage.json，发现他根本没有\ntypes，也就是说没有指定声明文件。所以才会有爆红的这个问题\n我们可以在根目录下创建一个 express.d.ts 文件\n在文件中写入declare var express:() =&gt; any\n这个时候，我们在使用 express\n的时候，就发现可以使用了express()，不会爆红了\n另一种方法就是按照提示去装包，然后去 tsconfig.json\n去导出一下\"allowSyntheticDefaultImports\":true进行补全\n\n\nnpm\n收录包大全\n\nTS\n没有流行起来的部分原因：有些第三方库没有写声明文件，那就没有提示还会报错了\n给出了提示让你试一试npm i --save-dev @types/express，@types\n是编写声明文件库的规范格式。\n如果装不上就说明社区没有写声明文件\n\n\n\nimage-20230223170402601\n\n//index.ts文件，用来使用express，为了不报错，我们要在后面自己写express的声明文件(当然这只是个例子，espress是有声明文件可以直接下载的)import express from \"express\";xiaoyu = \"大二学生\";const app = express();const router = express.Router();app.use(\"/api\", router);router.get(\"/list\", (req, res) =&gt; {\tres.json({\t\tcode: 200,\t});});app.listen(9001, () =&gt; {\t//监听端口\tconsole.log(9001);});\n//我们进行编写express.d.ts文件declare module 'express' {    interface Router {      //我们上面使用了两个参数，这里对其进行定义        get(path: string, cb: (req: any, res: any) =&gt; void): void    }    interface App {        use(path: string, router: any): void        listen(port: number, cb?: () =&gt; void): void    }    interface Express {        (): App        Router(): Router    }  \t//定义全局变量，那就能够在index.js中直接使用  \tdeclare var xiaoyu:string  \t//扩充函数，类，枚举等等都是可以的，然后直接在index直接使用    const express: Express    export default express}\nMixins 混入(TS – 19)\n\nTypeScript 混入 Mixins 其实 vue 也有 mixins 这个东西\n你可以把他看作为合并\n\n对象混入\n\n可以使用 ES6 的 Object.assign 合并多个对象\n此时 people 会被推断成一个交差类型 Name &amp; Age &amp; sex;\nObject.assign()\n\nObject.assign () 这个方法来实现浅复制\n主要的用途是用来合并多个 JavaScript 的对象\nObject.assign ()\n接口可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign\n方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）\nObject.assign\n拷贝的属性是有限制的，只会拷贝对象本身的属性（不会拷贝继承属性），也不会拷贝不可枚举的属性\nObject.assign 不会跳过那些值为 [null] 或 [undefined] 的源对象\n\n\ninterface Name {\tname: string;}interface Age {\tage: number;}interface Sex {\tsex: number;}let people1: Name = { name: \"小满\" };let people2: Age = { age: 20 };let people3: Sex = { sex: 1 };//Object.assign(a,b,c)const people = Object.assign(people1, people2, people3);\n类的混入\n\n首先声明两个 mixins 类 （严格模式要关闭不然编译不过）\n\n//混入类class A {\ttype: boolean;\tchangeType() {\t\tthis.type = !this.type;\t}}class B {\tname: string;\tgetName() {\t\treturn this.name;\t}}//实现类\t首先应该注意到的是，没使用 extends 而是使用 implements。 把类当成了接口。我们可以这么做来达到目的，为将要 mixin 进来的属性方法创建出占位属性。 这告诉编译器这些成员在运行时是可用的。 这样就能使用 mixin 带来的便利，虽说需要提前定义一些占位属性class C implements A, B {\t//这个时候编辑器会给出提示类\"C\"错误实现\"A\"。你是想扩展\"A\"并将其成员作为子继承吗？\t//类型\"C\"缺少类型\"A\"中的以下属性:type,changeType\t//B类同理\t//这个时候就需要我们提前定义占位符\ttype: boolean = false;\tname: string = \"小余\";\tchangeType: () =&gt; void;\tgetName: () =&gt; string;}mixins(C, [A, B]); //第一个为目标对象，后面为要混入的对象//最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 mixins 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码//帮助函数，把我们在实现类中写的去进行一个实现function mixins(curClas: any, itemCls: any[]) {\titemCls.forEach(item =&gt; {\t\tconsole.log(item); //输出[class A][class B]，我们要读取的不是这个，而是他原型上的一些属性\t\tObject.getOwnPropertyNames(item.prototype).forEach(name =&gt; {\t\t\t//Object.getOwnPropertyNames () 可以获取对象自身的属性，除去他继承来的属性，对它所有的属性遍历，它是一个数组，遍历一下它所有的属性名\t\t\tconsole.log(name); //打印出来了changeType跟getName\t\t\tcurClas.prototype[name] = item.prototype[name];\t\t});\t});}let ccc = new C(); //实例化一下console.log(ccc.type); //falseccc.changeType(); //这里切换了布尔值console.log(ccc.type); //true\n装饰器 Decorator(TS – 20)\n\nDecorator 装饰器是一项实验性特性，在未来的版本中可能会发生改变\n它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能\n若要启用实验性的装饰器特性，你必须在命令行或\ntsconfig.json 里启用编译器选项\n启用的名字叫experimentalDecorators\n\n装饰器\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、访问符、属性或者参数上\n通过@语法糖实现\n使用方法：对于这个的实现我认为就是定义好了之后直接盖在你想对其使用目标的头顶上\n\n\n以下两个代码块的 watcher 都是不支持传参的\n\nconst watcher: ClassDecorator = (target: Function) =&gt; {\tconsole.log(target);};@watcher //通过@去使用，会回传一个构造函数，也就是targetclass A {}//通过ts-node xxx打印出来的结果为[class A]\n\n知识点复习：\nprototype\n对象是实现面向对象的一个重要机制。每个函数也是一个对象，它们对应的类就是\nfunction，每个函数对象都具有一个子对象 prototype。\nPrototype 表示了该函数的原型，prototype\n表示了一个类的属性的集合。当通过 new 来生成一个类的对象时，prototype\n对象的属性就会成为实例化对象的属性。\nPrototype 与\nprototype 的区别\n\nconst watcher:ClassDecorator = (target:Function)=&gt;{    target.prototype.getName = &lt;T&gt;(name:T):T =&gt;{        return name    }}@watcherclass A{}let a = new A()a.getName()//会报类型\"A\"上不存在属性\"getName\"//(&lt;any&gt;a).getName()//我们将其断言成any类型console.log((&lt;any&gt;a).getName(\"小满深夜骑单车\"))//对其进行使用，输出 小满深夜骑单车@watcherclass B{}let b = new B()console.log(b.getName('666'))//也是可以的\n装饰器工厂\n\n支持传参的写法\n\n\n我认为其实就是多了一层壳，这层壳用来接收@watcher 的参数。里面 return\n的那一层再用来接收 class A 这个构造器\n其实也就是一个高阶函数 外层的函数接受值\n里层的函数最终接受类的构造函数\n\nconst watcher = (name=string):ClassDecorator =&gt;{    return (target:Function) =&gt;{        target.prototype.getNames = () =&gt;{            return name        }        target.prototype.getOptions = (): string =&gt; {            return name    }}@watcher(\"小余的笔记\")class A{}let a = new A()console.log((&lt;any&gt;a).getNames())//返回 小余的笔记\n装饰器组合\n\n就是可以使用多个装饰器\n\n//装饰器组合组合const watcher = (name: string): ClassDecorator =&gt; {\treturn (target: Function) =&gt; {\t\ttarget.prototype.getName = () =&gt; {\t\t\treturn name;\t\t};\t};};const log: ClassDecorator = (target: Function) =&gt; {\ttarget.prototype.a = 213;};@log@watcher(\"小满\")class A {}\nconst watcher = (name: string): ClassDecorator =&gt; {    return (target: Function) =&gt; {        target.prototype.getParams = &lt;T&gt;(params: T): T =&gt; {            return params        }        target.prototype.getOptions = (): string =&gt; {            return name        }    }}const watcher2 = (name: string): ClassDecorator =&gt; {    return (target: Function) =&gt; {        target.prototype.getNames = ():string =&gt; {            return name        }    }}@watcher2('name2')@watcher('name')class A {    constructor() {    }}const a = new A();console.log((a as any).getOptions());console.log((a as any).getNames());\n方法装饰器\n\n返回三个参数\n\n对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n成员的名字。\n成员的属性描述符。\n\n相当于抽离出来，在类中引用进去，这样可以在不同的类中引用\n\n[  {},  'setParasm',  {    value: [Function: setParasm],    writable: true,    enumerable: false,    configurable: true  }]\nconst met: MethodDecorator = (...args) =&gt; {\tconsole.log(args);};class A {\tconstructor() {}\t@met\tgetName(): string {\t\treturn \"小满\";\t}}const a = new A();\n属性装饰器\n\n返回两个参数\n\n对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n属性的名字。\n\n[ {}, ‘name’, undefined ]\n\nconst met: PropertyDecorator = (...args) =&gt; {\tconsole.log(args);};class A {\t@met\tname: string;\tconstructor() {}}const a = new A();\n参数装饰器\n返回三个参数\n\n对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n成员的名字。\n参数在函数参数列表中的索引。\n\n[ {}, ‘setParasm’, 0 ]\nconst met: ParameterDecorator = (...args) =&gt; {\tconsole.log(args);};class A {\tconstructor() {}\tsetParasm(@met name: string = \"213\") {}}const a = new A();\nRollup 构建 TS 项目(TS – 21)\n\n这个视频我是属于过一遍的程度，本章节内容将直接把小满在 CSDN 的文章\ncopy 过来\n\nRollup 构建 TS 项目\n安装依赖\n\n全局安装 rollup npm install rollup-g\n安装 TypeScript npm install typescript -D\n安装 TypeScript 转换器 npm install rollup-plugin-typescript2\n-D\n安装代码压缩插件 npm install rollup-plugin-terser -D\n安装 rollupweb 服务 npm install rollup-plugin-serve -D\n安装热更新\nnpm install rollup-plugin-livereload -D\n引入外部依赖 npm install rollup-plugin-node-resolve -D\n安装配置环境变量用来区分本地和生产 npm install cross-env\n-D\n替换环境变量给浏览器使用 npm install rollup-plugin-replace\n-D\n\n配置 json 文件\nnpm init -y\n{  \"name\": \"rollupTs\",  \"version\": \"1.0.0\",  \"description\": \"\",  \"main\": \"index.js\",  \"scripts\": {    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",    \"dev\": \"cross-env NODE_ENV=development  rollup -c -w\",    \"build\":\"cross-env NODE_ENV=produaction  rollup -c\"  },  \"keywords\": [],  \"author\": \"\",  \"license\": \"ISC\",  \"devDependencies\": {    \"cross-env\": \"^7.0.3\",    \"rollup-plugin-livereload\": \"^2.0.5\",    \"rollup-plugin-node-resolve\": \"^5.2.0\",    \"rollup-plugin-replace\": \"^2.2.0\",    \"rollup-plugin-serve\": \"^1.1.0\",    \"rollup-plugin-terser\": \"^7.0.2\",    \"rollup-plugin-typescript2\": \"^0.31.1\",    \"typescript\": \"^4.5.5\"  }}\n配置 rollup 文件\nconsole.log(process.env);import ts from \"rollup-plugin-typescript2\";import path from \"path\";import serve from \"rollup-plugin-serve\";import livereload from \"rollup-plugin-livereload\";import { terser } from \"rollup-plugin-terser\";import resolve from \"rollup-plugin-node-resolve\";import repacle from \"rollup-plugin-replace\";const isDev = () =&gt; {\treturn process.env.NODE_ENV === \"development\";};export default {\tinput: \"./src/main.ts\",\toutput: {\t\tfile: path.resolve(__dirname, \"./lib/index.js\"),\t\tformat: \"umd\",\t\tsourcemap: true,\t},\tplugins: [\t\tts(),\t\tterser({\t\t\tcompress: {\t\t\t\tdrop_console: !isDev(),\t\t\t},\t\t}),\t\trepacle({\t\t\t\"process.env.NODE_ENV\": JSON.stringify(process.env.NODE_ENV),\t\t}),\t\tresolve([\".js\", \".ts\"]),\t\tisDev() &amp;&amp; livereload(),\t\tisDev() &amp;&amp;\t\t\tserve({\t\t\t\topen: true,\t\t\t\topenPage: \"/public/index.html\",\t\t\t}),\t],};\n配置 tsconfig.json\n{  \"compilerOptions\": {    /* Visit https://aka.ms/tsconfig.json to read more about this file */    /* Projects */    // \"incremental\": true,                              /* Enable incremental compilation */    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */    // \"tsBuildInfoFile\": \"./\",                          /* Specify the folder for .tsbuildinfo incremental compilation files. */    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects */    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */    /* Language and Environment */    \"target\": \"es5\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */    // \"reactNamespace\": \"\",                             /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */    /* Modules */    \"module\": \"ES2015\",                                /* Specify what module code is generated. */    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */    // \"typeRoots\": [],                                  /* Specify multiple folders that act like `./node_modules/@types`. */    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */    // \"resolveJsonModule\": true,                        /* Enable importing .json files */    // \"noResolve\": true,                                /* Disallow `import`s, `require`s or `&lt;reference&gt;`s from expanding the number of files TypeScript should add to a project. */    /* JavaScript Support */    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */    /* Emit */    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */      \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */    // \"outDir\": \"./\",                                   /* Specify an output folder for all emitted files. */    // \"removeComments\": true,                           /* Disable emitting comments. */    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types */    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */    // \"newLine\": \"crlf\",                                /* Set the newline character for emitting files. */    // \"stripInternal\": true,                            /* Disable emitting declarations that have `@internal` in their JSDoc comments. */    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like `__extends` in compiled output. */    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */    // \"preserveConstEnums\": true,                       /* Disable erasing `const enum` declarations in generated code. */    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */    /* Interop Constraints */    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */    /* Type Checking */    \"strict\": true,                                      /* Enable all strict type-checking options. */    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied `any` type.. */    // \"strictNullChecks\": true,                         /* When type checking, take into account `null` and `undefined`. */    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */    // \"strictBindCallApply\": true,                      /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */    // \"noImplicitThis\": true,                           /* Enable error reporting when `this` is given the type `any`. */    // \"useUnknownInCatchVariables\": true,               /* Type catch clause variables as 'unknown' instead of 'any'. */    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */    // \"noUnusedLocals\": true,                           /* Enable error reporting when a local variables aren't read. */    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read */    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */    // \"noUncheckedIndexedAccess\": true,                 /* Include 'undefined' in index signature results */    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type */    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */    /* Completeness */    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */    \"skipLibCheck\": true                                 /* Skip type checking all .d.ts files. */  }}\nnpm run dev 启动就可以尽情的玩耍了\nwebpack 构建 TS 项目\n安装依赖\n安装 webpack npm install webpack -D\nwebpack4 以上需要 npm install webpack-cli -D\n编译 TS npm install ts-loader -D\nTS 环境 npm install typescript\n-D\n热更新服务 npm install webpack-dev-server -D\nHTML 模板 npm install html-webpack-plugin -D\n配置文件\nconst path = require(\"path\");const htmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = {\tentry: \"./src/index.ts\",\tmode: \"development\",\toutput: {\t\tpath: path.resolve(__dirname, \"./dist\"),\t\tfilename: \"index.js\",\t},\tstats: \"none\",\tresolve: {\t\textensions: [\".ts\", \".js\"],\t\talias: {\t\t\t\"@\": path.resolve(__dirname, \"./src\"),\t\t},\t},\tmodule: {\t\trules: [\t\t\t{\t\t\t\ttest: /\\.ts$/,\t\t\t\tuse: \"ts-loader\",\t\t\t},\t\t],\t},\tdevServer: {\t\tport: 1988,\t\tproxy: {},\t},\tplugins: [\t\tnew htmlWebpackPlugin({\t\t\ttemplate: \"./public/index.html\",\t\t}),\t],};\n目录结构\n\nTypeScript 高级 -\n实战插件编写\n\n目的\n使用 TypeScript 去封装 local storage(支持设置过期时间) =&gt;local\nstorage\n本身无此机制，只能人为手动删除，否则会一直存放在浏览器当中，可不可以跟\ncookie\n一样设置一个有效期。如果一直存放在浏览器又感觉有点浪费，那我们可以把localStorage进行二次封装实现该方案\n实现思路\n在存储的时候设置一个过期时间，并且存储的数据进行格式化方便统一校验，在读取的时候获取当前时间进行判断是否过期，如果过期进行删除即可。\n\n事前准备\n//新建dist文件夹(打包后的js代码放这里)//生成src文件夹//src文件夹下生成index.ts文件//src文件夹下生成enum文件夹，type文件夹//enum、type文件夹下生成index.ts文件//创建html文件，用来测试代码//初始化package.json文件 ：npm init -y(或者你使用pnpm yarn都行，-y是默认配置)//右键新建rollup.config.js文件(作用：将TS打包成JS)//生成tsconfig.json =&gt; 使用命令`tsc -init`(这是TS的配置文件)\n\n\nimage-20230118181032581\n\n\n写代码前需要进行 3\n个改动(tsconfig.json文件下的修改)\n\n\n\n\n\n\n\n\n改动地方\n改动原因\n\n\n\n\n\"module\": \"commonjs\"修改为\"module\": \"ESNext\"，位于\n27 行附近\n\"module\"选项用来指定 TypeScript 编译器生成\nJavaScript 代码时使用的模块系统。\"commonjs\" 是\nNode.js 默认的模块系统。当 \"module\" 设置为\n\"ESNext\" 时，TypeScript 编译器会把\nTypeScript\n代码编译成ECMAScript模块，这是最新的\nECMAScript 模块系统\n\n\n\"moduleResolution\": \"node\"功能打开，位于 29 行附近\n当 \"moduleResolution\" 设置为 \"node\"\n时，TypeScript 编译器会使用 Node.js\n模块解析策略来解析模块路径。这意味着编译器会先在当前目录下的\nnode_modules 文件夹中查找模块，如果找不到就会去父目录的\nnode_modules\n文件夹中查找，直到找到或者到达根目录这样配置的好处是可以使用\nNode.js 的模块解析机制来加载项目中的模块，并且可以使用\nnpm 和 yarn来管理项目中的依赖\n\n\n\"strict\": false，位于 79 行附近\n关掉严格模式\n\n\n\n编写插件\n\nenum 文件夹下的 index.ts\n\nexport enum Dictionaries {    expire = '__expire__',//下划线证明是私有的，存放的是过期时间    permanent = 'permanent'//设置local storage默认时间的}\n\ntype 文件夹下的 index.ts\n\nimport { Dictionaries } from \"../enum\"//引入字典表，因为字典表设置默认过期时间也有在传参中使用，所以需要定义类型export type Key = string //key类型export type expire = Dictionaries.permanent | number //有效期类型(联合类型，number由我们自己设置什么时候local storage什么时候过期)export interface Data&lt;T&gt; {  //格式化data类型    value: T    [Dictionaries.expire]: Dictionaries.expire | number}export interface Result&lt;T&gt; { //返回值类型，泛型，由用户自己定义    message: string,    value: T | null}export interface StorageCls { //class方法约束    set: &lt;T&gt;(key: Key, value: T, expire: expire) =&gt; void//设置，expire就是设置过期时间，也就是我们为什么要引入字典表的原因，在这里设置接口就用到了    get: &lt;T&gt;(key: Key) =&gt; Result&lt;T | null&gt;//读取    remove: (key: Key) =&gt; void//删除    clear: () =&gt; void//清空}\n\nsrc 下的 index.ts 文件\n\n//expire过期时间key permanent永久不过期import { StorageCls, Key, expire, Data, Result } from \"./type\";////引入接口import { Dictionaries } from \"./enum\";//Storage 类必须实现 StorageCls 接口中定义的所有成员，也就是类必须满足 StorageCls 接口的约束条件export class Storage implements StorageCls {////通过implements来约束类    //存储接受 key value 和过期时间 默认永久(由枚举Dictionaries.permanent实现)    public set&lt;T = any&gt;(key: Key, value: T, expire: expire = Dictionaries.permanent) {////key这些类型都是定义了接口在type文件夹中的，expire是处理local storage存的时间，不设置则存的就是永久        //格式化数据，按照我们自己的要求规范格式        const data = {            value,//用户传过来的value            [Dictionaries.expire]: expire//存放的过期时间        }        //存进去，对JSON进行转化成字符串        localStorage.setItem(key, JSON.stringify(data))//通过提示Storage.setItem(key: string, value: string): void，在set的形参中接收值key跟value    }    //获取数据    public get&lt;T = any&gt;(key: Key): Result&lt;T | null&gt; {        const value = localStorage.getItem(key)//获取key值        //检测读出来的数据是否有效，如果为null就会提示key值无效        if (value) {            const obj: Data&lt;T&gt; = JSON.parse(value)//将处理好的字符串形式的数据再转化回来，Data&lt;T&gt;一样是规范了类型(方便写的时候给出提示)，同时允许用户传递类型进来            const now = new Date().getTime()//获取当前的时间            //有效并且是数组类型 并且过期了 进行删除和提示            if (typeof obj[Dictionaries.expire] == 'number' &amp;&amp; obj[Dictionaries.expire] &lt; now) {//typeof判断类型，如果传递的是数字，那就是时间戳，且同时判断传递的时间是否小于当前时间(就是判断过期了没)                this.remove(key)//过期了就把localstorage清除掉                return {                    message: `您的${key}已过期`,                    value: null                }            } else {                //否则成功返回                return {                    message: \"成功读取\",                    value: obj.value                }            }        } else {            //否则key值无效            console.warn('key值无效')            return {                message: `key值无效`,                value: null            }        }    }    //删除某一项，过期了就删掉localStorage    public remove(key: Key) {        localStorage.removeItem(key)    }    //清空所有值    public clear() {        localStorage.clear()    }}\n\nsrc 下的 index.html 文件\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;\t&lt;head&gt;\t\t&lt;meta charset=\"UTF-8\" /&gt;\t\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;\t\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\t\t&lt;title&gt;小余练习&lt;/title&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t&lt;script type=\"module\"&gt;\t\t\timport { Storage } from \"./dist/index.js\"; //引入\t\t\tconst sl = new Storage();\t\t\t//五秒后过期\t\t\tsl.set(\"a\", 123, new Date().getTime() + 5000);\t\t\t//每过0.5s查看是否过期\t\t\tsetInterval(() =&gt; {\t\t\t\tconst a = sl.get(\"a\");\t\t\t\tconsole.log(a);\t\t\t}, 500);\t\t&lt;/script&gt;\t&lt;/body&gt;&lt;/html&gt;\n\nrullup.config.js 文件\n\n//旧版写法(小满视频里的就是旧版)import ts from 'rollup-plugin-typescript2'import path from 'path'export default {    input: './src/index.ts',//入口文件    output: {//出口文件，会打到dist里面        file: path.resolve(__dirname, './dist/index.js')    },    plugins: [//rollup插件，将ts转化成js        ts()    ]}//如果上面你打包失败了，切换新版的代码，附在下面//第一步全局下载：npm install rollup -g//第二步：切换代码(不用上面的代码)import ts from \"rollup-plugin-typescript2\";import path from \"path\";import { fileURLToPath } from \"url\";const metaUrl = fileURLToPath(import.meta.url);const dirName = path.dirname(metaUrl);export default {    input: \"./src/index.ts\",    output: {        file: path.resolve(dirName, \"./dist/index.js\"),    },    plugins: [ts()],};\n\ntsconfig.json 文件(不发了，太多了，就 3 个需要改动的地方)\n\n打包\n\n需要安装 3 个包(直接一次性安装好)\npnpm install rollup typescript rollup-plugin-typescript2\n\n在package.json中配置启动命令\n\"build\":\"rollup -c\"\n\n打包成功\n\n\n\nimage-20230118204531135\n\n\n启动\n\n在本地服务器中启动(Stop Live Server)\n\n\n\nimage-20230118205225841\n\n实战 TS 编写发布订阅模式(TS –\n22)\n\n什么是发布订阅模式，其实小伙伴已经用到了发布订阅模式例如\naddEventListener，Vue evnetBus\n都属于发布订阅模式\n简单来说就是 你(小满)要和 大满 二满\n三满打球，大满带球，二满带水，三满带球衣。全都准备完成后开始打球。\n\n思维导图\n\ninterface Evenet{  on:(name:string,fn:Function) =&gt; void,  emit:(name:string,...args:Array&lt;any&gt;) =&gt; void//派发  off:(name:string,fn:Function)=&gt; void//移除  once:(name:string,fn:Function) =&gt; void//只执行一次}interface List{  [key:string]:Array&lt;Function&gt;}class Dispatch implements Evenet{//通过implements来约束这个类(Evenet)  list:List  constructor(){      this.list = {}  }  on(name:string,fn:Function){      const callback = this.list[name] || []//如果有取到值的话那就是一个数组，没有取到值的话就是一个空数组      callback.push(fn)//因为不管怎么说，callback都是数组，所以我们后面的数组也可以直接添加上去      this.list[name] = callback      console.log(this.list);  }  emit(name:string,...args:Array&lt;any&gt;){      let eventName = this.list[name]      //on监听跟emit派发的时候 name 是需要一样的，不然会出错，所以我们这里要进行一个判断      if(eventName){          eventName.forEach(fn=&gt;{              //内容从下面的o.emit()传送上来              fn.apply(this,args)//第一个参数this指向，第二个参数为数组，这里也刚好是一个数组就直接传进去。会将on监听的数据直接打印出来，这里打印出来66 99          })      }else{          console.error(`名称错误${name}`)      }  }  off(name:string,fn:Function){      //off是删除一个函数，所以我们在下面将创建一个fn函数让他来删一下      let eventName = this.list[name]      //跟emit一样的，需要进行判断有没有值，还有就是函数存不存在，不存在的话就没得删了对吧      if(eventName &amp;&amp; fn){          //我们要通过索引来将其删掉          let index = eventName.findIndex(fns=&gt; fns === fn )          eventName.splice(index,1)          console.log(eventName)      }else{          console.error(`名称错误${name}`)      }  }  once(name:string,fn:Function){      let de = (...args:Array&lt;any&gt;) =&gt;{          fn.apply(this,args)//指向到那个只调用一次函数的那里          this.off(name,de)//调用完就把它删掉，这就是只能调用一次的原因哈哈      }      this.on(name,de)//第一个还是名字，第二个临时函数  }}const o = new Dispatch()//初始化o.on('post',()=&gt;{//post作为key  console.log(66);})//第一个参数是事件名称，第二个是回调函数o.on('post',(...args:Array&lt;any&gt;)=&gt;{  console.log(99,args)  //这里我们对第二个回调函数传入了...args，也就是收到了o.emit除了第一个参数后面那些乱七八糟的东西(因为我们设定了any，对接收的类型并没有限制，所以收到什么乱七八糟的东西都不奇怪)，并在控制台打印了出来})const fn = (...args:Array&lt;any&gt;) =&gt; {  console.log(args,2)}o.on('post',fn)//没错，这个就是特地创建出来删掉的o.off('post',fn)//将fn删掉//o.on('post2',()=&gt;{  //都会在控制台显示出来//})o.once('post',(...args:Array&lt;any&gt;)=&gt;{  console.log(args,'once')})o.emit('post',1,false,{name:\"小满\"})//除了第一个参数一样是事件，后面参数是不限制个数的，而且传什么都行o.emit('post',2,false,{name:\"小满\"})//这里如果收到就是有问题的，因为我们在上面使用once了，只调用一次\n\n上面在 off 删除中使用到的 splice 知识点补充\n\nsplice(index,len,[item])它也可以用来替换 / 删除 / 添加数组内某一个或者几个值（该方法会改变原始数组）index: 数组开始下标len: 替换 / 删除的长度item: 替换的值，删除操作的话 item 为空删除：// 删除起始下标为 1，长度为 1 的一个值 (len 设置 1，如果为 0，则数组不变)var arr = ['a','b','c','d'];arr.splice(1,1);console.log(arr);   //['a','c','d'];// 删除起始下标为 1，长度为 2 的一个值 (len 设置 2)var arr2 = ['a','b','c','d'] arr2.splice(1,2);console.log(arr2);  //['a','d']替换：// 替换起始下标为 1，长度为 1 的一个值为‘ttt’，len 设置的 1var arr = ['a','b','c','d'];arr.splice(1,1,'ttt');console.log(arr);         //['a','ttt','c','d']// 替换起始下标为 1，长度为 2 的两个值为‘ttt’，len 设置的 1var arr2 = ['a','b','c','d'];arr2.splice(1,2,'ttt');console.log(arr2);        //['a','ttt','d']添加：// 在下标为 1 处添加一项 'ttt'var arr = ['a','b','c','d'];arr.splice(1,0,'ttt');console.log(arr);         //['a','ttt','b','c','d']\nTS 进阶 协变 逆变\n双向协变(新增内容 - 代号:冬瓜)\n鸭子类型\n\n\n所谓的类型兼容性，就是用于确定一个类型是否能赋值给其他的类型。typeScript\n中的类型兼容性是基于结构类型的（也就是形状），如果 A\n要兼容 B 那么 A 至少具有 B 相同的属性。\n“鸭子类型”\n是一个术语，用于描述动态类型语言中的类型系统的一种特殊方式。在鸭子类型系统中，如果对象看起来像鸭子，那么它就是鸭子。\n在 TypeScript\n中，鸭子类型是一种使用接口（interfaces）和类型断言（type\nassertions）来模拟动态类型系统的方法。这种方法允许定义一个对象的外观，而不需要严格的类型声明。\n小满的解释：一只鸟 走路像鸭子\n，游泳也像，做什么都像，那么这只鸟就可以成为鸭子类型\n\n\n//主类型interface a {\tname: string;\tage: number;}//子类型interface b {\tname: string;\tage: number;\tsex: string;}let xiaoman: a = {\tname: \"小满\",\tage: 24,};let xiaoyu: b = {\tname: \"小余\",\tage: 20,\tsex: \"男\",};//此时b类型攘括了a类型，那此时a跟b都被称为了鸭子类型，关于为什么叫鸭子类型在上面有解释\n协变\n\nA B 两个类型完全不同但是竟然可以赋值并无报错 B 类型充当 A\n类型的子类型，当子类型里面的属性满足 A\n类型就可以进行赋值，也就是说不能少可以多，这就是协变\n\n举例子：a 工作是前端，b\n工作是全栈(全都干)。你是前端，我是全栈，我能覆盖掉你的工作，你覆盖不了我的工作。因为你的工作里面只有前端，而我的工作里面还有后端，服务器维护，等等杂七杂八的东西，这些你都不会，你一上，除了前端部分之外，你啥都看不懂，完成不了工作是会被赶走的。要求全栈的工作你可以会得更多，但是这门工作的要求你得达到，需要用到的技术你不能不会\n\n\n//主类型interface a {\tname: string;\tage: number;}//子类型interface b {\tname: string;\tage: number;\tsex: string;}let xiaoman: a = {\tname: \"小满\",\tage: 24,};let xiaoyu: b = {\tname: \"小余\",\tage: 20,\tsex: \"男\",};//协变xiaoman = xiaoyu; //可以覆盖，xiaoyu充当xiaoman的子类型(我的理解是，像父类跟子类，子类是在父类的基础上继续扩展的)xiaoyu = xiaoman; //报错，因为xiaoman没有sex这个属性，覆盖不了xiaoyu的sex\n逆变\n\n\n在 TypeScript\n中，逆变是一种类型系统的特性，可以在泛型（generics）和函数参数上使用。逆变允许我们定义一个泛型类型或函数参数，其类型可以是一个父类型，而不是子类型。\n逆变一般发生于函数的参数上面\n逆变可以帮助我们编写更灵活的代码，同时仍然保持类型安全性\n\n小满的解释：这里比较绕，注意看fna 赋值 给\nfnb 其实最后执行的还是fna 而\nfnb的类型能够完全覆盖fna\n所以这一定是安全的，相反fna的类型不能完全覆盖fnb少一个\nsex 所以是不安全的。 我的解释在下面\n\n//主类型interface a {\tname: string;\tage: number;}//子类型interface b {\tname: string;\tage: number;\tsex: string;}let fna = (params: a) =&gt; {};let fnb = (params: b) =&gt; {};//逆变//首先父类有的，子类一定有。父类没有的，子类不一定没有。//我们先知道了这里的目的是为了保持类型的安全性，那就很明白了，父类覆盖掉子类，那子类一定是不会多出其他类型的，但是子类覆盖掉父类那就不一定了fnb = fna; //父传子\n双向协变\n\n在逆变的基础上反过来\n\n从只能fnb = fna到能够fna = fnb，也就是子类赋值给了父类\n使用方式：tsconfig strictFunctionTypes 设置为 false 支持双向协变 fna\nfnb 随便可以来回赋值\n一般情况下建议不开启\n\n\n//步骤1：tsc --init\t生成tsconfig.json文件    \"strictFunctionTypes\": false,        /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */        //翻译：在分配函数时，检查以确保参数和返回值是子类型兼容的        //我们选择了false，对于上面的意思来说也就是不检查子类会不会被父类型兼容了(原本不兼容报错，现在不报错了)，dan's\n\n\nimage-20230211145443560\n\nTS 进阶用法 proxy &amp;\nReflect(TS – 23)\n\nproxy：对象代理(是 ES6\n新增的对象拦截器，能够监听到一个对象的变化)\nReflect：配合 proxy 来操作对象\n\nProxy\n\nProxy\n对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）\ntarget\n要使用 Proxy\n包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\nhandler\n一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理\np 的行为。\nhandler.get()本次使用的 get\n属性读取操作的捕捉器。\nhandler.set()本次使用的 set\n属性设置操作的捕捉器。\n\nReflect\n\n与大多数全局对象不同 Reflect\n并非一个构造函数，所以不能通过 new\n运算符对其进行调用，或者将 Reflect\n对象作为一个函数来调用。Reflect\n的所有属性和方法都是静态的（就像 Math\n对象）\nReflect.get(target, name,\nreceiver)\nReflect.get 方法查找并返回 target 对象的\nname 属性，如果没有该属性返回 undefined\nReflect.set(target,\nname,value, receiver)\nReflect.set 方法设置 target 对象的\nname 属性等于 value。\n\ntype Person = {\tname: string,\tage: number,\ttext: string,};const proxy = (object: any, key: any) =&gt; {\t//我们要自己实现proxy啦\treturn new Proxy(object, {\t\tget(target, prop, receiver) {\t\t\tconsole.log(\"================&gt;get\", prop);\t\t\t//prop就是一个key，target就是地下那个man的对象，receiver是跟target一样的值，防止上下文错误的\t\t\treturn Reflect.get(target, prop, receiver); //这里刚好对应的也是这三个参数\t\t},\t\tset(target, prop, value, receiver) {\t\t\t//多了一个value，因为我们要设置值\t\t\t//日志\t\t\tconsole.log(\"================&gt;set\", prop);\t\t\treturn Reflect.set(target, prop, value, receiver);\t\t},\t});};//日志监听函数//由于我们要监听man里面的内容，所以这里可以使用联合类型const logAccess = &lt;T&gt;(object: T, key: \"name\" | \"age\" | \"text\"): T =&gt; {\t//为了使其灵活度高一点，我们不使其object等于Person，而是为泛型T，使用的时候再去设置\treturn proxy(object, key);};let man: Person = {\tname: \"小满\",\tage: 22,\ttext: \"三秒真男人\",};let man2 = logAccess(\t{\t\tname: \"小余\",\t},\t\"name\");man.age = 30; //走setman.age; //走getconsole.log(man);\n\n泛型优化\n\nconst logAccess = &lt;T&gt;(object: T ,key:keyof T):T =&gt;{//为了使其灵活度高一点，我们不使其object等于Person，而是为泛型T，使用的时候再去设置。key也不固定死，而是使用keyof，将我们传入的对象推断为联合类型    return proxy(object,key)}let man2 = logAccess({    name:\"小余\",    id:925},'id')//就可以动态的去约束类型let man2 = logAccess({    name:\"小余\",    id:925},'id2')//报错，因为我们类型里没有id2\n\n优化完整版\n\ntype Person = {    name: string,    age: number,    text: string}const proxy = (object: any, key: any) =&gt; {    return new Proxy(object, {        get(target, prop, receiver) {            console.log(`get key======&gt;${key}`);            return Reflect.get(target, prop, receiver)        },        set(target, prop, value, receiver) {            console.log(`set key======&gt;${key}`);            return Reflect.set(target, prop, value, receiver)        }    })}const logAccess = &lt;T&gt;(object: T, key: keyof T): T =&gt; {    return proxy(object, key)}let man: Person = logAccess({    name: \"小满\",    age: 20,    text: \"我的很小\"}, 'age')let man2 = logAccess({    id:1,    name:\"小满2\"}, 'name')man.age = 30console.log(man);\nTS 进阶用法 Partial &amp; Pick(TS\n– 24)\n\nTypeScript 内置高级类型 Partial Pick\n\nPartial\n\n源码\n\n/** * Make all properties in T optional  将T中的所有属性设置为可选 */type Partial&lt;T&gt; = {    [P in keyof T]?: T[P];};\n\n手写实现\n\ntype Person = {\tname:string,\tage:number,\ttext:string}//keyof：将一个接口对象的全部属性取出来变成联合类型//keyof的作用就是把我们的属性变成联合类型，在底下就相当于\"name\"|\"age\"|\"text\"。而 in 就是为遍历这个联合类型的每一项，然后放到这个P里(所以P里就是name、age、text)，然后使其变成`?`可选的type Par&lt;T&gt; = {//这个T就是我们传过来的Person，所以T[P]就是Person里面name、age、text的内容(string那些啥的)    //小满对T[P]的形容方式：通过索引取值的方式    [P in keyof T]?:T[P]//所以你在看这个肯定能看懂};type p = Partial&lt;Person&gt;//这个时候，我们会发现p上面的属性，name、age、text都变成可选的了\n\n使用前(范例)\n\ntype Person = {\tname: string,\tage: number,};type p = Partial&lt;Person&gt;;\n\n使用后(范例)\n\ntype p = {\tname?: string | undefined,\tage?: number | undefined,};\nPick\n\n从类型定义 T 的属性中，选取指定一组属性，返回一个新的类型定义。\n\n\n源码\n\n/** * From T, pick a set of properties whose keys are in the union K */type Pick&lt;T, K extends keyof T&gt; = {    [P in K]: T[P];};\n\n手写实现\n\ntype Person = {\tname: string,\tage: number,\ttext: string,\taddress: string,};type Ex = \"text\" | \"age\";type A = Pick&lt;Person, Ex&gt;;\n\n分析(需要结合手写的内容看)\n\ntype Pick&lt;T, K extends keyof T&gt; = {//T跟K都是泛型,T相当于我们的Person，K就相当于我们传的联合类型，然后同样也经历了keyof的洗礼，使其变成联合类型，K通过extends被约束了这点，使其只能为T，也就是Person内的值    [P in K]: T[P];};type p = Pick&lt;Person,'age'|'name'&gt;//这里的Person请参考手写实现的Person\nTS 进阶用法 Record &amp;\nReadonly(TS – 25)\nReadonly\n\n和 Partial 很像是吧？只是将 Partial 替换成了 Readonly\n\n\n源码\n\ntype Readonly&lt;T&gt; = {    readonly [P in keyof T]: T[P];};\n\n手写实现\n\ntype R&lt;T&gt; = {    readonly [P in keyof T]: T[P];//keyof还是那样，转化为联合类型，in去遍历选项。T[P]通过索引取值的方式    //然后为里面每个内容都加上只读属性};type Person = {    name:string,    age:number,    text:string}type man = R&lt;Person&gt;\nRecord\n\n1 keyof any 返回 string number symbol 的联合类型\n2 in 我们可以理解成 for in P 就是 key 遍历 keyof any 就是 string\nnumber symbol 类型的每一项\n3 extends 来约束我们的类型\n4 T 直接返回类型\n做到了约束 对象的 key 同时约束了 value\n\n\n源码\n\ntype Record&lt;K extends keyof any, T&gt; = {    [P in K]: T;};\n\n手写实现\n\ntype Rec&lt;K extends keyof any,T&gt; = {//T是泛型，传什么在这里并没有限制    [P in K]: T;};//keyof返回联合类型type key = string |number | symboltype Person ={    name:string,    age:number,    text:string}type K = \"A\"|\"B\"|\"C\"//因为我们在这里定义了K，所以let B才只能使用A、B、C，如果这里换成1、2、3，那底下也只能使用1、2、3而不是A、B、Ctype B = Rec&lt;K,Person&gt;//这里会返回成type B = {A:Person;B:Person;C:Person;}的形式let obj:B = {    A:{name:\"小满\",age:3,text:\"三秒真男人\"},//这里值的类型需要是Person的类型，因为在type B中已经定义了    B:{name:\"小余\",age:18,text:\"三小时真男人\"},    C:{name:\"狗洛\",age:1,text:\"零点三秒真男人\"}}\nTS 进阶用法 infer(TS – 26)\n\ninfer 是 TypeScript 新增到的关键字 充当占位符\n我们来实现一个条件类型推断的例子\n定义一个类型 如果是数组类型 就返回 数组元素的类型 否则 就传入什么类型\n就返回什么类型\n\ntype TYPE&lt;T&gt; = T extends Array&lt;any&gt; ? T[number] : Ttype A = TYPE&lt;string[]&gt;//会返回type A = stringtype B = TYPE&lt;(string|number)[]&gt;//会返回type B = string|numbertype C = TYPE&lt;boolean&gt;//返回type C = boolean\ninfer\n\n使用 inter 修改\n\n// 是不是某种数组类型 是：返回数组元素类型的类型 不是：返回类型本身type TYPE&lt;T&gt; = T entends Array&lt;infer U&gt; ? U : T//U不是泛型，而是充当占位符使用，读取Array类型然后进行返回// 是不是某种数组类型 是：返回数组元素类型的类型 不是：返回nevertype TYPE&lt;T&gt; = T entends Array&lt;infer U&gt; ? U : never//限制只能传type T这个元组类型，其他都不能传type A = TYPE&lt;string[]&gt;//会返回type A = stringtype B = TYPE&lt;(string|number)[]&gt;//会返回type B = string|numbertype T = [string,number]//使其变成联合类型(小技巧)type uni = TYPE&lt;T&gt;//返回联合类型type uni = string|numbertype uni = TYPE&lt;T&gt;//返回type uni = never。因为我们进行了限制\ninfer 类型提取(TS – 27)\n提取头部元素\n\nT extends any[]：对 T 进行泛型约束，一个 any\n类型的数组\ntype First&lt;T extends any[]&gt; = T extends [infer one,infer two,infer three]?\none:[]：对 T 进行泛型约束为数组类型，用 infer 提取，提取的变量名对应着\nArr 的 a、b、c。然后决定返回 one，也就是第一个元素还是空数组\n\ntype Arr = ['a','b','c']type First&lt;T extends any[]&gt; = T extends [infer one,infer two,infer three]? one:[]//ES6进阶版type First&lt;T extends any[]&gt; =  T extends [infer First,...any[]] ? First : []//1 ...type a = First&lt;Arr&gt;\n提取尾部元素\n\n将头尾反过来了\n\ntype Arr = ['a', 'b', 'c']type Last&lt;T extends any[]&gt; = T extends [...any[], infer Last] ? Last : []//... 尾部type c = Last&lt;Arr&gt;\n剔除第一个元素 Shift\n\n将除了第一个之外的其他通过 ES6 语法提取出来\n\ntype Arr = ['a','b','c']type First&lt;T extends any[]&gt; =  T extends [unknown,...infer Rest] ? Rest : []type a = First&lt;Arr&gt;\n剔除尾部元素 pop\n\n将除了第最后一个之外的其他通过 ES6 语法提取出来\n\ntype Arr = ['a','b','c']type First&lt;T extends any[]&gt; =  T extends [...infer Rest,unknown] ? Rest : []type a = First&lt;Arr&gt;\ninfer 递归(TS – 28)\n\n需求：\n有这么一个类型\ntype Arr = [1, 2, 3, 4];\n希望通过一个 ts 工具变成\ntype Arr = [4, 3, 2, 1];\n\n\n具体思路 首先使用泛型约束 约束只能传入数组类型的东西\n然后从数组中提取第一个，放入新数组的末尾，反复此操作，形成递归\n满足结束条件返回该类型\n\ntype Arr = [1,2,3,4]//先来一个泛型约束(对T)，这是通过不断递归拿到最后一个元素(也就是问好后面的那个First)填到最前面，直到没有元素为止(三元表达式)//type ReverArr&lt;T extends any[]&gt; = T extends [infer First,...infer rest] ? [...ReverArr&lt;rest&gt;,First] : Ttype Arrb = ReverArr&lt;Arr&gt;\n","categories":["前端","TypeScript"],"tags":["TypeScript"]},{"title":"有生之年一定看完","url":"/2021/05/04/%E6%9C%89%E7%94%9F%E4%B9%8B%E5%B9%B4%E4%B8%80%E5%AE%9A%E7%9C%8B%E5%AE%8C/","content":"\n\n\n\n\n\n\n\n\n\n\n序号\n名称\n评价\n备注\n\n\n\n\n1\n斗破苍穹\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n2\n龙族\n⭐️\n\n\n\n3\n一念永恒\n⭐️⭐️\n\n\n\n4\n三寸人间\n⭐️⭐️\n\n\n\n5\n我欲封天\n⭐️⭐️⭐️\n\n\n\n6\n碧蓝之海\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n7\n某科学的超电磁炮\n⭐️⭐️⭐️⭐️\n\n\n\n8\n魔法禁书目录\n⭐️⭐️⭐️\n\n\n\n9\n樱花庄的宠物女孩\n⭐️⭐️⭐️⭐️\n\n\n\n10\n春园庄的管理人小姐\n⭐️⭐️\n\n\n\n11\n摇曳庄的幽奈小姐\n⭐️\n\n\n\n12\n我们大家的河合庄\n⭐️⭐️⭐️⭐️\n\n\n\n13\n我的青春恋爱物语果然有问题\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n14\n这个美术社大有问题\n⭐️⭐️\n\n\n\n15\n路人女主的养成方法\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n16\n日常\n⭐️⭐️\n\n\n\n17\n阿宅的恋爱真难\n⭐️⭐️\n\n\n\n18\n五等分的新娘\n⭐️⭐️⭐️⭐️\n\n\n\n19\n笨蛋，测验，召唤兽\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n20\n白夜行\n⭐️⭐️⭐️\n\n\n\n21\n深空彼岸\n⭐️\n\n\n\n22\n庙不可言\n\n\n\n\n23\n超能力女儿\n\n\n\n\n24\n中二病也要谈恋爱！\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n25\nto love\n\n\n\n\n26\n摇曳露营\n\n\n\n\n27\n一世之尊\n⭐️⭐️⭐️\n\n\n\n28\n完美世界\n⭐️⭐️⭐️⭐️\n\n\n\n29\n圣墟\n⭐️⭐️⭐️⭐️\n\n\n\n30\n遮天\n⭐️⭐️⭐️\n\n\n\n31\n银魂\n⭐️⭐️⭐️⭐️\n\n\n\n32\n漫画家与助手们\n\n\n\n\n33\n我们真的学不来\n\n\n\n\n34\n我的妹妹哪有这么可爱\n\n\n\n\n35\n吞噬星空\n⭐️⭐️⭐️\n\n\n\n36\n牧神记\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n37\n白色相簿\n\n\n\n\n38\n我的朋友很少\n\n\n\n\n39\n时空罪恶\n\n\n\n\n40\n圣斗士星矢\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n41\n凡人修仙传\n⭐️\n\n\n\n42\n后宫那些事\n\n\n\n\n43\n毒枭\n\n\n\n\n44\n汉尼拔\n\n\n\n\n45\n超超超超超喜欢你的 100 个女朋友\n\n\n\n\n46\n青春猪头少年不会梦到兔女郎学姐\n⭐️⭐️⭐️⭐️\n\n\n\n47\n我们仍未知道那天所看见的花的名字\n⭐️⭐️⭐️⭐️\n\n\n\n48\n花开伊吕波\n⭐️⭐️⭐️⭐️\n\n\n\n49\n龙战士\n\n\n\n\n50\n玄鉴仙族\n⭐️\n\n\n\n51\n我爱上的人是奇葩\n⭐️⭐️\n\n\n\n52\n冰与火之歌\n⭐️⭐️⭐️⭐️\n\n\n\n53\n斩赤红之瞳\n⭐️\n\n\n\n54\n我的师兄太稳健了\n\n\n\n\n55\n天倾之后\n\n\n\n\n56\n轮回乐园\n\n\n\n\n57\n恶魔阿萨尔在召唤你\n⭐️⭐️\n\n\n\n58\n邻座艾莉同学\n⭐️⭐️⭐️\n\n\n\n59\n小林家的龙女仆\n⭐️⭐️⭐️⭐️\n\n\n\n60\n徒然喜欢你\n⭐️⭐️⭐️⭐️\n\n\n\n61\n十日终焉\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n62\n神墓\n⭐️⭐️⭐️⭐️\n\n\n\n63\n纸钞屋\n⭐️⭐️⭐️⭐️\n\n\n\n64\n恶搞之家\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n65\nfate 系列\n⭐️⭐️⭐️⭐️\n\n\n\n66\n帝尊\n⭐️⭐️\n\n\n\n67\n游戏三人娘\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n68\n校园迷糊大王\n\n\n\n\n69\n越狱兔\n⭐️⭐️⭐️\n\n\n\n70\n择日飞升\n⭐️⭐️⭐️⭐️\n\n\n\n71\n灵笼\n⭐️⭐️\n\n\n\n72\n奇幻世界舅舅\n⭐️⭐️\n\n\n\n73\n埃罗芒阿老师\n⭐️⭐️\n\n\n\n74\n未闻花名\n⭐️⭐️⭐️⭐️\n\n\n\n75\n花开伊吕波\n⭐️⭐️⭐️⭐️\n\n\n\n76\n后宫露营\n\n\n\n\n77\n我想吃掉你的胰脏\n\n\n\n\n78\n星期一的丰硕果实\n⭐️⭐️⭐️\n\n\n\n79\n从零开始的异世界生活\n⭐️\n\n\n\n80\n欢迎来到实力至上主义的教室\n⭐️⭐️⭐️⭐️\n\n\n\n81\n大奉打更人\n⭐️⭐️⭐️⭐️\n\n\n\n82\n约会大作战\n⭐️⭐️\n\n\n\n83\n莉可丽丝\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n84\n夏目友人帐\n⭐️⭐️⭐️\n\n\n\n85\n通往夏天的隧道，离别的出口\n\n\n\n\n86\n间谍过家家\n⭐️⭐️⭐️\n\n\n\n87\n轻音少女\n⭐️⭐️⭐️\n\n\n\n88\n天使降临到我身边\n⭐️⭐️⭐️\n\n\n\n89\n我的妹妹不可能那么可爱\n⭐️⭐️\n\n\n\n90\n濑户的花嫁\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n91\n逆天邪神\n\n\n\n\n92\n物语系列\n\n\n\n\n93\n败犬女主太多了\n⭐️⭐️⭐️\n\n\n\n94\n鹿乃子乃子虎视眈眈\n⭐️⭐️⭐️⭐️\n\n\n\n95\n百变的七仓同学\n⭐️⭐️⭐️⭐️\n\n\n\n96\n堀与宫村\n⭐️⭐️⭐️⭐️\n\n\n\n97\n架向星空之桥\n\n\n\n\n98\n灰色的果实\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n99\n诡秘之主\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n100\n强风吹拂\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n101\n宿命之环\n⭐️⭐️⭐️⭐️\n\n\n\n102\n灵境行者\n⭐️⭐️⭐️⭐️\n\n\n\n103\n夜的命名术\n⭐️⭐️⭐️⭐️\n\n\n\n104\n黑镜\n⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n105\n超异能族\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n106\n555 二十周年剧场版\n⭐️⭐️⭐️\n\n\n\n107\n人生切割术\n⭐️⭐️⭐️⭐️\n\n\n\n108\n精神病院学斩神\n⭐️⭐️⭐️⭐️\n\n\n\n109\n异兽迷城\n⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n110\n总之就是非常可爱\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n111\n冰菓\n⭐️⭐️⭐️⭐️\n\n\n\n112\n关于前辈很烦人的事\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n113\n变态王子与不笑猫\n⭐️\n\n\n\n114\n蛊真人\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n115\n道诡异仙\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n116\n幸福加奈子的快乐杀手生活\n⭐️⭐️⭐️⭐️\n\n\n\n117\n辉夜大小姐想让我告白\n⭐️⭐️⭐️⭐️\n\n\n\n118\n女高中生的虚度日常\n⭐️⭐️⭐️⭐️\n\n\n\n119\n孤独摇滚！\n⭐️⭐️⭐️⭐️\n\n\n\n120\n普罗之主\n\n\n\n\n121\n我不是戏神\n\n\n\n\n122\n神秘复苏\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n123\n诡舍\n\n\n\n\n124\n魔法少女伊莉亚\n\n\n\n\n125\n炮弹音量调\n⭐️\n\n\n\n126\n回复术士的重启人生\n⭐️\n\n\n\n127\n莉可丽丝 2\n\n\n\n\n128\n吞噬星空 2\n\n\n\n\n129\n我的妻子竟然是大乘期修士\n⭐️⭐️⭐️\n\n\n\n130\n惊悚乐园\n\n\n\n\n131\n我有一座冒险屋\n\n\n\n\n132\n星门\n\n\n\n\n133\n万族之劫\n⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n134\n全球高武\n\n\n\n\n135\n捞尸人\n\n\n\n\n136\n不科学御兽\n\n\n\n\n137\n第一序列\n\n\n\n\n138\n伪恋\n⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n139\n会长是女仆大人！\n⭐️⭐️\n\n\n\n140\n邻座的怪同学\n⭐️⭐️⭐️⭐️⭐️⭐️\n\n\n\n141\n未确认进行式\n⭐️⭐️⭐️⭐️⭐️\n\n\n\n142\n摇滚乃是淑女的爱好\n⭐️⭐️⭐️⭐️⭐️⭐️⭐️\n战斗音乐番\n\n\n\n","categories":["生活"],"tags":["待看列表"]},{"title":"浏览器事件循环","url":"/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","content":"事件循环：浏览器中事件运行顺序和过程\n\n浏览器的进程模型\n何为进程？\n程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程\n\n每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。\n何为线程？\n有了进程后，就可以运行程序的代码了。\n运行代码的「人」称之为「线程」。\n一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。\n如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。\n\n\nimage-20220809210859457\n\n浏览器有哪些进程和线程？\n浏览器是一个多进程多线程的应用程序\n浏览器内部工作极其复杂。\n为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。\n\n\nimage-20220809213152371\n\n\n可以在浏览器的任务管理器中查看当前的所有进程\n\n其中，最主要的进程有：\n\n浏览器进程\n主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。\n网络进程\n负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。\n渲染进程（本节课重点讲解的进程）\n渲染进程启动后，会开启一个渲染主线程，主线程负责执行\nHTML、CSS、JS 代码。\n默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。\n\n将来该默认模式可能会有所改变，有兴趣的同学可参见chrome官方说明文档\n\n\n渲染主线程是如何工作的？\n渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：\n\n解析 HTML\n解析 CSS\n计算样式\n布局\n处理图层\n每秒把页面画 60 次\n执行全局 JS 代码\n执行事件处理函数\n执行计时器的回调函数\n……\n\n\n思考题：为什么渲染进程不适用多个线程来处理这些事情？\n\n要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？\n比如：\n\n我正在执行一个 JS\n函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？\n我正在执行一个 JS\n函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？\n浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？\n……\n\n渲染主线程想出了一个绝妙的主意来处理这个问题：排队\n\n\nimage-20220809223027806\n\n\n在最开始的时候，渲染主线程会进入一个无限循环\n每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。\n其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务\n\n这样一来，就可以让每个任务有条不紊的、持续的进行下去了。\n整个过程，被称之为事件循环（消息循环）\n若干解释\n何为异步？\n代码在执行过程中，会遇到一些无法立即处理的任务，比如：\n\n计时完成后需要执行的任务 ——\nsetTimeout、setInterval\n网络通信完成后需要执行的任务 –\nXHR、Fetch\n用户操作后需要执行的任务 – addEventListener\n\n如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」\n\n\nimage-20220810104344296\n\n渲染主线程承担着极其重要的工作，无论如何都不能阻塞！\n因此，浏览器选择异步来解决这个问题\n\n\nimage-20220810104858857\n\n使用异步的方式，渲染主线程永不阻塞\n\n面试题：如何理解 JS 的异步？\n参考答案：\nJS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。\n而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。\n如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。\n所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。\n在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。\n\nJS为何会阻碍渲染？\n先看代码\n&lt;h1&gt;Mr.Yuan is awesome!&lt;/h1&gt;&lt;button&gt;change&lt;/button&gt;&lt;script&gt;  var h1 = document.querySelector('h1');  var btn = document.querySelector('button');  // 死循环指定的时间  function delay(duration) {    var start = Date.now();    while (Date.now() - start &lt; duration) {}  }  btn.onclick = function () {    h1.textContent = '袁老师很帅！';    delay(3000);  };&lt;/script&gt;\n点击按钮后，会发生什么呢？\n&lt;见具体演示&gt;\n任务有优先级吗？\n任务没有优先级，在消息队列中先进先出\n但消息队列是有优先级的\n根据 W3C 的最新解释:\n\n每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。\n在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。\n浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行\nhttps://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\n\n\n随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法\n\n在目前 chrome 的实现中，至少包含了下面的队列：\n\n延时队列：用于存放计时器到达后的回调任务，优先级「中」\n交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」\n微队列：用户存放需要最快执行的任务，优先级「最高」\n\n\n添加任务到微队列的主要方式主要是使用 Promise、MutationObserver\n例如：\n// 立即把一个函数添加到微队列Promise.resolve().then(函数)\n\n\n浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑\n\n\n面试题：阐述一下 JS 的事件循环\n参考答案：\n事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。\n在 Chrome 的源码中，它开启一个不会结束的 for\n循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。\n过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。\n根据 W3C\n官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。\n\n\n面试题：JS 中的计时器能做到精确计时吗？为什么？\n参考答案：\n不行，因为：\n\n计算机硬件没有原子钟，无法做到精确计时\n操作系统的计时函数本身就有少量偏差，由于 JS\n的计时器最终调用的是操作系统的函数，也就携带了这些偏差\n按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有\n4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差\n受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差\n\n\n","categories":["前端","基础知识"],"tags":["Web"]},{"title":"数据库索引设计","url":"/2024/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1/","content":"索引是数据库性能优化的重要手段，不同类型的索引适用于不同的查询场景。MySQL\n8.0\n引入了如隐藏索引、降序索引等新特性，增强了索引的灵活性与可维护性。在实际设计中，应遵循最左前缀原则、选择性高优先、覆盖索引优先等原则，以最大程度发挥索引的性能优势。\n\n1. 索引的声明与使用\n1.1 索引的分类\n\n从功能逻辑上说，索引主要有 4\n种，分别是普通索引、唯一索引、主键索引、全文索引。\n按照物理实现方式，索引可以分为 2\n种：聚簇索引和非聚簇索引。\n按照作用字段个数进行划分，分成单列索引和联合索引。\n\n1. 普通索引\n在创建普通索引时，不附加任何限制条件，只是用于提高查询效率。这类索引可以创建在任何数据类型中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。建立索而以后，可以通过索引进行查询。例如，在表\nstudent 的字段 name\n上建立一个普通索引，查询记录时就可以根据该索引进行查询。|\n2. 唯一性索引\n使用UNIQUE参数\n可以设置索引为唯一性索引，在创建唯一性索引时，限制该索引的值必须是唯一的，但允许有空值。在一张数据表里\n可以有多个 唯一索引。\n例如，在表 student 的字段 email 中创建唯一性索引，那么字段 email\n的值就必须是唯一的。通过唯一性索引，可以更快速地确定某条记录。\n3. 主键索引\n主键索引就是一种\n特殊的唯一性索引，在唯一索引的基础上增加了不为空的约束，也就是\nNOT NULL+UNIQUE，一张表里 最多只有一个主键索引。\n\n这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。\n\n4. 单列索引\n在表中的单个字段上创建索引。单列素引只根据该字段进行素引。单列索引可以是普通素引，也可以是唯一性素引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。\n5. 多列 (组合、联合) 索引\n多列索引是在表的多个字段组合上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段\nid、name 和 gender 上建立一个多列索引\nidx_id_name-gender，只有在查询条件中使用了字段 id\n时该索引才会被使用。使用组合索引时遵循最左前缀集合。\n6. 全文检索\n全文索引 (也称全文检索)\n是目前搜索引擎使用的一种关键技术。它能够利用【分词技术】等多种算法智能分析出文本文字中关键词的频率和重要性，然后按照一定的算法规则智能地耖选出我们想要的搜索结果。全文索引非常适合大型数据集，对于小的数据集，它的用处比较小。\n使用参数 FULLTEXT\n可以设置索引为全文索引。在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引只能创建在\nCHAR 、VARCHAR 或 TEXT\n类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表\nstudent 的字段 information 是 TEXT\n类型，该字段包含了很多文字信息。在字段 information\n上建立全文索引后，可以提高查询字段 information 的速度。\n全文索引典型的有两种类型：自然语言的全文索引 和 布尔全文索引。\n\n自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过\n50%\n的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。\n\nMySQL 数据库从 3.23.23 版开始支持全文索引，但 MySQL5.6.4 以前只有\nMyisam 支持，5.6.4 版本以后 innodb\n才支持，但是官方版本不支持中文分词，需要第三方分词插件。在 5.7.6\n版本，MySQL 内置了 ngram\n全文解析器，用来支持亚洲语种的分词。测试或使用全文索引时，要先看一下自己的\nMYSQL 版本、存储引擎和数据类型是否支持全文索引。\n随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被\nsolr、ElasticSearch 等专门的搜索引擎所替代。\n7. 补充：空间索引\n使用参数 SPATIAL\n可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL\n中的空间数据类型包括 GEOMETRY、POINT、LINESTRING 和 POLYGON 等。目前只有\nMyISAM\n存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。\n小结：不同的存储引擎支持的索引类型也不一样 \nInnoDB ：支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引；\nMemory ：支持 B-tree、Hash 等 索引，不支持 Full-text 索引；\nNDB ：支持 Hash 索引，不支持 B-tree、Full-text 等索引；\nArchive ：不支 持 B-tree、Hash、Full-text 等索引；\n1.2 创建索引\nMySQL 支持多种方法在单个或多个列上创建索引：在创建表的定义语句 CREATE\nTABLE 中指定索引列，使用 ALTER TABLE 语句在存在的表上创建索引，或者使用\nCREATE INDEX 语句在已存在的表上添加索引。\n1. 创建表的时候创建索引\n使用 CREATE TABLE\n创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。\n举例：\nCREATE TABLE dept(dept_id INT PRIMARY KEY AUTO_INCREMENT,dept_name VARCHAR(20));CREATE TABLE emp(emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR(20) UNIQUE,dept_id INT,CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id))\n但是，如果显式创建表时创建索引的话，基本语法格式如下：\nCREATE TABLE table_name [col_name data_type][UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |DESC]\n\nUNIQUE 、 FULLTEXT 和 SPATIAL\n为可选参数，分别表示唯一索引、全文索引和空间索引；\nINDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；\nindex_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认\ncol_name 为索引名；\ncol_name\n为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；\nlength\n为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；\nASC 或 DESC 指定升序或者降序的索引值存储。\n\n1. 创建普通索引\n在 book 表中的 year_publication 字段上建立普通索引，SQL\n语句如下：\nCREATE TABLE book(    book_id INT ,    book_name VARCHAR(100),    authors VARCHAR(100),    info VARCHAR(100) ,    comment VARCHAR(100),    year_publication YEAR,    INDEX year_pu(year_publication));\n2. 创建唯一索引\nCREATE TABLE test1(    id INT NOT NULL,    name varchar(30) NOT NULL,    UNIQUE INDEX uk_idx_id(id));\n该语句执行完毕之后，使用 SHOW CREATE TABLE 查看表结构：\nSHOW INDEX FROM test1 \\G\n3. 主键索引\n设定为主键后数据库会自动建立索引，innodb 为聚簇索引，语法：\n\n随表一起建索引：\n\nCREATE TABLE student (    id INT(10) UNSIGNED AUTO_INCREMENT ,    student_no VARCHAR(200),    student_name VARCHAR(200),    PRIMARY KEY(id));\n\n删除主键索引：\n\nALTER TABLE studentdrop PRIMARY KEY;\n\n修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引\n\n4. 创建单列索引\nCREATE TABLE test2(id INT NOT NULL,name CHAR(50) NULL,INDEX single_idx_name(name(20)));\n5. 创建组合索引\n举例：创建表 test3，在表中的 id、name 和 age 字段上建立组合索引，SQL\n语句如下：\nCREATE TABLE test3(    id INT(11) NOT NULL,    name CHAR(30) NOT NULL,    age INT(11) NOT NULL,    info VARCHAR(255),    INDEX multi_idx(id,name,age));\n在 test3 表中，查询 id 和 name 字段，使用 EXPLAIN\n语句查看索引的使用情况：\nEXPLAIN SELECT * FROM test3 WHERE id=1 AND name='songhongkang' \\G\n可以看到，查询 id 和 name 字段时，使用了名称为 MultiIdx\n的索引，如果查询 (name, age) 组合或者单独查询 name 和 age\n字段，会发现结果中 possible_keys 和 key 值为 NULL, 并没有使用在 t3\n表中创建的索引进行查询。\n6. 创建全文索引\nFULLTEXT 全文索引可以用于全文检索，并且只为 CHAR\n、VARCHAR 和 TEXT\n列创建索引。索引总是对整个列进行，不支持局部 (前缀) 索引。\n举例 1：创建表 test4，在表中的 info 字段上建立全文索引，SQL\n语句如下：\nCREATE TABLE test4(id INT NOT NULL,name CHAR(30) NOT NULL,age INT NOT NULL,info VARCHAR(255),FULLTEXT INDEX futxt_idx_info(info)) ENGINE=MyISAM;\n\n在 MySQL5.7 及之后版本中可以不指定最后的 ENGINE 了，因为在此版本中\nInnoDB 支持全文索引\n\n举例 2：\nCREATE TABLE `papers` (`id` int(10) unsigned NOT NULL AUTO_INCREMENT,`title` varchar(200) DEFAULT NULL,`content` text,PRIMARY KEY (`id`),FULLTEXT KEY `title` (`title`,`content`)) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n不同于 like 方式的的查询：\nSELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;\n全文索引用 match+against 方式查询：\nSELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);\n明显的提高查询效率。\n\n注意点\n\n使用全文索引前，搞清楚版本支持情况；\n全文索引比 like + % 快 N 倍，但是可能存在精度问题；\n如果需要全文索引的是大量数据，建议先添加数据，再创建索引。\n\n\n7. 创建空间索引\n空间索引创建中，要求空间类型的字段必须为 非空 。\n举例：创建表 test5，在空间类型为 GEOMETRY 的字段上创建空间索引，SQL\n语句如下：\nCREATE TABLE test5(    geo GEOMETRY NOT NULL,    SPATIAL INDEX spa_idx_geo(geo)) ENGINE=MyISAM;\n2. 在已经存在的表上创建索引\n在已经存在的表中创建索引可以使用 ALTER TABLE 语句或者 CREATE INDEX\n语句。\n1. 使用 ALTER TABLE 语句创建索引 ALTER TABLE\n语句创建索引的基本语法如下：\nALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY][index_name] (col_name[length],...) [ASC | DESC]\n2. 使用 CREATE INDEX 创建索引 CREATE INDEX\n语句可以在已经存在的表上添加索引，在 MySQL 中， CREATE INDEX\n被映射到一个 ALTER TABLE 语句上，基本语法结构为：\nCREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_nameON table_name (col_name[length],...) [ASC | DESC]\n1.3 删除索引\n有索引字段进行大量插入和删除时，性能会下降\n在插入和删除前可以先删除索引，之后重建索引进行查询操作\n1. 使用 ALTER TABLE 删除索引 ALTER TABLE\n删除索引的基本语法格式如下：\nALTER TABLE table_name DROP INDEX index_name;\n2. 使用 DROP INDEX 语句删除索引 DROP INDEX\n删除索引的基本语法格式如下：\nDROP INDEX index_name ON table_name;\n\n提示:\n删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。\n\n2. MySQL8.0 索引新特性\n2.1 支持降序索引\n降序索引以降序存储键值。虽然在语法上，从 MySQL 4\n版本开始就已经支持降序索引的语法了，但实际上 DESC 定义是被忽略的，直到\nMySQL 8.x 版本才开始真正支持降序索引 (仅限于 InnoDB 存储引擎)。\nMySQL 在 8.0\n版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。\n举例：分别在 MySQL 5.7 版本和 MySQL 8.0 版本中创建数据表\nts1，结果如下：\nCREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc);\n在 MySQL 5.7 版本中查看数据表 ts1 的结构，结果如下:\n从结果可以看出，索引仍然是默认的升序\n在 MySQL 8.0 版本中查看数据表 ts1 的结构，结果如下：\n从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。\n分别在 MySQL 5.7 版本和 MySQL 8.0 版本的数据表 ts1 中插入 800\n条随机数据，执行语句如下：\nDELIMITER //CREATE PROCEDURE ts_insert()BEGIN\tDECLARE i INT DEFAULT 1;\tWHILE i &lt; 800\tDO\t\tinsert into ts1 select rand()*80000, rand()*80000;\t\tSET i = i+1;\tEND WHILE;\tcommit;END //DELIMITER;# 调用CALL ts_insert();\n查看数据表 ts1 的执行计划:\nEXPLAIN SELECT * FROM ts1 ORDER BY a, b DESC LIMIT 5;\n从结果可以看出，修改后 MySQL 5.7 的执行计划要明显好于 MySQL 8.0。\n2.2 隐藏索引\n在 MySQL 5.7\n版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。\n从 MySQL 8.x 开始支持 隐藏索引（invisible\nindexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用\nforce index（强制使用索引），优化器也不会使用该索引，\n确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。\n这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。\n同时，如果你想验证某个索引删除之后的\n查询性能影响，就可以暂时先隐藏该索引。\n\n主键不能被设置为隐藏索引。\n当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。\n\n索引默认是可见的，在使用 CREATE TABLE, CREATE INDEX 或者 ALTER TABLE\n等语句时可以通过 VISIBLE 或者 INVISIBLE\n关键词设置索引的可见性。\n1. 创建表时直接创建\n在 MySQL 中创建隐藏索引通过 SQL 语句 INVISIBLE\n来实现，其语法形式如下：\nCREATE TABLE tablename(propname1 type1[CONSTRAINT1],propname2 type2[CONSTRAINT2],……propnamen typen,INDEX [indexname](propname1 [(length)]) INVISIBLE);\n上述语句比普通索引多了一个关键字\nINVISIBLE，用来标记索引为不可见索引。\n2. 在已经存在的表上创建\n可以为已经存在的表设置隐藏索引，其语法形式如下：\nCREATE INDEX indexnameON tablename(propname[(length)]) INVISIBLE;\n3. 通过 ALTER TABLE 语句创建\n语法形式如下：\nALTER TABLE tablenameADD INDEX indexname (propname [(length)]) INVISIBLE;\n4. 切换索引可见状态\n已存在的索引可通过如下语句切换可见状态：\nALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引\n如果将 index_cname 索引切换成可见状态，通过 explain\n查看执行计划，发现优化器选择了 index_cname 索引。\n\n注意\n当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。\n\n通过设置隐藏索引的可见性可以查看索引对调优的帮助。\n5. 使隐藏索引对查询优化器可见\n在 MySQL 8.x\n版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关\n(use_invisible_indexes) 来打开某个设置，使隐藏索引对查询优化器可见。如果\nuse_invisible_indexes 设置为 off\n(默认)，优化器会忽略隐藏索引。如果设置为\non，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。\n（1）在 MySQL 命令行执行如下命令查看查询优化器的开关设置。\nmysql&gt; select @@optimizer_switch \\G\n在输出的结果信息中找到如下属性配置。\nuse_invisible_indexes=off\n此属性配置值为 off，说明隐藏索引默认对查询优化器不可见。\n（2）使隐藏索引对查询优化器可见，需要在 MySQL\n命令行执行如下命令：\nmysql&gt; set session optimizer_switch=\"use_invisible_indexes=on\";Query OK, 0 rows affected (0.00 sec)\nSQL 语句执行成功，再次查看查询优化器的开关设置。\nmysql&gt; select @@optimizer_switch \\G*************************** 1. row ***************************@@optimizer_switch:index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=on,skip_scan=on,hash_join=on1 row in set (0.00 sec)\n此时，在输出结果中可以看到如下属性配置。\nuse_invisible_indexes=on\nuse_invisible_indexes 属性的值为\non，说明此时隐藏索引对查询优化器可见。\n（3）使用 EXPLAIN 查看以字段 invisible_column\n作为查询条件时的索引使用情况。\nexplain select * from classes where cname = '高一2班';\n查询优化器会使用隐藏索引来查询数据。\n（4）如果需要使隐藏索引对查询优化器不可见，则只需要执行如下命令即可。\nmysql&gt; set session optimizer_switch=\"use_invisible_indexes=off\";Query OK, 0 rows affected (0.00 sec)\n再次查看查询优化器的开关设置。\nmysql&gt; select @@optimizer_switch \\G\n此时，use_invisible_indexes 属性的值已经被设置为“off”。\n3. 索引的设计原则\n为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑相应准则。\n3.1 数据准备\n第 1 步：创建数据库、创建表\nCREATE DATABASE atguigudb1;USE atguigudb1;#1.创建学生表和课程表CREATE TABLE `student_info` (`id` INT(11) NOT NULL AUTO_INCREMENT,`student_id` INT NOT NULL ,`name` VARCHAR(20) DEFAULT NULL,`course_id` INT NOT NULL ,`class_id` INT(11) DEFAULT NULL,`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `course` (`id` INT(11) NOT NULL AUTO_INCREMENT,`course_id` INT NOT NULL ,`course_name` VARCHAR(40) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n第 2 步：创建模拟数据必需的存储函数\n#函数1：创建随机产生字符串函数DELIMITER //CREATE FUNCTION rand_string(n INT)\tRETURNS VARCHAR(255) #该函数会返回一个字符串BEGIN\tDECLARE chars_str VARCHAR(100) DEFAULT'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';\tDECLARE return_str VARCHAR(255) DEFAULT '';    DECLARE i INT DEFAULT 0;    WHILE i &lt; n DO    \tSET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));    \tSET i = i + 1;    END WHILE;    RETURN return_str;END //DELIMITER ;\n#函数2：创建随机数函数DELIMITER //CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)BEGINDECLARE i INT DEFAULT 0;SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;RETURN i;END //DELIMITER ;\n创建函数，假如报错：\nThis function has none of DETERMINISTIC......\n由于开启过慢查询日志 bin-log, 我们就必须为我们的 function\n指定一个参数。\n主从复制，主机会将写操作记录在 bin-log 日志中。从机读取 bin-log\n日志，执行语句来同步数据。如果使\n用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql\n不开启创建函数设置。\n\n查看 mysql 是否允许创建函数：\n\nshow variables like 'log_bin_trust_function_creators';\n\n命令开启：允许创建函数设置：\n\nset global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。\n\nmysqld 重启，上述参数又会消失。永久方法：\n\nwindows 下：my.ini[mysqld]加上：\nlog_bin_trust_function_creators=1\nlinux 下：/etc/my.cnf 下 my.cnf[mysqld]加上：\nlog_bin_trust_function_creators=1\n\n\n第 3 步：创建插入模拟数据的存储过程\n# 存储过程1：创建插入课程表存储过程DELIMITER //CREATE PROCEDURE insert_course( max_num INT )BEGINDECLARE i INT DEFAULT 0;SET autocommit = 0; #设置手动提交事务REPEAT #循环SET i = i + 1; #赋值INSERT INTO course (course_id, course_name ) VALUES(rand_num(10000,10100),rand_string(6));UNTIL i = max_numEND REPEAT;COMMIT; #提交事务END //DELIMITER ;\n# 存储过程2：创建插入学生信息表存储过程DELIMITER //CREATE PROCEDURE insert_stu( max_num INT )BEGINDECLARE i INT DEFAULT 0;SET autocommit = 0; #设置手动提交事务REPEAT #循环SET i = i + 1; #赋值INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES(rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));UNTIL i = max_numEND REPEAT;COMMIT; #提交事务END //DELIMITER ;\n第 4 步：调用存储过程\nCALL insert_course(100);\nCALL insert_stu(1000000);\n3.2 哪些情况适合创建索引\n1. 字段的数值有唯一性的限制\n索引本身可以起到约束的作用，比如唯一索引、主键索引都可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一的，就可以直接创建唯一性索引，或者主键索引。这样可以更快速地通过该索引来确定某条记录。\n\n业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba）\n说明：不要以为唯一索引影响了 insert\n速度，这个速度损耗可以忽略，但提高查找速度是明显的。\n\n2. 频繁作为 WHERE\n查询条件的字段\n某个字段在 SELECT 语句的 WHERE\n条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在\n数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。\n比如 student_info 数据表（含 100 万条数据），假设我们想要查询\nstudent_id=123110 的用户信息。\n3. 经常 GROUP BY 和 ORDER BY\n的列\n索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY\n对数据进行分组查询，或者使用 ORDER BY\n对数据进行排序的时候，就需要对分组或者排序的字段进行索引\n。如果待排序的列有多个，那么可以在这些列上建立组合索引（要注意分组或排序中查询的字段顺序）。\n4. UPDATE、DELETE 的 WHERE\n条件列\n对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对\nWHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE\n条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。\n5.DISTINCT 字段需要创建索引\n有时候我们需要对某个字段进行去重，使用\nDISTINCT，那么对这个字段创建索引，也会提升查询效率。\n比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对\nstudent_id 创建索引，执行 SQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`;\n运行结果（600637 条记录，运行时间 0.683s ）\n如果我们对 student_id 创建索引，再执行 SQL 语句：\nSELECT DISTINCT(student_id) FROM `student_info`;\n运行结果（600637 条记录，运行时间 0.010s ）\n你能看到 SQL 查询效率有了提升，同时显示出来的 student_id\n还是按照递增的顺序\n进行展示的。这是因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。\n6. 多表 JOIN\n连接操作时，创建索引注意事项\n首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增\n长会非常快，严重影响查询的效率。\n其次，对 WHERE 条件创建索引，因为 WHERE\n才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE\n条件过滤是非常可怕的。\n最后，对用于连接的字段创建索引，并且该字段在多张表中的\n类型必须一致 。比如 course_id 在 student_info 表和 course 表中都为\nint(11) 类型，而不能一个为 int 另一个为 varchar 类型。\n举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句：\nSELECT s.course_id, name, s.student_id, c.course_nameFROM student_info s JOIN course cON s.course_id = c.course_idWHERE name = '462eed7ac6e791292a79';\n运行结果（1 条数据，运行时间 0.189s ）\n这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s\n。\n7. 使用列的类型小的创建索引\n我们这里所说的 类型大小\n指的就是该类型表示的数据范围的大小。\n我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有\nTINYINT、MEDIUMINT 、INT、 BIGINT\n等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。\n如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用\nINT 就不要使用 BIGINT，能使用 MEDIUMINT 就不要使用 INT。这是因为：\n\n数据类型越小，在查询时进行的比较操作越快\n数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘\nI /0\n带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。\n\n这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的\nI/O。\n8. 使用字符串前缀创建索引\n假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的\nB+树中有这么两个问题:\n\nB+\n树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。\n如果 B+\n树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间\n。\n\n我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。\n创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引\ncreate table shop(address varchar(120) not null);alter table shop add index(address(12));\n问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。怎么计算不同的长度的选择性呢？\n先看一下字段在全部数据中的选择度：\nselect count(distinct address) / count(*) from shop\n通过不同长度去计算，与全表的选择性对比：\ncount(distinct left(列名, 索引长度))/count(*)\nselect count(distinct left(address,10)) / count(*) as sub10, -- 截取前10个字符的选择度count(distinct left(address,15)) / count(*) as sub11, -- 截取前15个字符的选择度count(distinct left(address,20)) / count(*) as sub12, -- 截取前20个字符的选择度count(distinct left(address,25)) / count(*) as sub13 -- 截取前25个字符的选择度from shop;\n\n越接近于 1 越好，说明越有区分度\n\n引申另一个问题：索引列前缀对排序的影响\n如果使用了索引列前缀，比方说前边只把 address 列的\n前12个字符\n放到了二级索引中，下边这个查询可能就有点尴尬了：\nSELECT * FROM shopORDER BY addressLIMIT 12;\n因为二级索引中不包含完整的 address 列信息，所以无法对前 12\n个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式\n无法支持使用索引排序，只能使用文件排序。\n拓展：Alibaba《Java 开发手册》\n【 强制 】在 varchar\n字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本\n区分度决定索引长度。\n说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20\n的索引，区分度会高达 90% 以上 ，可以使用 count(distinct left(列名,\n索引长度))/count(*)的区分度来确定。\n9.\n区分度高(散列性高)的列适合作为索引\n列的基数\n指的是某一列中不重复数据的个数，比方说某个列包含值\n2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是\n3。也就是说在记录行数一定的情况下，列的基数越大，该列中的值越分散；列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列简历索引，为基数太小的列的简历索引效果可能不好。\n可以使用公式select count(distinct a) / count(*) from t1\n计算区分度，越接近 1 越好，一般超过 33%就算比较高效的索引了。\n扩展：联合索引把区分度高(散列性高)的列放在前面。\n10.\n使用最频繁的列放到联合索引的左侧\n这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。\n11.\n在多个字段都要创建索引的情况下，联合索引优于单值索引\n3.3 限制索引的数目\n在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因：\n\n每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。\n索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。\n优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加\nMySQL 优化器生成执行计划时间，降低查询性能。\n\n3.4 哪些情况不适合创建索引\n1. 在 where\n中使用不到的字段，不要设置索引\nWHERE 条件 (包括 GROUP BY、ORDER BY)\n里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个例子：\nSELECT course_id, student_id, create_timeFROM student_infoWHERE student_id = 41251;\n因为我们是按照 student_id\n来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在 SELECT\n字段中。\n2.\n数据量小的表最好不要使用索引\n如果表记录太少，比如少于 1000\n个，那么是不需要创建索引的。表记录太少，是否创建索引\n对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。\n\n结论：在数据表中的数据行数比较少的情况下，比如不到 1000\n行，是不需要创建索引的。\n\n3.\n有大量重复数据的列上不要建立索引\n在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的”性别”字段上只有“男”与“女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。\n\n结论：当数据重复度大，比如高于 10%\n的时候，也不需要对这个字段使用索引。\n\n4.\n避免对经常更新的表创建过多的索引\n第一层含义：频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。\n第二层含义：避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却降低更新表的速度。\n5. 不建议用无序的值作为索引\n例如身份证、UUID(在索引比较时需要转为\nASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。\n6.\n删除不再使用或者很少使用的索引\n表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。\n7. 不要定义夯余或重复的索引\n① 冗余索引\n举例：建表语句如下\nCREATE TABLE person_info(    id INT UNSIGNED NOT NULL AUTO_INCREMENT,    name VARCHAR(100) NOT NULL,    birthday DATE NOT NULL,    phone_number CHAR(11) NOT NULL,    country varchar(100) NOT NULL,    PRIMARY KEY (id),    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),    KEY idx_name (name(10)));\n我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name\n列进行快速搜索，再创建一个专门针对 name 列的索引就算是一个 冗余索引\n，维护这个索引只会增加维护的成本，并不会对搜索有 什么好处。\n② 重复索引\n另一种情况，我们可能会对某个列 重复建立索引 ，比方说这样：\nCREATE TABLE repeat_index_demo (    col1 INT PRIMARY KEY,    col2 INT,    UNIQUE uk_idx_c1 (col1),    INDEX idx_c1 (col1));\n我们看到，col1\n既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。\n","categories":["Database"],"tags":["DB-Index"]},{"title":"浏览器页面渲染流程","url":"/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/","content":"面试题：浏览器工作的原理，网页是渲染的过程。\n\n浏览器是如何渲染页面的？\n当浏览器的网络线程收到 HTML\n文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。\n在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。\n\n整个渲染流程分为多个阶段，分别是： HTML\n解析、样式计算、布局、分层、绘制、分块、光栅化、画\n每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。\n这样，整个渲染流程就形成了一套组织严密的生产流水线。\n\n渲染的第一步是解析 HTML。\n解析过程中遇到 CSS 解析 CSS，遇到 JS 执行\nJS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载\nHTML 中的外部 CSS 文件和 外部的 JS 文件。\n如果主线程解析到link位置，此时外部的 CSS\n文件还没有下载解析好，主线程不会等待，继续解析后续的\nHTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS\n不会阻塞 HTML 解析的根本原因。\n如果主线程解析到script位置，会停止解析 HTML，转而等待 JS\n文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS\n代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是\nJS 会阻塞 HTML 解析的根本原因。\n第一步完成后，会得到 DOM 树和 CSSOM\n树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM\n树中。\n\n渲染的下一步是样式计算。\n主线程会遍历得到的 DOM\n树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。\n在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px\n这一步完成后，会得到一棵带有样式的 DOM 树。\n\n接下来是布局，布局完成后会得到布局树。\n布局阶段会依次遍历 DOM\n树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。\n大部分时候，DOM 树和布局树并非一一对应。\n比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然\nDOM\n树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致\nDOM 树和布局树无法一一对应。\n\n下一步是分层\n主线程会使用一套复杂的策略对整个布局树中进行分层。\n分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。\n滚动条、堆叠上下文、transform、opacity\n等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。\n\n再下一步是绘制\n主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。\n\n完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。\n合成线程首先对每个图层进行分块，将其划分为更多的小区域。\n它会从线程池中拿取多个线程来完成分块工作。\n\n分块完成后，进入光栅化阶段。\n合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。\nGPU\n进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。\n光栅化的结果，就是一块一块的位图\n\n最后一个阶段就是画了\n合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。\n指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。\n变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。\n合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给\nGPU 硬件，完成最终的屏幕成像。\n什么是 reflow？\nreflow 的本质就是重新计算 layout 树。\n当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。\n为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS\n代码全部完成后再进行统一计算。所以，改动属性造成的 reflow\n是异步完成的。\n也同样因为如此，当 JS\n获取布局属性时，就可能造成无法获取到最新的布局信息。\n浏览器在反复权衡下，最终决定获取属性立即 reflow。\n什么是 repaint？\nrepaint 的本质就是重新根据分层信息计算了绘制指令。\n当改动了可见样式后，就需要重新计算，会引发 repaint。\n由于元素的布局信息也属于可见样式，所以 reflow 一定会引起\nrepaint。\n为什么 transform 的效率高？\n因为 transform\n既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段\n由于 draw 阶段在合成线程中，所以 transform\n的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响\ntransform 的变化。\n","categories":["前端","基础知识"],"tags":["Web"]}]