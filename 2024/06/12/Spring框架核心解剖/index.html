<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="blog, decade, lucky">
    <meta name="description" content="Decade&#39;s lucky blog">
    <meta name="author" content="Zhongjun Qiu">
    
    <title>
        
            Spring框架核心解剖 |
        
        Decade
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.ico">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/brands.min.css">
    
        
            
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"decade.net.cn","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Decade","author":"Zhongjun Qiu","avatar":"/images/avatar.ico","logo":"/images/avatar.ico","favicon":"/images/logo.ico"},"menu":{"home":"/ || fa-solid fa-home","archives":"/archives || fa-solid fa-box-archive","tags":"/tags || fa-solid fa-tags","categories":"/categories || fa-solid fa-layer-group","more":{"icon":"fa-solid fa-circle-user","children":[{"tools":"/tools || fa-solid fa-tools"},{"photos":"/photos || fa-solid fa-image"},{"about":"/about || fa-solid fa-user-graduate"}]}},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"The Steadfast Determination of An Ordinary Soul.","hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/Decade-qiu","weixin":"img | /images/social/weixin.jpg","qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":"qiuyu6021@gmail.com"}},"scroll":{"progress_bar":true,"percent":true,"hide_header":false},"home":{"announcement":null,"category":true,"tag":true,"post_datetime":"created || fa-solid fa-history","post_datetime_format":"ago"},"post":{"author_badge":{"enable":true,"level_badge":false,"custom_badge":"元婴开发者"},"word_count":{"wordcount":true,"min2read":true},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":true,"share":true,"reward":{"enable":true,"img_link":"/images/post/payment.jpg","text":null,"icon":null},"created_datetime_icon":"fa-solid fa-calendar-plus","updated_datetime_icon":"fa-solid fa-arrows-rotate"},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":false,"init_open":false,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":false,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"waline","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.39"},"waline":{"server_url":"https://waline-vercel-two-rho.vercel.app/","reaction":true,"version":"3.3.2"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2020,"word_count":true,"site_deploy":{"enable":true,"provider":"github","url":"https://github.com"},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":true,"css":[null,"/css/custom.css"],"js":[null,"/js/custom_code_block.js"]},"root":"","source_data":{"photos":[{"url":"/images/post/【哲风壁纸】日本动漫-电锯人.webp","name":"电锯人"},{"url":"/images/post/Quicker_20250428_193139.webp","name":"kowayia"},{"url":"/images/post/Quicker_20250428_233349.webp","name":"世界地图"},{"url":"/images/post/tmpFE1E.tmp.webp","name":"施红"},{"url":"/images/post/result-1745849388402.webp","name":"仇忠骏.动漫版"},{"url":"/images/photos/猫猫困了PNG.png","name":"猫猫困了PNG"},{"url":"/images/photos/宁静的暴雨天.png","name":"宁静的暴雨天"},{"url":"/images/photos/我在扬州好想你.png","name":"我在扬州好想你"},{"url":"/images/photos/信鸽.png","name":"信鸽"},{"url":"/images/photos/啤酒烧烤.png","name":"啤酒烧烤"},{"url":"/images/photos/随手拍.png","name":"随手拍"},{"url":"/images/photos/糖油混合炸弹.png","name":"糖油混合炸弹"},{"url":"/images/photos/香香的.png","name":"香香的"},{"url":"/images/photos/蝎子莱莱.png","name":"蝎子莱莱"},{"url":"/images/post/指C为python.png","name":"指C为python"},{"url":"/images/photos/YangZhou_Station.png","name":"YangZhou Station"}],"tools":[{"category":"AIGC","anchorId":"QUlHQw0"},{"name":"ChatGPT","link":"https://chat.openai.com/","description":"OpenAI 旗下 AI 聊天对话工具","image":"/images/tools/chatgpt.svg"},{"name":"Gemini","link":"https://gemini.google.com/app","description":"Google 旗下 AI 聊天对话工具","image":"/images/tools/gemini.svg"},{"name":"Copilot","link":"https://copilot.microsoft.com/","description":"Microsoft 旗下 AI 聊天对话工具","image":"/images/tools/copilot.png"},{"name":"Deepseek","link":"https://chat.deepseek.com/","description":"Deepseek 旗下 AI 聊天对话工具","image":"/images/tools/deepseek.jpg"},{"name":"Qwen","link":"https://chat.qwen.ai/","description":"Alibaba 旗下 AI 聊天对话工具","image":"/images/tools/tongyiqianwen.svg"},{"name":"即梦AI","link":"https://jimeng.jianying.com/ai-tool/home","description":"Dreamina 图像生成工具","image":"/images/tools/dream.png"},{"name":"komiko","link":"https://komiko.app/home","description":"Komiko 动漫化AI工具","image":"/images/tools/komiko.webp"},{"name":"InsMind","link":"https://www.insmind.com/zh-cn/workspace/","description":"AI图片编辑工具","image":"/images/tools/insmind.svg"},{"name":"Raphael","link":"https://raphael.app/zh","description":"AI图片生成工具","image":"/images/tools/rap.png"},{"name":"腾讯元宝","link":"https://yuanbao.tencent.com/chat/","description":"Tencent 旗下 AI 聊天对话工具","image":"/images/tools/tencent.jpg"},{"name":"豆包","link":"https://www.doubao.com/chat/","description":"字节跳动 图片生成工具","image":"/images/tools/dn.jpg"},{"category":"Airport","anchorId":"QWlycG9ydA12"},{"name":"独角兽","link":"https://91unicorn.cloud/","description":"十分稳定","image":"/images/tools/dujiaoshou.ico"},{"name":"极速机场","link":"https://xn--mes358acgm99l.com/","description":"便宜好用","image":"/images/tools/jisu.ico"},{"name":"iKuuu","link":"https://ikuuu.org/user","description":"以备不时之需","image":"/images/tools/ikuu.ico"},{"category":"File Converter","anchorId":"RmlsZSUyMENvbnZlcnRlcg16"},{"name":"Online Image Tool","link":"https://www.onlineimagetool.com/zh/","description":"在线压缩和转换图片","image":"/images/tools/oit.png"},{"name":"Vector Magic","link":"https://zh.vectormagic.com/","description":"文件矢量化","image":"/images/tools/apple-touch-icon-180_97956a9f5fbf6a767de100280d78c1f8.png"},{"name":"TinyPNG","link":"https://tinypng.com/","description":"Smart AVIF, WebP, PNG and JPEG Compression for Faster Websites","image":"/images/tools/tiny.ico"},{"name":"踏得","link":"https://techbrood.com/tool","description":"HTML5在线工具","image":"/images/tools/td.ico"},{"name":"UU在线工具","link":"https://uutool.cn/base64/","description":"base64工具包","image":"/images/tools/uu.png"},{"name":"I Love PDF","link":"https://www.ilovepdf.com/","description":"PDF工具包","image":"/images/tools/ilovepdf.svg"},{"category":"Free GPT API","anchorId":"RnJlZSUyMEdQVCUyMEFQSQ23"},{"name":"Gemini API","link":"https://ai.google.dev/gemini-api/docs/quickstart?lang=python","description":"Google Gemini API","image":"/images/tools/touchicon-180-new.png"},{"name":"SiliconCloud","link":"https://cloud.siliconflow.cn/models","description":"各种模型API"},{"name":"Cloudflare Workers AI","link":"https://developers.cloudflare.com/workers-ai/configuration/open-ai-compatibility/","description":"OpenAI compatible API endpoints","image":"/images/tools/logo.p_ySeMR1.svg"},{"name":"算了么","link":"https://api.suanli.cn/","description":"共享算力API","image":"/images/tools/suanlm.svg"},{"category":"Resource Explorer","anchorId":"UmVzb3VyY2UlMjBFeHBsb3Jlcg28"},{"name":"Free for Developers","link":"https://free-for.dev/","description":"A list of SaaS, PaaS and IaaS offerings that have free tiers of interest to devops and infradev","image":"/images/tools/freefd.webp"},{"name":"zlibrary","link":"https://zh.z-library.sk/","description":"在线图书馆","image":"/images/tools/logo.zlibrary.svg"},{"name":"PicX","link":"https://picx.xpoet.cn/","description":"基于Github的图床","image":"/images/tools/logo.ffee4291.png"},{"name":"HaoWallpaper","link":"https://haowallpaper.com/","description":"哲风壁纸","image":"/images/tools/haowall.ico"},{"name":"Awesome","link":"https://wallhaven.cc/","description":"WallHaven","image":"/images/tools/wallheaven.ico"},{"name":"WallHere","link":"https://wallhere.com/","description":"WallHere"},{"name":"SnapAny","link":"https://snapany.com/zh","description":"万能视频图片解析下载"},{"name":"ØMagnet","link":"https://0cili.org/","description":"种子下载"},{"name":"twitter","link":"https://snapvid.net/zh-cn/twitter-downloader","description":"推特视频下载器","image":"/images/tools/apple-touch-icon.png"},{"name":"youtube","link":"https://www.y2mate.com/en949","description":"Youtube视频下载器","image":"/images/tools/y2mate.webp"},{"name":"Icons8","link":"https://icons8.com/icons","description":"免费图标下载","image":"/images/tools/logo-icons8.svg"},{"name":"全能emoji","link":"https://www.emojiall.com/zh-hans","description":"emoji制作","image":"/images/tools/emoji.ico"},{"name":"emojidb","link":"https://emojidb.org/","description":"免费表情包下载","image":"/images/tools/emojidb.png"},{"name":"Flaticon","link":"https://www.flaticon.com/","description":"免费图标下载","image":"/images/tools/logo-flaticon.svg"},{"name":"IconFinder","link":"https://www.iconfinder.com/","description":"免费图标下载","image":"/images/tools/logo-iconfinder.svg"}]},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/avatar.ico">
                </a>
            
            <a class="site-name border-box" href="/">
               Decade
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-home"></i>
                                
                                HOME
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                
                                ARCHIVES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-tags"></i>
                                
                                TAGS
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                
                                CATEGORIES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box has-sub-menu">
                            <a class="menu-text-color border-box" href="javascript:void(0);">
                                
                                    <i class="menu-text-color menu-icon fa-solid fa-circle-user"></i>
                                
                                MORE
                                
                                    <i class="menu-text-color collapse-icon fa-solid fa-angle-down"></i>
                                
                            </a>
                            
                                <ul class="sub-menu-list border-box">
                                    
                                        
                                        <li class="sub-menu-item border-box ">
                                            <a class="menu-text-color border-box flex-start" href="/tools">
                                                
                                                    <i class="menu-text-color sub-menu-icon fa-solid fa-tools"></i>
                                                
                                                TOOLS
                                            </a>
                                        </li>
                                    
                                        
                                        <li class="sub-menu-item border-box ">
                                            <a class="menu-text-color border-box flex-start" href="/photos">
                                                
                                                    <i class="menu-text-color sub-menu-icon fa-solid fa-image"></i>
                                                
                                                PHOTOS
                                            </a>
                                        </li>
                                    
                                        
                                        <li class="sub-menu-item border-box ">
                                            <a class="menu-text-color border-box flex-start" href="/about">
                                                
                                                    <i class="menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i>
                                                
                                                ABOUT
                                            </a>
                                        </li>
                                    
                                </ul>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-home"></i>
                                </span>
                            
                            HOME
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-box-archive"></i>
                                </span>
                            
                            ARCHIVES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-tags"></i>
                                </span>
                            
                            TAGS
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-layer-group"></i>
                                </span>
                            
                            CATEGORIES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box has-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="javascript:void(0);">
                            
                                <span class="menu-icon-wrap border-box flex-center">
                                    <i class="drawer-menu-text-color menu-icon fa-solid fa-circle-user"></i>
                                </span>
                            
                            MORE
                        </a>
                        
                            <i class="right-side collapse-icon fa-solid fa-angle-left"></i>
                        
                    </label>
                    
                        <ul class="drawer-sub-menu-list border-box">
                            
                                
                                <li class="sub-menu-item border-box">
                                    <a class="drawer-menu-text-color border-box flex-start" href="/tools">
                                        
                                            <span class="sub-menu-icon-wrap border-box flex-center">
                                                <i class="drawer-menu-text-color sub-menu-icon fa-solid fa-tools"></i>
                                            </span>
                                        
                                        TOOLS
                                    </a>
                                </li>
                            
                                
                                <li class="sub-menu-item border-box">
                                    <a class="drawer-menu-text-color border-box flex-start" href="/photos">
                                        
                                            <span class="sub-menu-icon-wrap border-box flex-center">
                                                <i class="drawer-menu-text-color sub-menu-icon fa-solid fa-image"></i>
                                            </span>
                                        
                                        PHOTOS
                                    </a>
                                </li>
                            
                                
                                <li class="sub-menu-item border-box">
                                    <a class="drawer-menu-text-color border-box flex-start" href="/about">
                                        
                                            <span class="sub-menu-icon-wrap border-box flex-center">
                                                <i class="drawer-menu-text-color sub-menu-icon fa-solid fa-user-graduate"></i>
                                            </span>
                                        
                                        ABOUT
                                    </a>
                                </li>
                            
                        </ul>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        Spring框架核心解剖
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.ico">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Zhongjun Qiu</span>
                                
                                    <span class="author-badge">元婴开发者</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-06-12 11:07:52</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-arrows-rotate"></i>&nbsp;
                    <span class="datetime" data-updated="Thu May 15 2025 23:39:44 GMT+0800">2025-05-15 23:39:44</span>
                </span>
            
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li>
                        
                    
                            <li class="category-item">&nbsp;<i class="icon fas fa-angle-right"></i>&nbsp;<a href="/categories/Spring/">Spring</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/IoC/">IoC</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/AOP/">AOP</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/TX/">TX</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>28.9k Words</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>119 Mins</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <p>Spring框架核心解剖聚焦 IoC/DI 容器、AOP
切面编程与事务管理（TX）三大核心功能，深入探讨依赖注入原理、切面织入机制和声明式事务控制。</p>
<span id="more"></span>
<h2 id="一技术体系结构">一、技术体系结构</h2>
<h3 id="总体技术体系">1.1 总体技术体系</h3>
<ul>
<li><p>单一架构</p>
<p>一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in
one。</p>
<p>单一架构，项目主要应用技术框架为：Spring , SpringMVC , Mybatis</p>
<figure>
<img lazyload="" alt="img" data-src="ssmjiagou.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>分布式架构</p>
<p>一个项目（对应 IDEA 中的一个
project），拆分成很多个模块，每个模块是一个 IDEA 中的一个
module。每一个工程都是运行在自己的 Tomcat
上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用。</p>
<figure>
<img lazyload="" alt="img" data-src="image_rR3xK4zw_I.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>分布式架构，项目主要应用技术框架：SpringBoot (SSM), SpringCloud ,
中间件等</p></li>
</ul>
<h3 id="框架概念和理解">1.2 框架概念和理解</h3>
<p>框架( Framework
)是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。</p>
<p>框架的优点包括以下几点：</p>
<ol type="1">
<li>提高开发效率：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。</li>
<li>降低开发成本：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。</li>
<li>提高应用程序的稳定性：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。</li>
<li>提供标准化的解决方案：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。</li>
</ol>
<p>框架的缺点包括以下几个方面：</p>
<ol type="1">
<li>学习成本高：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。</li>
<li>可能存在局限性：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。</li>
<li>版本变更和兼容性问题：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。</li>
<li>架构风险：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性。</li>
</ol>
<p>站在文件结构的角度理解框架，可以将框架总结：<strong>框架 =
jar包+配置文件</strong></p>
<p>莎士比亚说,“一千个观众眼中有一千个哈姆雷特”
即仁者见仁,智者见智.说每个人都会对作品有不同的理解，每个人对待任何事物都有自己的看法，同样的技术解决同样的问题会产生不同流程和风格的解决方案，而采用一种框架其实就是限制用户必须使用其规定的方案来实现，可以降低程序员之间沟通以及日后维护的成本！</p>
<p>常用的单一架构JavaEE项目框架演进，从SSH、SSH2过渡到了SSM：SpringMVC、Spring、MyBatis。</p>
<p>总之，框架已经对基础的代码进行了封装并提供相应的API，开发者在使用框架是直接调用封装好的API可以省去很多代码编写，从而提高工作效率和开发速度。</p>
<h2 id="二springframework介绍">二、SpringFramework介绍</h2>
<h3 id="spring-和-springframework概念">2.1 Spring 和
SpringFramework概念</h3>
<p>https://spring.io/projects</p>
<p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p>
<p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p>
<p>经过十多年的发展，Spring
已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如
Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring
Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p>
<p>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p>
<p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p>
<p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring
框架。</p>
<p>Spring
Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency
Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p>
<p>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<p><strong>对比理解：</strong></p>
<p>QQ 和 腾讯</p>
<p>腾讯 = Spring</p>
<p>QQ = SpringFramework</p>
<h3 id="springframework主要功能模块">2.2
SpringFramework主要功能模块</h3>
<p>SpringFramework框架结构图：</p>
<figure>
<img lazyload="" alt="img" data-src="image_iZefjOGOWr.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core Container</td>
<td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>Spring MVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody>
</table>
<h3 id="springframework-主要优势">2.3 SpringFramework 主要优势</h3>
<ol type="1">
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring
Boot、Spring Security、Spring Cloud
等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring
Framework
具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和
API，可以降低开发复杂度和学习成本。同时，Spring Framework
支持各种应用场景，包括 Web 应用程序、RESTful
API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework
开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架。</li>
</ol>
<p>因此，这些优点使得 Spring Framework
成为了一个稳定、可靠、且创新的框架，为企业级 Java
开发提供了一站式的解决方案。</p>
<p>Spring 使创建 Java 企业应用程序变得容易。它提供了在企业环境中采用
Java 语言所需的一切，支持 Groovy 和 Kotlin 作为 JVM
上的替代语言，并且可以根据应用程序的需求灵活地创建多种架构。从Spring
Framework 6.0.6开始，Spring 需要 Java 17+。</p>
<h2 id="三spring-ioc容器和核心概念">三、Spring IoC容器和核心概念</h2>
<h3 id="组件和组件管理概念">3.1 组件和组件管理概念</h3>
<ul>
<li><p><strong><em>*3.1.1 什么是组件?*</em></strong></p>
<p>回顾常规的三层架构处理请求流程：</p>
<figure>
<img lazyload="" alt="img" data-src="image_Gusp1HuW3X.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>整个项目就是由各种组件搭建而成的：</p>
<figure>
<img lazyload="" alt="img" data-src="image_evy1Qf9TmX.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p><strong><em>*3.1.2 我们的期待*</em></strong></p>
<ul>
<li>有人替我们创建组件的对象</li>
<li>有人帮我们保存组件的对象</li>
<li>有人帮助我们自动组装</li>
<li>有人替我们管理事务</li>
<li>有人协助我们整合其他框架</li>
<li>……</li>
</ul></li>
<li><p><strong><em>*3.1.3
Spring充当组件管理角色（IoC）*</em></strong></p>
<p>那么谁帮我们完成我们的期待，帮我们管理组件呢？</p>
<p>当然是Spring 框架了！</p>
<p>组件可以完全交给Spring
框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等！</p>
<p>Spring具体的组件管理动作包含：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>…… 我们只需要编写元数据（配置文件）告知Spring
管理哪些类组件和他们的关系即可！
注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</li>
<li>组件一定是对象</li>
<li>对象不一定是组件 综上所述，Spring
充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</li>
</ul></li>
<li><p><strong><em>*3.1.4 组件交给Spring管理优势*</em></strong>!</p>
<ol type="1">
<li>降低了组件之间的耦合性：Spring
IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。</li>
<li>提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring
IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。</li>
<li>方便了配置和管理：Spring
IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。</li>
<li>交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理）等</li>
</ol></li>
</ul>
<h3 id="spring-ioc容器和容器实现">3.2 Spring IoC容器和容器实现</h3>
<ul>
<li><p><strong><em>*3.2.1 普通和复杂容器*</em></strong></p>
<p><strong><em>*普通容器*</em></strong></p>
<blockquote>
<p>普通容器只能用来存储，没有更多功能。 程序中的普通容器</p>
<ul>
<li>数组</li>
<li>集合：List</li>
<li>集合：Set</li>
</ul>
</blockquote>
<p><strong><em>*复杂容器*</em></strong> Servlet 容器能够管理
Servlet(init,service,destroy)、Filter、Listener
这样的组件的一生，所以它是一个复杂容器。</p>
<blockquote>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 48%">
<col style="width: 3%">
</colgroup>
<thead>
<tr>
<th>名称</th>
<th>时机</th>
<th>次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建对象</td>
<td>默认情况：接收到第一次请求 修改启动顺序后：Web应用启动过程中</td>
<td>一次</td>
</tr>
<tr>
<td>初始化操作</td>
<td>创建对象之后</td>
<td>一次</td>
</tr>
<tr>
<td>处理请求</td>
<td>接收到请求</td>
<td>多次</td>
</tr>
<tr>
<td>销毁操作</td>
<td>Web应用卸载之前</td>
<td>一次</td>
</tr>
<tr>
<td>我们即将要学习的 SpringIoC
容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p>总结：Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等！</p></li>
<li><p><strong><em>*3.2.2 SpringIoC容器介绍*</em></strong></p>
<p>Spring IoC 容器，负责实例化、配置和组装
bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以
<strong><em>*XML、Java 注解或 Java
代码*</em></strong>形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<figure>
<img lazyload="" alt="img" data-src="image_xogFLaPVQN.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>上图显示了 Spring
容器工作原理的高级视图。应用程序类与配置元数据相结合，您拥有完全配置且可执行的系统或应用程序。</p></li>
<li><p><strong><em>*3.2.3
SpringIoC容器具体接口和实现类*</em></strong></p>
<p><strong><em>*SpringIoc容器接口*</em></strong>：</p>
<p><code>BeanFactory</code>
接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！</p>
<p><code>ApplicationContext</code> 是 <code>BeanFactory</code>
的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web 应用程序的
<code>WebApplicationContext</code> 简而言之， <code>BeanFactory</code>
提供了配置框架和基本功能，而 <code>ApplicationContext</code>
添加了更多特定于企业的功能。 <code>ApplicationContext</code> 是
<code>BeanFactory</code> 的完整超集！
<strong><em>*ApplicationContext容器实现类*</em></strong>：</li>
</ul>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>通过读取Java配置类创建 IOC 容器对象</td>
</tr>
<tr>
<td>WebApplicationContext</td>
<td>专门为 Web 应用准备，基于 Web 环境创建 IOC
容器对象，并将对象引入存入 ServletContext 域中。</td>
</tr>
</tbody>
</table></li>
<li><p><strong><em>*3.2.4 SpringIoC容器管理配置方式*</em></strong></p>
<p>Spring IoC
容器使用多种形式的配置元数据。此配置元数据表示您作为应用程序开发人员如何告诉
Spring 容器实例化、配置和组装应用程序中的对象。</p>
<p>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p>
<ol type="1">
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring
IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
</ol></li>
</ul>
<ol type="1">
<li>注解方式：从Spring
2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component,
<span class="citation" data-cites="Service">@Service</span>, <span class="citation" data-cites="Autowired等">@Autowired等</span>），将Bean注册到Spring
IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。
<ol type="1">
<li><strong><em>*Java配置类*</em></strong>方式：从Spring
3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、<span class="citation" data-cites="Bean等注解来实现Bean和依赖关系的配置">@Bean等注解来实现Bean和依赖关系的配置</span>。
为了迎合当下开发环境，我们将以<strong><em>*配置类+注解方式*</em></strong>为主进行讲解！</li>
</ol></li>
</ol>
<h3 id="spring-ioc-di概念总结">3.3 Spring IoC / DI概念总结</h3>
<ul>
<li><p><strong><em>*IoC容器*</em></strong></p>
<p>Spring IoC 容器，负责实例化、配置和组装
bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p></li>
<li><p><strong><em>*IoC（Inversion of
Control）控制反转*</em></strong></p>
<p>IoC
主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由
IoC 容器来创建和管理，即控制权由应用程序转移到 IoC
容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即
IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p></li>
<li><p><strong><em>*DI (Dependency Injection)
依赖注入*</em></strong></p>
<p>DI
是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在
Spring 中，DI 是通过 XML
配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter
方法注入和接口注入。</p></li>
</ul>
<h2 id="四spring-ioc实践和应用">四、Spring IoC实践和应用</h2>
<h3 id="spring-ioc-di-实现步骤">4.1 Spring IoC / DI 实现步骤</h3>
<blockquote>
<p>我们总结下，组件交给Spring
IoC容器管理，并且获取和使用的基本步骤！</p>
</blockquote>
<ol type="1">
<li><p><strong><em>*配置元数据（配置）*</em></strong></p>
<p>配置元数据，既是编写交给SpringIoC容器管理组件的信息，配置方式有三种。</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">    https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id="..." [1] class="..." [2]&gt;  </span><br><span class="line">    &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id="..." class="..."&gt;</span><br><span class="line">    &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;!-- more bean definitions go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>Spring IoC 容器管理一个或多个组件。这些
组件是使用你提供给容器的配置元数据（例如，以 XML
<code>&lt;bean/&gt;</code> 定义的形式）创建的。</p>
<p><bean></bean> 标签 == 组件信息声明</p>
<ul>
<li><code>id</code> 属性是标识单个 Bean 定义的字符串。</li>
</ul></li>
</ol>
<ul>
<li><code>class</code> 属性定义 Bean 的类型并使用完全限定的类名。</li>
</ul>
<ol type="1">
<li><p><strong><em>*实例化IoC容器*</em></strong></p>
<p>提供给 <code>ApplicationContext</code>
构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java
<code>CLASSPATH</code> 等）加载配置元数据。</p>
<p>我们应该选择一个合适的容器实现类，进行IoC容器的实例化工作：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span><br><span class="line">ApplicationContext context = </span><br><span class="line">           new ClassPathXmlApplicationContext("services.xml", "daos.xml");</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*获取Bean（组件）*</em></strong></p>
<p><code>ApplicationContext</code> 是一个高级工厂的接口，能够维护不同
bean 及其依赖项的注册表。通过使用方法
<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>
，您可以检索 bean 的实例。</p>
<p>允许读取 Bean 定义并访问它们，如以下示例所示：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span><br><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");</span><br><span class="line">//获取ioc容器的组件对象</span><br><span class="line">PetStoreService service = context.getBean("petStore", PetStoreService.class);</span><br><span class="line">//使用组件对象</span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="基于xml配置方式组件管理">4.2 基于XML配置方式组件管理</h3>
<h4 id="实验一-组件bean信息声明配置ioc">4.2.1 实验一：
组件（Bean）信息声明配置（IoC）</h4>
<ol type="1">
<li><p>目标</p>
<p>Spring IoC 容器管理一个或多个 bean。这些 Bean
是使用您提供给容器的配置元数据创建的（例如，以 XML
<code>&lt;bean/&gt;</code> 定义的形式）。</p>
<p>我们学习如何通过定义XML配置文件，声明组件类信息，交给 Spring 的 IoC
容器进行组件管理！</p></li>
<li><p>思路</p>
<figure>
<img lazyload="" alt="img" data-src="img006.c8bae859.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>准备项目</p>
<ol type="1">
<li><p>创建maven工程（spring-ioc-xml-01）</p></li>
<li><p>导入SpringIoC相关依赖</p>
<p>pom.xml</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring context依赖--&gt;</span><br><span class="line">    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--junit5测试--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.3.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>基于无参数构造函数</p>
<blockquote>
<p>当通过构造函数方法创建一个 bean（组件对象） 时，所有普通类都可以由
Spring
使用并与之兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定
Bean
类信息就足够了。但是，默认情况下，我们需要一个默认（空）构造函数。</p>
</blockquote>
<ul>
<li>bean标签：通过配置bean标签告诉IOC容器需要创建对象的组件信息</li>
<li>id属性：bean的唯一标识,方便后期获取Bean！</li>
<li>class属性：组件类的全限定符！</li>
<li>注意：要求当前组件类必须包含无参数构造函数！</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class HappyComponent {</span><br><span class="line"></span><br><span class="line">    //默认包含无参数构造函数</span><br><span class="line"></span><br><span class="line">    public void doWork() {</span><br><span class="line">        System.out.println("HappyComponent.doWork");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="happyComponent" class="com.atguigu.ioc.HappyComponent"/&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>基于静态工厂方法实例化</p>
<blockquote>
<p>除了使用构造函数实例化对象，还有一类是通过工厂模式实例化对象。接下来我们讲解如何定义使用静态工厂方法创建Bean的配置
！</p>
</blockquote>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ClientService {</span><br><span class="line">  private static ClientService clientService = new ClientService();</span><br><span class="line">  private ClientService() {}</span><br><span class="line"></span><br><span class="line">  public static ClientService createInstance() {</span><br><span class="line">  </span><br><span class="line">    return clientService;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="clientService"</span><br><span class="line">  class="examples.ClientService"</span><br><span class="line">  factory-method="createInstance"/&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>class属性：指定工厂类的全限定符！</li>
<li>factory-method:
指定静态工厂方法，注意，该方法必须是static方法。</li>
</ul></li>
<li><p>基于实例工厂方法实例化</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultServiceLocator {</span><br><span class="line"></span><br><span class="line">  private static ClientServiceImplclientService = new ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">  public ClientService createClientServiceInstance() {</span><br><span class="line">    return clientService;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将工厂类进行ioc配置 --&gt;</span><br><span class="line">&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据工厂对象的实例工厂方法进行实例化组件对象 --&gt;</span><br><span class="line">&lt;bean id="clientService"</span><br><span class="line">  factory-bean="serviceLocator"</span><br><span class="line">  factory-method="createClientServiceInstance"/&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>factory-bean属性：指定当前容器中工厂Bean 的名称。</li>
<li>factory-method:
指定实例工厂方法名。注意，实例方法必须是非static的！</li>
</ul></li>
<li><p>图解IoC配置流程</p>
<figure>
<img lazyload="" alt="img" data-src="image_1TRaZzVWj_.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ol>
<h4 id="实验二-组件bean依赖注入配置di">4.2.2 实验二：
组件（Bean）依赖注入配置（DI）</h4>
<ol type="1">
<li><p>目标</p>
<p>通过配置文件,实现IoC容器中Bean之间的引用（依赖注入DI配置）。</p>
<p>主要涉及注入场景：基于构造函数的依赖注入和基于 Setter
的依赖注入。</p></li>
<li><p>思路</p>
<figure>
<img lazyload="" alt="img" data-src="image_Av7Jxm_Dok.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>基于构造函数的依赖注入（单个构造参数）</p>
<blockquote>
<p>基于构造函数的 DI
是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
</blockquote>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public UserService(UserDao userDao) {</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;!-- 引用类bean声明 --&gt;</span><br><span class="line">  &lt;bean id="userService" class="x.y.UserService"&gt;</span><br><span class="line">   &lt;!-- 构造函数引用 --&gt;</span><br><span class="line">    &lt;constructor-arg ref="userDao"/&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;!-- 被引用类bean声明 --&gt;</span><br><span class="line">  &lt;bean id="userDao" class="x.y.UserDao"/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>constructor-arg标签：可以引用构造参数 有value和ref两个属性
<ul>
<li>ref引用其他bean的标识。</li>
<li>value为直接属性值。</li>
</ul></li>
</ul></li>
<li><p>基于构造函数的依赖注入（多构造参数解析）</p>
<blockquote>
<p>基于构造函数的 DI
是通过容器调用具有多个参数的构造函数来完成的，每个参数表示一个依赖项。</p>
</blockquote>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao {</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public UserService(int age , String name ,UserDao userDao) {</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 场景1: 多参数，可以按照相应构造函数的顺序注入数据 --&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;bean id="userService" class="x.y.UserService"&gt;</span><br><span class="line">    &lt;!-- value直接注入基本类型值 --&gt;</span><br><span class="line">    &lt;constructor-arg  value="18"/&gt;</span><br><span class="line">    &lt;constructor-arg  value="赵伟风"/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;constructor-arg  ref="userDao"/&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;!-- 被引用类bean声明 --&gt;</span><br><span class="line">  &lt;bean id="userDao" class="x.y.UserDao"/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 场景2: 多参数，可以按照相应构造函数的名称注入数据 --&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;bean id="userService" class="x.y.UserService"&gt;</span><br><span class="line">    &lt;!-- value直接注入基本类型值 --&gt;</span><br><span class="line">    &lt;constructor-arg name="name" value="赵伟风"/&gt;</span><br><span class="line">    &lt;constructor-arg name="userDao" ref="userDao"/&gt;</span><br><span class="line">    &lt;constructor-arg name="age"  value="18"/&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;!-- 被引用类bean声明 --&gt;</span><br><span class="line">  &lt;bean id="userDao" class="x.y.UserDao"/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 场景2: 多参数，可以按照相应构造函数的角标注入数据 </span><br><span class="line">           index从0开始 构造函数(0,1,2....)</span><br><span class="line">--&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id="userService" class="x.y.UserService"&gt;</span><br><span class="line">    &lt;!-- value直接注入基本类型值 --&gt;</span><br><span class="line">    &lt;constructor-arg index="1" value="赵伟风"/&gt;</span><br><span class="line">    &lt;constructor-arg index="2" ref="userDao"/&gt;</span><br><span class="line">    &lt;constructor-arg index="0"  value="18"/&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;!-- 被引用类bean声明 --&gt;</span><br><span class="line">  &lt;bean id="userDao" class="x.y.UserDao"/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>constructor-arg标签：name属性指定参数名、index属性指定参数角标、value属性指定普通属性值</li>
</ul></li>
<li><p><strong><em>*基于Setter方法依赖注入*</em></strong></p>
<blockquote>
<p>开发中，除了构造函数注入（DI）更多的使用的Setter方法进行注入！</p>
</blockquote>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public Class MovieFinder{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class SimpleMovieLister {</span><br><span class="line"></span><br><span class="line">  private MovieFinder movieFinder;</span><br><span class="line">  </span><br><span class="line">  private String movieName;</span><br><span class="line"></span><br><span class="line">  public void setMovieFinder(MovieFinder movieFinder) {</span><br><span class="line">    this.movieFinder = movieFinder;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  public void setMovieName(String movieName){</span><br><span class="line">    this.movieName = movieName;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  // business logic that actually uses the injected MovieFinder is omitted...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id="simpleMovieLister" class="examples.SimpleMovieLister"&gt;</span><br><span class="line">  &lt;!-- setter方法，注入movieFinder对象的标识id</span><br><span class="line">       name = setter方法名（去除前面的set，并将首字母改为小写）  </span><br><span class="line">		ref = 引用bean的id值</span><br><span class="line">   --&gt;</span><br><span class="line">  &lt;property name="movieFinder" ref="movieFinder" /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- setter方法，注入基本数据类型movieName</span><br><span class="line">       name = setter方法名（去除前面的set，并将首字母改为小写）  </span><br><span class="line">		value= 基本类型值</span><br><span class="line">   --&gt;</span><br><span class="line">  &lt;property name="movieName" value="消失的她"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id="movieFinder" class="examples.MovieFinder"/&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>property标签： 可以给setter方法对应的属性赋值</li>
<li>property 标签：
name属性代表<strong><em>*set方法标识*</em></strong>、ref代表引用bean的标识id、value属性代表基本属性值</li>
</ul></li>
</ol>
<p><strong>总结：</strong></p>
<p>依赖注入（DI）包含引用类型和基本数据类型，同时注入的方式也有多种！主流的注入方式为setter方法注入和构造函数注入，两种注入语法都需要掌握！</p>
<p>需要特别注意：引用其他bean，使用ref属性。直接注入基本类型值，使用value属性。</p>
<h4 id="实验三-ioc容器创建和使用">4.2.3 实验三： IoC容器创建和使用</h4>
<ol type="1">
<li><p>介绍</p>
<p>上面的实验只是讲解了如何在XML格式的配置文件编写IoC和DI配置！</p>
<p>想要配置文件中声明组件类信息真正的进行实例化成Bean对象和形成Bean之间的引用关系，我们需要声明IoC容器对象，读取配置文件，实例化组件和关系维护的过程都是在IoC容器中实现的！</p></li>
<li><p>容器实例化</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//方式1:实例化并且指定配置文件</span><br><span class="line">//参数：String...locations 传入一个或者多个配置文件</span><br><span class="line">ApplicationContext context = </span><br><span class="line">           new ClassPathXmlApplicationContext("services.xml", "daos.xml");</span><br><span class="line">           </span><br><span class="line">//方式2:先实例化，再指定配置文件，最后刷新容器触发Bean实例化动作 [springmvc源码和contextLoadListener源码方式]  </span><br><span class="line">ApplicationContext context = </span><br><span class="line">           new ClassPathXmlApplicationContext();   </span><br><span class="line">//设置配置配置文件,方法参数为可变参数,可以设置一个或者多个配置</span><br><span class="line">iocContainer1.setConfigLocations("services.xml", "daos.xml");</span><br><span class="line">//后配置的文件,需要调用refresh方法,触发刷新配置</span><br><span class="line">iocContainer1.refresh();           </span><br></pre></td></tr></table></figure></p></li>
<li><p>Bean对象读取</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//方式1: 根据id获取</span><br><span class="line">//没有指定类型,返回为Object,需要类型转化!</span><br><span class="line">HappyComponent happyComponent = </span><br><span class="line">        (HappyComponent) iocContainer.getBean("bean的id标识");</span><br><span class="line">//使用组件对象        </span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line">//方式2: 根据类型获取</span><br><span class="line">//根据类型获取,但是要求,同类型(当前类,或者之类,或者接口的实现类)只能有一个对象交给IoC容器管理</span><br><span class="line">//配置两个或者以上出现: org.springframework.beans.factory.NoUniqueBeanDefinitionException 问题</span><br><span class="line">HappyComponent happyComponent = iocContainer.getBean(HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line">//方式3: 根据id和类型获取</span><br><span class="line">HappyComponent happyComponent = iocContainer.getBean("bean的id标识", HappyComponent.class);</span><br><span class="line">happyComponent.doWork();</span><br><span class="line"></span><br><span class="line">//根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，</span><br><span class="line">//只要返回的是true就可以认定为和类型匹配，能够获取到。</span><br><span class="line"></span><br><span class="line">// 例如A为一个接口，B实现了A。在IOC配置中要声明实例化对象B。</span><br><span class="line">// 而在使用中getBean(B.class)和getBean(A.class)是等价的。</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="实验四-高级特性组件bean作用域和周期方法配置">4.2.4 实验四：
高级特性：组件（Bean）作用域和周期方法配置</h4>
<ol type="1">
<li><p>组件周期方法配置</p>
<ul>
<li><p>周期方法概念</p>
<p>我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p>类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p></li>
<li><p>周期方法声明</p></li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BeanOne {</span><br><span class="line"></span><br><span class="line">  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span><br><span class="line">  public void init() {</span><br><span class="line">    // 初始化逻辑</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class BeanTwo {</span><br><span class="line"></span><br><span class="line">  public void cleanup() {</span><br><span class="line">    // 释放资源逻辑</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<ul>
<li>周期方法配置</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;bean id="beanOne" class="examples.BeanOne" init-method="init" /&gt;</span><br><span class="line">  &lt;bean id="beanTwo" class="examples.BeanTwo" destroy-method="cleanup" /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>组件作用域配置</p>
<ul>
<li>Bean作用域概念</li>
</ul>
<p><code>&lt;bean</code>
标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p>在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部
<code>BeanDefinition</code> 对象，<code>BeanDefinition</code>
对象内，包含定义的信息（id,class,属性等等）！</p>
<p>这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p>具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p>
<ul>
<li>作用域可选值</li>
</ul>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 58%">
<col style="width: 21%">
<col style="width: 8%">
</colgroup>
<thead>
<tr>
<th>取值</th>
<th style="text-align: left;">含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td style="text-align: left;">在 IOC 容器中，这个 bean
的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td style="text-align: left;">这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>作用域配置</p>
<p>配置scope范围</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bean的作用域 </span><br><span class="line">    准备两个引用关系的组件类即可！！</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;</span><br><span class="line">&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;</span><br><span class="line">&lt;bean id="happyMachine8" scope="prototype" class="com.atguigu.ioc.HappyMachine"&gt;</span><br><span class="line">    &lt;property name="machineName" value="happyMachine"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id="happyComponent8" scope="singleton" class="com.atguigu.ioc.HappyComponent"&gt;</span><br><span class="line">    &lt;property name="componentName" value="happyComponent"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>作用域测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testExperiment08()  {</span><br><span class="line">    ApplicationContext iocContainer = new ClassPathXmlApplicationContext("配置文件名");</span><br><span class="line"></span><br><span class="line">    HappyMachine bean = iocContainer.getBean(HappyMachine.class);</span><br><span class="line">    HappyMachine bean1 = iocContainer.getBean(HappyMachine.class);</span><br><span class="line">    //多例对比 false</span><br><span class="line">    System.out.println(bean == bean1);</span><br><span class="line"></span><br><span class="line">    HappyComponent bean2 = iocContainer.getBean(HappyComponent.class);</span><br><span class="line">    HappyComponent bean3 = iocContainer.getBean(HappyComponent.class);</span><br><span class="line">    //单例对比 true</span><br><span class="line">    System.out.println(bean2 == bean3);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
</ol>
<h4 id="实验五-高级特性factorybean特性和使用">4.2.5 实验五：
高级特性：FactoryBean特性和使用</h4>
<ol type="1">
<li><p>FactoryBean简介</p>
<p><code>FactoryBean</code> 接口是Spring
IoC容器实例化逻辑的可插拔性点。</p>
<p>用于配置复杂的Bean对象，可以将创建过程存储在<code>FactoryBean</code>
的getObject方法！</p>
<p><code>FactoryBean&lt;T&gt;</code> 接口提供三种方法：</p>
<ul>
<li><p><code>T getObject()</code>:</p>
<p>返回此工厂创建的对象的实例。该返回值会被存储到IoC容器！</p></li>
<li><p><code>boolean isSingleton()</code>:</p>
<p>如果此 <code>FactoryBean</code> 返回单例，则返回 <code>true</code>
，否则返回 <code>false</code> 。此方法的默认实现返回 <code>true</code>
（注意，lombok插件使用，可能影响效果）。</p></li>
<li><p><code>Class&lt;?&gt; getObjectType()</code>: 返回
<code>getObject()</code> 方法返回的对象类型，如果事先不知道类型，则返回
<code>null</code> 。 <img lazyload="" alt="img" data-src="image_lCmgMdmbvi.png"></p></li>
</ul></li>
<li><p>FactoryBean使用场景</p>
<ol type="1">
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol></li>
<li><p>Factorybean应用</p>
<ol type="1">
<li><p>准备FactoryBean实现类</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 实现FactoryBean接口时需要指定泛型</span><br><span class="line">// 泛型类型就是当前工厂要生产的对象的类型</span><br><span class="line">public class HappyFactoryBean implements FactoryBean&lt;HappyMachine&gt; {</span><br><span class="line">    </span><br><span class="line">    private String machineName;</span><br><span class="line">    </span><br><span class="line">    public String getMachineName() {</span><br><span class="line">        return machineName;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void setMachineName(String machineName) {</span><br><span class="line">        this.machineName = machineName;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public HappyMachine getObject() throws Exception {</span><br><span class="line">    </span><br><span class="line">        // 方法内部模拟创建、设置一个对象的复杂过程</span><br><span class="line">        HappyMachine happyMachine = new HappyMachine();</span><br><span class="line">    </span><br><span class="line">        happyMachine.setMachineName(this.machineName);</span><br><span class="line">    </span><br><span class="line">        return happyMachine;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() {</span><br><span class="line">    </span><br><span class="line">        // 返回要生产的对象的类型</span><br><span class="line">        return HappyMachine.class;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>配置FactoryBean实现类</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- FactoryBean机制 --&gt;</span><br><span class="line">&lt;!-- 这个bean标签中class属性指定的是HappyFactoryBean，但是将来从这里获取的bean是HappyMachine对象 --&gt;</span><br><span class="line">&lt;bean id="happyMachine7" class="com.atguigu.ioc.HappyFactoryBean"&gt;</span><br><span class="line">    &lt;!-- property标签仍然可以用来通过setXxx()方法给属性赋值 --&gt;</span><br><span class="line">    &lt;property name="machineName" value="iceCreamMachine"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试读取FactoryBean和FactoryBean.getObject对象</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testExperiment07()  {</span><br><span class="line"></span><br><span class="line">    ApplicationContext iocContainer = new ClassPathXmlApplicationContext("spring-bean-07.xml");</span><br><span class="line"></span><br><span class="line">    //注意: 直接根据声明FactoryBean的id,获取的是getObject方法返回的对象</span><br><span class="line">    HappyMachine happyMachine = iocContainer.getBean("happyMachine7",HappyMachine.class);</span><br><span class="line">    System.out.println("happyMachine = " + happyMachine);</span><br><span class="line"></span><br><span class="line">    //如果想要获取FactoryBean对象, 直接在id前添加&amp;符号即可!  &amp;happyMachine7 这是一种固定的约束</span><br><span class="line">    Object bean = iocContainer.getBean("&amp;happyMachine7");</span><br><span class="line">    System.out.println("bean = " + bean);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>FactoryBean和BeanFactory区别</p>
<p><strong><em>*FactoryBean*</em></strong>是 Spring 中一种特殊的
bean，可以在 getObject()
工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的
Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用
getObject() 方法来得到其所生产的 Bean。因此，FactoryBean
可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。</p>
<p>一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</p>
<p><strong><em>*BeanFactory*</em></strong> 是 Spring
框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean
的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory
接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean
实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java
配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory
还包含很多子类（例如，ApplicationContext
接口）提供了额外的强大功能。</p>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建
bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean
的框架基础接口，提供了基本的容器功能和 bean 生命周期管理。</p></li>
</ol>
<h4 id="实验六-基于xml方式整合三层架构组件">4.2.6 实验六：
基于XML方式整合三层架构组件</h4>
<ol type="1">
<li><p>需求分析</p>
<p>搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML方式进行组件管理！</p>
<figure>
<img lazyload="" alt="img" data-src="image_oAOD-VE7wl.png">
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>数据库准备</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">create database studb;</span><br><span class="line"></span><br><span class="line">use studb;</span><br><span class="line"></span><br><span class="line">CREATE TABLE students (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50) NOT NULL,</span><br><span class="line">  gender VARCHAR(10) NOT NULL,</span><br><span class="line">  age INT,</span><br><span class="line">  class VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO students (id, name, gender, age, class)</span><br><span class="line">VALUES</span><br><span class="line">  (1, '张三', '男', 20, '高中一班'),</span><br><span class="line">  (2, '李四', '男', 19, '高中二班'),</span><br><span class="line">  (3, '王五', '女', 18, '高中一班'),</span><br><span class="line">  (4, '赵六', '女', 20, '高中三班'),</span><br><span class="line">  (5, '刘七', '男', 19, '高中二班'),</span><br><span class="line">  (6, '陈八', '女', 18, '高中一班'),</span><br><span class="line">  (7, '杨九', '男', 20, '高中三班'),</span><br><span class="line">  (8, '吴十', '男', 19, '高中二班');</span><br></pre></td></tr></table></figure></p></li>
<li><p>项目准备</p>
<ol type="1">
<li><p>项目创建</p>
<p>spring-xml-practice-02</p></li>
<li><p>依赖导入</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;!--spring context依赖--&gt;</span><br><span class="line">      &lt;!--当你引入SpringContext依赖之后，表示将Spring的基础依赖引入了--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 数据库驱动和连接池--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;8.0.25&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.2.8&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- spring-jdbc --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt; </span><br></pre></td></tr></table></figure></p></li>
<li><p>实体类准备</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Student {</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private String gender;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String classes;</span><br><span class="line"></span><br><span class="line">    public Integer getId() {</span><br><span class="line">        return id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getGender() {</span><br><span class="line">        return gender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setGender(String gender) {</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Integer getAge() {</span><br><span class="line">        return age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) {</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getClasses() {</span><br><span class="line">        return classes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setClasses(String classes) {</span><br><span class="line">        this.classes = classes;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() {</span><br><span class="line">        return "Student{" +</span><br><span class="line">                "id=" + id +</span><br><span class="line">                ", name='" + name + '\'' +</span><br><span class="line">                ", gender='" + gender + '\'' +</span><br><span class="line">                ", age=" + age +</span><br><span class="line">                ", classes='" + classes + '\'' +</span><br><span class="line">                '}';</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>JdbcTemplate技术讲解</p>
<blockquote>
<p>为了在特定领域帮助我们简化代码，Spring 封装了很多
『Template』形式的模板类。例如：RedisTemplate、RestTemplate
等等，包括我们今天要学习的 JdbcTemplate。 jdbc.properties
提取数据库连接信息</p>
</blockquote>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atguigu.url=jdbc:mysql://localhost:3306/studb</span><br><span class="line">atguigu.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">atguigu.username=root</span><br><span class="line">atguigu.password=root</span><br></pre></td></tr></table></figure></p>
<p>springioc配置文件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd </span><br><span class="line">       http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line">        &lt;!-- 导入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;</span><br><span class="line">        &lt;property name="url" value="${atguigu.url}"/&gt;</span><br><span class="line">        &lt;property name="driverClassName" value="${atguigu.driver}"/&gt;</span><br><span class="line">        &lt;property name="username" value="${atguigu.username}"/&gt;</span><br><span class="line">        &lt;property name="password" value="${atguigu.password}"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 JdbcTemplate --&gt;</span><br><span class="line">    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;</span><br><span class="line">        &lt;!-- 装配数据源 --&gt;</span><br><span class="line">        &lt;property name="dataSource" ref="druidDataSource"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>基于jdbcTemplate的CRUD使用</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTemplateTest {</span><br><span class="line">    /**</span><br><span class="line">     * 使用jdbcTemplate进行DML动作</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testDML(){</span><br><span class="line"></span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">            new ClassPathXmlApplicationContext("spring-ioc.xml");</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        //TODO 执行插入一条学员数据</span><br><span class="line">        String sql = "insert into students (id,name,gender,age,class) values (?,?,?,?,?);";</span><br><span class="line">        /*</span><br><span class="line">        参数1: sql语句</span><br><span class="line">        参数2: 可变参数,占位符的值</span><br><span class="line">     */</span><br><span class="line">        int rows = jdbcTemplate.update(sql, 9,"十一", "男", 18, "二年三班");</span><br><span class="line"></span><br><span class="line">        System.out.println("rows = " + rows);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询单条实体对象</span><br><span class="line">     *   public class Student {</span><br><span class="line">     *     private Integer id;</span><br><span class="line">     *     private String name;</span><br><span class="line">     *     private String gender;</span><br><span class="line">     *     private Integer age;</span><br><span class="line">     *     private String classes;</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testDQLForPojo(){</span><br><span class="line"></span><br><span class="line">        String sql = "select id , name , age , gender , class as classes from students where id = ? ;";</span><br><span class="line"></span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">            new ClassPathXmlApplicationContext("spring-ioc.xml");</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);</span><br><span class="line"></span><br><span class="line">        //根据id查询</span><br><span class="line">        Student student = jdbcTemplate.queryForObject(sql,  (rs, rowNum) -&gt; {</span><br><span class="line">            //自己处理结果映射</span><br><span class="line">            Student stu = new Student();</span><br><span class="line">            stu.setId(rs.getInt("id"));</span><br><span class="line">            stu.setName(rs.getString("name"));</span><br><span class="line">            stu.setAge(rs.getInt("age"));</span><br><span class="line">            stu.setGender(rs.getString("gender"));</span><br><span class="line">            stu.setClasses(rs.getString("classes"));</span><br><span class="line">            return stu;</span><br><span class="line">        }, 2);</span><br><span class="line"></span><br><span class="line">        System.out.println("student = " + student);</span><br><span class="line">    }</span><br><span class="line">    /**</span><br><span class="line">     * 查询实体类集合</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testDQLForListPojo(){</span><br><span class="line"></span><br><span class="line">        String sql = "select id , name , age , gender , class as classes from students  ;";</span><br><span class="line"></span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">            new ClassPathXmlApplicationContext("spring-ioc.xml");</span><br><span class="line"></span><br><span class="line">        JdbcTemplate jdbcTemplate = applicationContext.getBean(JdbcTemplate.class);</span><br><span class="line">        /*</span><br><span class="line">        query可以返回集合!</span><br><span class="line">        BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可</span><br><span class="line">     */</span><br><span class="line">        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));</span><br><span class="line"></span><br><span class="line">        System.out.println("studentList = " + studentList);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>三层架构搭建和实现</p>
<ol type="1">
<li><p>持久层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">public interface StudentDao {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学生数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Student&gt; queryAll();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现类</span><br><span class="line">public class StudentDaoImpl implements StudentDao {</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {</span><br><span class="line">        this.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学生数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Student&gt; queryAll() {</span><br><span class="line"></span><br><span class="line">        String sql = "select id , name , age , gender , class as classes from students ;";</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">          query可以返回集合!</span><br><span class="line">          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可</span><br><span class="line">         */</span><br><span class="line">        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));</span><br><span class="line"></span><br><span class="line">        return studentList;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>业务层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">public interface StudentService {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学员业务</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Student&gt; findAll();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现类</span><br><span class="line">public class StudentServiceImpl  implements StudentService {</span><br><span class="line">    </span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    public void setStudentDao(StudentDao studentDao) {</span><br><span class="line">        this.studentDao = studentDao;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学员业务</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Student&gt; findAll() {</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; studentList =  studentDao.queryAll();</span><br><span class="line">        </span><br><span class="line">        return studentList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>表述层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StudentController {</span><br><span class="line">    </span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    public void setStudentService(StudentService studentService) {</span><br><span class="line">        this.studentService = studentService;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void  findAll(){</span><br><span class="line">       List&lt;Student&gt; studentList =  studentService.findAll();</span><br><span class="line">        System.out.println("studentList = " + studentList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>三层架构IoC配置</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line">    &lt;!-- 导入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;</span><br><span class="line">        &lt;property name="url" value="${atguigu.url}"/&gt;</span><br><span class="line">        &lt;property name="driverClassName" value="${atguigu.driver}"/&gt;</span><br><span class="line">        &lt;property name="username" value="${atguigu.username}"/&gt;</span><br><span class="line">        &lt;property name="password" value="${atguigu.password}"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置 JdbcTemplate --&gt;</span><br><span class="line">    &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;</span><br><span class="line">        &lt;!-- 装配数据源 --&gt;</span><br><span class="line">        &lt;property name="dataSource" ref="druidDataSource"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id="studentDao" class="com.atguigu.dao.impl.StudentDaoImpl"&gt;</span><br><span class="line">        &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id="studentService" class="com.atguigu.service.impl.StudentServiceImpl"&gt;</span><br><span class="line">        &lt;property name="studentDao" ref="studentDao" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id="studentController" class="com.atguigu.controller.StudentController"&gt;</span><br><span class="line">        &lt;property name="studentService" ref="studentService" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>运行测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ControllerTest {</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  void testRun(){</span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">                new ClassPathXmlApplicationContext("spring-ioc.xml");</span><br><span class="line">        StudentController studentController = applicationContext.getBean(StudentController.class);</span><br><span class="line">        studentController.findAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>XMLIoC方式问题总结</p>
<ol type="1">
<li>注入的属性必须添加setter方法、代码结构乱！</li>
<li>配置文件和Java代码分离、编写不是很方便！</li>
<li>XML配置文件解析效率低</li>
</ol></li>
</ol>
<h3 id="基于-注解-方式管理-bean">4.3 基于 注解 方式管理 Bean</h3>
<h4 id="实验一-bean注解标记和扫描-ioc">4.3.1 实验一： Bean注解标记和扫描
(IoC)</h4>
<ol type="1">
<li><p><strong><em>*注解理解*</em></strong></p>
<p>和 XML
配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，
然后针对这个位置按照注解标记的功能来执行具体操作。</p>
<p>本质上：所有一切的操作都是 Java 代码来完成的，XML
和注解只是告诉框架中的 Java 代码如何执行。</p></li>
<li><p><strong><em>*扫描理解*</em></strong></p>
<p>Spring
为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。</p></li>
<li><p><strong><em>*准备Spring项目和组件*</em></strong></p>
<ol type="1">
<li><p>准备项目pom.xml</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring context依赖--&gt;</span><br><span class="line">    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--junit5测试--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.3.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>准备组件类</p>
<p>普通组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: 普通的组件</span><br><span class="line"> */</span><br><span class="line">public class CommonComponent {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Controller组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: controller类型组件</span><br><span class="line"> */</span><br><span class="line">public class XxxController {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Service组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: service类型组件</span><br><span class="line"> */</span><br><span class="line">public class XxxService {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Dao组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: dao类型组件</span><br><span class="line"> */</span><br><span class="line">public class XxxDao {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p><strong><em>*组件添加标记注解*</em></strong></p>
<ol type="1">
<li><p>组件标记注解和区别</p>
<p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java
类上，将它们定义成 Spring Bean。</p>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 84%">
</colgroup>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="citation" data-cites="Component">@Component</span></td>
<td>该注解用于描述 Spring 中的
Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如
Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td><span class="citation" data-cites="Repository">@Repository</span></td>
<td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的
Bean，其功能与 <span class="citation" data-cites="Component">@Component</span> 相同。</td>
</tr>
<tr>
<td><span class="citation" data-cites="Service">@Service</span></td>
<td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring
中的 Bean，其功能与 <span class="citation" data-cites="Component">@Component</span> 相同。</td>
</tr>
<tr>
<td><span class="citation" data-cites="Controller">@Controller</span></td>
<td>该注解通常作用在控制层（如SpringMVC 的
Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 <span class="citation" data-cites="Component">@Component</span> 相同。</td>
</tr>
</tbody>
</table></li>
</ol></li>
<li><p>使用注解标记</p>
<p>普通组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: 普通的组件</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CommonComponent {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Controller组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: controller类型组件</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">public class XxxController {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Service组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: service类型组件</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class XxxService {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Dao组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: dao类型组件</span><br><span class="line"> */</span><br><span class="line">@Repository</span><br><span class="line">public class XxxDao {</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*配置文件确定扫描范围*</em></strong></p>
<p>情况1：基本扫描配置</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line">    &lt;!-- 配置自动扫描的包 --&gt;</span><br><span class="line">    &lt;!-- 1.包要精准,提高性能!</span><br><span class="line">         2.会扫描指定的包和子包内容</span><br><span class="line">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.atguigu.components"/&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>情况2：指定排除组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 情况三：指定不扫描的组件 --&gt;</span><br><span class="line">&lt;context:component-scan base-package="com.atguigu.components"&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;</span><br><span class="line">    &lt;!-- type属性：指定根据什么来进行排除，annotation取值表示根据注解来排除 --&gt;</span><br><span class="line">    &lt;!-- expression属性：指定排除规则的表达式，对于注解来说指定全类名即可 --&gt;</span><br><span class="line">    &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p>
<p>情况3：指定扫描组件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 情况四：仅扫描指定的组件 --&gt;</span><br><span class="line">&lt;!-- 仅扫描 = 关闭默认规则 + 追加规则 --&gt;</span><br><span class="line">&lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;</span><br><span class="line">&lt;context:component-scan base-package="com.atguigu.ioc.components" use-default-filters="false"&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;</span><br><span class="line">    &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*组件BeanName问题*</em></strong></p>
<p>在我们使用 XML 方式管理 bean 的时候，每个 bean 都有一个唯一标识——id
属性的值，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。</p>
<p>默认情况：</p>
<p>类名首字母小写就是 bean 的 id。例如：SoldierController 类对应的 bean
的 id 就是 soldierController。</p>
<p>使用value属性指定：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>当注解中只设置一个属性时，value属性的属性名可以省略：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Service("smallDog")</span><br><span class="line">public class SoldierService {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*总结*</em></strong></p>
<ol type="1">
<li>注解方式IoC只是标记哪些类要被Spring管理</li>
<li>最终，我们还需要XML方式或者后面讲解Java配置类方式指定注解生效的包</li>
<li><strong><em>*现阶段配置方式为 注解 （标记）+
XML（扫描）*</em></strong></li>
</ol></li>
</ol>
<h4 id="实验二-组件bean作用域和周期方法注解">4.3.2 实验二：
组件（Bean）作用域和周期方法注解</h4>
<ol type="1">
<li><p>组件周期方法配置</p>
<ol type="1">
<li><p>周期方法概念</p>
<p>我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！</p>
<p>类似于Servlet的init/destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p></li>
<li><p>周期方法声明</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BeanOne {</span><br><span class="line"></span><br><span class="line">  //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span><br><span class="line">  @PostConstruct  //注解制指定初始化方法</span><br><span class="line">  public void init() {</span><br><span class="line">    // 初始化逻辑</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class BeanTwo {</span><br><span class="line">  </span><br><span class="line">  @PreDestroy //注解指定销毁方法</span><br><span class="line">  public void cleanup() {</span><br><span class="line">    // 释放资源逻辑</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>组件作用域配置</p>
<ol type="1">
<li><p>Bean作用域概念</p>
<p><code>&lt;bean</code>
标签声明Bean，只是将Bean的信息配置给SpringIoC容器！</p>
<p>在IoC容器中，这些<code>&lt;bean</code>标签对应的信息转成Spring内部
<code>BeanDefinition</code> 对象，<code>BeanDefinition</code>
对象内，包含定义的信息（id,class,属性等等）！</p>
<p>这意味着，<code>BeanDefinition</code>与<code>类</code>概念一样，SpringIoC容器可以可以根据<code>BeanDefinition</code>对象反射创建多个Bean对象实例。</p>
<p>具体创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！</p></li>
<li><p>作用域可选值</p>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 58%">
<col style="width: 21%">
<col style="width: 8%">
</colgroup>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton</td>
<td>在 IOC 容器中，这个 bean 的对象始终为单实例</td>
<td>IOC 容器初始化时</td>
<td>是</td>
</tr>
<tr>
<td>prototype</td>
<td>这个 bean 在 IOC 容器中有多个实例</td>
<td>获取 bean 时</td>
<td>否</td>
</tr>
<tr>
<td>request</td>
<td>请求范围内有效的实例</td>
<td>每次请求</td>
<td>否</td>
</tr>
<tr>
<td>session</td>
<td>会话范围内有效的实例</td>
<td>每次会话</td>
<td>否</td>
</tr>
</tbody>
</table></li>
<li><p>作用域配置</p></li>
</ol>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON) //单例,默认值</span><br><span class="line">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) //多例  二选一</span><br><span class="line">    public class BeanOne {</span><br><span class="line">    </span><br><span class="line">      //周期方法要求： 方法命名随意，但是要求方法必须是 public void 无形参列表</span><br><span class="line">      @PostConstruct  //注解制指定初始化方法</span><br><span class="line">      public void init() {</span><br><span class="line">        // 初始化逻辑</span><br><span class="line">      }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="实验三-bean属性赋值引用类型自动装配-di">4.3.3 实验三：
Bean属性赋值：引用类型自动装配 (DI)</h4>
<ol type="1">
<li><p><strong><em>*设定场景*</em></strong></p>
<ul>
<li><p>SoldierController 需要 SoldierService</p></li>
<li><p>SoldierService 需要 SoldierDao
同时在各个组件中声明要调用的方法。</p></li>
<li><p>SoldierController中声明方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line"></span><br><span class="line">    private SoldierService soldierService;</span><br><span class="line"></span><br><span class="line">    public void getMessage() {</span><br><span class="line">        soldierService.getMessage();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>SoldierService中声明方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service("smallDog")</span><br><span class="line">public class SoldierService {</span><br><span class="line"></span><br><span class="line">    private SoldierDao soldierDao;</span><br><span class="line"></span><br><span class="line">    public void getMessage() {</span><br><span class="line">        soldierDao.getMessage();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>SoldierDao中声明方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class SoldierDao {</span><br><span class="line"></span><br><span class="line">    public void getMessage() {</span><br><span class="line">        System.out.print("I am a soldier");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p><strong><em>*自动装配实现*</em></strong></p>
<ol type="1">
<li><p>前提</p>
<p>参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。</p>
<p>注意：不区分IoC的方式！XML和注解都可以！</p></li>
<li><p><span class="citation" data-cites="Autowired注解">@Autowired注解</span></p>
<p>在成员变量上直接标记@Autowired注解即可，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。</p></li>
<li><p>给Controller装配Service</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private SoldierService soldierService;</span><br><span class="line">    </span><br><span class="line">    public void getMessage() {</span><br><span class="line">        soldierService.getMessage();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>给Service装配Dao</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service("smallDog")</span><br><span class="line">public class SoldierService {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private SoldierDao soldierDao;</span><br><span class="line">    </span><br><span class="line">    public void getMessage() {</span><br><span class="line">        soldierDao.getMessage();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p><strong><em>*<span class="citation" data-cites="Autowired注解细节">@Autowired注解细节</span>*</em></strong></p>
<ol type="1">
<li><p>标记位置</p>
<ol type="1">
<li><p>成员变量</p>
<p>这是最主要的使用方式！</p>
<p>与xml进行bean ref引用不同，他不需要有set方法！</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service("smallDog")</span><br><span class="line">public class SoldierService {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private SoldierDao soldierDao;</span><br><span class="line">    </span><br><span class="line">    public void getMessage() {</span><br><span class="line">        soldierDao.getMessage();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>构造器</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line">    </span><br><span class="line">    private SoldierService soldierService;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    public SoldierController(SoldierService soldierService) {</span><br><span class="line">        this.soldierService = soldierService;</span><br><span class="line">    }</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure></p></li>
<li><p>setXxx()方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line"></span><br><span class="line">    private SoldierService soldierService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setSoldierService(SoldierService soldierService) {</span><br><span class="line">        this.soldierService = soldierService;</span><br><span class="line">    }</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>工作流程</p>
<figure>
<img lazyload="" alt="img" data-src="img018.2ff0ae09.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>首先根据所需要的组件类型到 IOC 容器中查找
<ul>
<li>能够找到唯一的 bean：直接执行装配</li>
<li>如果完全找不到匹配这个类型的 bean：装配失败</li>
<li>和所需类型匹配的 bean 不止一个
<ul>
<li>没有 <span class="citation" data-cites="Qualifier">@Qualifier</span>
注解：根据 <span class="citation" data-cites="Autowired">@Autowired</span> 标记位置成员变量的变量名作为
bean 的 id 进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul></li>
<li>使用 <span class="citation" data-cites="Qualifier">@Qualifier</span>
注解：根据 <span class="citation" data-cites="Qualifier">@Qualifier</span> 注解中指定的名称作为 bean
的id进行匹配
<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController { </span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(value = "maomiService222")</span><br><span class="line">    // 根据面向接口编程思想，使用接口类型引入Service组件</span><br><span class="line">    private ISoldierService soldierService;</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p><strong><em>*佛系装配*</em></strong></p>
<p>给 <span class="citation" data-cites="Autowired">@Autowired</span>
注解设置 required = false
属性表示：能装就装，装不上就不装。但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Controller(value = "tianDog")</span><br><span class="line">public class SoldierController {</span><br><span class="line">    // 给@Autowired注解设置required = false属性表示：能装就装，装不上就不装</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private ISoldierService soldierService;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*扩展JSR-250注解@Resource*</em></strong></p>
<ul>
<li><p>理解JSR系列注解</p>
<p>JSR（Java Specification
Requests）是Java平台标准化进程中的一种技术规范，而JSR注解是其中一部分重要的内容。按照JSR的分类以及注解语义的不同，可以将JSR注解分为不同的系列，主要有以下几个系列：</p>
<ol type="1">
<li>JSR-175: 这个JSR是Java SE 5引入的，是Java注解最早的规范化版本，Java
SE 5后的版本中都包含该JSR中定义的注解。主要包括以下几种标准注解：</li>
</ol>
<ul>
<li><code>@Deprecated</code>:
标识一个程序元素（如类、方法或字段）已过时，并且在将来的版本中可能会被删除。</li>
<li><code>@Override</code>: 标识一个方法重写了父类中的方法。</li>
<li><code>@SuppressWarnings</code>: 抑制编译时产生的警告消息。</li>
<li><code>@SafeVarargs</code>: 标识一个有安全性警告的可变参数方法。</li>
<li><code>@FunctionalInterface</code>:
标识一个接口只有一个抽象方法，可以作为lambda表达式的目标。</li>
</ul>
<ol type="1">
<li>JSR-250: 这个JSR主要用于在Java EE
5中定义一些支持注解。该JSR主要定义了一些用于进行对象管理的注解，包括：</li>
</ol>
<ul>
<li><code>@Resource</code>: 标识一个需要注入的资源，是实现Java
EE组件之间依赖关系的一种方式。</li>
<li><code>@PostConstruct</code>: 标识一个方法作为初始化方法。</li>
<li><code>@PreDestroy</code>: 标识一个方法作为销毁方法。</li>
<li><code>@Resource.AuthenticationType</code>:
标识注入的资源的身份验证类型。</li>
<li><code>@Resource.AuthenticationType</code>:
标识注入的资源的默认名称。</li>
</ul>
<ol type="1">
<li>JSR-269: 这个JSR主要是Java SE
6中引入的一种支持编译时元数据处理的框架，即使用注解来处理Java源文件。该JSR定义了一些可以用注解标记的注解处理器，用于生成一些元数据，常用的注解有：</li>
</ol>
<ul>
<li><code>@SupportedAnnotationTypes</code>:
标识注解处理器所处理的注解类型。</li>
<li><code>@SupportedSourceVersion</code>:
标识注解处理器支持的Java源码版本。</li>
</ul>
<ol type="1">
<li>JSR-330:
该JSR主要为Java应用程序定义了一个依赖注入的标准，即Java依赖注入标准（javax.inject）。在此规范中定义了多种注解，包括：</li>
</ol>
<ul>
<li><code>@Named</code>: 标识一个被依赖注入的组件的名称。</li>
<li><code>@Inject</code>: 标识一个需要被注入的依赖组件。</li>
<li><code>@Singleton</code>:
标识一个组件的生命周期只有一个唯一的实例。</li>
</ul>
<p>但是你要理解JSR是Java提供的<strong><em>*技术规范*</em></strong>，也就是说，他只是规定了注解和注解的含义，<strong><em>*JSR并不是直接提供特定的实现*</em></strong>，而是提供标准和指导方针，由第三方框架（Spring）和库来实现和提供对应的功能。</p></li>
<li><p>JSR-250 <span class="citation" data-cites="Resource注解">@Resource注解</span></p>
<p><span class="citation" data-cites="Resource注解也可以完成属性注入">@Resource注解也可以完成属性注入</span>。那它和@Autowired注解有什么区别？</p>
<ul>
<li><span class="citation" data-cites="Resource注解是JDK扩展包中的">@Resource注解是JDK扩展包中的</span>，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li>
<li><span class="citation" data-cites="Autowired注解是Spring框架自己的">@Autowired注解是Spring框架自己的</span>。</li>
<li><strong><em>*<span class="citation" data-cites="Resource注解默认根据Bean名称装配">@Resource注解默认根据Bean名称装配</span>，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型装配。*</em></strong></li>
<li><strong><em>*<span class="citation" data-cites="Autowired注解默认根据类型装配">@Autowired注解默认根据类型装配</span>，如果想根据名称装配，需要配合@Qualifier注解一起用。*</em></strong></li>
<li><span class="citation" data-cites="Resource注解用在属性上">@Resource注解用在属性上</span>、setter方法上。</li>
<li><span class="citation" data-cites="Autowired注解用在属性上">@Autowired注解用在属性上</span>、setter方法上、构造方法上、构造方法参数上。
<span class="citation" data-cites="Resource注解属于JDK扩展包">@Resource注解属于JDK扩展包</span>，所以不在JDK当中，需要额外引入以下依赖：【<strong><em>*高于JDK11或低于JDK8需要引入以下依赖*</em></strong>】</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p><span class="citation" data-cites="Resource使用">@Resource使用</span></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class XxxController {</span><br><span class="line">    /**</span><br><span class="line">     * 1. 如果没有指定name,先根据属性名查找IoC中组件xxxService</span><br><span class="line">     * 2. 如果没有指定name,并且属性名没有对应的组件,会根据属性类型查找</span><br><span class="line">     * 3. 可以指定name名称查找!  @Resource(name='test') == @Autowired + @Qualifier(value='test')</span><br><span class="line">     */</span><br><span class="line">    @Resource</span><br><span class="line">    private XxxService xxxService;</span><br><span class="line"></span><br><span class="line">    //@Resource(name = "指定beanName")</span><br><span class="line">    //private XxxService xxxService;</span><br><span class="line"></span><br><span class="line">    public void show(){</span><br><span class="line">        System.out.println("XxxController.show");</span><br><span class="line">        xxxService.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ol>
<h4 id="实验四-bean属性赋值基本类型属性赋值-di">4.3.4 实验四：
Bean属性赋值：基本类型属性赋值 (DI)</h4>
<p><code>@Value</code> 通常用于注入外部化属性</p>
<p><strong>声明外部配置</strong></p>
<p>application.properties</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catalog.name=MovieCatalog</span><br></pre></td></tr></table></figure>
<p><strong>xml引入外部配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入外部配置文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location="application.properties" /&gt;</span><br></pre></td></tr></table></figure>
<p><strong><span class="citation" data-cites="Value注解读取配置">@Value注解读取配置</span></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.components;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.components</span><br><span class="line"> *</span><br><span class="line"> * description: 普通的组件</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CommonComponent {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 情况1: ${key} 取外部配置key对应的值!</span><br><span class="line">     * 情况2: ${key:defaultValue} 没有key,可以给与默认值</span><br><span class="line">     */</span><br><span class="line">    @Value("${catalog.name:Store}")</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="实验五-基于注解xml方式整合三层架构组件">4.3.5 实验五：
基于注解+XML方式整合三层架构组件</h4>
<ol type="1">
<li><p>需求分析</p>
<p>搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用XML+注解方式进行组件管理！</p></li>
<li><p>数据库准备</p></li>
<li><p>项目准备</p>
<ol type="1">
<li><p>项目创建</p>
<p>spring-annotation-practice-04</p></li>
<li><p>依赖导入</p></li>
<li><p>实体类准备</p></li>
</ol></li>
<li><p>三层架构搭建和实现</p>
<ol type="1">
<li><p>持久层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">public interface StudentDao {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学生数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Student&gt; queryAll();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现类</span><br><span class="line">@Repository</span><br><span class="line">public class StudentDaoImpl implements StudentDao {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学生数据</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Student&gt; queryAll() {</span><br><span class="line"></span><br><span class="line">        String sql = "select id , name , age , gender , class as classes from students ;";</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">          query可以返回集合!</span><br><span class="line">          BeanPropertyRowMapper就是封装好RowMapper的实现,要求属性名和列名相同即可</span><br><span class="line">         */</span><br><span class="line">        List&lt;Student&gt; studentList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Student.class));</span><br><span class="line"></span><br><span class="line">        return studentList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>业务层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//接口</span><br><span class="line">public interface StudentService {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学员业务</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Student&gt; findAll();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//实现类</span><br><span class="line">@Service</span><br><span class="line">public class StudentServiceImpl  implements StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询全部学员业务</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Student&gt; findAll() {</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; studentList =  studentDao.queryAll();</span><br><span class="line"></span><br><span class="line">        return studentList;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>表述层</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class StudentController {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    public void  findAll(){</span><br><span class="line">       List&lt;Student&gt; studentList =  studentService.findAll();</span><br><span class="line">        System.out.println("studentList = " + studentList);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>三层架构IoC配置</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line">        &lt;!-- 导入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置数据源 --&gt;</span><br><span class="line">    &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;</span><br><span class="line">        &lt;property name="url" value="${atguigu.url}"/&gt;</span><br><span class="line">        &lt;property name="driverClassName" value="${atguigu.driver}"/&gt;</span><br><span class="line">        &lt;property name="username" value="${atguigu.username}"/&gt;</span><br><span class="line">        &lt;property name="password" value="${atguigu.password}"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class="org.springframework.jdbc.core.JdbcTemplate"&gt;</span><br><span class="line">        &lt;property name="dataSource" ref="druidDataSource" /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 扫描Ioc/DI注解 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.atguigu.dao,com.atguigu.service,com.atguigu.controller" /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>运行测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ControllerTest {</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  void testRun(){</span><br><span class="line">        ApplicationContext applicationContext =</span><br><span class="line">                new ClassPathXmlApplicationContext("spring-ioc.xml");</span><br><span class="line">        StudentController studentController = applicationContext.getBean(StudentController.class);</span><br><span class="line">        studentController.findAll();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>注解+XML IoC方式问题总结</p>
<ol type="1">
<li>自定义类可以使用注解方式，但是第三方依赖的类依然使用XML方式！</li>
<li>XML格式解析效率低！</li>
</ol></li>
</ol>
<h3 id="基于-配置类-方式管理-bean">4.4 基于 配置类 方式管理 Bean</h3>
<h4 id="完全注解开发理解">4.4.1 完全注解开发理解</h4>
<p>Spring 完全注解配置（Fully Annotation-based Configuration）是指通过
Java配置类 代码来配置 Spring 应用程序，使用注解来替代原本在 XML
配置文件中的配置。相对于 XML
配置，完全注解配置具有更强的类型安全性和更好的可读性。</p>
<p><strong>两种方式思维转化</strong>：</p>
<figure>
<img lazyload="" alt="img" data-src="image_XWhvLQBC2h.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h4 id="实验一配置类和扫描注解">4.4.2 实验一：配置类和扫描注解</h4>
<p><strong>xml+注解方式</strong></p>
<p>配置文件application.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置自动扫描的包 --&gt;</span><br><span class="line">    &lt;!-- 1.包要精准,提高性能!</span><br><span class="line">         2.会扫描指定的包和子包内容</span><br><span class="line">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.atguigu.components"/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入外部配置文件--&gt;</span><br><span class="line">    &lt;context:property-placeholder location="application.properties" /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>测试创建IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// xml方式配置文件使用ClassPathXmlApplicationContext容器读取</span><br><span class="line">ApplicationContext applicationContext =</span><br><span class="line">               new ClassPathXmlApplicationContext("application.xml");</span><br></pre></td></tr></table></figure>
<p><strong>配置类+注解方式（完全注解方式）</strong></p>
<p>配置类</p>
<p>使用 <span class="citation" data-cites="Configuration">@Configuration</span>
注解将一个普通的类标记为 Spring 的配置类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line">//标注当前类是配置类，替代application.xml    </span><br><span class="line">@Configuration</span><br><span class="line">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span><br><span class="line">@PropertySource("classpath:application.properties")</span><br><span class="line">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span><br><span class="line">@ComponentScan(basePackages = {"com.atguigu.components"})</span><br><span class="line">public class MyConfiguration {</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>测试创建IoC容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span><br><span class="line">ApplicationContext iocContainerAnnotation = </span><br><span class="line">new AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure>
<p>可以使用 no-arg 构造函数实例化
<code>AnnotationConfigApplicationContext</code> ，然后使用
<code>register()</code> 方法对其进行配置。此方法在以编程方式生成
<code>AnnotationConfigApplicationContext</code>
时特别有用。以下示例演示如何执行此操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// AnnotationConfigApplicationContext-IOC容器对象</span><br><span class="line">ApplicationContext iocContainerAnnotation = </span><br><span class="line">new AnnotationConfigApplicationContext();</span><br><span class="line">//外部设置配置类</span><br><span class="line">iocContainerAnnotation.register(MyConfiguration.class);</span><br><span class="line">//刷新后方可生效！！</span><br><span class="line">iocContainerAnnotation.refresh();</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p><span class="citation" data-cites="Configuration指定一个类为配置类">@Configuration指定一个类为配置类</span>，可以添加配置注解，替代配置xml文件</p>
<p><span class="citation" data-cites="ComponentScan">@ComponentScan</span>(basePackages =
{“包”,“包”}) 替代&lt;context:component-scan标签实现注解扫描</p>
<p><span class="citation" data-cites="PropertySource">@PropertySource</span>(“classpath:配置文件地址”)
替代 &lt;context:property-placeholder标签</p>
<p>配合IoC/DI注解，可以进行完整注解开发！</p>
<h4 id="实验二bean定义组件">4.4.3 实验二：<span class="citation" data-cites="Bean定义组件">@Bean定义组件</span></h4>
<p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器</p>
<p><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式！</p>
<p><strong>xml方式实现</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 引入外部属性文件 --&gt;</span><br><span class="line">    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 实验六 [重要]给bean的属性赋值：引入外部属性文件 --&gt;</span><br><span class="line">    &lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;</span><br><span class="line">        &lt;property name="url" value="${jdbc.url}"/&gt;</span><br><span class="line">        &lt;property name="driverClassName" value="${jdbc.driver}"/&gt;</span><br><span class="line">        &lt;property name="username" value="${jdbc.user}"/&gt;</span><br><span class="line">        &lt;property name="password" value="${jdbc.password}"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p><strong>配置类方式实现</strong>：</p>
<p><code>@Bean</code> 注释用于指示方法实例化、配置和初始化要由 Spring
IoC 容器管理的新对象。对于那些熟悉 Spring 的 <code>&lt;beans/&gt;</code>
XML 配置的人来说， <code>@Bean</code> 注释与 <code>&lt;bean/&gt;</code>
元素起着相同的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//标注当前类是配置类，替代application.xml    </span><br><span class="line">@Configuration</span><br><span class="line">//引入jdbc.properties文件</span><br><span class="line">@PropertySource({"classpath:application.properties","classpath:jdbc.properties"})</span><br><span class="line">@ComponentScan(basePackages = {"com.atguigu.components"})</span><br><span class="line">public class MyConfiguration {</span><br><span class="line">    //如果第三方类进行IoC管理,无法直接使用@Component相关注解</span><br><span class="line">    //解决方案: xml方式可以使用&lt;bean标签</span><br><span class="line">    //解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span><br><span class="line">    // 返回值类型：bean组件的类型或其父类</span><br><span class="line">    // 方法名字：bean组件ID</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource createDataSource(@Value("${jdbc.user}") String username,</span><br><span class="line">                                       @Value("${jdbc.password}")String password,</span><br><span class="line">                                       @Value("${jdbc.url}")String url,</span><br><span class="line">                                       @Value("${jdbc.driver}")String driverClassName){</span><br><span class="line">        //使用Java代码实例化</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        //返回结果即可</span><br><span class="line">        return dataSource;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // 或者全局声明属性</span><br><span class="line">    @Value("${jdbc.user}") </span><br><span class="line">    private String username;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="实验三高级特性bean注解细节">4.4.4 实验三：高级特性：<span class="citation" data-cites="Bean注解细节">@Bean注解细节</span></h4>
<ol type="1">
<li><p><strong><em>*<span class="citation" data-cites="Bean生成BeanName问题">@Bean生成BeanName问题</span>*</em></strong></p>
<p><span class="citation" data-cites="Bean注解源码">@Bean注解源码</span>：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public @interface Bean {</span><br><span class="line">    //前两个注解可以指定Bean的标识</span><br><span class="line">    @AliasFor("name")</span><br><span class="line">    String[] value() default {};</span><br><span class="line">    @AliasFor("value")</span><br><span class="line">    String[] name() default {};</span><br><span class="line">  </span><br><span class="line">    //autowireCandidate 属性来指示该 Bean 是否候选用于自动装配。</span><br><span class="line">    //autowireCandidate 属性默认值为 true，表示该 Bean 是一个默认的装配目标，</span><br><span class="line">    //可被候选用于自动装配。如果将 autowireCandidate 属性设置为 false，则说明该 Bean 不是默认的装配目标，不会被候选用于自动装配。</span><br><span class="line">    boolean autowireCandidate() default true;</span><br><span class="line"></span><br><span class="line">    //指定初始化方法</span><br><span class="line">    String initMethod() default "";</span><br><span class="line">    //指定销毁方法</span><br><span class="line">    String destroyMethod() default "(inferred)";</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>指定@Bean的名称：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig {</span><br><span class="line"></span><br><span class="line">  @Bean("myThing") //指定名称</span><br><span class="line">  public Thing thing() {</span><br><span class="line">    return new Thing();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>使用此方法在指定为方法返回值的类型的 <code>ApplicationContext</code>
中注册 Bean 定义。缺省情况下，Bean 名称与方法名称相同。下面的示例演示
<code>@Bean</code> 方法声明：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig {</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public TransferServiceImpl transferService() {</span><br><span class="line">    return new TransferServiceImpl();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>前面的配置完全等同于下面的Spring XML：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*<span class="citation" data-cites="Bean">@Bean</span> 初始化和销毁方法指定*</em></strong></p>
<p><code>@Bean</code> 注解支持指定任意初始化和销毁回调方法，非常类似于
Spring XML 在 <code>bean</code> 元素上的 <code>init-method</code> 和
<code>destroy-method</code> 属性，如以下示例所示：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class BeanOne {</span><br><span class="line"></span><br><span class="line">  public void init() {</span><br><span class="line">    // initialization logic</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class BeanTwo {</span><br><span class="line"></span><br><span class="line">  public void cleanup() {</span><br><span class="line">    // destruction logic</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig {</span><br><span class="line"></span><br><span class="line">  @Bean(initMethod = "init")</span><br><span class="line">  public BeanOne beanOne() {</span><br><span class="line">    return new BeanOne();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  @Bean(destroyMethod = "cleanup")</span><br><span class="line">  public BeanTwo beanTwo() {</span><br><span class="line">    return new BeanTwo();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*<span class="citation" data-cites="Bean">@Bean</span> Scope作用域*</em></strong></p>
<p>可以指定使用 <code>@Bean</code> 注释定义的 bean
应具有特定范围。您可以使用在 Bean 作用域部分中指定的任何标准作用域。</p>
<p>默认作用域为 <code>singleton</code> ，但您可以使用
<code>@Scope</code> 注释覆盖此范围，如以下示例所示：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfiguration {</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  @Scope("prototype")</span><br><span class="line">  public Encryptor encryptor() {</span><br><span class="line">    // ...</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*<span class="citation" data-cites="Bean方法之间依赖">@Bean方法之间依赖</span>*</em></strong></p>
<p><strong><em>*准备组件*</em></strong></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HappyMachine {</span><br><span class="line">    </span><br><span class="line">    private String machineName;</span><br><span class="line">    </span><br><span class="line">    public String getMachineName() {</span><br><span class="line">        return machineName;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    public void setMachineName(String machineName) {</span><br><span class="line">        this.machineName = machineName;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class HappyComponent {</span><br><span class="line">    //引用新组件</span><br><span class="line">    private HappyMachine happyMachine;</span><br><span class="line"></span><br><span class="line">    public HappyMachine getHappyMachine() {</span><br><span class="line">        return happyMachine;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setHappyMachine(HappyMachine happyMachine) {</span><br><span class="line">        this.happyMachine = happyMachine;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void doWork() {</span><br><span class="line">        System.out.println("HappyComponent.doWork");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong><em>*Java配置类实现：*</em></strong></p>
<p>方案1：</p>
<p>直接调用方法返回 Bean 实例：在一个 <code>@Bean</code>
方法中直接调用其他 <code>@Bean</code> 方法来获取 Bean
实例，虽然是方法调用，也是通过IoC容器获取对应的Bean，例如：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class JavaConfig {</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HappyMachine happyMachine(){</span><br><span class="line">        return new HappyMachine();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HappyComponent happyComponent(){</span><br><span class="line">        HappyComponent happyComponent = new HappyComponent();</span><br><span class="line">        //直接调用方法即可! </span><br><span class="line">        happyComponent.setHappyMachine(happyMachine());</span><br><span class="line">        return happyComponent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>方案2：</p>
<p>参数引用法：通过方法参数传递 Bean 实例的引用来解决 Bean
实例之间的依赖关系，例如：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.config;</span><br><span class="line"></span><br><span class="line">import com.atguigu.ioc.HappyComponent;</span><br><span class="line">import com.atguigu.ioc.HappyMachine;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.config</span><br><span class="line"> * description: 配置HappyComponent和HappyMachine关系</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class JavaConfig {</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HappyMachine happyMachine(){</span><br><span class="line">        return new HappyMachine();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可以直接在形参列表接收IoC容器中的Bean!</span><br><span class="line">     *    情况1: 直接指定类型即可</span><br><span class="line">     *    情况2: 如果有多个bean,(HappyMachine 名称 ) 形参名称等于要指定的bean名称!</span><br><span class="line">     *           例如:</span><br><span class="line">     *               @Bean</span><br><span class="line">     *               public Foo foo1(){</span><br><span class="line">     *                   return new Foo();</span><br><span class="line">     *               }</span><br><span class="line">     *               @Bean</span><br><span class="line">     *               public Foo foo2(){</span><br><span class="line">     *                   return new Foo()</span><br><span class="line">     *               }</span><br><span class="line">     *               @Bean</span><br><span class="line">     *               public Component component(Foo foo1 / foo2 通过此处指定引入的bean)</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public HappyComponent happyComponent(HappyMachine happyMachine){</span><br><span class="line">        HappyComponent happyComponent = new HappyComponent();</span><br><span class="line">        //赋值</span><br><span class="line">        happyComponent.setHappyMachine(happyMachine);</span><br><span class="line">        return happyComponent;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="实验四高级特性import扩展">4.4.5 实验四：高级特性：<span class="citation" data-cites="Import扩展">@Import扩展</span></h4>
<p><code>@Import</code> 注释允许从另一个配置类加载 <code>@Bean</code>
定义，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA {</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public A a() {</span><br><span class="line">    return new A();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB {</span><br><span class="line"></span><br><span class="line">  @Bean</span><br><span class="line">  public B b() {</span><br><span class="line">    return new B();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>现在，在实例化上下文时不需要同时指定 <code>ConfigA.class</code> 和
<code>ConfigB.class</code> ，只需显式提供 <code>ConfigB</code>
，如以下示例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) {</span><br><span class="line">  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line"></span><br><span class="line">  // now both beans A and B will be available...</span><br><span class="line">  A a = ctx.getBean(A.class);</span><br><span class="line">  B b = ctx.getBean(B.class);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>此方法简化了容器实例化，因为只需要处理一个类，而不是要求您在构造期间记住可能大量的
<code>@Configuration</code> 类。</p>
<h4 id="实验五基于注解配置类方式整合三层架构组件">4.4.6
实验五：基于注解+配置类方式整合三层架构组件</h4>
<ol type="1">
<li><p>需求分析</p>
<p>搭建一个三层架构案例，模拟查询全部学生（学生表）信息，持久层使用JdbcTemplate和Druid技术，使用注解+配置类方式进行组件管理！</p></li>
<li><p>数据库准备</p></li>
<li><p>项目准备</p>
<ol type="1">
<li><p>项目创建</p>
<p>spring-java-practice-06</p></li>
<li><p>依赖导入</p></li>
<li><p>实体类准备</p></li>
</ol></li>
<li><p>三层架构搭建和实现</p>
<ol type="1">
<li>持久层</li>
<li>业务层</li>
<li>表述层</li>
</ol></li>
<li><p>三层架构IoC配置类</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = "com.atguigu")</span><br><span class="line">@PropertySource("classpath:jdbc.properties")</span><br><span class="line">public class JavaConfig {</span><br><span class="line"></span><br><span class="line">    @Value("${atguigu.url}")</span><br><span class="line">    private String url;</span><br><span class="line">    @Value("${atguigu.driver}")</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value("${atguigu.username}")</span><br><span class="line">    private String username;</span><br><span class="line">    @Value("${atguigu.password}")</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean(destroyMethod = "close")</span><br><span class="line">    public DruidDataSource dataSource(){</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate jdbcTemplate(DataSource dataSource){</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>运行测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ControllerTest {</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public  void testRun(){</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext applicationContext =</span><br><span class="line">                new AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line"></span><br><span class="line">        StudentController studentController = applicationContext.getBean(StudentController.class);</span><br><span class="line"></span><br><span class="line">        studentController.findAll();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>注解+配置类 IoC方式总结</p>
<ol type="1">
<li>完全摒弃了XML配置文件</li>
<li>自定义类使用IoC和DI注解标记</li>
<li>第三方类使用配置类声明方法+@Bean方式处理</li>
<li>完全注解方式（配置类+注解）是现在主流配置方式</li>
</ol></li>
</ol>
<h3 id="三种配置方式总结">4.5 三种配置方式总结</h3>
<h4 id="xml方式配置总结">4.5.1 XML方式配置总结</h4>
<ol type="1">
<li>所有内容写到xml格式配置文件中</li>
<li>声明bean通过&lt;bean标签</li>
<li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name
value / ref</li>
<li>引入外部的properties文件可以通过&lt;context:property-placeholder</li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<h4 id="xml注解方式配置总结">4.5.2 XML+注解方式配置总结</h4>
<ol type="1">
<li>注解负责标记IoC的类和进行属性装配</li>
<li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li>
<li>标记IoC注解：<span class="citation" data-cites="Component">@Component</span>,<span class="citation" data-cites="Service">@Service</span>,<span class="citation" data-cites="Controller">@Controller</span>,<span class="citation" data-cites="Repository">@Repository</span></li>
<li>标记DI注解：<span class="citation" data-cites="Autowired">@Autowired</span> <span class="citation" data-cites="Qualifier">@Qualifier</span> <span class="citation" data-cites="Resource">@Resource</span> <span class="citation" data-cites="Value">@Value</span></li>
<li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li>
</ol>
<h4 id="完全注解方式配置总结">4.5.3 完全注解方式配置总结</h4>
<ol type="1">
<li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li>
<li>xml文件替换成使用@Configuration注解标记的类</li>
<li>标记IoC注解：<span class="citation" data-cites="Component">@Component</span>,<span class="citation" data-cites="Service">@Service</span>,<span class="citation" data-cites="Controller">@Controller</span>,<span class="citation" data-cites="Repository">@Repository</span></li>
<li>标记DI注解：<span class="citation" data-cites="Autowired">@Autowired</span> <span class="citation" data-cites="Qualifier">@Qualifier</span> <span class="citation" data-cites="Resource">@Resource</span> <span class="citation" data-cites="Value">@Value</span></li>
<li>&lt;context:component-scan标签指定注解范围使用@ComponentScan(basePackages
= {“com.atguigu.components”})替代</li>
<li>&lt;context:property-placeholder引入外部配置文件使用@PropertySource({“classpath:application.properties”,“classpath:jdbc.properties”})替代</li>
<li>&lt;bean 标签使用@Bean注解和方法实现</li>
<li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li>
</ol>
<h3 id="整合spring5-test5搭建测试环境">4.6
整合Spring5-Test5搭建测试环境</h3>
<ol type="1">
<li><p>整合测试环境作用</p>
<p>好处1：不需要自己创建IOC容器对象了</p>
<p>好处2：任何需要的bean都可以在测试类中直接享受自动装配</p></li>
<li><p>导入相关依赖</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--junit5测试--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>整合测试注解使用</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//@SpringJUnitConfig(locations = {"classpath:spring-context.xml"})  //指定配置文件xml</span><br><span class="line">@SpringJUnitConfig(value = {BeanConfig.class})  //指定配置类</span><br><span class="line">public class Junit5IntegrationTest {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private User user;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void testJunit5() {</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="五spring-aop面向切面编程">五、Spring AOP面向切面编程</h2>
<h3 id="场景设定和问题复现">5.1 场景设定和问题复现</h3>
<ol type="1">
<li><p>准备AOP项目</p>
<p>项目名：spring-aop-annotation</p>
<p>pom.xml</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring context依赖--&gt;</span><br><span class="line">    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--junit5测试--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.3.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>声明接口</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *       + - * / 运算的标准接口!</span><br><span class="line"> */</span><br><span class="line">public interface Calculator {</span><br><span class="line">    </span><br><span class="line">    int add(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int sub(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int mul(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int div(int i, int j);</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>接口实现</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!</span><br><span class="line"> */</span><br><span class="line">public class CalculatorPureImpl implements Calculator {</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i + j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int sub(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i - j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int mul(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i * j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int div(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i / j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>声明带日志接口实现</p>
<p>新需求：
需要在每个方法中，添加控制台输出，输出参数和输出计算后的返回值！</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在每个方法中,输出传入的参数和计算后的返回结果!</span><br><span class="line"> */</span><br><span class="line">public class CalculatorLogImpl implements Calculator {</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        System.out.println("参数是：" + i + "," + j);</span><br><span class="line">        int result = i + j;</span><br><span class="line">        System.out.println("方法内部 result = " + result);</span><br><span class="line">      </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int sub(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        System.out.println("参数是：" + i + "," + j);</span><br><span class="line">    </span><br><span class="line">        int result = i - j;</span><br><span class="line">    </span><br><span class="line">        System.out.println("方法内部 result = " + result);</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int mul(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        System.out.println("参数是：" + i + "," + j);</span><br><span class="line">    </span><br><span class="line">        int result = i * j;</span><br><span class="line">    </span><br><span class="line">        System.out.println("方法内部 result = " + result);</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int div(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        System.out.println("参数是：" + i + "," + j);</span><br><span class="line">    </span><br><span class="line">        int result = i / j;</span><br><span class="line">    </span><br><span class="line">        System.out.println("方法内部 result = " + result);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>代码问题分析</p>
<ol type="1">
<li><p>代码缺陷</p>
<ul>
<li>对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力</li>
<li>附加功能代码重复，分散在各个业务功能方法中！冗余，且不方便统一维护！</li>
</ul></li>
<li><p>解决思路</p>
<p>核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。</p>
<p>将重复的代码统一提取，并且[[动态插入]]到每个业务方法！</p></li>
<li><p>技术困难</p>
<p>解决问题的困难：提取重复附加功能代码到一个类中，可以实现</p>
<p>但是如何将代码插入到各个方法中，我们不会，我们需要引用新技术！！！</p></li>
</ol></li>
</ol>
<h3 id="解决技术代理模式">5.2 解决技术代理模式</h3>
<ol type="1">
<li><p><strong><em>*代理模式*</em></strong></p>
<p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p>
<p>无代理场景：</p>
<p>有代理场景：</p>
<p>生活中的代理：</p>
<ul>
<li>广告商找大明星拍广告需要经过经纪人</li>
<li>合作伙伴找大老板谈合作要约见面时间需要经过秘书</li>
<li>房产中介是买卖双方的代理</li>
<li>太监是大臣和皇上之间的代理</li>
</ul>
<p>程序中的代理：</p>
<ul>
<li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。(中介)
<ul>
<li>动词：指做代理这个动作，或这项工作</li>
<li>名词：扮演代理这个角色的类、对象、方法</li>
</ul></li>
<li>目标：<strong><em>*被代理*</em></strong>“套用”了核心逻辑代码的类、对象、方法。(房东)
代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</li>
</ul></li>
<li><p><strong><em>*静态代理*</em></strong></p>
<p>主动创建代理类：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorStaticProxy implements Calculator {</span><br><span class="line">    </span><br><span class="line">    // 将被代理的目标对象声明为成员变量</span><br><span class="line">    private Calculator target;</span><br><span class="line">    </span><br><span class="line">    public CalculatorStaticProxy(Calculator target) {</span><br><span class="line">        this.target = target;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        // 附加功能由代理类中的代理方法来实现</span><br><span class="line">        System.out.println("参数是：" + i + "," + j);</span><br><span class="line">    </span><br><span class="line">        // 通过目标对象来实现核心业务逻辑</span><br><span class="line">        int addResult = target.add(i, j);</span><br><span class="line">    </span><br><span class="line">        System.out.println("方法内部 result = " + result);</span><br><span class="line">    </span><br><span class="line">        return addResult;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。</p>
<p>提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。</p></li>
<li><p><strong><em>*动态代理*</em></strong></p>
<p>动态代理技术分类</p>
<ul>
<li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong><em>*实现接口*</em></strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口！（拜把子）</li>
<li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口！（认干爹）
JDK动态代理技术实现（了解）</li>
</ul></li>
</ol>
<p>代理工程：基于jdk代理技术，生成代理对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyFactory {</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public ProxyFactory(Object target) {</span><br><span class="line">        this.target = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Object getProxy(){</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * newProxyInstance()：创建一个代理实例</span><br><span class="line">         * 其中有三个参数：</span><br><span class="line">         * 1、classLoader：加载动态生成的代理类的类加载器</span><br><span class="line">         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组</span><br><span class="line">         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法</span><br><span class="line">         */</span><br><span class="line">        ClassLoader classLoader = target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        InvocationHandler invocationHandler = new InvocationHandler() {</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span><br><span class="line">                /**</span><br><span class="line">                 * proxy：代理对象</span><br><span class="line">                 * method：代理对象需要实现的方法，即其中需要重写的方法</span><br><span class="line">                 * args：method所对应方法的参数</span><br><span class="line">                 */</span><br><span class="line">                Object result = null;</span><br><span class="line">                try {</span><br><span class="line">                    System.out.println("[动态代理][日志] "+method.getName()+"，参数："+ Arrays.toString(args));</span><br><span class="line">                    result = method.invoke(target, args);</span><br><span class="line">                    System.out.println("[动态代理][日志] "+method.getName()+"，结果："+ result);</span><br><span class="line">                } catch (Exception e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println("[动态代理][日志] "+method.getName()+"，异常："+e.getMessage());</span><br><span class="line">                } finally {</span><br><span class="line">                    System.out.println("[动态代理][日志] "+method.getName()+"，方法执行完毕");</span><br><span class="line">                }</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testDynamicProxy(){</span><br><span class="line">    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());</span><br><span class="line">    Calculator proxy = (Calculator) factory.getProxy();</span><br><span class="line">    proxy.div(1,0);</span><br><span class="line">    //proxy.div(1,1);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p><strong><em>*代理总结*</em></strong></p>
<p><strong><em>*代理方式可以解决附加功能代码干扰核心代码和不方便统一维护的问题！*</em></strong></p>
<p>他主要是将附加功能代码提取到代理中执行，不干扰目标核心代码！</p>
<p>但是我们也发现，无论使用静态代理和动态代理(jdk,cglib)，程序员的工作都比较繁琐！</p>
<p>需要自己编写代理工厂等！</p>
<p>但是，提前剧透，我们在实际开发中，不需要编写代理代码，我们可以使用[Spring
AOP]框架，</p>
<p>他会简化动态代理的实现！！！</p></li>
</ol>
<h3 id="面向切面编程思维aop">5.3 面向切面编程思维（AOP）</h3>
<ol type="1">
<li><p><strong><em>*面向切面编程思想AOP*</em></strong></p>
<p><code>AOP：Aspect Oriented Programming 面向切面编程</code></p>
<p>AOP可以说是OOP（Object Oriented
Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross
cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用AOP，可以在不修改原来代码的基础上添加新功能。</p></li>
<li><p><strong><em>*AOP思想主要的应用场景*</em></strong></p>
<p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p>
<ol type="1">
<li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li>
<li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li>
<li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li>
<li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li>
<li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li>
<li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li>
<li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。
综上所述，AOP可以应用于各种场景，它的作用是将通用的横切关注点与业务逻辑分离，使得代码更加清晰、简洁、易于维护。</li>
</ol></li>
<li><p><strong><em>*AOP术语名词介绍*</em></strong></p>
<p>1-横切关注点</p>
<p>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。</p>
<p>这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p>
<p>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p>2-通知(增强)</p>
<p>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p>
<ul>
<li>前置通知：在被代理的目标方法前执行</li>
<li>返回通知：在被代理的目标方法成功结束后执行（<strong><em>*寿终正寝*</em></strong>）</li>
<li>异常通知：在被代理的目标方法异常结束后执行（<strong><em>*死于非命*</em></strong>）</li>
<li>后置通知：在被代理的目标方法最终结束后执行（<strong><em>*盖棺定论*</em></strong>）</li>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p>3-连接点 joinpoint</p>
<p>这也是一个纯逻辑概念，不是语法定义的。 指那些被拦截到的点。在 Spring
中，可以被动态代理拦截目标类的方法 4-切入点 pointcut
定位连接点的方式，或者可以理解成被选中的连接点！
是一个表达式，比如execution(*
com.spring.service.impl.<em>.</em>(..))。符合条件的每个方法都是一个具体的连接点。
5-切面 aspect 切入点和通知的结合。是一个类。 6-目标 target
被代理的目标对象。 7-代理 proxy</p>
<p>向目标对象应用通知之后创建的代理对象。</p>
<p>8-织入 weave</p>
<p>指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p></li>
</ol>
<h3 id="spring-aop框架介绍和关系梳理">5.4 Spring
AOP框架介绍和关系梳理</h3>
<ol type="1">
<li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li>
<li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li>
<li>Spring
AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li>
</ol>
<h3 id="spring-aop基于注解方式实现和细节">5.5 Spring
AOP基于注解方式实现和细节</h3>
<h4 id="spring-aop底层技术组成">5.5.1 Spring AOP底层技术组成</h4>
<ul>
<li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li>
<li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li>
<li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li>
</ul>
<h4 id="初步实现">5.5.2 初步实现</h4>
<ol type="1">
<li><p>加入依赖</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>准备接口</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Calculator {</span><br><span class="line">    </span><br><span class="line">    int add(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int sub(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int mul(int i, int j);</span><br><span class="line">    </span><br><span class="line">    int div(int i, int j);</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>纯净实现类</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现计算接口,单纯添加 + - * / 实现! 掺杂其他功能!</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class CalculatorPureImpl implements Calculator {</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int add(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i + j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int sub(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i - j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int mul(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i * j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int div(int i, int j) {</span><br><span class="line">    </span><br><span class="line">        int result = i / j;</span><br><span class="line">    </span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>声明切面类</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.advice;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">// @Aspect表示这个类是一个切面类</span><br><span class="line">@Aspect</span><br><span class="line">// @Component注解保证这个切面类能够放入IOC容器</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect {</span><br><span class="line">        </span><br><span class="line">    // @Before注解：声明当前方法是前置通知方法</span><br><span class="line">    // value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span><br><span class="line">    @Before(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">    public void printLogBeforeCore() {</span><br><span class="line">        System.out.println("[AOP前置通知] 方法开始了");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @AfterReturning(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">    public void printLogAfterSuccess() {</span><br><span class="line">        System.out.println("[AOP返回通知] 方法成功返回了");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @AfterThrowing(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">    public void printLogAfterException() {</span><br><span class="line">        System.out.println("[AOP异常通知] 方法抛异常了");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    @After(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">    public void printLogFinallyEnd() {</span><br><span class="line">        System.out.println("[AOP后置通知] 方法最终结束了");</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>开启aspectj注解支持</p>
<ol type="1">
<li><p>xml方式</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xmlns:aop="http://www.springframework.org/schema/aop"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 进行包扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.atguigu" /&gt;</span><br><span class="line">    &lt;!-- 开启aspectj框架注解支持--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>配置类方式</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = "com.atguigu")</span><br><span class="line">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class MyConfig {</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol></li>
<li><p>测试效果</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//@SpringJUnitConfig(locations = "classpath:spring-aop.xml")</span><br><span class="line">@SpringJUnitConfig(value = {MyConfig.class})</span><br><span class="line">public class AopTest {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Calculator calculator;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCalculator(){</span><br><span class="line">        calculator.add(1,1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[AOP前置通知] 方法开始了</span><br><span class="line">[AOP返回通知] 方法成功返回了</span><br><span class="line">[AOP后置通知] 方法最终结束了</span><br></pre></td></tr></table></figure>
<h4 id="获取通知细节信息">5.5.3 获取通知细节信息</h4>
<ol type="1">
<li><p><strong><em>*JointPoint接口*</em></strong></p>
<p>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</p>
<ul>
<li>要点1：JoinPoint 接口通过 getSignature()
方法获取目标方法的签名（方法声明时的完整信息）</li>
<li>要点2：通过目标方法签名对象获取方法名</li>
<li>要点3：通过 JoinPoint
对象获取外界调用目标方法时传入的实参列表组成的数组</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// @Before注解标记前置通知方法</span><br><span class="line">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span><br><span class="line">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span><br><span class="line">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span><br><span class="line">@Before(value = "execution(public int com.atguigu.aop.api.Calculator.add(int,int))")</span><br><span class="line">public void printLogBeforeCore(JoinPoint joinPoint) {</span><br><span class="line">    </span><br><span class="line">    // 1.通过JoinPoint对象获取目标方法签名对象</span><br><span class="line">    // 方法的签名：一个方法的全部声明信息</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    // 2.通过方法的签名对象获取目标方法的详细信息</span><br><span class="line">    String methodName = signature.getName();</span><br><span class="line">    System.out.println("methodName = " + methodName);</span><br><span class="line">    </span><br><span class="line">    int modifiers = signature.getModifiers();</span><br><span class="line">    System.out.println("modifiers = " + modifiers);</span><br><span class="line">    </span><br><span class="line">    String declaringTypeName = signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println("declaringTypeName = " + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    // 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    // 4.由于数组直接打印看不到具体数据，所以转换为List集合</span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println("[AOP前置通知] " + methodName + "方法开始了，参数列表：" + argList);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*方法返回值*</em></strong></p>
<p>在返回通知中，通过 <strong><em>*<span class="citation" data-cites="AfterReturning">@AfterReturning</span>*</em></strong>注解的returning属性获取目标方法的返回值！</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// @AfterReturning注解标记返回通知方法</span><br><span class="line">// 在返回通知中获取目标方法返回值分两步：</span><br><span class="line">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span><br><span class="line">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span><br><span class="line">@AfterReturning(</span><br><span class="line">        value = "execution(public int com.atguigu.aop.api.Calculator.add(int,int))",</span><br><span class="line">        returning = "targetMethodReturnValue"</span><br><span class="line">)</span><br><span class="line">public void printLogAfterCoreSuccess(JoinPoint joinPoint, Object targetMethodReturnValue) {</span><br><span class="line">    </span><br><span class="line">    String methodName = joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println("[AOP返回通知] "+methodName+"方法成功结束了，返回值是：" + targetMethodReturnValue);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong><em>*异常对象捕捉*</em></strong></p>
<p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// @AfterThrowing注解标记异常通知方法</span><br><span class="line">// 在异常通知中获取目标方法抛出的异常分两步：</span><br><span class="line">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span><br><span class="line">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span><br><span class="line">@AfterThrowing(</span><br><span class="line">        value = "execution(public int com.atguigu.aop.api.Calculator.add(int,int))",</span><br><span class="line">        throwing = "targetMethodException"</span><br><span class="line">)</span><br><span class="line">public void printLogAfterCoreException(JoinPoint joinPoint, Throwable targetMethodException) {</span><br><span class="line">    </span><br><span class="line">    String methodName = joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println("[AOP异常通知] "+methodName+"方法抛异常了，异常类型是：" + targetMethodException.getClass().getName());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="切点表达式语法">5.5.4 切点表达式语法</h4>
<ol type="1">
<li><p><strong><em>*切点表达式作用*</em></strong></p>
<p>AOP切点表达式（Pointcut
Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p></li>
<li><p><strong><em>*切点表达式语法*</em></strong></p>
<p>切点表达式总结</p>
<p>语法细节</p>
<ul>
<li><p>第一位：execution( ) 固定开头</p></li>
<li><p>第二位：方法访问修饰符</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public private 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure></p></li>
<li><p>第三位：方法返回值</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int String void 直接描述返回值类型</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ol>
<p>特殊情况 不考虑 访问修饰符和返回值（要么都考虑，要么都不考虑）
execution(*)</p>
<ul>
<li><p>第四位：指定包的地址</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = com.atguigu.api  com.atguigu.dao  * = 任意一层的任意命名</span><br><span class="line">    任意层任意命名: com.. = com.atguigu.api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   public int .. 错误语法</span><br><span class="line">    找到任何包下: *..</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>第五位：指定类名称</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br></pre></td></tr></table></figure></p></li>
<li><p>第六位：指定方法名称</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure></p></li>
<li><p>第七位：方法参数</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">​```java</span><br><span class="line">具体值: (String,int) != (int,String) </span><br><span class="line">没有参数 ()</span><br></pre></td></tr></table></figure></p>
<p>模糊值: 任意参数 有 或者 没有 (..) ..任意参数的意识 部分具体和模糊:
第一个参数是字符串的方法 (String..) 最后一个参数是字符串 (..String)
字符串开头,int结尾 (String..int) 包含int类型(..int..) ```</p></li>
</ul>
<ol type="1">
<li><p><strong><em>*切点表达式案例*</em></strong></p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.查询com.org包dao类下，访问修饰符是公有，返回值是int的全部方法 </span><br><span class="line">    public int com.org.dao.*(..)</span><br><span class="line">2.查询com.org包下类中第一个参数是String的方法</span><br><span class="line">    * com.org.*.*(String..)</span><br><span class="line">3.查询全部包下，无参数的方法！</span><br><span class="line">    * *..*.*()</span><br><span class="line">4.查询com包下，以int参数类型结尾的方法</span><br><span class="line">    * com..*.*(..int)</span><br><span class="line">5.查询com.org包下，Service开头类的私有返回值int的无参数方法</span><br><span class="line">    private int com.org.Service*.*()</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="重用提取切点表达式">5.5.5 重用（提取）切点表达式</h4>
<ol type="1">
<li><p>重用切点表达式优点</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// @Before注解：声明当前方法是前置通知方法</span><br><span class="line">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span><br><span class="line">@Before(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">public void printLogBeforeCore() {</span><br><span class="line">    System.out.println("[AOP前置通知] 方法开始了");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@AfterReturning(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">public void printLogAfterSuccess() {</span><br><span class="line">    System.out.println("[AOP返回通知] 方法成功返回了");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@AfterThrowing(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">public void printLogAfterException() {</span><br><span class="line">    System.out.println("[AOP异常通知] 方法抛异常了");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@After(value = "execution(public int com.atguigu.proxy.CalculatorPureImpl.add(int,int))")</span><br><span class="line">public void printLogFinallyEnd() {</span><br><span class="line">    System.out.println("[AOP后置通知] 方法最终结束了");</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>上面案例，是我们之前编写切点表达式的方式，发现，
所有增强方法的切点表达式相同！</p>
<p>出现了冗余，如果需要切换也不方便统一维护！</p>
<p>我们可以将切点提取，在增强上进行引用即可！</p></li>
<li><p>同一类内部引用</p>
<p>提取</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 切入点表达式重用</span><br><span class="line">@Pointcut("execution(public int com.atguigu.aop.api.Calculator.add(int,int)))")</span><br><span class="line">public void declarPointCut() {}</span><br></pre></td></tr></table></figure></p>
<p>注意：提取切点注解使用@Pointcut(切点表达式) ，
需要添加到一个无参数无返回值方法上即可！</p>
<p>引用</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = "declarPointCut()")</span><br><span class="line">public void printLogBeforeCoreOperation(JoinPoint joinPoint) {</span><br></pre></td></tr></table></figure></p></li>
<li><p>不同类中引用</p>
<p>不同类在引用切点，只需要添加类的全限定符+方法名即可！</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Before(value = "com.atguigu.spring.aop.aspect.LogAspect.declarPointCut()")</span><br><span class="line">public Object roundAdvice(ProceedingJoinPoint joinPoint) {</span><br></pre></td></tr></table></figure></p></li>
<li><p>切点统一管理</p>
<p>建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AtguiguPointCut {</span><br><span class="line">    @Pointcut(value = "execution(public int *..Calculator.sub(int,int))")</span><br><span class="line">    public void atguiguGlobalPointCut(){}</span><br><span class="line">    @Pointcut(value = "execution(public int *..Calculator.add(int,int))")</span><br><span class="line">    public void atguiguSecondPointCut(){}</span><br><span class="line">    @Pointcut(value = "execution(* *..*Service.*(..))")</span><br><span class="line">    public void transactionPointCut(){}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="环绕通知">5.5.6 环绕通知</h4>
<p>环绕通知对应整个 try…catch…finally
结构，包括前面四种通知的所有功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 使用@Around注解标明环绕通知方法</span><br><span class="line">@Around(value = "com.atguigu.aop.aspect.AtguiguPointCut.transactionPointCut()")</span><br><span class="line">public Object manageTransaction(</span><br><span class="line">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span><br><span class="line">        // Spring会将这个类型的对象传给我们</span><br><span class="line">        ProceedingJoinPoint joinPoint) {</span><br><span class="line">    </span><br><span class="line">    // 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    // 通过ProceedingJoinPoint对象获取目标方法的签名对象</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    // 通过签名对象获取目标方法的方法名</span><br><span class="line">    String methodName = signature.getName();</span><br><span class="line">    // 声明变量用来存储目标方法的返回值</span><br><span class="line">    Object targetMethodReturnValue = null;</span><br><span class="line">    try {</span><br><span class="line">        // 在目标方法执行前：开启事务（模拟）</span><br><span class="line">        log.debug("[AOP 环绕通知] 开启事务，方法名：" + methodName + "，参数列表：" + Arrays.asList(args));</span><br><span class="line">        // 过ProceedingJoinPoint对象调用目标方法</span><br><span class="line">        // 目标方法的返回值一定要返回给外界调用者</span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">        // 在目标方法成功返回后：提交事务（模拟）</span><br><span class="line">        log.debug("[AOP 环绕通知] 提交事务，方法名：" + methodName + "，方法返回值：" + targetMethodReturnValue);</span><br><span class="line">    }catch (Throwable e){</span><br><span class="line">        // 在目标方法抛异常后：回滚事务（模拟）</span><br><span class="line">        log.debug("[AOP 环绕通知] 回滚事务，方法名：" + methodName + "，异常：" + e.getClass().getName());</span><br><span class="line">    }finally {</span><br><span class="line">        // 在目标方法最终结束后：释放数据库连接</span><br><span class="line">        log.debug("[AOP 环绕通知] 释放数据库连接，方法名：" + methodName);</span><br><span class="line">    }</span><br><span class="line">    return targetMethodReturnValue;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="切面优先级设置">5.5.7 切面优先级设置</h4>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用 <span class="citation" data-cites="Order">@Order</span>
注解可以控制切面的优先级：</p>
<ul>
<li><span class="citation" data-cites="Order">@Order</span>(较小的数)：优先级高</li>
<li><span class="citation" data-cites="Order">@Order</span>(较大的数)：优先级低</li>
</ul>
<p>实际意义</p>
<p>实际开发时，如果有多个切面嵌套的情况，要慎重考虑。例如：如果事务切面优先级高，那么在缓存中命中数据的情况下，事务切面的操作都浪费了。</p>
<p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p>
<h4 id="cglib动态代理生效">5.5.8 CGLib动态代理生效</h4>
<p>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。为了证明这一点，我们做下面的测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class EmployeeService {</span><br><span class="line">    public void getEmpList() {</span><br><span class="line">       System.out.print("方法内部 com.atguigu.aop.imp.EmployeeService.getEmpList");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testNoInterfaceProxy() {</span><br><span class="line">    employeeService.getEmpList();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>没有接口：</p>
<p>有接口：</p>
<p>使用总结：</p>
<p>​ a. 如果目标类有接口,选择使用jdk动态代理</p>
<p>​ b. 如果目标类没有接口,选择cglib动态代理</p>
<p>​ c. 如果有接口,接口接值</p>
<p>​ d. 如果没有接口,类进行接值</p>
<h4 id="注解实现小结">5.5.9 注解实现小结</h4>
<h3 id="spring-aop基于xml方式实现了解">5.6 Spring
AOP基于XML方式实现(了解)</h3>
<ol type="1">
<li><p>准备工作</p>
<p>加入依赖</p>
<p>和基于注解的 AOP 时一样。</p>
<p>准备代码</p>
<p>把测试基于注解功能时的Java类复制到新module中，去除所有注解。</p></li>
<li><p>配置Spring配置文件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置目标类的bean --&gt;</span><br><span class="line">&lt;bean id="calculatorPure" class="com.atguigu.aop.imp.CalculatorPureImpl"/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 配置切面类的bean --&gt;</span><br><span class="line">&lt;bean id="logAspect" class="com.atguigu.aop.aspect.LogAspect"/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 配置AOP --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 配置切入点表达式 --&gt;</span><br><span class="line">    &lt;aop:pointcut id="logPointCut" expression="execution(* *..*.*(..))"/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- aop:aspect标签：配置切面 --&gt;</span><br><span class="line">    &lt;!-- ref属性：关联切面类的bean --&gt;</span><br><span class="line">    &lt;aop:aspect ref="logAspect" order="5"&gt;</span><br><span class="line">        &lt;!-- aop:before标签：配置前置通知 --&gt;</span><br><span class="line">        &lt;!-- method属性：指定前置通知的方法名 --&gt;</span><br><span class="line">        &lt;!-- pointcut-ref属性：引用切入点表达式 --&gt;</span><br><span class="line">        &lt;aop:before method="printLogBeforeCore" pointcut-ref="logPointCut"/&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- aop:after-returning标签：配置返回通知 --&gt;</span><br><span class="line">        &lt;!-- returning属性：指定通知方法中用来接收目标方法返回值的参数名 --&gt;</span><br><span class="line">        &lt;aop:after-returning</span><br><span class="line">                method="printLogAfterCoreSuccess"</span><br><span class="line">                pointcut-ref="logPointCut"</span><br><span class="line">                returning="targetMethodReturnValue"/&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- aop:after-throwing标签：配置异常通知 --&gt;</span><br><span class="line">        &lt;!-- throwing属性：指定通知方法中用来接收目标方法抛出异常的异常对象的参数名 --&gt;</span><br><span class="line">        &lt;aop:after-throwing</span><br><span class="line">                method="printLogAfterCoreException"</span><br><span class="line">                pointcut-ref="logPointCut"</span><br><span class="line">                throwing="targetMethodException"/&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- aop:after标签：配置后置通知 --&gt;</span><br><span class="line">        &lt;aop:after method="printLogCoreFinallyEnd" pointcut-ref="logPointCut"/&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- aop:around标签：配置环绕通知 --&gt;</span><br><span class="line">        &lt;!--&lt;aop:around method="……" pointcut-ref="logPointCut"/&gt;--&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SpringJUnitConfig(locations = "classpath:spring-aop.xml")</span><br><span class="line">public class AopTest {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private Calculator calculator;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testCalculator(){</span><br><span class="line">        System.out.println(calculator);</span><br><span class="line">        calculator.add(1,1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="spring-aop对获取bean的影响理解">5.7 Spring
AOP对获取Bean的影响理解</h3>
<h4 id="根据类型装配-bean">5.7.1 根据类型装配 bean</h4>
<ol type="1">
<li><p>情景一</p>
<ul>
<li><p>bean 对应的类没有实现任何接口</p></li>
<li><p>根据 bean 本身的类型获取 bean</p>
<ul>
<li><p>测试：IOC容器中同类型的 bean 只有一个</p>
<p>正常获取到 IOC 容器中的那个 bean 对象</p></li>
<li><p>测试：IOC 容器中同类型的 bean 有多个</p>
<p>会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC
容器中这个类型的 bean 有多个</p></li>
</ul></li>
</ul></li>
<li><p>情景二</p>
<ul>
<li>bean 对应的类实现了接口，这个接口也只有这一个实现类
<ul>
<li>测试：根据接口类型获取 bean</li>
<li>测试：根据类获取 bean</li>
<li>结论：上面两种情况其实都能够正常获取到 bean，而且是同一个对象</li>
</ul></li>
</ul></li>
<li><p>情景三</p>
<ul>
<li><p>声明一个接口</p></li>
<li><p>接口有多个实现类</p></li>
<li><p>接口所有实现类都放入 IOC 容器</p>
<ul>
<li><p>测试：根据接口类型获取 bean</p>
<p>会抛出 NoUniqueBeanDefinitionException 异常，表示 IOC
容器中这个类型的 bean 有多个</p></li>
<li><p>测试：根据类获取bean</p>
<p>正常</p></li>
</ul></li>
</ul></li>
<li><p>情景四</p>
<ul>
<li><p>声明一个接口</p></li>
<li><p>接口有一个实现类</p></li>
<li><p>创建一个切面类，对上面接口的实现类应用通知</p>
<ul>
<li><p>测试：根据接口类型获取bean</p>
<p>正常</p></li>
<li><p>测试：根据类获取bean</p>
<p>无法获取</p></li>
</ul></li>
</ul>
<p>原因分析：</p>
<ul>
<li><p>应用了切面后，真正放在IOC容器中的是代理类的对象</p></li>
<li><p>目标类并没有被放到IOC容器中，所以根据目标类的类型从IOC容器中是找不到的</p></li>
</ul></li>
<li><p>情景五</p>
<ul>
<li><p>声明一个类</p></li>
<li><p>创建一个切面类，对上面的类应用通知</p>
<ul>
<li>测试：根据类获取 bean，能获取到 debug查看实际类型：</li>
</ul></li>
</ul></li>
</ol>
<h4 id="使用总结">5.7.2 使用总结</h4>
<p>对实现了接口的类应用切面</p>
<figure>
<img lazyload="" alt="img" data-src="image_EbfR90kP01.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>对没实现接口的类应用切面</p>
<figure>
<img lazyload="" alt="img" data-src="image_wUfCJhIWI3.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>如果使用AOP技术，目标类有接口，必须使用接口类型接收IoC容器中代理组件！</strong></p>
<h2 id="六spring-声明式事务">六、Spring 声明式事务</h2>
<h3 id="声明式事务概念">6.1 声明式事务概念</h3>
<h4 id="编程式事务">6.1.1 编程式事务</h4>
<p>编程式事务是指手动编写程序来管理事务，即通过编写代码的方式直接控制事务的提交和回滚。在
Java 中，通常使用事务管理器(如 Spring 中的
<code>PlatformTransactionManager</code>)来实现编程式事务。</p>
<p>编程式事务的主要优点是灵活性高，可以按照自己的需求来控制事务的粒度、模式等等。但是，编写大量的事务控制代码容易出现问题，对代码的可读性和可维护性有一定影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = ...;</span><br><span class="line">  </span><br><span class="line">try {</span><br><span class="line">    // 开启事务：关闭事务的自动提交</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    // 核心操作</span><br><span class="line">    // 业务代码</span><br><span class="line">    // 提交事务</span><br><span class="line">    conn.commit();</span><br><span class="line">  </span><br><span class="line">}catch(Exception e){</span><br><span class="line">  </span><br><span class="line">    // 回滚事务</span><br><span class="line">    conn.rollBack();</span><br><span class="line">  </span><br><span class="line">}finally{</span><br><span class="line">  </span><br><span class="line">    // 释放数据库连接</span><br><span class="line">    conn.close();</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>编程式的实现方式存在缺陷：</p>
<ul>
<li>细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。</li>
<li>代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。</li>
</ul>
<h4 id="声明式事务">6.1.2 声明式事务</h4>
<p>声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。</p>
<p>开发者只需要添加配置即可，
具体事务的实现由第三方框架实现，避免我们直接进行事务操作！</p>
<p>使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。</p>
<p>区别：</p>
<ul>
<li>编程式事务需要手动编写代码来管理事务</li>
<li>而声明式事务可以通过配置文件或注解来控制事务。</li>
</ul>
<h4 id="spring事务管理器">6.1.3 Spring事务管理器</h4>
<ol type="1">
<li><p>Spring声明式事务对应依赖</p>
<ul>
<li>spring-tx:
包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li>
<li>spring-jdbc:
包含DataSource方式事务管理器实现类DataSourceTransactionManager</li>
<li>spring-orm:
包含其他持久层框架的事务管理器实现类例如：Hibernate/Jpa等</li>
</ul></li>
<li><p>Spring声明式事务对应事务管理器接口</p>
<figure>
<img lazyload="" alt="img" data-src="image_s2BCX_Qltm.png">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>我们现在要使用的事务管理器是org.springframework.jdbc.datasource.DataSourceTransactionManager，将来整合
JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现！</p>
<p>DataSourceTransactionManager类中的主要方法：</p>
<ul>
<li>doBegin()：开启事务</li>
<li>doSuspend()：挂起事务</li>
<li>doResume()：恢复挂起的事务</li>
<li>doCommit()：提交事务</li>
<li>doRollback()：回滚事务</li>
</ul></li>
</ol>
<h3 id="基于注解的声明式事务">6.2 基于注解的声明式事务</h3>
<h4 id="准备工作">6.2.1 准备工作</h4>
<ol type="1">
<li><p>准备项目</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring context依赖--&gt;</span><br><span class="line">    &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--junit5测试--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.3.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 数据库驱动 和 连接池--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;8.0.25&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.8&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- spring-jdbc --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明式事务依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p></li>
<li><p>外部配置文件</p>
<p>jdbc.properties</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">atguigu.url=jdbc:mysql://localhost:3306/studb</span><br><span class="line">atguigu.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">atguigu.username=root</span><br><span class="line">atguigu.password=root</span><br></pre></td></tr></table></figure></p></li>
<li><p>spring配置文件</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan("com.atguigu")</span><br><span class="line">@PropertySource("classpath:jdbc.properties")</span><br><span class="line">public class JavaConfig {</span><br><span class="line"></span><br><span class="line">    @Value("${atguigu.driver}")</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value("${atguigu.url}")</span><br><span class="line">    private String url;</span><br><span class="line">    @Value("${atguigu.username}")</span><br><span class="line">    private String username;</span><br><span class="line">    @Value("${atguigu.password}")</span><br><span class="line">    private String password;</span><br><span class="line">    //druid连接池</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource(){</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    }</span><br><span class="line">    @Bean</span><br><span class="line">    //jdbcTemplate</span><br><span class="line">    public JdbcTemplate jdbcTemplate(DataSource dataSource){</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>准备dao/service层</p>
<p>dao</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class StudentDao {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    public void updateNameById(String name,Integer id){</span><br><span class="line">        String sql = "update students set name = ? where id = ? ;";</span><br><span class="line">        int rows = jdbcTemplate.update(sql, name, id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void updateAgeById(Integer age,Integer id){</span><br><span class="line">        String sql = "update students set age = ? where id = ? ;";</span><br><span class="line">        jdbcTemplate.update(sql,age,id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>service</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line">    public void changeInfo(){</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        System.out.println("-----------");</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试环境搭建</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.test</span><br><span class="line"> *</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">@SpringJUnitConfig(JavaConfig.class)</span><br><span class="line">public class TxTest {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void  testTx(){</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="基本事务控制">6.2.2 基本事务控制</h4>
<ol type="1">
<li><p>配置事务管理器</p>
<p>数据库相关的配置</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.config</span><br><span class="line"> *</span><br><span class="line"> * description: 数据库和连接池配置类</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponenScan("com.atguigu")</span><br><span class="line">@PropertySource(value = "classpath:jdbc.properties")</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">public class DataSourceConfig {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实例化dataSource加入到ioc容器</span><br><span class="line">     * @param url</span><br><span class="line">     * @param driver</span><br><span class="line">     * @param username</span><br><span class="line">     * @param password</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource(@Value("${atguigu.url}")String url,</span><br><span class="line">                                 @Value("${atguigu.driver}")String driver,</span><br><span class="line">                                 @Value("${atguigu.username}")String username,</span><br><span class="line">                                 @Value("${atguigu.password}")String password){</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        return dataSource;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span><br><span class="line">     * @param dataSource</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JdbcTemplate jdbcTemplate(DataSource dataSource){</span><br><span class="line">        JdbcTemplate jdbcTemplate = new JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        return jdbcTemplate;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 装配事务管理实现对象</span><br><span class="line">     * @param dataSource</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public TransactionManager transactionManager(DataSource dataSource){</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用声明事务注解@Transactional</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.service</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void changeInfo(){</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        System.out.println("-----------");</span><br><span class="line">        int i = 1/0;</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试事务效果</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.test</span><br><span class="line"> *</span><br><span class="line"> * description:</span><br><span class="line"> */</span><br><span class="line">//@SpringJUnitConfig(locations = "classpath:application.xml")</span><br><span class="line">@SpringJUnitConfig(classes = DataSourceConfig.class)</span><br><span class="line">public class TxTest {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void  testTx(){</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="事务属性只读">6.2.3 事务属性：只读</h4>
<ol type="1">
<li><p>只读介绍</p>
<p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。</p></li>
<li><p>设置方式</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// readOnly = true把当前事务设置为只读 默认是false!</span><br><span class="line">@Transactional(readOnly = true)</span><br></pre></td></tr></table></figure></p></li>
<li><p>针对DML动作设置只读模式</p>
<p>会抛出下面异常：</p>
<p>Caused by: java.sql.SQLException: Connection is read-only. Queries
leading to data modification are not allowed</p></li>
<li><p><span class="citation" data-cites="Transactional注解放在类上">@Transactional注解放在类上</span></p>
<ol type="1">
<li><p>生效原则</p>
<p>如果一个类中每一个方法上都使用了 <span class="citation" data-cites="Transactional">@Transactional</span> 注解，那么就可以将
<span class="citation" data-cites="Transactional">@Transactional</span>
注解提取到类上。反过来说：<span class="citation" data-cites="Transactional">@Transactional</span>
注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 <span class="citation" data-cites="Transactional">@Transactional</span>
注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了
<span class="citation" data-cites="Transactional">@Transactional</span>
注解。</p>
<p><strong><em>*对一个方法来说，离它最近的 <span class="citation" data-cites="Transactional">@Transactional</span>
注解中的事务属性设置生效。*</em></strong></p></li>
<li><p>用法举例</p>
<p>在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。</p>
<p>然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为
false。</p></li>
</ol>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Transactional(readOnly = true)</span><br><span class="line">public class EmpService {</span><br><span class="line">    </span><br><span class="line">    // 为了便于核对数据库操作结果，不要修改同一条记录</span><br><span class="line">    @Transactional(readOnly = false)</span><br><span class="line">    public void updateTwice(……) {</span><br><span class="line">    ……</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // readOnly = true把当前事务设置为只读</span><br><span class="line">    // @Transactional(readOnly = true)</span><br><span class="line">    public String getEmpName(Integer empId) {</span><br><span class="line">    ……</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="事务属性超时时间">6.2.4 事务属性：超时时间</h4>
<ol type="1">
<li><p>需求</p>
<p>事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。</p>
<p>此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p>
<p>概括来说就是一句话：超时回滚，释放资源。</p></li>
<li><p>设置超时时间</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line">     */</span><br><span class="line">    @Transactional(readOnly = false,timeout = 3)</span><br><span class="line">    public void changeInfo(){</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        //休眠4秒,等待方法超时!</span><br><span class="line">        try {</span><br><span class="line">            Thread.sleep(4000);</span><br><span class="line">        } catch (InterruptedException e) {</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        }</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试超时效果</p>
<p>执行抛出事务超时异常</p></li>
</ol>
<h4 id="事务属性事务异常">6.2.5 事务属性：事务异常</h4>
<ol type="1">
<li><p>默认情况</p>
<p>默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span><br><span class="line">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span><br><span class="line">     */</span><br><span class="line">    @Transactional(readOnly = false,timeout = 3)</span><br><span class="line">    public void changeInfo() throws FileNotFoundException {</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span><br><span class="line">        new FileInputStream("xxxx");</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>设置回滚异常</p>
<p>rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and
Error 异常方可回滚!</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line"> * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span><br><span class="line"> * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span><br><span class="line"> */</span><br><span class="line">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)</span><br><span class="line">public void changeInfo() throws FileNotFoundException {</span><br><span class="line">    studentDao.updateAgeById(100,1);</span><br><span class="line">    //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span><br><span class="line">    new FileInputStream("xxxx"); </span><br><span class="line">    studentDao.updateNameById("test1",1);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>设置不回滚的异常</p>
<p>在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。</p>
<p>noRollbackFor属性：指定哪些异常不会回滚,
默认没有指定,如果指定,应该在rollbackFor的范围内!</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span><br><span class="line">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span><br><span class="line">     */</span><br><span class="line">    @Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)</span><br><span class="line">    public void changeInfo() throws FileNotFoundException {</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span><br><span class="line">        new FileInputStream("xxxx");</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="事务属性事务隔离级别">6.2.6 事务属性：事务隔离级别</h4>
<ol type="1">
<li><p>事务隔离级别</p>
<p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p>
<ol type="1">
<li>读未提交（Read
Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</li>
<li>读已提交（Read
Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</li>
<li>可重复读（Repeatable
Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</li>
<li>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。
不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。</li>
</ol></li>
<li><p>事务隔离级别设置</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.service;</span><br><span class="line"></span><br><span class="line">import com.atguigu.dao.StudentDao;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Isolation;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * projectName: com.atguigu.service</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span><br><span class="line">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span><br><span class="line">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span><br><span class="line">     */</span><br><span class="line">    @Transactional(readOnly = false,</span><br><span class="line">                   timeout = 3,</span><br><span class="line">                   rollbackFor = Exception.class,</span><br><span class="line">                   noRollbackFor = FileNotFoundException.class,</span><br><span class="line">                   isolation = Isolation.REPEATABLE_READ)</span><br><span class="line">    public void changeInfo() throws FileNotFoundException {</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span><br><span class="line">        new FileInputStream("xxxx");</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="事务属性事务传播行为">6.2.7 事务属性：事务传播行为</h4>
<ol type="1">
<li><p>事务传播行为要研究的问题</p>
<p>举例代码：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void MethodA(){</span><br><span class="line">    // ...</span><br><span class="line">    MethodB();</span><br><span class="line">    // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！</span><br><span class="line">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">public void MethodB(){</span><br><span class="line">    // ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>propagation属性</p>
<p><span class="citation" data-cites="Transactional">@Transactional</span> 注解通过 propagation
属性设置事务的传播行为。它的默认值是：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Propagation propagation() default Propagation.REQUIRED;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>propagation 属性的可选值由
org.springframework.transaction.annotation.Propagation 枚举类提供：</p>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 75%">
</colgroup>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>REQUIRED 默认值</td>
<td>如果父方法有事务，就加入，如果没有就新建自己独立！</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>不管父方法是否有事务，我都新建事务，都是独立的！</td>
</tr>
</tbody>
</table>
<ol type="1">
<li><p>测试</p>
<ol type="1">
<li><p>声明两个业务方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class StudentService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span><br><span class="line">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span><br><span class="line">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span><br><span class="line">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span><br><span class="line">     */</span><br><span class="line">    @Transactional(readOnly = false,</span><br><span class="line">                   timeout = 3,</span><br><span class="line">                   rollbackFor = Exception.class,</span><br><span class="line">                   noRollbackFor = FileNotFoundException.class,</span><br><span class="line">                   isolation = Isolation.REPEATABLE_READ)</span><br><span class="line">    public void changeInfo() throws FileNotFoundException {</span><br><span class="line">        studentDao.updateAgeById(100,1);</span><br><span class="line">        //主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span><br><span class="line">        new FileInputStream("xxxx");</span><br><span class="line">        studentDao.updateNameById("test1",1);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 声明两个独立修改数据库的事务业务方法</span><br><span class="line">     */</span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void changeAge(){</span><br><span class="line">        studentDao.updateAgeById(99,1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRED)</span><br><span class="line">    public void changeName(){</span><br><span class="line">        studentDao.updateNameById("test2",1);</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>声明一个整合业务方法</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TopService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void  topService(){</span><br><span class="line">        studentService.changeAge();</span><br><span class="line">        studentService.changeName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p></li>
<li><p>添加传播行为测试</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SpringJUnitConfig(classes = AppConfig.class)</span><br><span class="line">public class TxTest {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentService studentService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TopService topService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void  testTx() throws FileNotFoundException {</span><br><span class="line">        topService.topService();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p><strong><em>*注意：*</em></strong></p></li>
</ol>
<p>在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</p></li>
<li><p>其他传播行为值（了解）</p>
<ol type="1">
<li>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li>
<li>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li>
<li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li>
<li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li>
<li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li>
<li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li>
<li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li>
</ol></li>
</ol>
<h2 id="七spring核心掌握总结">七、Spring核心掌握总结</h2>
<table>
<thead>
<tr>
<th>核心点</th>
<th>掌握目标</th>
</tr>
</thead>
<tbody>
<tr>
<td>spring框架理解</td>
<td>spring家族和spring framework框架</td>
</tr>
<tr>
<td>spring核心功能</td>
<td>ioc/di , aop , tx</td>
</tr>
<tr>
<td>spring ioc / di</td>
<td>组件管理、ioc容器、ioc/di , 三种配置方式</td>
</tr>
<tr>
<td>spring aop</td>
<td>aop和aop框架和代理技术、基于注解的aop配置</td>
</tr>
<tr>
<td>核心点</td>
<td>掌握目标</td>
</tr>
<tr>
<td>spring tx</td>
<td>声明式和编程式事务、动态事务管理器、事务注解、属性</td>
</tr>
</tbody>
</table>

                    
                </div>

                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                Spring框架核心解剖
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                2024/06/12/Spring框架核心解剖/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    Author
                </div>
                <div class="content">Zhongjun Qiu</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    Published
                </div>
                <div class="content">2024-06-12 11:07</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    License
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="Copy copyright info" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/IoC/">IoC</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/AOP/">AOP</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/TX/">TX</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                            <div class="post-share-container border-box">
    <ul class="share-list-wrap border-box">
        <li class="qq share-item border-box flex-center tooltip"
            data-tooltip-content="Share to QQ"
        >
            <i class="fa-brands fa-qq"></i>
        </li>
        <li class="wechat share-item border-box flex-center tooltip tooltip-img"
            data-tooltip-content="Share to WeChat"
            data-tooltip-img-tip="Scan by WeChat"
            data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"
        >
            <i class="fa-brands fa-weixin"></i>
        </li>
        <li class="weibo share-item border-box flex-center tooltip"
            data-tooltip-content="Share to WeiBo"
        >
            <i class="fa-brands fa-weibo"></i>
        </li>
    </ul>
</div>

                        
                    </div>
                </div>

                
                    

<div class="reward-author-container border-box flex-center">
    <div class="reward-btn border-box flex-center tooltip tooltip-img"
            data-tooltip-img-url="/images/post/payment.jpg"
            data-tooltip-img-trigger="click"
            data-tooltip-img-style="top: -6px;"
    >
        <i class="fa-solid fa-gift"></i>&nbsp;REWARD AUTHOR
    </div>
</div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/06/13/MyBatis-%E5%AE%9E%E8%B7%B5/"
                                   title="MyBatis 实践"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">MyBatis 实践</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/06/05/Maven-%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"
                                   title="Maven 入门到进阶"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">Maven 入门到进阶</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;Comments
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">Comment plugin failed to load</span>
    <button class="reload keep-button">Click to reload</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">Loading comment plugin</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="waline-comment-container">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.3.2/waline.css"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/waline/3.3.2/waline-meta.css"/>
        <div id="waline-comment"></div>
        <script data-pjax>
          window.KeepCommentPlugin.walineOptions = JSON.parse('{}'.replace(/&#34;/g, '"'))
          window.KeepCommentPlugin.walineOptions.el = '#waline-comment'
          window.KeepCommentPlugin.walineOptions.comment = '.post-comments-count'
          window.KeepCommentPlugin.walineOptions.serverURL = 'https://waline-vercel-two-rho.vercel.app/'
          window.KeepCommentPlugin.walineOptions.lang = 'en' || 'zh-CN'
          window.KeepCommentPlugin.walineOptions.reaction = 'true' === 'true'
        </script>

        

        
            <script data-pjax
                    async
                    type="module"
            >
              import { init } from 'https://cdnjs.cloudflare.com/ajax/libs/waline/3.3.2/waline.js'
              window.KeepCommentPlugin.initWaline = () => {
                if (init) {
                  init(window.KeepCommentPlugin.walineOptions)
                  window.KeepCommentPlugin.hideLoading()
                } else {
                  setTimeout(() => {
                    window.KeepCommentPlugin.initWaline()
                  }, 1000)
                }
              }

              if ('true' === 'true') {
                setTimeout(() => {
                  window.KeepCommentPlugin.initWaline()
                }, 1200)
              } else {
                window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initWaline)
              }
            </script>
        
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">一、技术体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB"><span class="nav-text">1.1 总体技术体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5%E5%92%8C%E7%90%86%E8%A7%A3"><span class="nav-text">1.2 框架概念和理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8Cspringframework%E4%BB%8B%E7%BB%8D"><span class="nav-text">二、SpringFramework介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E5%92%8C-springframework%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 Spring 和
SpringFramework概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springframework%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="nav-text">2.2
SpringFramework主要功能模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springframework-%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="nav-text">2.3 SpringFramework 主要优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89spring-ioc%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">三、Spring IoC容器和核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 组件和组件管理概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2 Spring IoC容器和容器实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc-di%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="nav-text">3.3 Spring IoC &#x2F; DI概念总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9Bspring-ioc%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-text">四、Spring IoC实践和应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc-di-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-text">4.1 Spring IoC &#x2F; DI 实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">4.2 基于XML配置方式组件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-%E7%BB%84%E4%BB%B6bean%E4%BF%A1%E6%81%AF%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AEioc"><span class="nav-text">4.2.1 实验一：
组件（Bean）信息声明配置（IoC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%BB%84%E4%BB%B6bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AEdi"><span class="nav-text">4.2.2 实验二：
组件（Bean）依赖注入配置（DI）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-ioc%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">4.2.3 实验三： IoC容器创建和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E7%BB%84%E4%BB%B6bean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"><span class="nav-text">4.2.4 实验四：
高级特性：组件（Bean）作用域和周期方法配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7factorybean%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">4.2.5 实验五：
高级特性：FactoryBean特性和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.2.6 实验六：
基于XML方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-%E6%B3%A8%E8%A7%A3-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86-bean"><span class="nav-text">4.3 基于 注解 方式管理 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-bean%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AE%B0%E5%92%8C%E6%89%AB%E6%8F%8F-ioc"><span class="nav-text">4.3.1 实验一： Bean注解标记和扫描
(IoC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%BB%84%E4%BB%B6bean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.3.2 实验二：
组件（Bean）作用域和周期方法注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-di"><span class="nav-text">4.3.3 实验三：
Bean属性赋值：引用类型自动装配 (DI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC-di"><span class="nav-text">4.3.4 实验四：
Bean属性赋值：基本类型属性赋值 (DI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3xml%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.3.5 实验五：
基于注解+XML方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86-bean"><span class="nav-text">4.4 基于 配置类 方式管理 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%90%86%E8%A7%A3"><span class="nav-text">4.4.1 完全注解开发理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%89%AB%E6%8F%8F%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.4.2 实验一：配置类和扫描注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8Cbean%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="nav-text">4.4.3 实验二：@Bean定义组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7bean%E6%B3%A8%E8%A7%A3%E7%BB%86%E8%8A%82"><span class="nav-text">4.4.4 实验三：高级特性：@Bean注解细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7import%E6%89%A9%E5%B1%95"><span class="nav-text">4.4.5 实验四：高级特性：@Import扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.4.6
实验五：基于注解+配置类方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-text">4.5 三种配置方式总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xml%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.1 XML方式配置总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xml%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.2 XML+注解方式配置总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.3 完全注解方式配置总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%90%88spring5-test5%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-text">4.6
整合Spring5-Test5搭建测试环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94spring-aop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-text">五、Spring AOP面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="nav-text">5.1 场景设定和问题复现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">5.2 解决技术代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4aop"><span class="nav-text">5.3 面向切面编程思维（AOP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86"><span class="nav-text">5.4 Spring
AOP框架介绍和关系梳理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-text">5.5 Spring
AOP基于注解方式实现和细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-aop%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E7%BB%84%E6%88%90"><span class="nav-text">5.5.1 Spring AOP底层技术组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.5.2 初步实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E7%BB%86%E8%8A%82%E4%BF%A1%E6%81%AF"><span class="nav-text">5.5.3 获取通知细节信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">5.5.4 切点表达式语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%94%A8%E6%8F%90%E5%8F%96%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5.5.5 重用（提取）切点表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-text">5.5.6 环绕通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="nav-text">5.5.7 切面优先级设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%95%88"><span class="nav-text">5.5.8 CGLib动态代理生效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93"><span class="nav-text">5.5.9 注解实现小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%A3"><span class="nav-text">5.6 Spring
AOP基于XML方式实现(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%AF%B9%E8%8E%B7%E5%8F%96bean%E7%9A%84%E5%BD%B1%E5%93%8D%E7%90%86%E8%A7%A3"><span class="nav-text">5.7 Spring
AOP对获取Bean的影响理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A3%85%E9%85%8D-bean"><span class="nav-text">5.7.1 根据类型装配 bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">5.7.2 使用总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%ADspring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">六、Spring 声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1 声明式事务概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.1.1 编程式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.1.2 声明式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">6.1.3 Spring事务管理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.2 基于注解的声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">6.2.1 准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">6.2.2 基本事务控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%8F%AA%E8%AF%BB"><span class="nav-text">6.2.3 事务属性：只读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-text">6.2.4 事务属性：超时时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="nav-text">6.2.5 事务属性：事务异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">6.2.6 事务属性：事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-text">6.2.7 事务属性：事务传播行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83spring%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E6%80%BB%E7%BB%93"><span class="nav-text">七、Spring核心掌握总结</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
    
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Zhongjun Qiu</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    
        
        <div class="deploy-info info-item">
            
                <a target="_blank" rel="nofollow" href="https://github.com">
            
            This site is deployed on <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span>
            
                </a>
            
        </div>
    

    
        <div class="count-info info-item">
            
                <span class="count-item border-box word">
                    <span class="item-type border-box">Total words</span>
                    <span class="item-value border-box word">340.5k</span>
                </span>
            

            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">Page View</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-text">一、技术体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB"><span class="nav-text">1.1 总体技术体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E6%A6%82%E5%BF%B5%E5%92%8C%E7%90%86%E8%A7%A3"><span class="nav-text">1.2 框架概念和理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8Cspringframework%E4%BB%8B%E7%BB%8D"><span class="nav-text">二、SpringFramework介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E5%92%8C-springframework%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1 Spring 和
SpringFramework概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springframework%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="nav-text">2.2
SpringFramework主要功能模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springframework-%E4%B8%BB%E8%A6%81%E4%BC%98%E5%8A%BF"><span class="nav-text">2.3 SpringFramework 主要优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89spring-ioc%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-text">三、Spring IoC容器和核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1 组件和组件管理概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2 Spring IoC容器和容器实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc-di%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="nav-text">3.3 Spring IoC &#x2F; DI概念总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9Bspring-ioc%E5%AE%9E%E8%B7%B5%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-text">四、Spring IoC实践和应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-ioc-di-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-text">4.1 Spring IoC &#x2F; DI 实现步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-text">4.2 基于XML配置方式组件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-%E7%BB%84%E4%BB%B6bean%E4%BF%A1%E6%81%AF%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AEioc"><span class="nav-text">4.2.1 实验一：
组件（Bean）信息声明配置（IoC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%BB%84%E4%BB%B6bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AEdi"><span class="nav-text">4.2.2 实验二：
组件（Bean）依赖注入配置（DI）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-ioc%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">4.2.3 实验三： IoC容器创建和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E7%BB%84%E4%BB%B6bean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"><span class="nav-text">4.2.4 实验四：
高级特性：组件（Bean）作用域和周期方法配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7factorybean%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-text">4.2.5 实验五：
高级特性：FactoryBean特性和使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.2.6 实验六：
基于XML方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-%E6%B3%A8%E8%A7%A3-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86-bean"><span class="nav-text">4.3 基于 注解 方式管理 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80-bean%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AE%B0%E5%92%8C%E6%89%AB%E6%8F%8F-ioc"><span class="nav-text">4.3.1 实验一： Bean注解标记和扫描
(IoC)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E7%BB%84%E4%BB%B6bean%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.3.2 实验二：
组件（Bean）作用域和周期方法注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89-bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-di"><span class="nav-text">4.3.3 实验三：
Bean属性赋值：引用类型自动装配 (DI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B-bean%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC-di"><span class="nav-text">4.3.4 实验四：
Bean属性赋值：基本类型属性赋值 (DI)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3xml%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.3.5 实验五：
基于注解+XML方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86-bean"><span class="nav-text">4.4 基于 配置类 方式管理 Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%90%86%E8%A7%A3"><span class="nav-text">4.4.1 完全注解开发理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%89%AB%E6%8F%8F%E6%B3%A8%E8%A7%A3"><span class="nav-text">4.4.2 实验一：配置类和扫描注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8Cbean%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="nav-text">4.4.3 实验二：@Bean定义组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7bean%E6%B3%A8%E8%A7%A3%E7%BB%86%E8%8A%82"><span class="nav-text">4.4.4 实验三：高级特性：@Bean注解细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7import%E6%89%A9%E5%B1%95"><span class="nav-text">4.4.5 实验四：高级特性：@Import扩展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-text">4.4.6
实验五：基于注解+配置类方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="nav-text">4.5 三种配置方式总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#xml%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.1 XML方式配置总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#xml%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.2 XML+注解方式配置总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93"><span class="nav-text">4.5.3 完全注解方式配置总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%90%88spring5-test5%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-text">4.6
整合Spring5-Test5搭建测试环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94spring-aop%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-text">五、Spring AOP面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A%E5%92%8C%E9%97%AE%E9%A2%98%E5%A4%8D%E7%8E%B0"><span class="nav-text">5.1 场景设定和问题复现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-text">5.2 解决技术代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4aop"><span class="nav-text">5.3 面向切面编程思维（AOP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86"><span class="nav-text">5.4 Spring
AOP框架介绍和关系梳理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%92%8C%E7%BB%86%E8%8A%82"><span class="nav-text">5.5 Spring
AOP基于注解方式实现和细节</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-aop%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E7%BB%84%E6%88%90"><span class="nav-text">5.5.1 Spring AOP底层技术组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.5.2 初步实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%80%9A%E7%9F%A5%E7%BB%86%E8%8A%82%E4%BF%A1%E6%81%AF"><span class="nav-text">5.5.3 获取通知细节信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-text">5.5.4 切点表达式语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E7%94%A8%E6%8F%90%E5%8F%96%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">5.5.5 重用（提取）切点表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-text">5.5.6 环绕通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%BE%E7%BD%AE"><span class="nav-text">5.5.7 切面优先级设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%95%88"><span class="nav-text">5.5.8 CGLib动态代理生效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%B0%8F%E7%BB%93"><span class="nav-text">5.5.9 注解实现小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%A3"><span class="nav-text">5.6 Spring
AOP基于XML方式实现(了解)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop%E5%AF%B9%E8%8E%B7%E5%8F%96bean%E7%9A%84%E5%BD%B1%E5%93%8D%E7%90%86%E8%A7%A3"><span class="nav-text">5.7 Spring
AOP对获取Bean的影响理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A3%85%E9%85%8D-bean"><span class="nav-text">5.7.1 根据类型装配 bean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="nav-text">5.7.2 使用总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%ADspring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">六、Spring 声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5"><span class="nav-text">6.1 声明式事务概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.1.1 编程式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.1.2 声明式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-text">6.1.3 Spring事务管理器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-text">6.2 基于注解的声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-text">6.2.1 准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-text">6.2.2 基本事务控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%8F%AA%E8%AF%BB"><span class="nav-text">6.2.3 事务属性：只读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="nav-text">6.2.4 事务属性：超时时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E5%BC%82%E5%B8%B8"><span class="nav-text">6.2.5 事务属性：事务异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">6.2.6 事务属性：事务隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-text">6.2.7 事务属性：事务传播行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%83spring%E6%A0%B8%E5%BF%83%E6%8E%8C%E6%8F%A1%E6%80%BB%E7%BB%93"><span class="nav-text">七、Spring核心掌握总结</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/lazyload.min.js"></script>


<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/copyright-info.min.js"></script>
        

        <!-- share -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/share.min.js"></script>
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
    
        
            
<script class="custom-inject-js" src="/js/custom_code_block.js" data-pjax></script>

        
    

</body>
</html>
